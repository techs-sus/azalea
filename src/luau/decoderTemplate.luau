--!native
--!optimize 2

-- WARNING: This file is @generated by azalea. Do not edit.

--@generate TypeId
--@generate CFrameIdLookupTable
--@generate NewScript
--@generate NewLocalScript
--@generate NewModuleScript

local function decode(payloadBuffer: buffer)
	--@generate NilParentedInstance

	local loc = 0
	local VARIANT_DECODER: { [number]: () -> any } = nil
	local nextVariant

	local function nextNullstring(): string
		local start = loc
		while true do
			loc += 1
			if buffer.readu8(payloadBuffer, loc) == 0 then
				-- ensure we skip null byte
				loc += 1
				break
			end
		end

		-- ensure we skip null byte in decoded string
		return buffer.readstring(payloadBuffer, start, loc - start - 1)
	end

	local function nextUnsignedInteger(): number
		local result = 0
		local shift = 0
		local byte

		repeat
			byte = buffer.readu8(payloadBuffer, loc)
			loc += 1

			result = bit32.bor(result, bit32.lshift(bit32.band(byte, 0x7F), shift))
			shift = shift + 7

			if shift >= 32 and byte >= 0x80 then
				error("leb128 overflow (exceeded 32 bits)")
			end
		until bit32.band(byte, 0x80) == 0

		return result
	end

	--@generate VariantDecoder

	function nextVariant(expectedTypeIds: { number }?)
		-- 1. read type id
		-- 2. loc++;
		-- 3. call type id handler (which uses loc)

		local typeId = buffer.readu8(payloadBuffer, loc)
		loc += 1

		if expectedTypeIds and not table.find(expectedTypeIds, typeId) then
			error(`expected type id inside of array {table.concat(expectedTypeIds, ", ")}, got {typeId}`)
		end

		return assert(VARIANT_DECODER[typeId], "no variant decoder for type id " .. typeId)()
	end

	type Ref = number

	local rootReferent: Ref?
	local referentTree: { [string]: Instance } = {}

	-- late properties must be applied after the entire tree is decoded
	-- index signature: latePropertyMap[referent][propertyName] = propertyValue
	local latePropertiesMap: { [Ref]: { [string]: string } } = {}

	local function decodeInstance()
		local name: string = nextVariant({ TYPE_ID.String })
		local className: string = nextNullstring()
		local instanceReferent: Ref = nextVariant({ TYPE_ID.Ref })
		local parentReferent: Ref? = nextVariant({ TYPE_ID.Ref, TYPE_ID.None })

		local propertiesLength = buffer.readu16(payloadBuffer, loc)
		local propertiesMap: { [string]: any } = {}
		loc += 2

		while propertiesLength > 0 do
			local propertyName = nextNullstring()

			local propertyValueIsReferent = buffer.readu8(payloadBuffer, loc) == TYPE_ID.Ref
			if propertyValueIsReferent then
				if not latePropertiesMap[instanceReferent] then
					latePropertiesMap[instanceReferent] = {}
				end

				latePropertiesMap[instanceReferent][propertyName] = nextVariant({ TYPE_ID.Ref })
			else
				propertiesMap[propertyName] = nextVariant()
			end

			-- print(propertyName)
			-- print(propertyName, propertiesMap[propertyName])

			propertiesLength -= 1
		end

		local instance: Instance = nil
		--@generate SpecializedInstanceCreator
		referentTree[instanceReferent] = instance

		instance.Name = name

		if propertiesMap.Attributes then
			for attributeName, value in propertiesMap.Attributes do
				instance:SetAttribute(attributeName, value)
			end

			propertiesMap.Attributes = nil
		end

		if propertiesMap.Tags then
			for _, tag in propertiesMap.Tags do
				instance:AddTag(tag)
			end

			propertiesMap.Tags = nil
		end

		for propertyName, propertyValue in propertiesMap do
			-- TODO: add custom handlers
			xpcall(function()
				instance[propertyName] = propertyValue
			end, function(error)
				-- warn(`failed setting property {propertyName} with value {propertyValue}; got error "{error}"`)
			end)
		end

		if parentReferent ~= nil then
			instance.Parent = referentTree[parentReferent]
		else
			assert(rootReferent == nil, "there are multiple root referents in the hierarchy")
			rootReferent = instanceReferent
		end

		return instanceReferent
	end

	-- decode entire buffer
	while true do
		local decodedReferent = decodeInstance()
		-- print(`decoded referent {decodedReferent}{if rootReferent == decodedReferent then " [root]" else ""}`)

		if buffer.len(payloadBuffer) == loc then
			-- print("finished decoding payloadBuffer")
			break
		end
	end

	assert(rootReferent, "no root referent in hierarchy")

	for referent, propertyMap in latePropertiesMap do
		-- late property handling (referent handling)
		for propertyName, propertyValue in propertyMap do
			xpcall(function()
				referentTree[referent][propertyName] = referentTree[propertyValue]
			end, function(error)
				warn(
					`failed setting late property {propertyName} on referent {referent} with value {propertyValue}; got error "{error}"`
				)
			end)
		end
	end

	return referentTree[rootReferent]
end

return decode
