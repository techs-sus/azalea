--!native
--!optimize 2

-- WARNING: This file is automatically generated from a template by azalea. Do not edit.

{{type_id_table}}

{% if let Some(cframe_lookup_table) = cframe_lookup_table %}
  {{ cframe_lookup_table }}
{% else %}
	-- CFrame lookup table not present
{% endif %}

{% if let Some(new_script_shim) = new_script_shim %}
  {{ new_script_shim }}
{% else %}
	-- NewScript not required
{% endif %}

{% if let Some(new_local_script_shim) = new_local_script_shim %}
	{{ new_local_script_shim }}
{% else %}
	-- NewLocalScript not required
{% endif %}

{% if let Some(new_module_script_shim) = new_module_script_shim %}
	{{ new_module_script_shim }}
{% else %}
	-- NewModuleScript not required
{% endif %}

{% if mesh_part_exists %}
	local AssetService = game:GetService("AssetService")
{% endif %}

local function decode(payloadBuffer: buffer)	
	{% if new_script_shim.is_some() || new_local_script_shim.is_some() || new_module_script_shim.is_some() %}
		local nilParentedInstance = Instance.new("Folder", nil)
	{% else %}
		-- Nil parented instance not required
	{% endif %}

	local loc = 0
	local VARIANT_DECODER: { [number]: () -> any } = nil
	local nextVariant

	local function nextNullstring(): string
		local start = loc
		while true do
			loc += 1
			if buffer.readu8(payloadBuffer, loc) == 0 then
				-- ensure we skip null byte
				loc += 1
				break
			end
		end

		-- ensure we skip null byte in decoded string
		return buffer.readstring(payloadBuffer, start, loc - start - 1)
	end

	local function nextUnsignedInteger(): number
		local result = 0
		local shift = 0
		local byte

		repeat
			byte = buffer.readu8(payloadBuffer, loc)
			loc += 1

			result = bit32.bor(result, bit32.lshift(bit32.band(byte, 0x7F), shift))
			shift = shift + 7

			if shift >= 32 and byte >= 0x80 then
				error("leb128 overflow (exceeded 32 bits)")
			end
		until bit32.band(byte, 0x80) == 0

		return result
	end

	{{ variant_decoder_table }}

	function nextVariant(expectedTypeIds: { number }?)
		-- 1. read type id
		-- 2. loc++;
		-- 3. call type id handler (which uses loc)

		local typeId = buffer.readu8(payloadBuffer, loc)
		loc += 1

		if expectedTypeIds and not table.find(expectedTypeIds, typeId) then
			error(`expected type id inside of array {table.concat(expectedTypeIds, ", ")}, got {typeId}`)
		end

		return assert(VARIANT_DECODER[typeId], "no variant decoder for type id " .. typeId)()
	end

	type Ref = number

	local rootReferent: Ref?
	local referentTree: { [string]: Instance } = {}

	-- late properties must be applied after the entire tree is decoded
	-- index signature: latePropertyMap[referent][propertyName] = propertyValue
	local latePropertiesMap: { [Ref]: { [string]: string } } = {}

	local function decodeInstance()
		local name: string = nextVariant({ TYPE_ID.String })
		local className: string = nextNullstring()
		local instanceReferent: Ref = nextVariant({ TYPE_ID.Ref })
		local parentReferent: Ref? = nextVariant({ TYPE_ID.Ref, TYPE_ID.None })

		local propertiesLength = buffer.readu16(payloadBuffer, loc)
		local propertiesMap: { [string]: any } = {}
		loc += 2

		while propertiesLength > 0 do
			local propertyName = nextNullstring()

			local peekedTypeId = buffer.readu8(payloadBuffer, loc)
			local propertyValueIsContentObject = peekedTypeId == TYPE_ID.ContentObject
			local propertyValueIsReferent = peekedTypeId == TYPE_ID.Ref or propertyValueIsContentObject
			if propertyValueIsReferent then
				if not latePropertiesMap[instanceReferent] then
					latePropertiesMap[instanceReferent] = {}
				end

				latePropertiesMap[instanceReferent][propertyName] = { variant = nextVariant({ TYPE_ID.Ref, TYPE_ID.ContentObject }), isContentObject = propertyValueIsContentObject }
			else
				propertiesMap[propertyName] = nextVariant()
			end

			-- print(propertyName)
			-- print(propertyName, propertiesMap[propertyName])

			propertiesLength -= 1
		end

		local instance: Instance = if className == "DataModel" then Instance.new("Model")
			{% if new_script_shim.is_some() %}elseif className == "Script" then NewScript(propertiesMap.Source or "", nilParentedInstance){% endif %}
			{% if new_local_script_shim.is_some() %}elseif className == "LocalScript" then NewLocalScript(propertiesMap.Source or "", nilParentedInstance){% endif %}
			{% if new_module_script_shim.is_some() %}elseif className == "ModuleScript" then NewModuleScript(propertiesMap.Source or "", nilParentedInstance){% endif %}
			{% if mesh_part_exists %}elseif className == "MeshPart" then AssetService:CreateMeshPartAsync(propertiesMap.MeshContent){% endif %}
			else Instance.new(className)
		referentTree[instanceReferent] = instance

		instance.Name = name

		if propertiesMap.Attributes then
			for attributeName, value in propertiesMap.Attributes do
				instance:SetAttribute(attributeName, value)
			end

			propertiesMap.Attributes = nil
		end

		if propertiesMap.Tags then
			for _, tag in propertiesMap.Tags do
				instance:AddTag(tag)
			end

			propertiesMap.Tags = nil
		end

		for propertyName, propertyValue in propertiesMap do
			-- TODO: add custom handlers
			xpcall(function()
				instance[propertyName] = propertyValue
			end, function(error)
				-- warn(`failed setting property {propertyName} with value {propertyValue}; got error "{error}"`)
			end)
		end

		if parentReferent ~= nil then
			instance.Parent = referentTree[parentReferent]
		else
			assert(rootReferent == nil, "there are multiple root referents in the hierarchy")
			rootReferent = instanceReferent
		end

		return instanceReferent
	end

	-- decode entire buffer
	while true do
		local decodedReferent = decodeInstance()
		-- print(`decoded referent {decodedReferent}{if rootReferent == decodedReferent then " [root]" else ""}`)

		if buffer.len(payloadBuffer) == loc then
			-- print("finished decoding payloadBuffer")
			break
		end
	end

	assert(rootReferent, "no root referent in hierarchy")

	for referent, propertyMap in latePropertiesMap do
		-- late property handling (referent handling)
		for propertyName, propertyValue in propertyMap do
			xpcall(function()
				referentTree[referent][propertyName] = if propertyValue.isContentObject then Content.fromObject(referentTree[propertyValue.variant]) else referentTree[propertyValue.variant]
			end, function(error)
				warn(
					`failed setting late property {propertyName} on referent {referent} with value {propertyValue}; got error "{error}"`
				)
			end)
		end
	end
	
	{% if new_script_shim.is_some() || new_local_script_shim.is_some() || new_module_script_shim.is_some() %}
		nilParentedInstance:Destroy()
	{% else %}
		-- Nil parented instance destructor not required
	{% endif %}

	return referentTree[rootReferent]
end

return decode
