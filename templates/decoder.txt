--!native
--!optimize 2

-- WARNING: This file is automatically generated from a template by azalea. Do not edit.

{% if requirements.contains(Requirements::USE_NOVEL_INLINING) %}
	-- local TrackModuleScript
{% endif %}

{% if let Some(new_module_script_shim) = new_module_script_shim %}
	{{ new_module_script_shim }}
{% else %}
	-- NewModuleScript not required
{% endif %}

{% if let Some(new_script_shim) = new_script_shim %}
  {{ new_script_shim }}
{% else %}
	-- NewScript not required
{% endif %}

{% if let Some(new_local_script_shim) = new_local_script_shim %}
	{{ new_local_script_shim }}
{% else %}
	-- NewLocalScript not required
{% endif %}

{{type_id_table}}

{% if requirements.contains(Requirements::CFRAME_LOOKUP_TABLE) %}
local CFRAME_ID_LOOKUP_TABLE = table.freeze({
	[0x02] = CFrame.fromEulerAnglesYXZ(0, 0, 0),
	[0x03] = CFrame.fromEulerAnglesYXZ(math.rad(90), 0, 0),
	[0x05] = CFrame.fromEulerAnglesYXZ(0, math.rad(180), math.rad(180)),
	[0x06] = CFrame.fromEulerAnglesYXZ(math.rad(-90), 0, 0),
	[0x07] = CFrame.fromEulerAnglesYXZ(0, math.rad(180), math.rad(90)),
	[0x09] = CFrame.fromEulerAnglesYXZ(0, math.rad(90), math.rad(90)),
	[0x0a] = CFrame.fromEulerAnglesYXZ(0, 0, math.rad(90)),
	[0x0c] = CFrame.fromEulerAnglesYXZ(0, math.rad(-90), math.rad(90)),
	[0x0d] = CFrame.fromEulerAnglesYXZ(math.rad(-90), math.rad(-90), 0),
	[0x0e] = CFrame.fromEulerAnglesYXZ(math.rad(0), math.rad(-90), 0),
	[0x10] = CFrame.fromEulerAnglesYXZ(math.rad(90), math.rad(-90), 0),
	[0x11] = CFrame.fromEulerAnglesYXZ(math.rad(0), math.rad(90), 180),

	[0x14] = CFrame.fromEulerAnglesYXZ(0, math.rad(180), 0),
	[0x15] = CFrame.fromEulerAnglesYXZ(math.rad(-90), math.rad(-180), 0),
	[0x17] = CFrame.fromEulerAnglesYXZ(0, 0, math.rad(180)),
	[0x18] = CFrame.fromEulerAnglesYXZ(math.rad(90), math.rad(180), 0),
	[0x19] = CFrame.fromEulerAnglesYXZ(0, 0, math.rad(-90)),
	[0x1b] = CFrame.fromEulerAnglesYXZ(0, math.rad(-90), math.rad(-90)),
	[0x1c] = CFrame.fromEulerAnglesYXZ(0, math.rad(-180), math.rad(-90)),
	[0x1e] = CFrame.fromEulerAnglesYXZ(0, math.rad(90), math.rad(-90)),
	[0x1f] = CFrame.fromEulerAnglesYXZ(math.rad(90), math.rad(90), 0),
	[0x20] = CFrame.fromEulerAnglesYXZ(0, math.rad(90), 0),
	[0x22] = CFrame.fromEulerAnglesYXZ(math.rad(-90), math.rad(90), 0),
	[0x23] = CFrame.fromEulerAnglesYXZ(0, math.rad(-90), math.rad(180)),
})
{% else %}
	-- CFrame lookup table not present
{% endif %}

{% if requirements.contains(Requirements::MESH_PART_SUPPORT) %}
	local AssetService = game:GetService("AssetService")
{% endif %}

local function decode(payloadBuffer: buffer)	
	{% if new_script_shim.is_some() || new_local_script_shim.is_some() || new_module_script_shim.is_some() %}
		local nilParentedInstance = Instance.new("Folder", nil)
	{% else %}
		-- Nil parented instance not required
	{% endif %}

	local loc = 0
	local VARIANT_DECODER: { [number]: () -> any } = nil
	local nextVariant

	local function nextNullstring(): string
		local start = loc
		while true do
			loc += 1
			if buffer.readu8(payloadBuffer, loc) == 0 then
				-- ensure we skip null byte
				loc += 1
				break
			end
		end

		-- ensure we skip null byte in decoded string
		return buffer.readstring(payloadBuffer, start, loc - start - 1)
	end

	local function nextUnsignedInteger(): number
		local result = 0
		local shift = 0
		local byte

		repeat
			byte = buffer.readu8(payloadBuffer, loc)
			loc += 1

			result = bit32.bor(result, bit32.lshift(bit32.band(byte, 0x7F), shift))
			shift = shift + 7

			if shift >= 32 and byte >= 0x80 then
				error("leb128 overflow (exceeded 32 bits)")
			end
		until bit32.band(byte, 0x80) == 0

		return result
	end

	{{ variant_decoder_table }}

	function nextVariant(expectedTypeIds: { number }?)
		-- 1. read type id
		-- 2. loc++;
		-- 3. call type id handler (which uses loc)

		local typeId = buffer.readu8(payloadBuffer, loc)
		loc += 1

		if expectedTypeIds and not table.find(expectedTypeIds, typeId) then
			error(`expected type id inside of array {table.concat(expectedTypeIds, ", ")}, got {typeId}`)
		end

		return assert(VARIANT_DECODER[typeId], "no variant decoder for type id " .. typeId)()
	end

	type Ref = number

	local rootReferent: Ref?
	local referentTree: { [Ref]: Instance } = {}

	-- late properties must be applied after the entire tree is decoded
	-- index signature: latePropertyMap[referent][propertyName] = propertyValue
	local latePropertiesMap: { [Ref]: { [string]: { variant: Ref, isContentObject: boolean } } } = {}

	local function decodeInstance()
		local name: string = nextVariant({ TYPE_ID.String })
		local className: string = nextNullstring()
		local instanceReferent: Ref = nextVariant({ TYPE_ID.Ref })
		local parentReferent: Ref? = nextVariant({ TYPE_ID.Ref, TYPE_ID.None })

		local propertiesLength = buffer.readu16(payloadBuffer, loc)
		local propertiesMap: { [string]: any } = {}
		loc += 2

		while propertiesLength > 0 do
			local propertyName = nextNullstring()

			local peekedTypeId = buffer.readu8(payloadBuffer, loc)
			local propertyValueIsContentObject = peekedTypeId == TYPE_ID.ContentObject
			local propertyValueIsReferent = peekedTypeId == TYPE_ID.Ref or propertyValueIsContentObject
			if propertyValueIsReferent then
				if not latePropertiesMap[instanceReferent] then
					latePropertiesMap[instanceReferent] = {}
				end

				latePropertiesMap[instanceReferent][propertyName] = { variant = nextVariant({ TYPE_ID.Ref, TYPE_ID.ContentObject }), isContentObject = propertyValueIsContentObject }
			else
				propertiesMap[propertyName] = nextVariant()
			end

			-- print(propertyName)
			-- print(propertyName, propertiesMap[propertyName])

			propertiesLength -= 1
		end

		local instance: Instance = if className == "DataModel" then Instance.new("Model")
			{% if new_script_shim.is_some() %}elseif className == "Script" then NewScript(propertiesMap.Source, nilParentedInstance){% endif %}
			{% if new_local_script_shim.is_some() %}elseif className == "LocalScript" then NewLocalScript(propertiesMap.Source, nilParentedInstance){% endif %}
			{% if new_module_script_shim.is_some() %}elseif className == "ModuleScript" then {% if requirements.contains(Requirements::USE_NOVEL_INLINING) %}TrackModuleScript(instanceReferent, NewModuleScript(propertiesMap.Source, nilParentedInstance)){% else %}NewModuleScript(propertiesMap.Source, nilParentedInstance){% endif %}{% endif %}
			{% if requirements.contains(Requirements::MESH_PART_SUPPORT) %}elseif className == "MeshPart" then AssetService:CreateMeshPartAsync(propertiesMap.MeshContent){% endif %}
			else Instance.new(className)
			
		referentTree[instanceReferent] = instance

		instance.Name = name

		if propertiesMap.Attributes then
			for attributeName, value in pairs(propertiesMap.Attributes) do
				instance:SetAttribute(attributeName, value)
			end

			propertiesMap.Attributes = nil
		end

		if propertiesMap.Tags then
			for _, tag in pairs(propertiesMap.Tags) do
				instance:AddTag(tag)
			end

			propertiesMap.Tags = nil
		end

		for propertyName, propertyValue in pairs(propertiesMap) do
			-- TODO: add custom handlers
			xpcall(function()
				instance[propertyName] = propertyValue
			end, function(error)
				-- warn(`failed setting property {propertyName} with value {propertyValue}; got error "{error}"`)
			end)
		end

		if parentReferent ~= nil then
			instance.Parent = referentTree[parentReferent]
		else
			assert(rootReferent == nil, "there are multiple root referents in the hierarchy")
			rootReferent = instanceReferent
		end

		return instanceReferent
	end

	-- decode entire buffer
	while true do
		local decodedReferent = decodeInstance()
		-- print(`decoded referent {decodedReferent}{if rootReferent == decodedReferent then " [root]" else ""}`)

		if buffer.len(payloadBuffer) == loc then
			-- print("finished decoding payloadBuffer")
			break
		end
	end

	assert(rootReferent, "no root referent in hierarchy")

	for referent, propertyMap in pairs(latePropertiesMap) do
		-- late property handling (referent handling)
		for propertyName, propertyValue in pairs(propertyMap) do
			xpcall(function()
				referentTree[referent][propertyName] = if propertyValue.isContentObject then Content.fromObject(referentTree[propertyValue.variant]) else referentTree[propertyValue.variant]
			end, function(error)
				warn(
					`failed setting late property {propertyName} on referent {referent} with value {propertyValue}; got error "{error}"`
				)
			end)
		end
	end
	
	{% if new_script_shim.is_some() || new_local_script_shim.is_some() || new_module_script_shim.is_some() %}
		nilParentedInstance:Destroy()
	{% else %}
		-- Nil parented instance destructor not required
	{% endif %}

	return referentTree[rootReferent]
end

{% if requirements.contains(Requirements::RETURN_DECODE) %}
return decode
{% endif %}
