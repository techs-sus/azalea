
script:Destroy();script=nil
local a={ClassName="Model",Children={},Properties={}}
a.Name="DataModel"
local b={ClassName="Folder",Children={},Properties={}}
b.Name="RoactAlignment"
a.Children._3a3b759d2de5c9cef41f0ecb3ad132a3=b
local c
local d={ClassName="Folder",Children={},Properties={}}
d.Name="TestRunner"
c.Children._b6bbf58c5d6619cb8f49aeec075d0925=d
local e
local f={ClassName="ModuleScript",Children={},Properties={}}
f.Name="Src"
f.Properties.Source=[[ return {} ]]
e.Children._2a96756d58d21271bf05d76b98a5809e=f
local g

local h={ClassName="ModuleScript",Children={},Properties={}}
h.Name="JestReact"
h.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/jest-react/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local exports = {}
-- ROBLOX deviation START: extract to variable, fix import and export type
--  Object.assign(exports, require(script.src.JestReact))
local jestReactModule = Object.assign(exports, require(script.JestReact))
return exports :: typeof(exports) & typeof(jestReactModule)
-- ROBLOX deviation END ]]
c.Children._ca0e01d97af5166777e2e48d84fa0244=h
local i
local j={ClassName="ModuleScript",Children={},Properties={}}
j.Name="JestReact"
j.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/jest-react/src/JestReact.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
-- ROBLOX deviation START: not used
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
local Object = LuauPolyfill.Object
local exports = {}
-- ROBLOX deviation START: fix import
-- local JestGlobals = require(Packages.Dev.JestGlobals)
local JestGlobals = require(Packages.JestGlobals)
local expect = JestGlobals.expect
-- ROBLOX deviation END
-- ROBLOX deviation START: fix import
-- local sharedReactSymbolsModule = require(Packages.shared.ReactSymbols)
local sharedReactSymbolsModule = require(Packages.Shared).ReactSymbols
-- ROBLOX deviation END
local REACT_ELEMENT_TYPE = sharedReactSymbolsModule.REACT_ELEMENT_TYPE
local REACT_FRAGMENT_TYPE = sharedReactSymbolsModule.REACT_FRAGMENT_TYPE
-- ROBLOX deviation START: fix import
-- local invariant = require(Packages.shared.invariant).default
local invariant = require(Packages.Shared).invariant
-- ROBLOX deviation END
-- ROBLOX deviation START: predeclare variables
local jsonChildToJSXChild, jsonChildrenToJSXChildren
-- ROBLOX deviation END
local function captureAssertion(fn)
	-- Trick to use a Jest matcher inside another Jest matcher. `fn` contains an
	-- assertion; if it throws, we capture the error and return it, so the stack
	-- trace presented to the user points to the original assertion in the
	-- test file.
	do --\[\[ ROBLOX COMMENT: try-catch block conversion \]\]
		-- ROBLOX deviation START: use pcall, format message
		-- local ok, result, hasReturned = xpcall(function()
		-- 	fn()
		-- end, function(error_)
		-- 	return {
		-- 		pass = false,
		-- 		message = function()
		-- 			return error_.message
		-- 		end,
		-- 	},
		-- 		true
		-- end)
		-- if hasReturned then
		-- 	return result
		-- end
		local ok, result = pcall(fn)

		if not ok then
			local stringResult = tostring(result)
			local subMessageIndex = string.find(stringResult, " ")
			local message = string.sub(stringResult, subMessageIndex + 1)

			return {
				pass = false,
				message = function()
					return message
				end,
			}
		end
		-- ROBLOX deviation END
	end
	return { pass = true }
end
local function assertYieldsWereCleared(root)
	local Scheduler = root._Scheduler
	-- ROBLOX deviation START: use dot notation
	-- local actualYields = Scheduler:unstable_clearYields()
	local actualYields = Scheduler.unstable_clearYields()
	-- ROBLOX deviation END
	invariant(
		-- ROBLOX deviation START: fix .length
		-- actualYields.length == 0,
		#actualYields == 0,
		-- ROBLOX deviation END
		"Log of yielded values is not empty. "
			.. "Call expect(ReactTestRenderer).unstable_toHaveYielded(...) first."
	)
end
local function unstable_toMatchRenderedOutput(root, expectedJSX)
	assertYieldsWereCleared(root)
	-- ROBLOX deviation START: use dot notation
	-- local actualJSON = root:toJSON()
	local actualJSON = root.toJSON()
	-- ROBLOX deviation END
	local actualJSX
	if actualJSON == nil or typeof(actualJSON) == "string" then
		actualJSX = actualJSON
		-- ROBLOX deviation START: remove toJSBoolean
		-- elseif Boolean.toJSBoolean(Array.isArray(actualJSON)) then
	elseif Array.isArray(actualJSON) then
		-- ROBLOX deviation END
		-- ROBLOX deviation START: fix .length
		-- if actualJSON.length == 0 then
		if #actualJSON == 0 then
			-- ROBLOX deviation END
			actualJSX = nil
		-- ROBLOX deviation START: fix .length
		-- elseif actualJSON.length == 1 then
		elseif #actualJSON == 1 then
			-- ROBLOX deviation END
			actualJSX = jsonChildToJSXChild(actualJSON[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			])
		else
			local actualJSXChildren = jsonChildrenToJSXChildren(actualJSON)
			if actualJSXChildren == nil or typeof(actualJSXChildren) == "string" then
				actualJSX = actualJSXChildren
			else
				actualJSX = {
					["$$typeof"] = REACT_ELEMENT_TYPE,
					type = REACT_FRAGMENT_TYPE,
					key = nil,
					ref = nil,
					props = { children = actualJSXChildren },
					_owner = nil,
					-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
					-- _store = if Boolean.toJSBoolean(__DEV__) then {} else nil,
					_store = if _G.__DEV__ then {} else nil,
					-- ROBLOX deviation END
				}
			end
		end
	else
		actualJSX = jsonChildToJSXChild(actualJSON)
	end
	return captureAssertion(function()
		expect(actualJSX).toEqual(expectedJSX)
	end)
end
exports.unstable_toMatchRenderedOutput = unstable_toMatchRenderedOutput
-- ROBLOX deviation START: predeclared function
-- local function jsonChildToJSXChild(jsonChild)
function jsonChildToJSXChild(jsonChild)
	-- ROBLOX deviation END
	if jsonChild == nil or typeof(jsonChild) == "string" then
		return jsonChild
	else
		local jsxChildren = jsonChildrenToJSXChildren(jsonChild.children)
		return {
			["$$typeof"] = REACT_ELEMENT_TYPE,
			type = jsonChild.type,
			key = nil,
			ref = nil,
			props = if jsxChildren == nil
				then jsonChild.props
				else Object.assign({}, jsonChild.props, { children = jsxChildren }),
			_owner = nil,
			-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
			-- _store = if Boolean.toJSBoolean(__DEV__) then {} else nil,
			_store = if _G.__DEV__ then {} else nil,
			-- ROBLOX deviation END
		}
	end
end
-- ROBLOX deviation START: predeclared function
-- local function jsonChildrenToJSXChildren(jsonChildren)
function jsonChildrenToJSXChildren(jsonChildren)
	-- ROBLOX deviation END
	if jsonChildren ~= nil then
		-- ROBLOX deviation START: fix .length
		-- if jsonChildren.length == 1 then
		if #jsonChildren == 1 then
			-- ROBLOX deviation END
			return jsonChildToJSXChild(jsonChildren[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			])
		elseif
			-- ROBLOX deviation START: fix .length
			-- jsonChildren.length
			#jsonChildren
			-- ROBLOX deviation END
			> 1 --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
		then
			local jsxChildren = {}
			local allJSXChildrenAreStrings = true
			local jsxChildrenString = ""
			-- ROBLOX deviation START: use in loop instead of while loop
			-- do
			-- 	local i = 0
			-- 	while
			-- 		i
			-- 		< jsonChildren.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
			-- 	do
			-- 		local jsxChild = jsonChildToJSXChild(jsonChildren[tostring(i)])
			-- 		table.insert(jsxChildren, jsxChild) --\[\[ ROBLOX CHECK: check if 'jsxChildren' is an Array \]\]
			-- 		if Boolean.toJSBoolean(allJSXChildrenAreStrings) then
			-- 			if typeof(jsxChild) == "string" then
			-- 				jsxChildrenString += jsxChild
			-- 			elseif jsxChild ~= nil then
			-- 				allJSXChildrenAreStrings = false
			-- 			end
			-- 		end
			-- 		i += 1
			-- 	end
			-- end
			for _, jsonChild in jsonChildren do
				local jsxChild = jsonChildToJSXChild(jsonChild)

				table.insert(jsxChildren, jsxChild)

				if allJSXChildrenAreStrings then
					if typeof(jsxChild) == "string" then
						jsxChildrenString = jsxChildrenString .. jsxChild
					elseif jsxChild ~= nil then
						allJSXChildrenAreStrings = false
					end
				end
			end
			-- ROBLOX deviation END
			-- ROBLOX deviation START: remove toJSBoolean
			-- return if Boolean.toJSBoolean(allJSXChildrenAreStrings)
			return if allJSXChildrenAreStrings
				-- ROBLOX deviation END
				then jsxChildrenString
				else jsxChildren
		end
	end
	return nil
end
return exports ]]
i.Children._ca60d19dab41d272d3b7e882c0d7ec97=j
local k

local l={ClassName="ModuleScript",Children={},Properties={}}
l.Name="React"
l.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react/src/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *\]\]

-- ROBLOX deviation: simulates `index.js` and exports React's public interface
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local React = require(script.React)
-- ROBLOX deviation START: bindings support
export type Binding<T> = React.ReactBinding<T>
export type BindingUpdater<T> = React.ReactBindingUpdater<T>
-- ROBLOX deviation END

local ReactLazy = require(script.ReactLazy)
export type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

local SharedModule = require(Packages.Shared)
export type StatelessFunctionalComponent<P> =
	SharedModule.React_StatelessFunctionalComponent<P>
-- ROBLOX deviation START: we use the definitely-typed version of this, which appears to work for flowtype in VirtualizedList, etc
export type ComponentType<P> = ComponentClass<P> | FC<P>
-- ROBLOX deviation END
export type AbstractComponent<Config, Instance> = SharedModule.React_AbstractComponent<
	Config,
	Instance
>
export type ElementType = SharedModule.React_ElementType
export type Element<C> = SharedModule.React_Element<C>
export type Key = SharedModule.React_Key
export type Ref<ElementType> = SharedModule.React_Ref<ElementType>
export type Node = SharedModule.React_Node
export type Context<T> = SharedModule.ReactContext<T>
-- ROBLOX TODO: Portal
export type ElementProps<C> = SharedModule.React_ElementProps<C>
export type ElementConfig<T> = SharedModule.React_ElementConfig<T>
export type ElementRef<C> = SharedModule.React_ElementRef<C>
-- ROBLOX TODO: Config
-- ROBLOX TODO: ChildrenArray

-- ROBLOX deviation START: manual type exports since that's not free with 'return React'
export type ComponentClass<P> = SharedModule.React_ComponentType<P>
export type PureComponent<Props, State = nil> = React.PureComponent<Props, State>
-- ROBLOX deviation END

-- ROBLOX deviation START: definitelytyped typescript exports
export type ReactElement<Props = Object, ElementType = any> = SharedModule.ReactElement<
	Props,
	ElementType
>
-- we don't include ReactText in ReactChild since roblox renderer doesn't support raw text nodes
export type ReactChild = SharedModule.ReactElement<any, string> | string | number
export type FC<P> = SharedModule.React_StatelessFunctionalComponent<P>
export type ReactNode = SharedModule.React_Node
-- ROBLOX deviation END

-- ROBLOX deviation START: export React types that are flowtype built-ins and used by VirtualizedList, etc
export type React_AbstractComponent<Props, Instance> = SharedModule.React_Component<
	Props,
	Instance
>
export type React_Component<Props, State> = SharedModule.React_Component<Props, State>
export type React_ComponentType<P> = SharedModule.React_ComponentType<P>
export type React_Context<T> = SharedModule.React_Context<T>
export type React_Element<ElementType> = SharedModule.React_Element<ElementType>
export type React_ElementType = SharedModule.React_ElementType
export type React_Node = SharedModule.React_Node

-- ROBLOX deviation END

return React ]]
c.Children._1d44bd677e02369ce251fcee385f8672=l
local m
local n={ClassName="ModuleScript",Children={},Properties={}}
n.Name="None.roblox"
n.Properties.Source=[[ --!strict
-- code derived from https://github.com/Roblox/roact/blob/master/src/None.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)

-- Roact uses `Object.assign` internally to assign new state values; the same
-- None value should give us the proper semantics. We can re-export this value
-- as React.None for easy use, and to mirror Roact.None in legacy Roact.
return LuauPolyfill.Object.None ]]
m.Children._e77e6a45f83de7d4a70597cabfb25206=n
local o

local p={ClassName="ModuleScript",Children={},Properties={}}
p.Name="React"
p.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react/src/React.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *\]\]

local React = script.Parent
local Packages = React.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local createMutableSource = require(React.ReactMutableSource)
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactBaseClasses = require(React.ReactBaseClasses)
local ReactChildren = require(React.ReactChildren)
local ReactElementValidator = require(React.ReactElementValidator)
local ReactElement = require(React.ReactElement)
local ReactCreateRef = require(React.ReactCreateRef)
local ReactForwardRef = require(React.ReactForwardRef)
local ReactHooks = require(React.ReactHooks)
local ReactMemo = require(React.ReactMemo)
local ReactContext = require(React.ReactContext)
local ReactLazy = require(React.ReactLazy)
type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

-- ROBLOX DEVIATION: Bindings
local ReactBinding = require(React["ReactBinding.roblox"])
-- ROBLOX DEVIATION: Re-export `None` marker
local ReactNone = require(React["None.roblox"])

local SharedModule = require(Packages.Shared)
local ReactSymbols = SharedModule.ReactSymbols

local shouldValidate = _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__
local ReactTypes = require(Packages.Shared)
export type React_StatelessFunctionalComponent<P> =
	ReactTypes.React_StatelessFunctionalComponent<P>
export type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_AbstractComponent<P, T> = ReactTypes.React_AbstractComponent<P, T>
export type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
export type ReactElement<P = Object, T = any> = ReactTypes.ReactElement<P, T>
export type ReactContext<T> = ReactTypes.ReactContext<T>
export type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
export type React_Node = ReactTypes.React_Node
export type PureComponent<Props, State = nil> = ReactTypes.React_PureComponent<
	Props,
	State
>
-- ROBLOX deviation START: bindings support
export type ReactBinding<T> = ReactTypes.ReactBinding<T>
export type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END

type createElementFn = <P, T>(
	type_: React_StatelessFunctionalComponent<P>
		| React_ComponentType<P>
		| React_AbstractComponent<P, T>
		| string
		| ReactContext<any>
		| ReactProviderType<any>
		| LazyComponent<T, P>,
	props: P?,
	...(React_Node | (...any) -> React_Node)
) -> ReactElement<P, T>

type cloneElementFn = <P, T>(
	element: ReactElement<P, T>,
	config: P?,
	...React_Node
) -> ReactElement<P, T>
-- ROBLOX FIXME Luau: these yield Cannot call non-function because the identical unions don't collapse
-- ROBLOX FIXME Luau: the next step is to add createElementFn here and work through issues, AFTER normalization and type packs work
local createElement = if shouldValidate
	then ReactElementValidator.createElementWithValidation :: createElementFn
	else ReactElement.createElement :: createElementFn
local cloneElement: cloneElementFn = if shouldValidate
	then ReactElementValidator.cloneElementWithValidation :: cloneElementFn
	else ReactElement.cloneElement :: cloneElementFn

return {
	Children = ReactChildren,
	createMutableSource = createMutableSource,
	createRef = ReactCreateRef.createRef,
	Component = ReactBaseClasses.Component,
	PureComponent = ReactBaseClasses.PureComponent,
	createContext = ReactContext.createContext,
	forwardRef = ReactForwardRef.forwardRef,
	lazy = ReactLazy.lazy,
	memo = ReactMemo.memo,
	useCallback = ReactHooks.useCallback,
	useContext = ReactHooks.useContext,
	useEffect = ReactHooks.useEffect,
	useImperativeHandle = ReactHooks.useImperativeHandle,
	useDebugValue = ReactHooks.useDebugValue,
	useLayoutEffect = ReactHooks.useLayoutEffect,
	useMemo = ReactHooks.useMemo,
	useMutableSource = ReactHooks.useMutableSource,
	useReducer = ReactHooks.useReducer,
	useRef = ReactHooks.useRef,
	-- ROBLOX deviation: bindings support
	useBinding = ReactHooks.useBinding,
	useState = ReactHooks.useState,
	Fragment = ReactSymbols.REACT_FRAGMENT_TYPE,
	Profiler = ReactSymbols.REACT_PROFILER_TYPE,
	StrictMode = ReactSymbols.REACT_STRICT_MODE_TYPE,
	unstable_DebugTracingMode = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE,
	Suspense = ReactSymbols.REACT_SUSPENSE_TYPE,
	createElement = createElement,
	cloneElement = cloneElement,
	isValidElement = ReactElement.isValidElement,
	-- ROBLOX TODO: ReactVersion
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals,
	-- Deprecated behind disableCreateFactory
	-- ROBLOX TODO: createFactory,
	-- Concurrent Mode
	-- ROBLOX TODO: useTransition,
	-- ROBLOX TODO: startTransition,
	-- ROBLOX TODO: useDeferredValue,
	-- ROBLOX TODO: REACT_SUSPENSE_LIST_TYPE as SuspenseList,
	unstable_LegacyHidden = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE,
	-- enableBlocksAPI
	-- ROBLOX TODO: block,
	-- enableFundamentalAPI
	-- ROBLOX TODO: createFundamental as unstable_createFundamental,
	-- enableScopeAPI
	-- ROBLOX TODO: REACT_SCOPE_TYPE as unstable_Scope,
	-- ROBLOX TODO: useOpaqueIdentifier as unstable_useOpaqueIdentifier,

	-- ROBLOX deviation START: bindings support
	createBinding = ReactBinding.create,
	joinBindings = ReactBinding.join,
	-- ROBLOX deviation END

	-- ROBLOX DEVIATION: export the `None` placeholder for use with setState
	None = ReactNone,

	-- ROBLOX FIXME: These aren't supposed to be exposed, but they're needed by
	-- the renderer in order to update properly
	__subscribeToBinding = ReactBinding.subscribe,

	-- ROBLOX DEVIATION: export Change, Event, and Tag from React
	Event = require(Packages.Shared).Event,
	Change = require(Packages.Shared).Change,
	Tag = require(Packages.Shared).Tag,

	-- ROBLOX DEVIATION: used by error reporters to parse caught errors. React
	-- stringifies at its boundaries to maintain compatibility with
	-- ScriptContext signals that may ultimately catch them
	unstable_parseReactError = require(Packages.Shared).parseReactError,
} ]]
m.Children._8282b02c7061064afa5a8800c6ec3476=p
local q

local r={ClassName="ModuleScript",Children={},Properties={}}
r.Name="ReactBaseClasses"
r.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactBaseClasses.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]
local __DEV__ = _G.__DEV__ :: boolean
local __COMPAT_WARNINGS__ = _G.__COMPAT_WARNINGS__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local SharedModule = require(Packages.Shared)
-- ROBLOX deviation START: we do boolean checks and error() like React 18 does to save functional call in hot path
-- local invariant = SharedModule.invariant
-- ROBLOX deviation END
type React_Component<Props, State = nil> = SharedModule.React_Component<Props, State>
local ReactNoopUpdateQueue = require(script.Parent.ReactNoopUpdateQueue)
local emptyObject = {}

if __DEV__ then
	Object.freeze(emptyObject)
end

-- ROBLOX DEVIATION: Initialize state to a singleton that warns on access and
-- errors on assignment
local UninitializedState = require(Packages.Shared).UninitializedState

--\[\[*
 * Base class helpers for the updating state of a component.
\]\]
-- FIXME: Due to metatable inheritance, this field will be accessible and true
-- on class component _instances_ as well as class component definitions; this
-- is probably not correct
local componentClassPrototype = {
	isReactComponent = true,
}

-- ROBLOX deviation: logic to support old Roact lifecycle method names
-- ROBLOX FIXME: remove below table and function once we've formally stopped
-- supporting old Roact lifecycle method names.

-- ROBLOX FIXME Luau: have to annotate this function manually to suppress ReactBaseClasses.lua:55:3-13: (E001) TypeError: Expected to return 2 values, but 1 is returned here
local function trimPath(path: string): string
	-- ROBLOX TODO: The path splits files by . but file names can
	-- have . in them, so we use best guess heuristics to determine
	-- the file name breaks.
	-- Works for our codebase, but is pretty brittle.

	local pascalFile = string.match(path, "%.%u[%.%w]-$")
	if pascalFile then
		return string.gsub(pascalFile, "^%.", "")
	end

	return path
end

local function warnAboutExistingLifecycle(componentName, newName, existingName)
	console.warn(
		"%s already defined '%s', but it also defining the deprecated Roact method '%s'. %s should only implement one of these methods, preferably using the non-deprecated name.",
		componentName,
		existingName,
		newName,
		componentName
	)
end

local function warnAboutDeprecatedLifecycleName(componentName, newName, existingName)
	if __DEV__ and __COMPAT_WARNINGS__ then
		local path, linenum = debug.info(3, "sln")
		console.warn(
			"%s is using method '%s', which is no longer supported and should be updated to '%s'\nFile: %s:%s",
			componentName,
			newName,
			existingName,
			trimPath(path),
			tostring(linenum)
		)
	end
end

local lifecycleNames = {
	didMount = "componentDidMount",
	shouldUpdate = "shouldComponentUpdate",
	willUpdate = "UNSAFE_componentWillUpdate",
	didUpdate = "componentDidUpdate",
	willUnmount = "componentWillUnmount",
}

local function handleNewLifecycle(self, key, value)
	-- if we're defining a new lifecycle method using old naming convention
	if lifecycleNames[key] ~= nil then
		-- if the method we're defining was already defined under a different name
		if self[lifecycleNames[key\]\] ~= nil then
			warnAboutExistingLifecycle(self.__componentName, key, lifecycleNames[key])
		-- special case for willUpdate which can be defined properly with 2 different names
		elseif key == "willUpdate" and self["componentWillUpdate"] then
			warnAboutExistingLifecycle(
				self.__componentName,
				key,
				"UNSAFE_componentWillUpdate"
			)
		-- otherwise if not previously defined, just warn about deprecated name
		else
			warnAboutDeprecatedLifecycleName(
				self.__componentName,
				key,
				lifecycleNames[key]
			)
		end
		-- update key to proper name
		key = lifecycleNames[key]
	end
	rawset(self, key, value)
end

local componentClassMetatable = {
	__newindex = handleNewLifecycle,
	__index = componentClassPrototype,
	__tostring = function(self)
		return self.__componentName
	end,
}

-- ROBLOX deviation: Extend needs to be a table field for our top-level interface
type React_BaseComponent = React_Component<any, any> & {
	extend: (self: React_BaseComponent, name: string) -> React_Component<any, any>,
}

local Component = (
	setmetatable({ __componentName = "Component" }, componentClassMetatable) :: any
) :: React_BaseComponent

-- ROBLOX deviation: Lua doesn't expose inheritance in a class-syntax way
--\[\[
  A method called by consumers of Roact to create a new component class.
  Components can not be extended beyond this point, with the exception of
  PureComponent.
\]\]

-- ROBLOX performance: pool size tuned for benchmarks
local InstancePoolSize = if not _G.__TESTEZ_RUNNING_TEST__ then 900 else 0
local InstancePoolIndex = 1
local InstancePool = table.create(InstancePoolSize)
for i = 1, InstancePoolSize do
	table.insert(InstancePool, {
		-- pre-initialize instance fields with known static values
		props = nil,
		context = nil,
		state = UninitializedState,
		__refs = emptyObject,
		__updater = ReactNoopUpdateQueue,
	})
end

local function setStateInInit(
	componentInstance: React_Component<any, any>,
	statePayload: any,
	callback: nil
): ()
	if __DEV__ and (callback :: any) ~= nil then
		console.warn(
			"Received a `callback` argument to `setState` during initialization of "
				.. '"%s". The callback behavior is not supported when using `setState` '
				.. "in `init`.\n\nConsider defining similar behavior in a "
				.. "`compontentDidMount` method instead.",
			componentInstance.__componentName
		)
	end

	-- Use the same warning as in the "real" `setState` below
	local typeStatePayload = statePayload and type(statePayload)
	if
		statePayload == nil
		or (typeStatePayload ~= "table" and typeStatePayload ~= "function")
	then
		error(
			"setState(...): takes an object of state variables to update or a "
				.. "function which returns an object of state variables."
		)
	end
	local prevState = componentInstance.state
	local partialState
	if typeStatePayload == "function" then
		-- Updater function
		partialState = statePayload(prevState, componentInstance.props)
	else
		-- Partial state object
		partialState = statePayload
	end
	-- ROBLOX TODO: can't use table.clone optimization here: invalid argument #1 to 'clone' (table has a protected metatable)
	-- local newState = if prevState then table.clone(prevState) else {}
	componentInstance.state = Object.assign({}, prevState, partialState)
end

function Component:extend(name): React_Component<any, any>
	-- ROBLOX note: legacy Roact will accept nil here and default to empty string
	-- ROBLOX TODO: if name in "" in ReactComponentStack frame, we should try and get the variable name it was assigned to
	if name == nil then
		if __COMPAT_WARNINGS__ then
			console.warn(
				"Component:extend() accepting no arguments is deprecated, and will "
					.. "not be supported in a future version of Roact. Please provide an explicit name."
			)
		end
		name = ""
	elseif type(name) ~= "string" then
		error("Component class name must be a string")
	end

	-- ROBLOX performance? do table literal in one shot instead a field at a time in a pairs() loop
	local class = {
		__componentName = name,
		setState = self.setState,
		forceUpdate = self.forceUpdate,
		init = nil, -- ROBLOX note: required to make Luau analyze happy, should be removed by bytecode compiler
	}
	-- for key, value in self do
	--   -- Roact opts to make consumers use composition over inheritance, which
	--   -- lines up with React.
	--   -- https://reactjs.org/docs/composition-vs-inheritance.html
	--   if key ~= "extend" then
	--     class[key] = value
	--   end
	-- end

	class.__index = class
	-- class.__componentName = name

	function class.__ctor<P>(props: P, context, updater): React_Component<P, any>
		local instance
		-- ROBLOX performance: use a pooled object
		if InstancePoolIndex <= InstancePoolSize then
			instance = InstancePool[InstancePoolIndex]
			-- fill in the dynamic fields
			-- ROBLOX FIXME Luau: TypeError: Type 'P' could not be converted into 'nil'
			instance.props = props :: any
			instance.context = context
			-- release the premade object from the pool -- we aren't recycling objects right now
			InstancePool[InstancePoolIndex] = nil
			InstancePoolIndex += 1
		else
			-- ROBLOX note: uncomment to tune pool size for lua-apps
			-- print("!!!!! hit ReactBaseClass instance pool limit")
			instance = {
				-- ROBLOX FIXME Luau: TypeError: Type 'P' could not be converted into 'nil'
				props = props :: any,
				context = context,
				state = UninitializedState,
				__refs = emptyObject,
				__updater = updater or ReactNoopUpdateQueue,
			}

			-- instance.props = props
			-- instance.context = context
			-- ROBLOX DEVIATION: Initialize state to a singleton that warns on attempts
			-- to access this pseudo-uninitialized state and errors on attempts to directly mutate
			-- state.
			-- instance.state = UninitializedState
			-- If a component has string refs, we will assign a different object later.
			-- ROBLOX deviation: Uses __refs instead of refs to avoid conflicts
			-- instance.refs = emptyObject
			-- instance.__refs = emptyObject
			-- We initialize the default updater but the real one gets injected by the
			-- renderer.
			-- instance.__updater = updater or ReactNoopUpdateQueue
		end

		-- ROBLOX TODO: We should consider using a more idiomatic Lua approach for
		-- warning/blocking lifecycle calls during initialization. For now,
		-- ReactNoopUpdateQueue accomplishes this, but we might be able to be more
		-- thorough if we use a dummy metamethod that warns precisely on all sorts
		-- of misbehavior
		instance = setmetatable(instance, class)

		-- ROBLOX performance: only do typeof if it's non-nil to begin with
		if class.init and type(class.init) == "function" then
			-- ROBLOX deviation: Override setState to allow it to be used in init.
			-- This maintains legacy Roact behavior and allows more consistent
			-- adherance to the "never assign directly to state" rule
			instance.setState = setStateInInit

			class.init(instance, props, context)

			-- ROBLOX devition: Unbind specialized version of setState used in init
			instance.setState = nil :: any
		end

		return (instance :: any) :: React_Component<P, any>
	end

	setmetatable(class, getmetatable(self :: any))

	return (class :: any) :: React_Component<any, any>
end

--\[\[*
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `self.state` as immutable.
 *
 * There is no guarantee that `self.state` will be immediately updated, so
 * accessing `self.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from self.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to self.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 \]\]
function Component:setState(partialState, callback)
	if
		partialState ~= nil
		and type(partialState) ~= "table"
		and type(partialState) ~= "function"
	then
		error(
			"setState(...): takes an object of state variables to update or a "
				.. "function which returns an object of state variables."
		)
	end
	self.__updater.enqueueSetState(self, partialState, callback, "setState")
end

--\[\[*
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 \]\]

function Component:forceUpdate(callback)
	self.__updater.enqueueForceUpdate(self, callback, "forceUpdate")
end
--\[\[*
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 \]\]

if __DEV__ then
	-- ROBLOX FIXME Luau: need CLI-53569 to remove the any cast
	local deprecatedAPIs = {
		isMounted = {
			"isMounted",
			"Instead, make sure to clean up subscriptions and pending requests in "
				.. "componentWillUnmount to prevent memory leaks.",
		},
		replaceState = {
			"replaceState",
			"Refactor your code to use setState instead (see "
				.. "https://github.com/facebook/react/issues/3236).",
		},
	} :: any

	local defineDeprecationWarning = function(methodName, info)
		(Component :: any)[methodName] = function()
			console.warn(
				"%s(...) is deprecated in plain JavaScript React classes. %s",
				info[1],
				info[2]
			)
			return nil
		end
	end

	for fnName, _ in deprecatedAPIs do
		if deprecatedAPIs[fnName] ~= nil then
			defineDeprecationWarning(fnName, deprecatedAPIs[fnName])
		end
	end
end

--\[\[*
 * Convenience component with default shallow equality check for sCU.
 \]\]
-- ROBLOX deviation START: work within the `extend` framework defined above to emulate JS's
-- class inheritance

-- ROBLOX FIXME Luau: this is so we get *some* type checking despite the FIXME Luau above
local PureComponent = Component:extend("PureComponent") :: React_BaseComponent;

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
-- ROBLOX FIXME Luau: this is so we get *some* type checking despite the FIXME Luau above
(PureComponent :: any).extend = Component.extend

-- ROBLOX note: We copy members directly from the Component prototype above; we
-- don't need to redefine the constructor or do dummy function trickery to apply
-- it without jumping around
-- ROBLOX performance? inline (duplicate) explicit assignments to avoid loop overhead in hot path
-- Object.assign(pureComponentClassPrototype, componentClassPrototype)
local pureComponentClassPrototype = {
	isReactComponent = true,
	isPureReactComponent = true,
}

-- ROBLOX: FIXME: we should clean this up and align the implementations of
-- Component and PureComponent more clearly and explicitly
setmetatable(PureComponent, {
	__newindex = handleNewLifecycle,
	__index = pureComponentClassPrototype,
	__tostring = function(self)
		return self.__componentName
	end,
})
-- ROBLOX deviation END

return {
	Component = Component,
	PureComponent = PureComponent :: typeof(Component),
} ]]
m.Children._515f4cd0696310587e844482ec37056c=r
local s

local t={ClassName="ModuleScript",Children={},Properties={}}
t.Name="ReactBinding.roblox"
t.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local ReactSymbols = require(Packages.Shared).ReactSymbols

local ReactTypes = require(Packages.Shared)
type Binding<T> = ReactTypes.ReactBinding<T>
type BindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>

local Symbol = LuauPolyfill.Symbol
local createSignal = require(script.Parent["createSignal.roblox"])

local BindingImpl = Symbol("BindingImpl")

type BindingInternal<T> = {
	["$$typeof"]: typeof(ReactSymbols.REACT_BINDING_TYPE),
	value: T,

	getValue: (BindingInternal<T>) -> T,
	-- FIXME Luau: can't define recursive types with different parameters
	map: <U>(BindingInternal<T>, (T) -> U) -> any,

	update: (T) -> (),
	subscribe: ((T) -> ()) -> (() -> ()),
}

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype.getValue<T>(binding: BindingInternal<T>): T
	return BindingInternalApi.getValue(binding)
end

function bindingPrototype.map<T, U>(
	binding: BindingInternal<T>,
	predicate: (T) -> U
): Binding<U>
	return BindingInternalApi.map(binding, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update<T>(binding: any, newValue: T)
	return (binding[BindingImpl] :: BindingInternal<T>).update(newValue)
end

function BindingInternalApi.subscribe<T>(binding: any, callback: (T) -> ())
	return (binding[BindingImpl] :: BindingInternal<T>).subscribe(callback)
end

function BindingInternalApi.getValue<T>(binding: any): T
	return (binding[BindingImpl] :: BindingInternal<T>):getValue()
end

function BindingInternalApi.create<T>(initialValue: T): (Binding<T>, BindingUpdater<T>)
	local subscribe, fire = createSignal()
	local impl = {
		value = initialValue,
		subscribe = subscribe,
	}

	function impl.update(newValue: T)
		impl.value = newValue
		fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	local source
	if _G.__DEV__ then
		-- ROBLOX TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Binding created at:", 3)
	end

	return (setmetatable({
		["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
		[BindingImpl] = impl,
		_source = source,
	}, BindingPublicMeta) :: any) :: Binding<T>,
		impl.update
end

function BindingInternalApi.map<T, U>(
	upstreamBinding: BindingInternal<T>,
	predicate: (T) -> U
): Binding<U>
	if _G.__DEV__ then
		-- ROBLOX TODO: More informative error messages here
		assert(
			typeof(upstreamBinding) == "table"
				and upstreamBinding["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE,
			"Expected `self` to be a binding"
		)
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	local source
	if _G.__DEV__ then
		-- ROBLOX TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Mapped binding created at:", 3)
	end

	return (
		setmetatable({
			["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
			[BindingImpl] = impl,
			_source = source,
		}, BindingPublicMeta) :: any
	) :: Binding<U>
end

-- The `join` API is used statically, so the input will be a table with values
-- typed as the public Binding type
function BindingInternalApi.join<T>(
	upstreamBindings: { [string | number]: Binding<any> }
): Binding<T>
	if _G.__DEV__ then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in upstreamBindings do
			if
				typeof(value) ~= "table"
				or (value :: any)["$$typeof"] ~= ReactSymbols.REACT_BINDING_TYPE
			then
				local message = ("Expected arg #1 to contain only bindings, but key %q had a non-binding value"):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		-- ROBLOX FIXME Luau: needs CLI-56711 resolved to eliminate ipairs()
		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		-- ROBLOX FIXME: type refinements
		local disconnects: any = {}

		for key, upstream in upstreamBindings do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in disconnects do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	local source
	if _G.__DEV__ then
		-- ROBLOX TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Joined binding created at:", 2)
	end

	return (
		setmetatable({
			["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
			[BindingImpl] = impl,
			_source = source,
		}, BindingPublicMeta) :: any
	) :: Binding<T>
end

return BindingInternalApi ]]
m.Children._0ce1753ff9fd7e05319e2a02cbabf05e=t
local u

local v={ClassName="ModuleScript",Children={},Properties={}}
v.Name="ReactChildren"
v.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/7516bdfce3f0f8c675494b5c5d0e7ae441bef1d9/packages/react/src/ReactChildren.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type React_Node = ReactTypes.React_Node
type ReactElement<P, T> = ReactTypes.ReactElement<P, T>

local invariant = require(Packages.Shared).invariant

local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
-- local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local ReactElement = require(script.Parent.ReactElement)
local isValidElement = ReactElement.isValidElement
local cloneAndReplaceKey = ReactElement.cloneAndReplaceKey

local SEPARATOR = "."
local SUBSEPARATOR = ":"

-- --\[\[*
--  * Escape and wrap key so it is safe to use as a reactid
--  *
--  * @param {string} key to be escaped.
--  * @return {string} the escaped key.
--  \]\]
--ROBLOX DEVIATION: use gsub instead of RegEx
local function escape(key: string): string
	local escapedString = string.gsub(key, "=", "=0")
	escapedString = string.gsub(escapedString, ":", "=2")
	return "$" .. escapedString
end

-- --\[\[*
--  * TODO: Test that a single child and an array with one item have the same key
--  * pattern.
--  \]\]

-- ROBLOX DEVIATION: There is currently no good way to warn about maps
-- local didWarnAboutMaps = false

-- local userProvidedKeyEscapeRegex = '/\\/+/g'
local function escapeUserProvidedKey(text: string): string
	-- ROBLOX DEVIATION: just return the original string
	-- return text.replace(userProvidedKeyEscapeRegex, '$&/')
	return text
end

-- --\[\[*
--  * Generate a key string that identifies a element within a set.
--  *
--  * @param {*} element A element that could contain a manual key.
--  * @param {number} index Index that is used if a manual key is not provided.
--  * @return {string}
--  \]\]
local function getElementKey(element: any, index: number): string
	-- Do some typechecking here since we call this blindly. We want to ensure
	-- that we don't block potential future ES APIs.
	if typeof(element) == "table" and element ~= nil and element.key ~= nil then
		-- Explicit key
		return escape(tostring(element.key))
	end
	-- Implicit key determined by the index in the set
	-- ROBLOX DEVIATION: unsupported radix arg in tostring(number)
	-- return index.toString(36)
	return tostring(index)
end

local function mapIntoArray(
	children: ReactNodeList?,
	array: Array<React_Node>,
	escapedPrefix: string,
	nameSoFar: string,
	callback: (React_Node?) -> ReactNodeList?
): number
	local type = typeof(children)

	--\[\[
		ROBLOX DEVIATION: userdata type corresponds to React.None, which is perceived as nil. All
		userdata is treated as nil when passed as a child.
	\]\]
	if type == "nil" or type == "boolean" or type == "userdata" then
		-- All of the above are perceived as nil.
		children = nil
	end

	local invokeCallback = false

	if children == nil then
		invokeCallback = true
	else
		if type == "string" or type == "number" then
			invokeCallback = true
		elseif type == "table" then
			local childrenType = (children :: any)["$$typeof"]
			if
				childrenType == REACT_ELEMENT_TYPE
				or childrenType == REACT_PORTAL_TYPE
			then
				invokeCallback = true
			end
		end
	end

	if invokeCallback then
		local child = children
		local mappedChild = callback(child)
		-- If it's the only child, treat the name as if it was wrapped in an array
		-- so that it's consistent if the number of children grows:
		local childKey = if nameSoFar == ""
			then SEPARATOR .. getElementKey(child, 1)
			else nameSoFar
		if Array.isArray(mappedChild) then
			local escapedChildKey = ""
			if childKey ~= nil then
				escapedChildKey = escapeUserProvidedKey(childKey) .. "/"
			end
			mapIntoArray(mappedChild, array, escapedChildKey, "", function(c)
				return c
			end)
		elseif mappedChild ~= nil then
			if isValidElement(mappedChild :: any) then
				local mappedChildKey = (mappedChild :: ReactElement<Object, any>).key
				mappedChild = cloneAndReplaceKey(
					mappedChild :: ReactElement<Object, any>,
					-- Keep both the (mapped) and old keys if they differ, just as
					-- traverseAllChildren used to do for objects as children
					escapedPrefix
						-- $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
						.. (
							if mappedChildKey
									and (
										not child
										or (child :: ReactElement<Object, any>).key
											~= mappedChildKey
									)
								-- $FlowFixMe Flow incorrectly thinks existing element's key can be a number
								then escapeUserProvidedKey(tostring(mappedChildKey)) .. "/"
								else ""
						)
						.. childKey
				)
			end
			table.insert(array, mappedChild)
		end
		return 1
	end

	local child
	local nextName
	local subtreeCount = 0 -- Count of children found in the current subtree.
	local nextNamePrefix = if nameSoFar == ""
		then SEPARATOR
		else nameSoFar .. SUBSEPARATOR

	if Array.isArray(children) then
		-- ROBLOX FIXME: Luau doesn't recognize this as non-nil without the `or {}`
		for i = 1, #(children :: Array<React_Node>) do
			child = (children :: Array<React_Node>)[i]
			nextName = nextNamePrefix .. getElementKey(child, i)
			subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback)
		end
	else
		local iteratorFn = getIteratorFn(children)
		if typeof(iteratorFn) == "function" then
			local iterableChildren: Object & {
				entries: any,
			} = children :: any

			-- ROBLOX DEVIATION: No equivalent for checking if iterableChildren is a Map
			-- if _G.__DEV__ then
			-- 	-- Warn about using Maps as children
			-- 	if iteratorFn == iterableChildren.entries then
			-- 		if not didWarnAboutMaps then
			-- 			console.warn(
			-- 				"Using Maps as children is not supported. "
			-- 					.. "Use an array of keyed ReactElements instead."
			-- 			)
			-- 		end
			-- 		didWarnAboutMaps = true
			-- 	end
			-- end

			local iterator = iteratorFn(iterableChildren)
			local step
			local ii = 1
			step = iterator.next()
			while not step.done do
				child = step.value
				nextName = nextNamePrefix .. getElementKey(child, ii)
				ii += 1
				subtreeCount += mapIntoArray(
					child,
					array,
					escapedPrefix,
					nextName,
					callback
				)
				step = iterator.next()
			end
			--\[\[ ROBLOX DEVIATION: this condition will never be met with Roact iterator logic.
				getIteratorFn will always return a function when "children" is a table
			\]\]
			-- elseif type == 'table' then
			--   local childrenString = '' .. tostring(children)
			--   invariant(
			--     false,
			--     'Objects are not valid as a React child (found: %s). ' ..
			--       'If you meant to render a collection of children, use an array ' ..
			--       'instead.',
			--        if childrenString == '[object Object]'
			--          then 'object with keys {' .. Object.keys(children :: any).join(', ') .. '}'
			--          else childrenString
			--   )
		end
	end

	return subtreeCount
end

type MapFunc = (child: React_Node?, index: number) -> ReactNodeList?

--\[\[
	* Maps children that are typically specified as `props.children`.
	*
	* See https://reactjs.org/docs/react-api.html#reactchildrenmap
	*
	* The provided mapFunction(child, index) will be called for each
	* leaf child.
	*
	* @param {?*} children Children tree container.
	* @param {function(*, int)} func The map function.
	* @param {*} context Context for mapFunction.
	* @return {object} Object containing the ordered map of results.
\]\]
local function mapChildren(
	children: ReactNodeList?,
	func: MapFunc,
	context: any
): Array<React_Node>?
	if children == nil then
		return nil
	end
	local result = {}
	local count = 1
	mapIntoArray(children, result, "", "", function(child)
		-- ROBLOX DEVIATION: don't use context argument
		local mapFuncResult = func(child, count)
		count += 1
		return mapFuncResult
	end)
	return result
end

-- --\[\[*
--  * Count the number of children that are typically specified as
--  * `props.children`.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrencount
--  *
--  * @param {?*} children Children tree container.
--  * @return {number} The number of children.
--  \]\]
local function countChildren(children: ReactNodeList?): number
	local n = 0
	mapChildren(children, function()
		n += 1
		-- Don't return anything
		return
	end)
	return n
end

type ForEachFunc = (child: React_Node?, index: number) -> ()

-- --\[\[*
--  * Iterates through children that are typically specified as `props.children`.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
--  *
--  * The provided forEachFunc(child, index) will be called for each
--  * leaf child.
--  *
--  * @param {?*} children Children tree container.
--  * @param {function(*, int)} forEachFunc
--  * @param {*} forEachContext Context for forEachContext.
--  \]\]
local function forEachChildren(
	children: ReactNodeList?,
	forEachFunc: ForEachFunc,
	forEachContext: any
)
	mapChildren(children, function(...)
		-- ROBLOX DEVIATION: Don't use javascript apply
		forEachFunc(...)
		-- Don't return anything.
		return
	end, forEachContext)
end

-- --\[\[*
--  * Flatten a children object (typically specified as `props.children`) and
--  * return an array with appropriately re-keyed children.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
--  \]\]
local function toArray(children: ReactNodeList?): Array<React_Node>
	return mapChildren(children, function(child)
		return child
	end) or {}
end

--\[\[*
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
\]\]
-- ROBLOX deviation START: we skip generics here, because we can't explicitly constrain them. no annotation works as passthrough.
local function onlyChild(children)
	-- ROBLOX deviation END
	invariant(
		isValidElement(children),
		"React.Children.only expected to receive a single React element child."
	)
	return children
end

return {
	forEach = forEachChildren,
	map = mapChildren,
	count = countChildren,
	only = onlyChild,
	toArray = toArray,
} ]]
m.Children._7c8c0c54b4752e50631083ce81ad53c4=v
local w

local x={ClassName="ModuleScript",Children={},Properties={}}
x.Name="ReactContext"
x.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/7516bdfce3f0f8c675494b5c5d0e7ae441bef1d9/packages/react/src/ReactContext.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
\]\]
local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console

local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
type ReactContext<T> = Shared.ReactContext<T>
type ReactProviderType<T> = Shared.ReactProviderType<T>

local exports = {}

exports.createContext = function<T>(
	defaultValue: T,
	calculateChangedBits: ((a: T, b: T) -> number)?
): ReactContext<T>
	local context: ReactContext<any> = {
		["$$typeof"] = REACT_CONTEXT_TYPE,
		_calculateChangedBits = calculateChangedBits,
		-- As a workaround to support multiple concurrent renderers, we categorize
		-- some renderers as primary and others as secondary. We only expect
		-- there to be two concurrent renderers at most: React Native (primary) and
		-- Fabric (secondary); React DOM (primary) and React ART (secondary).
		-- Secondary renderers store their context values on separate fields.
		_currentValue = defaultValue,
		_currentValue2 = defaultValue,
		-- Used to track how many concurrent renderers this context currently
		-- supports within in a single renderer. Such as parallel server rendering.
		_threadCount = 0,
		-- These are circular
		Provider = (nil :: any) :: ReactProviderType<T>,
		Consumer = (nil :: any) :: ReactContext<T>,
		-- ROBLOX deviation: tables declared this way are considered sealed, so define we
		-- displayName as nil for it to be populated later
		displayName = nil,
		-- ROBLOX deviation: have to inline these optional fields to make Luau happy
		_currentRenderer = nil,
		_currentRenderer2 = nil,
	}
	context.Provider = {
		["$$typeof"] = REACT_PROVIDER_TYPE,
		_context = context,
	}

	local hasWarnedAboutDisplayNameOnConsumer = false

	if _G.__DEV__ then
		-- A separate object, but proxies back to the original context object for
		-- backwards compatibility. It has a different $$typeof, so we can properly
		-- warn for the incorrect usage of Context as a Consumer.
		local Consumer = {
			["$$typeof"] = REACT_CONTEXT_TYPE,
			_context = context,
			_calculateChangedBits = context._calculateChangedBits,
		}

		setmetatable(Consumer, {
			__index = function(self, key)
				-- deviation: don't implement already-deprecated things like Consumer.Provider, Consumer.Consumer, etc
				if key == "_currentValue" then
					return context._currentValue
				elseif key == "_currentValue2" then
					return context._currentValue2
				elseif key == "_threadCount" then
					return context._threadCount
				elseif key == "displayName" then
					return context.displayName
				end
				return nil
			end,
			__newindex = function(self, key, value)
				if key == "_currentValue" then
					context._currentValue = value
				elseif key == "_currentValue2" then
					context._currentValue2 = value
				elseif key == "_threadCount" then
					context._threadCount = value
				elseif key == "displayName" then
					if not hasWarnedAboutDisplayNameOnConsumer then
						console.warn(
							"Setting `displayName` on Context.Consumer has no effect. "
								.. "You should set it directly on the context with Context.displayName = "
								.. value
								.. "."
						)
						hasWarnedAboutDisplayNameOnConsumer = true
					end
				end
			end,
		})

		context.Consumer = (Consumer :: any) :: ReactContext<any>
	else
		context.Consumer = context
	end

	if _G.__DEV__ then
		context._currentRenderer = nil
		context._currentRenderer2 = nil
	end

	return context
end

return exports ]]
m.Children._61ab26df1cef070a6d876fc47d5dd6f4=x
local y

local z={ClassName="ModuleScript",Children={},Properties={}}
z.Name="ReactCreateRef"
z.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react/src/ReactCreateRef.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * @flow
*\]\]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type RefObject = ReactTypes.RefObject

-- ROBLOX DEVIATION: In Roact, refs are implemented in terms of bindings
--\[\[
  A ref is nothing more than a binding with a special field 'current'
  that maps to the getValue method of the binding
\]\]
local Binding = require(script.Parent["ReactBinding.roblox"])

local exports = {}

-- an immutable object with a single mutable value
exports.createRef = function(): RefObject
	local binding, _ = Binding.create(nil)

	local ref = {}

	-- ROBLOX DEVIATION: Since refs are used as bindings, they can often be
	-- assigned to fields of other Instances; we track creation here parallel to
	-- how we do with bindings created via `createBinding` to improve messaging
	-- when something goes wrong
	if _G.__DEV__ then
		-- ROBLOX TODO: LUAFDN-619 - improve debug stacktraces for refs
		binding._source = debug.traceback("Ref created at:", 1)
	end

	--\[\[
    A ref is just redirected to a binding via its metatable
  \]\]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return (binding :: any)[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				-- ROBLOX FIXME: Bindings - This is not allowed in Roact, but is okay in
				-- React. Lots of discussion at
				-- https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
				-- error("Cannot assign to the 'current' property of refs", 2)
				Binding.update(binding, value)
			end

			(binding :: any)[key] = value
		end,
		__tostring = function(self)
			return string.format("Ref(%s)", tostring(binding:getValue()))
		end,
	})

	return (ref :: any) :: RefObject
end

return exports ]]
m.Children._cf68a13e680fd45e3be1db0be52b8651=z
local A

local B={ClassName="ModuleScript",Children={},Properties={}}
B.Name="ReactElement"
B.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react/src/ReactElement.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local ReactTypes = require(Packages.Shared)
type React_StatelessFunctionalComponent<P> = ReactTypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_AbstractComponent<P, T> = ReactTypes.React_AbstractComponent<P, T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
type React_Node = ReactTypes.React_Node
type ReactElement<P = Object, T = any> = ReactTypes.ReactElement<P, T>
type ReactContext<T> = ReactTypes.ReactContext<T>
type Source = ReactTypes.Source

local ReactLazy = require(script.Parent.ReactLazy)
type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

local getComponentName = require(Packages.Shared).getComponentName
-- ROBLOX deviation START: we eliminate invariant like in React 18 to avoid string formatting and function call overhead
-- local invariant = require(Packages.Shared).invariant
-- ROBLOX deviation END
local REACT_ELEMENT_TYPE = require(Packages.Shared).ReactSymbols.REACT_ELEMENT_TYPE
local ReactCurrentOwner = require(Packages.Shared).ReactSharedInternals.ReactCurrentOwner
--local hasOwnProperty = Object.prototype.hasOwnProperty
-- ROBLOX deviation START: upstream iterates over this table, but we manually unroll those loops for hot path performance
-- IF THIS TABLE UPDATES, YOU MUST UPDATE THE UNROLLED LOOPS AS WELL
local RESERVED_PROPS = {
	key = true,
	ref = true,
	__self = true,
	__source = true,
}
-- ROBLOX deviation END

local specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs

if __DEV__ then
	didWarnAboutStringRefs = {}
end

local exports = {}

local function hasValidRef(config)
	if __DEV__ then
		-- ROBLOX DEVIATION: instead of getters, use `__index` metamethod to
		-- detect if it's a warning object
		if config.ref ~= nil and type(config.ref) == "table" then
			if (config.ref :: any).isReactWarning then
				return false
			end
		end
	end

	return config.ref ~= nil
end

local function hasValidKey(config)
	if __DEV__ then
		-- ROBLOX DEVIATION: instead of getters, use `__index` metamethod to
		-- detect if it's a warning object
		if config.key ~= nil and type(config.key) == "table" then
			if (config.key :: any).isReactWarning then
				return false
			end
		end
	end

	return config.key ~= nil
end

local reactWarning = { isReactWarning = true }

-- ROBLOX FIXME: These two warning 'getter' definitions both override the
-- metatable, and won't both work at the same time. The easy solution is to
-- define one metatable that does both instead of overwriting
local function defineKeyPropWarningGetter(props, displayName: string)
	local warnAboutAccessingKey = function()
		if __DEV__ then
			if not specialPropKeyWarningShown then
				specialPropKeyWarningShown = true
				console.error(
					"%s: `key` is not a prop. Trying to access it will result "
						.. "in `nil` being returned. If you need to access the same "
						.. "value within the child component, you should pass it as a different "
						.. "prop. (https://reactjs.org/link/special-props)",
					displayName
				)
			end
		end
	end

	-- ROBLOX deviation: clear key to ensure metamethod is called,
	-- then set key getter to call warnAboutAccessingKey
	props.key = nil
	setmetatable(props, {
		__index = function(t, k)
			if k == "key" then
				warnAboutAccessingKey()
				-- ROBLOX deviation: returns sentinel object that mimics upstream ability to check isReactWarning field
				return reactWarning
			end
			-- ROBLOX FIXME Luau: needs deferred constraint resolution
			return nil :: any
		end,
	})
end

local function defineRefPropWarningGetter(props, displayName: string)
	-- deviation: Use a __call metamethod here to make this function-like, but
	-- still able to have the `isReactWarning` flag defined on it
	local warnAboutAccessingRef = function()
		if __DEV__ then
			if not specialPropRefWarningShown then
				specialPropRefWarningShown = true
				console.error(
					"%s: `ref` is not a prop. Trying to access it will result "
						.. "in `nil` being returned. If you need to access the same "
						.. "value within the child component, you should pass it as a different "
						.. "prop. (https://reactjs.org/link/special-props)",
					displayName
				)
			end
		end
	end

	-- ROBLOX deviation: clear key to ensure metamethod is called,
	-- then set key getter to call warnAboutAccessingKey
	props.ref = nil
	setmetatable(props :: any, {
		__index = function(t, k)
			if k == "ref" then
				warnAboutAccessingRef()
				-- ROBLOX deviation: returns sentinel object that mimics upstream ability to check isReactWarning field
				return reactWarning
			end
			-- ROBLOX FIXME Luau: needs deferred constraint resolution
			return nil :: any
		end,
	})
end

local function warnIfStringRefCannotBeAutoConverted(config)
	if __DEV__ then
		if
			-- ROBLOX deviation: We removed support for string refs, so all stringrefs cannot be auto-converted regardless
			type(config.ref) == "string" and ReactCurrentOwner.current
			-- and config.__self
			-- and ReactCurrentOwner.current.stateNode ~= config.__self
		then
			local componentName = getComponentName(ReactCurrentOwner.current.type)

			-- ROBLOX deviation: we don't support string refs and hard error instead of warn
			if not didWarnAboutStringRefs[componentName] then
				error(
					string.format(
						'Component "%s" contains the string ref "%s". '
							.. "Support for string refs has been removed. "
							.. "We recommend using useRef() or createRef() instead. "
							.. "Learn more about using refs safely here: "
							.. "https://reactjs.org/link/strict-mode-string-ref",
						componentName or "Unknown",
						config.ref
					)
				)
				-- didWarnAboutStringRefs[componentName] = true
			end
		end
	end
end

--\[\[*
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param *} type
 * @param *} props
 * @param *} key
 * @param string|object} ref
 * @param *} owner
 * @param *} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param *} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 \]\]

-- ROBLOX deviation BEGIN: extra annotations here inspired by TS and flowtype to facilitate prop checking at analyze-time
local function ReactElement<P, T>(
	type_: T,
	key,
	ref,
	self,
	source: Source?,
	owner,
	props: P
): ReactElement<P, T>
	-- ROBLOX deviation END
	local element = {
		-- Built-in properties that belong on the element
		type = type_,
		key = key,
		ref = ref,
		props = props,
		-- Record the component responsible for creating this element.
		_owner = owner,
	}

	-- This tag allows us to uniquely identify this as a React Element
	element["$$typeof"] = REACT_ELEMENT_TYPE

	if __DEV__ then
		-- The validation flag is currently mutative. We put it on
		-- an external backing store so that we can freeze the whole object.
		-- This can be replaced with a WeakMap once they are implemented in
		-- commonly used development environments.
		local nonEnumerable = {
			validated = false,
		}
		element._store = setmetatable({}, {
			-- To make comparing ReactElements easier for testing purposes, we
			-- make the validation flag non-enumerable (where possible, which
			-- should include every environment we run tests in), so the test
			-- framework ignores it.
			__index = nonEnumerable,
			__newindex = function(table, key, value)
				if key == "validated" then
					nonEnumerable.validated = value
				else
					rawset(table, key, value)
				end
			end,
		})
		-- self and source are DEV only properties.
		setmetatable(element, {
			__index = {
				_self = self,
				-- Two elements created in two different places should be considered
				-- equal for testing purposes and therefore we hide it from enumeration.
				_source = source,
			},
		})
	end

	-- ROBLOX FIXME Luau: this cast is needed until normalization lands
	return element :: any
end

----\[\[*
-- * https://github.com/reactjs/rfcs/pull/107
-- * @param *} type
-- * @param object} props
-- * @param string} key
-- \]\]
--
--
exports.jsx = function(type, config, maybeKey)
	-- ROBLOX deviation START: skipping JSX for now, as it may never apply to Roblox
	error("JSX is currently unsupported")
	--  local propName; -- Reserved names are extracted
	--
	--  local props = }
	--  local key = nil
	--  local ref = nil; -- Currently, key can be spread in as a prop. This causes a potential
	--  -- issue if key is also explicitly declared (ie. <div ...props} key="Hi" />
	--  -- or <div key="Hi" ...props} /> ). We want to deprecate key spread,
	--  -- but as an intermediary step, we will use jsxDEV for everything except
	--  -- <div ...props} key="Hi" />, because we aren't currently able to tell if
	--  -- key is explicitly declared to be nil or not.
	--
	--  if maybeKey ~= nil)
	--    key = '' .. maybeKey
	--  end
	--
	--  if hasValidKey(config))
	--    key = '' .. config.key
	--  end
	--
	--  if hasValidRef(config))
	--    ref = config.ref
	--  } -- Remaining properties are added to a new props object
	--
	--
	--  for (propName in config)
	--    if hasOwnProperty.call(config, propName) and !RESERVED_PROPS.hasOwnProperty(propName))
	--      props[propName] = config[propName]
	--    end
	--  } -- Resolve default props
	--
	--
	--  if type and type.defaultProps)
	--    local defaultProps = type.defaultProps
	--
	--    for (propName in defaultProps)
	--      if props[propName] == nil)
	--        props[propName] = defaultProps[propName]
	--      end
	--    end
	-- end
	--
	--  return ReactElement(type, key, ref, nil, nil, ReactCurrentOwner.current, props)
	-- ROBLOX deviation END
end

--\[\[*
-- * https://github.com/reactjs/rfcs/pull/107
-- * @param *} type
-- * @param object} props
-- * @param string} key
-- \]\]
--
exports.jsxDEV = function(type, config, maybeKey, source, self)
	-- ROBLOX deviation START: we may never support JSX
	error("JSX is currently unsupported")
	--  local propName; -- Reserved names are extracted
	--
	--  local props = }
	--  local key = nil
	--  local ref = nil; -- Currently, key can be spread in as a prop. This causes a potential
	--  -- issue if key is also explicitly declared (ie. <div ...props} key="Hi" />
	--  -- or <div key="Hi" ...props} /> ). We want to deprecate key spread,
	--  -- but as an intermediary step, we will use jsxDEV for everything except
	--  -- <div ...props} key="Hi" />, because we aren't currently able to tell if
	--  -- key is explicitly declared to be nil or not.
	--
	--  if maybeKey ~= nil)
	--    key = '' .. maybeKey
	--  end
	--
	--  if hasValidKey(config))
	--    key = '' .. config.key
	--  end
	--
	--  if hasValidRef(config))
	--    ref = config.ref
	--    warnIfStringRefCannotBeAutoConverted(config)
	--  } -- Remaining properties are added to a new props object
	--
	--
	--  for (propName in config)
	--    if hasOwnProperty.call(config, propName) and !RESERVED_PROPS.hasOwnProperty(propName))
	--      props[propName] = config[propName]
	--    end
	--  } -- Resolve default props
	--
	--
	--  if type and type.defaultProps)
	--    local defaultProps = type.defaultProps
	--
	--    for (propName in defaultProps)
	--      if props[propName] == nil)
	--        props[propName] = defaultProps[propName]
	--      end
	--    end
	--  end
	--
	--  if key or ref)
	--    local displayName = function ()
	--      if typeof type == 'function')
	--        return type.displayName or type.name or 'Unknown'
	--      end
	--
	--      return type
	--    }()
	--
	--    if key)
	--      defineKeyPropWarningGetter(props, displayName)
	--    end
	--
	--    if ref)
	--      defineRefPropWarningGetter(props, displayName)
	--    end
	--
	--  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)
	return nil
	-- ROBLOX deviation END
end

--\[\[*
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 \]\]
-- ROBLOX deviation: this is TypeScript-derived annotation, but using flowtypes
--  function createElement<P extends {}>(
-- 	type: FunctionComponent<P> | ComponentClass<P> | string,
-- 	props?: Attributes & P | null,
-- 	...children: ReactNode[]): ReactElement<P>;
local function createElement<P, T>(
	type_: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | React_AbstractComponent<P, T> | ReactContext<any> | LazyComponent<T, P> | ReactProviderType<any> | string,
	config: P?,
	...: React_Node | (...any) -> React_Node
): ReactElement<P, T>
	-- ROBLOX deviation START: extreme hot path, so manually unroll RESERVED_PROPS loop and use table.clone
	local props = if config ~= nil then table.clone(config :: any) :: any else {}
	-- ROBLOX deviation END
	local key: (string | number)? = nil
	local ref = nil
	local self = nil
	local source: Source? = nil

	if config ~= nil then
		-- ROBLOX deviation START: inline hasValidRef and hasValidKey success in hot path, still call in error case for warning
		-- ROBLOX FIXME Luau: needs normalization: Type 'P & React_ElementProps<T>' could not be converted into 'React_ElementProps<T>'; none of the intersection parts are compatible
		if hasValidRef(config :: any) then
			ref = ((config :: any) :: React_ElementProps<T>).ref

			if __DEV__ then
				warnIfStringRefCannotBeAutoConverted(
					(config :: any) :: React_ElementProps<T>
				)
			end
		end

		-- ROBLOX FIXME Luau: when configKey is inline: Type 'P & React_ElementProps<T>' could not be converted into 'React_ElementProps<T>'; none of the intersection parts are compatible
		if hasValidKey(config :: any) then
			local configKey = (config :: any).key
			-- ROBLOX deviation: call tostring instead of concatenating with an
			-- empty string, which can throw in luau. If the string is a number,
			-- then do not use tostring
			if type(configKey) == "number" then
				key = configKey
			else
				-- ROBLOX FIXME Luau: narrowing bug: Type 'string' could not be converted into 'number'
				key = tostring(configKey :: any)
			end
		end
		-- ROBLOX deviation END

		-- ROBLOX deviation START: seemingly only used for string ref warnings, which we don't support
		-- self = if config.__self == nil then nil else config.__self
		-- ROBLOX deviation END

		source = if ((config :: any) :: React_ElementProps<T>).__source == nil
			then nil
			else ((config :: any) :: React_ElementProps<T>).__source

		-- Remaining properties are added to a new props object
		-- ROBLOX deviation START: extreme hot path, so manually unroll RESERVED_PROPS loop and use table.clone
		if props.key ~= nil then
			props.key = nil
		end
		if props.ref ~= nil then
			props.ref = nil
		end
		if props.__self ~= nil then
			props.__self = nil
		end
		if props.__source ~= nil then
			props.__source = nil
		end
		-- ROBLOX deviation END
	end

	-- Children can be more than one argument, and those are transferred onto
	-- the newly allocated props object.
	-- ROBLOX deviation START: we have a shortcut for capturing varargs into an array in Lua, which is more performant
	local childrenLength = select("#", ...)

	if childrenLength == 1 then
		props.children = select(1, ...)
	elseif childrenLength > 1 then
		-- ROBLOX TODO: there's a snapshot difference in storeOwners where key is 2 instead of 1 if we do `{...}`. does it matter?
		-- local childArray = {...}
		local childArray = table.create(childrenLength)
		for i = 1, childrenLength do
			local toInsert = select(i, ...)
			table.insert(childArray, toInsert)
		end

		-- ROBLOX deviation END

		if __DEV__ then
			table.freeze(childArray)
		end

		props.children = childArray
	end

	-- Resolve default props
	-- ROBLOX deviation START: Lua can't index defaultProps on a function
	-- ROBLOX FIXME Luau: should know this can be a table due to type_ intersection with React_ComponentType<>. needs normalization?
	if
		type(type_ :: any) == "table"
		and (type_ :: T & React_ComponentType<P>).defaultProps
	then
		-- ROBLOX deviation END
		-- ROBLOX FIXME Luau: defaultProps isn't narrowed by the guard above
		local defaultProps = (type_ :: T & React_ComponentType<P>).defaultProps :: P

		-- ROBLOX Luau TODO: defaultProps isn't known to be a table, since Luau doesn't allow us to do `<P extends {}>` yet
		for propName, _ in (defaultProps :: any) :: Object do
			if props[propName] == nil then
				props[propName] = ((defaultProps :: any) :: Object)[propName]
			end
		end
	end

	if __DEV__ then
		if key or ref then
			-- ROBLOX deviation START: Lua can't store fields like displayName on functions
			local displayName

			if type(type_) == "function" then
				-- displayName = (type_.displayName or type_.name) or "Unknown"
				displayName = debug.info(type_, "n") or "<function>"
			elseif type(type_) == "table" then
				displayName = (
					(type_ :: T & React_ComponentType<P>).displayName
					or (type_ :: T & React_ComponentType<P>).name
				) or "Unknown"
			else
				-- ROBLOX Luau FIXME: Luau should have narrowed type_ to string based on this above branches
				displayName = type_ :: string
			end
			-- ROBLOX deviation END

			if key then
				defineKeyPropWarningGetter(props, displayName)
			end

			if ref then
				defineRefPropWarningGetter(props, displayName)
			end
		end

		-- ROBLOX deviation START: In upstream, JSX transformation is what
		-- produces the `__source` field, so we'll just simulate it here for now
		if source == nil then
			-- go up one more because of ReactElementValidator indirection
			source = {
				fileName = debug.info(3, "s"),
				lineNumber = debug.info(3, "l"),
			}
		end
		-- ROBLOX deviation END
	end

	-- ROBLOX FIXME Luau: this cast is needed until normalization lands
	return ReactElement(
		type_,
		key,
		ref,
		self,
		source,
		ReactCurrentOwner.current,
		props
	) :: any
end
exports.createElement = createElement

----\[\[*
-- * Return a function that produces ReactElements of a given type.
-- * See https://reactjs.org/docs/react-api.html#createfactory
-- \]\]
--
--export function createFactory(type)
--  local factory = createElement.bind(null, type); -- Expose the type on the factory and the prototype so that it can be
--  -- easily accessed on elements. E.g. `<Foo />.type == Foo`.
--  -- This should not be named `constructor` since this may not be the function
--  -- that created the element, and it may not even be a constructor.
--  -- Legacy hook: remove it
--
--  factory.type = type
--  return factory
--end
exports.cloneAndReplaceKey =
	function<P, T>(oldElement: ReactElement<P, T>, newKey: any): ReactElement<P, T>
		local newElement = ReactElement(
			oldElement.type,
			newKey,
			oldElement.ref,
			oldElement._self,
			oldElement._source,
			oldElement._owner,
			oldElement.props
		)
		return newElement
	end

--\[\[*
* Clone and return a new ReactElement using element as the starting point.
* See https://reactjs.org/docs/react-api.html#cloneelement
\]\]

exports.cloneElement = function<P, T>(
	element: ReactElement<P, T>,
	config: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- ROBLOX deviation START: use if instead of variant to avoid error message formatting even when there's no problem
	if element == nil then
		error(
			Error.new(
				"React.cloneElement(...): The argument must be a React element, but you passed "
					.. tostring(element)
			)
		)
	end

	-- Original props are copied
	local elementProps = element.props
	local props: P & React_ElementProps<T> = if elementProps ~= nil
		then table.clone(elementProps :: P & React_ElementProps<T>) :: any
		else {} :: P & React_ElementProps<T>

	-- Reserved names are extracted
	local key = element.key
	local ref = element.ref

	-- Self is preserved since the owner is preserved.
	-- ROBLOX deviation: _self field only used for string ref checking
	-- local self = element._self

	-- Source is preserved since cloneElement is unlikely to be targeted by a
	-- transpiler, and the original source is probably a better indicator of the
	-- true owner.
	local source = element._source

	-- Owner will be preserved, unless ref is overridden
	local owner = element._owner

	if config ~= nil then
		-- ROBLOX deviation START: inline hasValidRef and hasValidKey success in hot path, still call in error case for warning
		local configRef = config.ref
		if configRef ~= nil then
			-- Silently steal the ref from the parent.
			ref = configRef
			owner = ReactCurrentOwner.current
		else
			hasValidRef(config)
		end

		local configKey = config.key
		-- ROBLOX FIXME Luau: needs normalization, generic subtype escaping scope
		if configKey ~= nil then
			if type(configKey) == "number" then
				key = configKey
			else
				-- ROBLOX FIXME Luau: narrowing bug: Type 'string' could not be converted into 'number'
				key = configKey :: any or "nil"
			end
		else
			hasValidKey((config :: any) :: React_ElementProps<T>)
		end
		-- ROBLOX deviation END
	end

	-- Remaining properties override existing props
	local elementType = element.type
	local defaultProps: P? = if type(elementType) == "table"
		then elementType.defaultProps
		else nil

	-- ROBLOX deviation: cannot call pairs on nil the way you can use `for...in`
	-- on nil in JS, so we check for nil before iterating
	if config ~= nil then
		for propName, _ in config :: any do
			if (config :: any)[propName] ~= nil and not RESERVED_PROPS[propName] then
				if (config :: any)[propName] == nil and defaultProps ~= nil then
					-- Resolve default props
					-- ROBLOX FIXME Luau: force-cast required to avoid TypeError: Expected type table, got 'P' instead
					(props :: any)[propName] = (defaultProps :: any)[propName]
				else
					(props :: any)[propName] = (config :: any)[propName]
				end
			end
		end
	end

	-- Children can be more than one argument, and those are transferred onto
	-- the newly allocated props object.
	-- ROBLOX deviation START: we have a shortcut for capturing varargs into an array in Lua, which is more performant
	local childrenLength = select("#", ...)

	if childrenLength == 1 then
		props.children = select(1, ...)
	elseif childrenLength > 1 then
		(props :: any).children = { ... }
	end
	-- ROBLOX deviation END

	-- ROBLOX FIXME Luau: this cast is needed until normalization lands
	return ReactElement(
		element.type,
		key,
		ref,
		nil,
		source,
		owner,
		(props :: any) :: P & React_ElementProps<T>
	) :: any
end
--\[\[*
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param ?object} object
 * @return boolean} True if `object` is a ReactElement.
 * @final
 \]\]

exports.isValidElement = function(object)
	return type(object) == "table" and object["$$typeof"] == REACT_ELEMENT_TYPE
end

return exports ]]
m.Children._a333e407c3eb59b3c43a3a718ff638af=B
local C

local D={ClassName="ModuleScript",Children={},Properties={}}
D.Name="ReactElementValidator"
D.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/bc6b7b6b16f771bfc8048fe15e211ac777253b64/packages/react/src/ReactElementValidator.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * @flow
*\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
local console = require(Packages.Shared).console
local inspect = LuauPolyfill.util.inspect
type Function = (...any) -> ...any

-- ROBLOX deviation START: import extra types
local ReactTypes = require(Packages.Shared)
type React_StatelessFunctionalComponent<P> = ReactTypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_Element<ElementType> = ReactTypes.React_Element<ElementType>
type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
type ReactElement<P, T> = ReactTypes.ReactElement<P, T>
type React_Node = ReactTypes.React_Node
type Source = ReactTypes.Source
-- ROBLOX deviation END

local isValidElementType = require(Packages.Shared).isValidElementType
local getComponentName = require(Packages.Shared).getComponentName
local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local _REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local _REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE

local warnAboutSpreadingKeyToJSX =
	require(Packages.Shared).ReactFeatureFlags.warnAboutSpreadingKeyToJSX
local checkPropTypes = require(Packages.Shared).checkPropTypes
local ReactCurrentOwner = require(Packages.Shared).ReactSharedInternals.ReactCurrentOwner

local ReactElement = require(script.Parent.ReactElement)
local isValidElement = ReactElement.isValidElement
local createElement = ReactElement.createElement
local cloneElement = ReactElement.cloneElement
local jsxDEV = ReactElement.jsxDEV

local setExtraStackFrame =
	require(Packages.Shared).ReactSharedInternals.ReactDebugCurrentFrame.setExtraStackFrame
local describeUnknownElementTypeFrameInDEV =
	require(Packages.Shared).ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV

local exports = {}

-- ROBLOX FIXME Luau: annotation shouldn't be necessary
local function setCurrentlyValidatingElement(element: ReactElement<any, any> | nil)
	if _G.__DEV__ then
		if element then
			local owner = element._owner
			local ownerArgument = nil
			if owner then
				ownerArgument = owner.type
			end
			local stack = describeUnknownElementTypeFrameInDEV(
				element.type,
				element._source,
				ownerArgument
			);
			-- ROBLOX FIXME Luau: needs normalization: Cannot call non-function (() -> ()) | ((string?) -> (...any))
			(setExtraStackFrame :: (...any) -> ())(stack)
		else
			-- ROBLOX FIXME Luau: needs normalization: Cannot call non-function (() -> ()) | ((string?) -> (...any))
			(setExtraStackFrame :: (...any) -> ())(nil)
		end
	end
end

local propTypesMisspellWarningShown

if _G.__DEV__ then
	propTypesMisspellWarningShown = false
end

local function hasOwnProperty(object, key)
	return object[key] ~= nil
end

local function getDeclarationErrorAddendum(): string
	if ReactCurrentOwner.current then
		local name = getComponentName(ReactCurrentOwner.current.type)
		if name then
			return "\n\nCheck the render method of `" .. name .. "`."
		end
	end
	return ""
end

-- ROBLOX FIXME Luau: annotation shouldn't be necessary
local function getSourceInfoErrorAddendum(source: Source | nil): string
	if source ~= nil then
		local fileName = string.gsub(source.fileName, "^.*[\\/]", "")
		local lineNumber = source.lineNumber
		return "\n\nCheck your code at " .. fileName .. ":" .. lineNumber .. "."
	end
	return ""
end

-- ROBLOX FIXME Luau: needs explicit annotation, even though call site and nil check should be enough
local function getSourceInfoErrorAddendumForProps(
	elementProps: React_ElementProps<any>?
): string
	if elementProps ~= nil then
		return getSourceInfoErrorAddendum(elementProps.__source)
	end
	return ""
end

-- /**
--  * Warn if there's no key explicitly set on dynamic arrays of children or
--  * object keys are not valid. This allows us to keep track of children between
--  * updates.
--  */
local ownerHasKeyUseWarning = {}

-- ROBLOX FIXME Luau: shouldn't need this annotation on parentType
local function getCurrentComponentErrorInfo(
	parentType: React_ComponentType<any> | string | Function
): string
	local info = getDeclarationErrorAddendum()

	if not Boolean.toJSBoolean(info) then
		local parentName = if typeof(parentType) == "string"
			then parentType
			else if typeof(parentType) == "table"
				then parentType.displayName or parentType.name
				else nil

		-- ROBLOX deviation: Lua doesn't store fields on functions, so try and get the name via reflection
		if not parentName and typeof(parentType) == "function" then
			local functionName = debug.info(parentType, "n")
			-- ROBLOX note: unlike other places, upstream doesn't default the component name string in this message
			parentName = if functionName ~= "" then functionName else nil
		end

		if parentName then
			info = string.format(
				"\n\nCheck the top-level render call using <%s>.",
				parentName
			)
		end
	end
	return info
end

-- /**
--  * Warn if the element doesn't have an explicit key assigned to it.
--  * This element is in an array. The array could grow and shrink or be
--  * reordered. All children that haven't already been validated are required to
--  * have a "key" property assigned to it. Error statuses are cached so a warning
--  * will only be shown once.
--  *
--  * @internal
--  * @param {ReactElement} element Element that requires a key.
--  * @param {*} parentType element's parent's type.
--  * @param {*} tableKey ROBLOX deviation: key provided by the children table
--  */
-- ROBLOX deviation START: add explicit optional table key parameter, move key check to after we mark it validated, since we may not have an explicit key (and will use tableKey to validate)
local function validateExplicitKey<P>(
	element: ReactElement<P, any>,
	parentType,
	tableKey: any?
)
	if element._store == nil or element._store.validated then
		return
	end
	-- ROBLOX FIXME Luau: doesn't narrow based on branch above
	(element._store :: any).validated = true
	-- ROBLOX note: Consider this element valid if only _one_ key is
	-- present, otherwise proceed and check for error states
	if (element.key ~= nil) ~= (tableKey ~= nil) then
		return
	end
	-- ROBLOX deviation END
	local currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType)
	if ownerHasKeyUseWarning[currentComponentErrorInfo] then
		return
	end
	ownerHasKeyUseWarning[currentComponentErrorInfo] = true

	-- // Usually the current owner is the offender, but if it accepts children as a
	-- // property, it may be the creator of the child that's responsible for
	-- // assigning it a key.
	local childOwner = ""
	if element and element._owner and element._owner ~= ReactCurrentOwner.current then
		-- // Give the component that originally created this child.
		childOwner = string.format(
			" It was passed a child from %s.",
			tostring(getComponentName(element._owner.type))
		)
	end

	if _G.__DEV__ then
		setCurrentlyValidatingElement(element)
		-- ROBLOX deviation START: Account for conflict between "key" prop and deviated table key behavior (in addition to missing key warnings)
		-- Both forms of key were provided
		if element.key ~= nil and tableKey ~= nil then
			-- ROBLOX TODO: Link to special Roact documentation that accounts
			-- for deviation instead of react docs
			console.error(
				'Child element received a "key" prop ("%s") in addition to a key in '
					.. 'the "children" table of its parent ("%s"). Please provide only '
					.. 'one key definition. When both are present, the "key" prop '
					.. "will take precedence."
					.. "%s%s See https://reactjs.org/link/warning-keys for more information.",
				tostring(element.key),
				tostring(tableKey),
				currentComponentErrorInfo,
				childOwner
			)
		-- No key was provided at all
		else
			console.error(
				'Each child in a list should have a unique "key" prop.'
					.. "%s%s See https://reactjs.org/link/warning-keys for more information.",
				currentComponentErrorInfo,
				childOwner
			)
		end
		-- ROBLOX deviation END
		setCurrentlyValidatingElement(nil)
	end
end

-- /**
--  * Ensure that every element either is passed in a static location, in an
--  * array with an explicit keys property defined, or in an object literal
--  * with valid key property.
--  *
--  * @internal
--  * @param {ReactNode} node Statically passed child of any type.
--  * @param {*} parentType node's parent's type.
--  */
local function validateChildKeys(node, parentType)
	if typeof(node) ~= "table" then
		return
	end

	if Array.isArray(node) then
		for i = 1, #node do
			local child = node[i]
			if isValidElement(child) then
				validateExplicitKey(child :: ReactElement<any, any>, parentType)
			end
		end
	elseif isValidElement(node) then
		-- // This element was passed in a valid location.
		if node._store then
			node._store.validated = true
		end
	elseif node then
		local iteratorFn = getIteratorFn(node)
		if typeof(iteratorFn) == "function" then
			-- // Entry iterators used to provide implicit keys,
			-- // but now we print a separate warning for them later.
			if iteratorFn ~= node.entries then
				local iterator = iteratorFn(node)
				local step = iterator.next()
				while not step.done do
					if isValidElement(step.value) then
						validateExplicitKey(step.value, parentType, step.key)
					end

					step = iterator.next()
				end
			end
		end
	end
end

-- /**
--  * Given an element, validate that its props follow the propTypes definition,
--  * provided by the type.
--  *
--  * @param {ReactElement} element
--  */
local function validatePropTypes<P>(element: ReactElement<P, any>)
	if _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local type = element.type
		if type == nil or typeof(type) == "string" then
			return
		end

		local propTypes
		local validateProps
		if typeof(type) == "function" then
			-- deviation: function components can't have propTypes in Lua
			-- propTypes = type.propTypes
			return
		elseif typeof(type) == "table" then
			propTypes = type.propTypes
			validateProps = type.validateProps
		else
			return
		end

		if propTypes or validateProps then
			-- Intentionally inside to avoid triggering lazy initializers:
			local name = getComponentName(type)
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			checkPropTypes(propTypes, validateProps, element.props, "prop", name, element)
			-- ROBLOX TODO: upstream this any, PropTypes is a bogus key check on purpose
		elseif (type :: any).PropTypes ~= nil and not propTypesMisspellWarningShown then
			propTypesMisspellWarningShown = true
			-- Intentionally inside to avoid triggering lazy initializers:
			local name = getComponentName(type)
			console.error(
				"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",
				name or "Unknown"
			)
		end
		-- ROBLOX TODO: upstream this any, PropTypes is a bogus key check on purpose
		-- ROBLOX deviation: we simplify this check since we never supported this in the first place
		if (type :: any).getDefaultProps ~= nil then
			console.error(
				"getDefaultProps is only used on classic React.createClass "
					.. "definitions. Use a static property named `defaultProps` instead."
			)
		end
	end
end

-- /**
--  * Given a fragment, validate that it can only be provided with fragment props
--  * @param {ReactElement} fragment
--  */
local function validateFragmentProps<P>(fragment: ReactElement<P & Object, any>)
	if _G.__DEV__ then
		local keys = Object.keys(fragment.props)
		for i = 1, #keys do
			local key = keys[i]
			if key ~= "children" and key ~= "key" then
				setCurrentlyValidatingElement(fragment)
				console.error(
					"Invalid prop `%s` supplied to `React.Fragment`. "
						.. "React.Fragment can only have `key` and `children` props.",
					key
				)
				setCurrentlyValidatingElement(nil)
				break
			end
		end

		if fragment.ref ~= nil then
			setCurrentlyValidatingElement(fragment)
			console.error("Invalid attribute `ref` supplied to `React.Fragment`.")
			setCurrentlyValidatingElement(nil)
		end
	end
end

-- ROBLOX deviation START: add strong types based on definitely-typed approach on createElement
local function jsxWithValidation<P, T>(
	type: T,
	props: P & React_ElementProps<T>,
	key: string | number,
	isStaticChildren,
	source: Source?,
	self: any?
)
	-- ROBLOX deviation END
	local validType = isValidElementType(type)

	-- // We warn in this case but don't throw. We expect the element creation to
	-- // succeed and there will likely be errors in render.
	if not validType then
		local info = ""
		if type == nil or (typeof(type) == "table" and #Object.keys(type) == 0) then
			info ..= (" You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and named imports.")
		end

		local sourceInfo = getSourceInfoErrorAddendum(source)
		if sourceInfo then
			info ..= sourceInfo
		else
			info ..= getDeclarationErrorAddendum()
		end

		local typeString
		if type == nil then
			typeString = "nil"
		elseif Array.isArray(type) then
			typeString = "array"
		elseif typeof(type) == "table" and type["$$typeof"] == REACT_ELEMENT_TYPE then
			typeString = string.format("<%s />", getComponentName(type.type) or "Unknown")
			info ..= " Did you accidentally export a JSX literal or Element instead of a component?"
		else
			typeString = typeof(type)
			info ..= "\n" .. inspect(type)
		end

		if _G.__DEV__ then
			console.error(
				"React.jsx: type is invalid -- expected a string (for "
					.. "built-in components) or a class/function (for composite "
					.. "components) but got: %s.%s",
				typeString,
				info
			)
		end
	end

	local element = jsxDEV(type, props, key, source, self)

	-- // The result can be nullish if a mock or a custom function is used.
	-- // TODO: Drop this when these are no longer allowed as the type argument.
	if element == nil then
		return element
	end

	-- // Skip key warning if the type isn't valid since our key validation logic
	-- // doesn't expect a non-string/function type and can throw confusing errors.
	-- // We don't want exception behavior to differ between dev and prod.
	-- // (Rendering will throw with a helpful message and as soon as the type is
	-- // fixed, the key warnings will appear.)

	if validType then
		local children = props.children
		if children ~= nil then
			if isStaticChildren then
				if Array.isArray(children) then
					for i = 1, #children do
						-- ROBLOX FIXME Luau: needs normalization
						validateChildKeys(children[i], type :: any)
					end

					-- deviation: Object.freeze always exist
					-- if Object.freeze then
					Object.freeze(children)
					-- end
				else
					if _G.__DEV__ then
						console.error(
							"React.jsx: Static children should always be an array. "
								.. "You are likely explicitly calling React.jsxs or React.jsxDEV. "
								.. "Use the Babel transform instead."
						)
					end
				end
			else
				-- ROBLOX FIXME Luau: needs normalization
				validateChildKeys(children, type :: any)
			end
		end
	end

	if _G.__DEV__ then
		if warnAboutSpreadingKeyToJSX then
			if hasOwnProperty(props, "key") then
				console.error(
					"React.jsx: Spreading a key to JSX is a deprecated pattern. "
						.. "Explicitly pass a key after spreading props in your JSX call. "
						.. "E.g. <%s {...props} key={key} />",
					getComponentName(type) or "ComponentName"
				)
			end
		end
	end

	if type == REACT_FRAGMENT_TYPE then
		-- ROBLOX FIXME Luau: luau doesn't understand narrowing of above branch
		validateFragmentProps((element :: any) :: ReactElement<any, any>)
	else
		validatePropTypes((element :: any) :: ReactElement<any, any>)
	end

	return element
end
exports.jsxWithValidation = jsxWithValidation

-- // These two functions exist to still get child warnings in dev
-- // even with the prod transform. This means that jsxDEV is purely
-- // opt-in behavior for better messages but that we won't stop
-- // giving you warnings if you use production apis.
exports.jsxWithValidationStatic = function(type, props, key)
	return jsxWithValidation(type, props, key, true)
end

exports.jsxWithValidationDynamic = function(type, props, key)
	return jsxWithValidation(type, props, key, false)
end

-- ROBLOX deviation START: add strong types based on definitely-typed approach on createElement
local function createElementWithValidation<P, T>(
	type_: React_StatelessFunctionalComponent<
		P
	> | React_ComponentType<P> | string,
	props: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- ROBLOX deviation END
	local validType = isValidElementType(type_)

	-- // We warn in this case but don't throw. We expect the element creation to
	-- // succeed and there will likely be errors in render.
	if not validType then
		local info = ""
		if type_ == nil or (typeof(type_) == "table" and #Object.keys(type_) == 0) then
			info ..= (" You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and named imports.")
		end

		local sourceInfo = getSourceInfoErrorAddendumForProps(props)
		if sourceInfo then
			info ..= sourceInfo
		else
			info ..= getDeclarationErrorAddendum()
		end

		local typeString
		if type_ == nil then
			typeString = "nil"
		elseif Array.isArray(type_) then
			typeString = "array"
		elseif
			type_ ~= nil
			and typeof(type_) == "table"
			and type_["$$typeof"] == REACT_ELEMENT_TYPE
		then
			typeString = string.format(
				"<%s />",
				getComponentName((type_ :: any).type) or "Unknown"
			)
			info ..= " Did you accidentally export a JSX literal or Element instead of a component?"
		else
			typeString = typeof(type_)
			if type_ ~= nil then
				-- ROBLOX deviation: print the table/string in readable form to give a clue, if no other info was gathered
				info ..= "\n" .. inspect(type_)
			end
		end

		if _G.__DEV__ then
			console.error(
				"React.createElement: type is invalid -- expected a string (for "
					.. "built-in components) or a class/function (for composite "
					.. "components) but got: %s.%s",
				typeString,
				info
			)
		end
	end

	-- ROBLOX FIXME Luau: hard cast to any, needs normalization to avoid 'React_ComponentType<P>' could not be converted into 'React_ComponentType<P>'
	local element = createElement(type_ :: any, props, ...)

	-- // The result can be nullish if a mock or a custom function is used.
	-- // TODO: Drop this when these are no longer allowed as the type argument.
	if element == nil then
		return element
	end

	-- // Skip key warning if the type isn't valid since our key validation logic
	-- // doesn't expect a non-string/function type and can throw confusing errors.
	-- // We don't want exception behavior to differ between dev and prod.
	-- // (Rendering will throw with a helpful message and as soon as the type is
	-- // fixed, the key warnings will appear.)
	if validType then
		-- ROBLOX deviation: skips (1) type and (2) props - starts from 3 to the end varargs (iterate through children)
		for i = 1, select("#", ...) do
			-- ROBLOX deviation: selects the ith child from this function's arguments to validate
			-- ROBLOX FIXME Luau: hard cast to any, needs normalization to avoid 'React_ComponentType<P>' could not be converted into 'React_ComponentType<P>'
			validateChildKeys(select(i, ...), type_ :: any)
		end
	end

	if type_ == REACT_FRAGMENT_TYPE then
		validateFragmentProps(element)
	else
		validatePropTypes(element)
	end

	return element
end
exports.createElementWithValidation = createElementWithValidation

-- devitation: createFactory is deprecated and will be removed
-- local didWarnAboutDeprecatedCreateFactory = false

-- exports.createFactoryWithValidation = function(type)
-- 	local validatedFactory = function(...)
-- 		createElementWithValidation(type, ...)
-- 	end
-- 	-- deviation: Lua can't assign fields to functions. The 'type'
-- 	-- property is deprecated so there is no need to port this over.
-- 	-- validatedFactory.type = type

-- 	if _G.__DEV__ then
-- 		if not didWarnAboutDeprecatedCreateFactory then
-- 			didWarnAboutDeprecatedCreateFactory = true
-- 			console.warn(
-- 				"React.createFactory() is deprecated and will be removed in " ..
-- 					"a future major release. Consider using JSX " ..
-- 					"or use React.createElement() directly instead."
-- 			)
-- 		end
-- 		-- // Legacy hook: remove it
-- 		-- deviation: no porting this behavior because it is deprecated
-- 		-- Object.defineProperty(validatedFactory, "type", {
-- 		-- 	enumerable = false,
-- 		-- 	get = function()
-- 		-- 		console.warn(
-- 		-- 			"Factory.type is deprecated. Access the class directly " ..
-- 		-- 				"before passing it to createFactory."
-- 		-- 		)
-- 		-- 		Object.defineProperty(this, "type", {
-- 		-- 			value = type,
-- 		-- 		})
-- 		-- 		return type
-- 		-- 	end,
-- 		-- })
-- 	end

-- 	return validatedFactory
-- end

-- ROBLOX deviation START: add strong types based on definitely-typed approach on createElement
exports.cloneElementWithValidation = function<P, T>(
	element: ReactElement<P, T>,
	props: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- ROBLOX deviation END
	local arguments = { element, props, ... } :: Array<any>
	local newElement = cloneElement(element, props, ...)
	for i = 3, #arguments do
		validateChildKeys(arguments[i], newElement.type)
	end
	validatePropTypes(newElement)
	return newElement
end

return exports ]]
m.Children._38c7d40e9bed265657097dc0a42a76a8=D
local E

local F={ClassName="ModuleScript",Children={},Properties={}}
F.Name="ReactForwardRef"
F.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/41694201988c5e651f0c3bc69921d5c9717be88b/packages/react/src/ReactForwardRef.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*\]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactSymbols = require(Packages.Shared).ReactSymbols
local ReactTypes = require(Packages.Shared)
type React_Node = ReactTypes.React_Node
type React_Ref<ElementType> = ReactTypes.React_Ref<ElementType>
type React_AbstractComponent<Config, Instance> = ReactTypes.React_AbstractComponent<
	Config,
	Instance
>
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE

local exports = {}
-- ROBLOX TODO? should return Component's ELementType be REACT_FORWARD_REF_TYPE? probably, right?
exports.forwardRef =
	function<Props, ElementType>(
		render: (props: Props, ref: React_Ref<ElementType>) -> React_Node
	): React_AbstractComponent<Props, ElementType>
		if _G.__DEV__ then
			-- ROBLOX deviation START: Lua functions can't have properties given a table (which we can index to see if it's the Memo type)
			if
				typeof(render :: any) == "table"
				and (render :: any)["$$typeof"] == REACT_MEMO_TYPE
			then
				-- ROBLOX deviation END
				console.error(
					"forwardRef requires a render function but received a `memo` "
						.. "component. Instead of forwardRef(memo(...)), use "
						.. "memo(forwardRef(...))."
				)
			elseif typeof(render) ~= "function" then
				console.error(
					"forwardRef requires a render function but was given %s.",
					typeof(render)
				)
			else
				local argumentCount, _variadic = debug.info(render, "a")
				if argumentCount ~= 0 and argumentCount ~= 2 then
					console.error(
						"forwardRef render functions accept exactly two parameters: props and ref. %s",
						(function()
							if argumentCount == 1 then
								return "Did you forget to use the ref parameter?"
							end
							return "Any additional parameter will be undefined."
						end)()
					)
				end
			end

			-- deviation: in Luau, functions cannot have fields; for now, we don't
			-- support defaultProps and propTypes on function components anyways, so
			-- this check can safely be a no-op

			-- if render ~= null then
			--   if (render.defaultProps != null || render.propTypes != null) {
			--     console.error(
			--       'forwardRef render functions do not support propTypes or defaultProps. ' +
			--         'Did you accidentally pass a React component?',
			--     );
			--   }
			-- }
		end

		local elementType = {
			["$$typeof"] = REACT_FORWARD_REF_TYPE,
			render = render,
		}
		if _G.__DEV__ then
			local ownName
			-- ROBLOX deviation: use metatables to approximate Object.defineProperty logic
			setmetatable(elementType, {
				__index = function(self, key)
					if key == "displayName" then
						return ownName
					end
					return rawget(self, key)
				end,
				__newindex = function(self, key, value)
					if key == "displayName" then
						ownName = value
					-- ROBLOX deviation: render is a function and cannot have properties
					-- if (render.displayName == null) {
					--   render.displayName = name;
					-- }
					else
						rawset(self, key, value)
					end
				end,
			})
		end
		-- ROBLOX FIXME Luau: making us explicitly add nilable (optional) fields: because the former is missing fields 'forceUpdate', 'getChildContext', 'props', 'setState', and 'state
		return (elementType :: any) :: React_AbstractComponent<Props, ElementType>
	end

return exports ]]
m.Children._90bb9472ab52fba3bce855779b8d4048=F
local G

local H={ClassName="ModuleScript",Children={},Properties={}}
H.Name="ReactHooks"
H.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/ddd1faa1972b614dfbfae205f2aa4a6c0b39a759/packages/react/src/ReactHooks.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
-- ROBLOX TODO: we only pull in Dispatcher here for the typecheck, remove once Luau narrowing improves
type Dispatcher = ReactTypes.Dispatcher
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type ReactContext<T> = ReactTypes.ReactContext<T>
local ReactFiberHostConfig = require(Packages.Shared)
type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType

-- local invariant = require(Packages.Shared).invariant

local ReactCurrentDispatcher =
	require(Packages.Shared).ReactSharedInternals.ReactCurrentDispatcher

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

-- ROBLOX FIXME Luau: we shouldn't need to explicitly annotate this
local function resolveDispatcher(): Dispatcher
	local dispatcher = ReactCurrentDispatcher.current
	-- ROBLOX performance: upstream main only does this check in DEV mode and then not as an invariant
	if _G.__DEV__ then
		if dispatcher == nil then
			console.error(
				"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
					.. " one of the following reasons:\n"
					.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
					.. "2. You might be breaking the Rules of Hooks\n"
					.. "3. You might have more than one copy of React in the same app\n"
					.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
			)
		end
	end
	-- Will result in a null access error if accessed outside render phase. We
	-- intentionally don't throw our own error because this is in a hot path.
	-- Also helps ensure this is inlined.
	return dispatcher :: Dispatcher
end

local exports = {}

local function useContext<T>(
	Context: ReactContext<T>,
	unstable_observedBits: number | boolean | nil,
	... -- ROBLOX deviation: Lua must specify ... here to capture additional args
): T
	local dispatcher = resolveDispatcher()
	if _G.__DEV__ then
		if unstable_observedBits ~= nil then
			console.error(
				"useContext() second argument is reserved for future "
					.. "use in React. Passing it is not supported. "
					.. "You passed: %s.%s",
				unstable_observedBits,
				(typeof(unstable_observedBits) == "number" and Array.isArray({ ... }))
						and "\n\nDid you call Array.map(useContext)? " .. "Calling Hooks inside a loop is not supported. " .. "Learn more at https://reactjs.org/link/rules-of-hooks"
					or ""
			)
		end

		-- TODO: add a more generic warning for invalid values.
		if (Context :: any)._context ~= nil then
			local realContext = (Context :: any)._context
			-- Don't deduplicate because this legitimately causes bugs
			-- and nobody should be using this in existing code.
			if realContext.Consumer == Context then
				console.error(
					"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be "
						.. "removed in a future major release. Did you mean to call useContext(Context) instead?"
				)
			elseif realContext.Provider == Context then
				console.error(
					"Calling useContext(Context.Provider) is not supported. "
						.. "Did you mean to call useContext(Context) instead?"
				)
			end
		end
	end
	return dispatcher.useContext(Context, unstable_observedBits)
end
exports.useContext = useContext

local function useState<S>(
	initialState: (() -> S) | S,
	...
): (S, Dispatch<BasicStateAction<S>>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useState(initialState, ...)
end
exports.useState = useState

local function useReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useReducer(reducer, initialArg, init)
end
exports.useReducer = useReducer

-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
-- ROBLOX TODO: reconciling this with bindings and sharing any relevant Ref types (there may be different ones depending on whether it's just a loose ref, vs one being assigned to the ref prop
local function useRef<T>(initialValue: T): { current: T | nil }
	-- ROBLOX deviation END
	local dispatcher = resolveDispatcher()
	return dispatcher.useRef(initialValue)
end
exports.useRef = useRef

-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
local function useBinding<T>(
	initialValue: T
): (
	ReactTypes.ReactBinding<T>,
	ReactTypes.ReactBindingUpdater<T>
)
	-- ROBLOX deviation END
	local dispatcher = resolveDispatcher()
	return dispatcher.useBinding(initialValue)
end
exports.useBinding = useBinding

local function useEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useEffect(create, deps)
end
exports.useEffect = useEffect

local function useLayoutEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useLayoutEffect(create, deps)
end
exports.useLayoutEffect = useLayoutEffect

local function useCallback<T>(callback: T, deps: Array<any> | nil): T
	local dispatcher = resolveDispatcher()
	return dispatcher.useCallback(callback, deps)
end
exports.useCallback = useCallback

local function useMemo<T...>(create: () -> T..., deps: Array<any> | nil): T...
	local dispatcher = resolveDispatcher()
	return dispatcher.useMemo(create, deps)
end
exports.useMemo = useMemo

local function useImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useImperativeHandle(ref, create, deps)
end
exports.useImperativeHandle = useImperativeHandle

local function useDebugValue<T>(value: T, formatterFn: ((value: T) -> any)?): ()
	if _G.__DEV__ then
		local dispatcher = resolveDispatcher()
		return dispatcher.useDebugValue(value, formatterFn)
	end

	-- deviation: return nil explicitly for safety
	return nil
end
exports.useDebugValue = useDebugValue

exports.emptyObject = {}

-- ROBLOX TODO: enable useTransition later
-- exports.useTransition = function(): ((() -> ()) -> (), boolean)
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useTransition()
-- end

-- ROBLOX TODO: enable useDeferredValue later
-- exports.useDeferredValue = function<T>(value: T): T
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useDeferredValue(value)
-- end

exports.useOpaqueIdentifier = function(): OpaqueIDType | nil
	local dispatcher = resolveDispatcher()
	return dispatcher.useOpaqueIdentifier()
end

exports.useMutableSource =
	function<Source, Snapshot>(
		source: MutableSource<Source>,
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		subscribe: MutableSourceSubscribeFn<Source, Snapshot>
	): Snapshot
		local dispatcher = resolveDispatcher()
		return dispatcher.useMutableSource(source, getSnapshot, subscribe)
	end

return exports ]]
m.Children._fc397028ca95d62f5bcf180d9b1357a2=H
local I

local J={ClassName="ModuleScript",Children={},Properties={}}
J.Name="ReactLazy"
J.Properties.Source=[[ --!nonstrict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react/src/ReactLazy.js
--\[\[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *\]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable
type Thenable<R> = ReactTypes.Thenable<R>
local ReactSymbols = require(Packages.Shared).ReactSymbols

local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE

local Uninitialized = -1
local Pending = 0
local Resolved = 1
local Rejected = 2

type UninitializedPayload<T> = {
	-- ROBLOX deviaton: Luau doesn't support literals
	--   _status: -1,
	_status: number,
	_result: () -> Thenable<{ default: T, [string]: any }>,
}

type PendingPayload = {
	-- ROBLOX deviaton: Luau doesn't support literals
	-- _status: 0,
	_status: number,
	_result: Wakeable,
}

type ResolvedPayload<T> = {
	-- ROBLOX deviaton: Luau doesn't support literals
	-- _status: 1,
	_status: number,
	_result: { default: T, [string]: any },
}

type RejectedPayload = {
	-- ROBLOX deviaton: Luau doesn't support literals
	-- _status: 2,
	_status: number,
	_result: any,
}

type Payload<T> =
	UninitializedPayload<T>
	| PendingPayload
	| ResolvedPayload<T>
	| RejectedPayload

export type LazyComponent<T, P> = {
	["$$typeof"]: number,
	_payload: P,
	_init: (payload: P) -> T,
	--   ...
}

function lazyInitializer<T>(payload: Payload<T>): T
	if payload._status == Uninitialized then
		local ctor = payload._result
		local thenable = ctor()
		-- Transition to the next state.
		local pending: PendingPayload = payload :: any
		pending._status = Pending
		pending._result = thenable
		thenable:andThen(function(moduleObject)
			if payload._status == Pending then
				local defaultExport = moduleObject.default
				if _G.__DEV__ then
					if defaultExport == nil then
						console.error(
							"lazy: Expected the result of a dynamic import() call. "
								.. "Instead received: `%s`\n\nYour code should look like: \n  "
								-- Break up imports to avoid accidentally parsing them as dependencies.
								-- ROBLOX deviation: Lua syntax in message
								.. "local MyComponent = lazy(function() return req"
								.. "quire(script.Parent.MyComponent) end)",
							inspect(moduleObject)
						)
					end
				end
				-- Transition to the next state.
				local resolved: ResolvedPayload<T> = payload :: any
				resolved._status = Resolved
				resolved._result = defaultExport
			end
		end, function(error_)
			if payload._status == Pending then
				-- Transition to the next state.
				local rejected: RejectedPayload = payload :: any
				rejected._status = Rejected
				rejected._result = error_
			end
		end)
	end
	if payload._status == Resolved then
		return payload._result
	else
		error(payload._result)
	end
end

local exports = {}

exports.lazy = function<T>(
	ctor: () -> Thenable<{ default: T, [string]: any }>
): LazyComponent<T, Payload<T>>
	local payload: Payload<T> = {
		-- We use these fields to store the result.
		_status = -1,
		_result = ctor,
	}

	local lazyType: LazyComponent<T, Payload<T>> = {
		["$$typeof"] = REACT_LAZY_TYPE,
		_payload = payload,
		-- ROBLOX FIXME Luau: needs something even beyond normalization to avoid Property '_init' is not compatible. Type '<T>(Payload<T>) -> T?' could not be converted into '(Payload<T>) -> T?'; different number of generic type parameters
		_init = lazyInitializer :: any,
	}

	if _G.__DEV__ then
		-- In production, this would just set it on the object.
		local defaultProps
		local propTypes
		-- $FlowFixMe
		setmetatable(lazyType, {
			__index = function(self, key)
				if key == "defaultProps" then
					return defaultProps
				end
				if key == "propTypes" then
					return propTypes
				end
				return
			end,
			__newindex = function(self, key, value)
				if key == "defaultProps" then
					console.error(
						"React.lazy(...): It is not supported to assign `defaultProps` to "
							.. "a lazy component import. Either specify them where the component "
							.. "is defined, or create a wrapping component around it."
					)
					defaultProps = value
					-- Match production behavior more closely:
					-- $FlowFixMe
					setmetatable(self, {
						__index = function() end,
						__newindex = function() end,
					})
				end
				if key == "propTypes" then
					console.error(
						"React.lazy(...): It is not supported to assign `propTypes` to "
							.. "a lazy component import. Either specify them where the component "
							.. "is defined, or create a wrapping component around it."
					)
					propTypes = value
					-- Match production behavior more closely:
					-- $FlowFixMe
					setmetatable(self, {
						__index = function() end,
						__newindex = function() end,
					})
				end
			end,
		})
	end

	return lazyType
end

return exports ]]
m.Children._92b47d701d10ca3c1ec06076fa8845bf=J
local K

local L={ClassName="ModuleScript",Children={},Properties={}}
L.Name="ReactMemo"
L.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/41694201988c5e651f0c3bc69921d5c9717be88b/packages/react/src/ReactMemo.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local inspect = LuauPolyfill.util.inspect
type React_StatelessFunctionalComponent<Props> = Shared.React_StatelessFunctionalComponent<
	Props
>
type React_ElementType = Shared.React_ElementType
type React_Component<Props, State> = Shared.React_Component<Props, State>
type React_ComponentType<Props> = Shared.React_ComponentType<Props>
type React_AbstractComponent<Config, Instance> = Shared.React_AbstractComponent<
	Config,
	Instance
>

local ReactSymbols = Shared.ReactSymbols
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local isValidElementType = Shared.isValidElementType
local getComponentName = Shared.getComponentName

local exports = {}

exports.memo = function<Props, T>(
	-- ROBLOX deviation START: expanded type pulled from definitelytyped, not sure why upstream doesn't accept function component types
	-- ROBLOX TODO Luau: React_Component<Props, any> gave me  Type 'React_Component<any, any>' could not be converted into '((any, any) -> (Array<(Array<<CYCLE>> | React_Element<any> | boolean | number | string)?> | React_Element<any> | boolean | number | string)?) | string'; none of the union options are compatible
	type_: React_StatelessFunctionalComponent<Props> | React_AbstractComponent<Props, T> | string,
	-- ROBLOX deviation END
	compare: ((oldProps: Props, newProps: Props) -> boolean)?
): React_AbstractComponent<Props, any>
	if _G.__DEV__ then
		local validType = isValidElementType(type_)

		-- We warn in this case but don't throw. We expect the element creation to
		-- succeed and there will likely be errors in render.
		if not validType then
			local info = ""
			if
				type_ == nil
				or (typeof(type_) == "table" and #Object.keys(type_) == 0)
			then
				info = info
					.. (
						" You likely forgot to export your component from the file "
						.. "it's defined in, or you might have mixed up default and named imports."
					)
			end
			local typeString
			if type_ == nil then
				typeString = "nil"
			elseif Array.isArray(type_) then
				typeString = "array"
			elseif
				type_ ~= nil
				and typeof(type_) == "table"
				and (type_)["$$typeof"] == REACT_ELEMENT_TYPE
			then
				typeString = string.format(
					"<%s />",
					getComponentName((type_ :: any).type) or "UNKNOWN"
				)
				info =
					" Did you accidentally export a JSX literal or Element instead of a component?"
			else
				typeString = typeof(type_)
				if type_ ~= nil then
					-- ROBLOX deviation: print the table/string in readable form to give a clue, if no other info was gathered
					info = "\n" .. inspect(type_)
				end
			end
			console.error(
				"memo: The first argument must be a component. Instead received: `%s`.%s",
				typeString,
				info
			)
		end
	end

	local elementType = {
		["$$typeof"] = REACT_MEMO_TYPE,
		type = type_,
		compare = compare or nil,
	}

	if _G.__DEV__ then
		local name
		-- ROBLOX deviation: use metatables to approximate Object.defineProperty logic
		setmetatable(elementType, {
			__index = function(self, key)
				if key == "displayName" then
					return name
				end
				return rawget(self, key)
			end,
			__newindex = function(self, key, value)
				if key == "displayName" then
					name = value
					-- ROBLOX deviation: render is a function and cannot have properties
					if
						typeof(type_) == "table"
						and (type_ :: React_AbstractComponent<Props, T>).displayName
							== nil
					then
						(type_ :: React_AbstractComponent<Props, T>).displayName = name
					end
				else
					rawset(self, key, value)
				end
			end,
		})
	end

	return elementType
end

return exports ]]
m.Children._dc88c1cdd75a709d858008fedd9d1a96=L
local M

local N={ClassName="ModuleScript",Children={},Properties={}}
N.Name="ReactMutableSource"
N.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react/src/ReactMutableSource.js
-- \[\[
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
-- \]\]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type MutableSourceGetVersionFn = ReactTypes.MutableSourceGetVersionFn
type MutableSource<T> = ReactTypes.MutableSource<T>

local function createMutableSource<Source>(
	source: Source,
	getVersion: MutableSourceGetVersionFn
): MutableSource<Source>
	local mutableSource: MutableSource<Source> = {
		_getVersion = getVersion,
		_source = source,
		_workInProgressVersionPrimary = nil,
		_workInProgressVersionSecondary = nil,
	}

	if _G.__DEV__ then
		mutableSource._currentPrimaryRenderer = nil
		mutableSource._currentSecondaryRenderer = nil
	end

	return mutableSource
end

return createMutableSource ]]
m.Children._734129d7f6fd5a1fcefcb5d08e8f4738=N
local O

local P={ClassName="ModuleScript",Children={},Properties={}}
P.Name="ReactNoopUpdateQueue"
P.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactNoopUpdateQueue.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local didWarnStateUpdateForUnmountedComponent = {}

local function warnNoop(publicInstance: any, callerName: string)
	if _G.__DEV__ then
		-- local constructor = publicInstance.constructor
		-- local componentName = ((constructor and (constructor.displayName or constructor.name)) or 'ReactClass')
		-- deviation: For Lua Class components, the name comes from a property
		-- defined on the metatable
		local componentName = publicInstance.__componentName or "ReactClass"
		local warningKey = componentName .. "." .. callerName
		if didWarnStateUpdateForUnmountedComponent[warningKey] then
			return
		end
		-- ROBLOX deviation: message adjusted for accuracy with Lua class components
		console.error(
			"Can't call %s on a component that is not yet mounted. "
				.. "This is a no-op, but it might indicate a bug in your application. "
				.. "Instead, assign to `self.state` directly with the desired state in "
				.. "the %s component's `init` method.",
			callerName,
			componentName
		)
		didWarnStateUpdateForUnmountedComponent[warningKey] = true
	end
end

--\[\[*
 * This is the abstract API for an update queue.
 \]\]
local ReactNoopUpdateQueue = {
	--\[\[*
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   \]\]
	isMounted = function(publicInstance)
		return false
	end,
	--\[\[*
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   \]\]
	enqueueForceUpdate = function(publicInstance, callback, callerName)
		warnNoop(publicInstance, "forceUpdate")
	end,
	--\[\[*
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   \]\]
	enqueueReplaceState = function(publicInstance, completeState, callback, callerName)
		warnNoop(publicInstance, "replaceState")
	end,
	--\[\[*
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   \]\]
	enqueueSetState = function(publicInstance, partialState, callback, callerName)
		warnNoop(publicInstance, "setState")
	end,
}

return ReactNoopUpdateQueue ]]
m.Children._f990bbf1f52d0c6cc1ef11f694e66325=P
local Q

local R={ClassName="Folder",Children={},Properties={}}
R.Name="__tests__"
m.Children._66527c145cd3e5ce1fe079f192ac81b8=R
local S
local T={ClassName="ModuleScript",Children={},Properties={}}
T.Name="ReactBaseClasses.roblox.spec"
T.Properties.Source=[[ --!strict
local Packages = script.Parent.Parent.Parent
local ReactBaseClasses = require(script.Parent.Parent.ReactBaseClasses)
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local Component = ReactBaseClasses.Component
local PureComponent = ReactBaseClasses.Component
local component

describe("Component", function()
	it("should prevent extending a second time", function()
		component = Component:extend("Sheev")

		jestExpect(function()
			(component :: any):extend("Frank")
		end).toThrow()
	end)

	it("should use a given name", function()
		component = Component:extend("FooBar")

		local name = tostring(component)

		jestExpect(name).toEqual(jestExpect.any("string"))
		jestExpect(name).toContain("FooBar")
	end)
end)

describe("PureComponent", function()
	it("should prevent extending a second time", function()
		component = PureComponent:extend("Sheev")

		jestExpect(function()
			(component :: any):extend("Frank")
		end).toThrow()
	end)

	it("should use a given name", function()
		component = PureComponent:extend("FooBar")

		local name = tostring(component)

		jestExpect(name).toEqual(jestExpect.any("string"))
		jestExpect(name).toContain("FooBar")
	end)
end) ]]
S.Children._d6c224d4f630f1310f5f73ea60383f2d=T
local U

local V={ClassName="ModuleScript",Children={},Properties={}}
V.Name="ReactBinding.spec"
V.Properties.Source=[[ --!strict
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local it = JestGlobals.it

local ReactTypes = require(Packages.Shared)
type Binding<T> = ReactTypes.ReactBinding<T>

local Binding = require(script.Parent.Parent["ReactBinding.roblox"])
local ReactCreateRef = require(script.Parent.Parent.ReactCreateRef)

describe("Binding.create", function()
	it("should return a Binding object and an update function", function()
		local binding, update = Binding.create(1)

		jestExpect(typeof(binding)).toBe("table")
		jestExpect(update).toEqual(jestExpect.any("function"))
	end)

	it("should support tostring on bindings", function()
		local binding, update = Binding.create(1 :: number | string)
		jestExpect(tostring(binding)).toBe("RoactBinding(1)")

		update("foo")
		jestExpect(tostring(binding)).toBe("RoactBinding(foo)")
	end)

	it("should allow mapping a mapped binding", function()
		local binding, update = Binding.create(1)
		local asPercent = binding
			:map(function(value: number)
				return value * 100
			end)
			:map(function(value)
				return tostring(value) .. "%"
			end)

		jestExpect(asPercent:getValue()).toEqual("100%")

		update(0.3)
		jestExpect(asPercent:getValue()).toEqual("30%")
	end)

	if _G.__DEV__ then
		it("should include a stack in DEV mode", function()
			-- Simulate the additional layer of stack depth we'll have when
			-- we use `React.createBinding` in the wild, since it will
			-- affect the shape of our debug stacktrace
			local function createBinding(...)
				return Binding.create(...)
			end
			local binding, _ = createBinding(1)
			jestExpect(binding._source).toContain(script.Name)
			jestExpect(binding._source).toContain("Binding created")
		end)
	end
end)

describe("Binding object", function()
	it("should provide a getter and setter", function()
		local binding, update = Binding.create(1)

		jestExpect(binding:getValue()).toBe(1)

		update(3)

		jestExpect(binding:getValue()).toBe(3)
	end)

	it("should let users subscribe and unsubscribe to its updates", function()
		local binding, update = Binding.create(1)

		local spy = jest.fn()
		local disconnect = Binding.subscribe(binding, function(...)
			spy(...)
		end)

		jestExpect(spy).never.toBeCalled()
		update(2)

		jestExpect(spy).toHaveBeenCalledTimes(1)
		jestExpect(spy).toHaveBeenCalledWith(2)

		disconnect()
		update(3)

		jestExpect(spy).toHaveBeenCalledTimes(1)
	end)
end)

describe("Mapped bindings", function()
	it("should be composable", function()
		local word, updateWord = Binding.create("hi")

		local wordLength = word:map(string.len)
		local isEvenLength = wordLength:map(function(value: number)
			return value % 2 == 0
		end)

		jestExpect(word:getValue()).toBe("hi")
		jestExpect(wordLength:getValue()).toBe(2)
		jestExpect(isEvenLength:getValue()).toBe(true)

		updateWord("sup")

		jestExpect(word:getValue()).toBe("sup")
		jestExpect(wordLength:getValue()).toBe(3)
		jestExpect(isEvenLength:getValue()).toBe(false)
	end)

	it("should cascade updates when subscribed", function()
		-- base binding
		local word, updateWord = Binding.create("hi")

		local wordSpy = jest.fn()
		local disconnectWord = Binding.subscribe(word, function(...)
			wordSpy(...)
		end)

		-- binding -> base binding
		local length = word:map(string.len)

		local lengthSpy = jest.fn()
		local disconnectLength = Binding.subscribe(length, function(...)
			lengthSpy(...)
		end)

		-- binding -> binding -> base binding
		local isEvenLength = length:map(function(value: number)
			return value % 2 == 0
		end)

		local isEvenLengthSpy = jest.fn()
		local disconnectIsEvenLength = Binding.subscribe(isEvenLength, function(...)
			isEvenLengthSpy(...)
		end)

		jestExpect(wordSpy).never.toBeCalled()
		jestExpect(lengthSpy).never.toBeCalled()
		jestExpect(isEvenLengthSpy).never.toBeCalled()

		updateWord("nice")

		jestExpect(wordSpy).toBeCalledTimes(1)
		jestExpect(wordSpy).toBeCalledWith("nice")

		jestExpect(lengthSpy).toBeCalledTimes(1)
		jestExpect(lengthSpy).toBeCalledWith(4)

		jestExpect(isEvenLengthSpy).toBeCalledTimes(1)
		jestExpect(isEvenLengthSpy).toBeCalledWith(true)

		disconnectWord()
		disconnectLength()
		disconnectIsEvenLength()

		updateWord("goodbye")

		jestExpect(wordSpy).toBeCalledTimes(1)
		jestExpect(isEvenLengthSpy).toBeCalledTimes(1)
		jestExpect(lengthSpy).toBeCalledTimes(1)
	end)

	it("should throw when updated directly", function()
		local source = Binding.create(1)
		local mapped = source:map(function(v)
			return v
		end)

		jestExpect(function()
			Binding.update(mapped, 5)
		end).toThrow()
	end)

	if _G.__DEV__ then
		it("should include a stack in DEV mode", function()
			local binding, _ = Binding.create(1)
			local mappedBinding = binding:map(function(value)
				return value
			end)
			jestExpect(mappedBinding._source).toContain(script.Name)
			jestExpect(mappedBinding._source).toContain("Mapped binding created")
		end)
	end
end)

describe("Binding.join", function()
	it("should have getValue", function()
		local binding1 = Binding.create(1)
		local binding2 = Binding.create(2)
		local binding3 = Binding.create(3)

		local joinedBinding = Binding.join({
			binding1,
			binding2,
			foo = binding3,
		})

		local bindingValue = joinedBinding:getValue()
		jestExpect(bindingValue).toEqual({
			[1] = 1,
			[2] = 2,
			foo = 3,
		})
	end)

	it("should update when any one of the subscribed bindings updates", function()
		local binding1, update1 = Binding.create(1)
		local binding2, update2 = Binding.create(2)
		local binding3, update3 = Binding.create(3)

		local joinedBinding = Binding.join({
			binding1,
			binding2,
			foo = binding3,
		})

		local spy = jest.fn()
		Binding.subscribe(joinedBinding, function(...)
			spy(...)
		end)

		jestExpect(spy).never.toBeCalled()

		update1(3)
		jestExpect(spy).toBeCalledTimes(1)

		jestExpect(spy).toBeCalledWith({
			[1] = 3,
			[2] = 2,
			["foo"] = 3,
		})

		update2(4)
		jestExpect(spy).toBeCalledTimes(2)

		jestExpect(spy).toBeCalledWith({
			[1] = 3,
			[2] = 4,
			["foo"] = 3,
		})

		update3(8)
		jestExpect(spy).toBeCalledTimes(3)

		jestExpect(spy).toBeCalledWith({
			[1] = 3,
			[2] = 4,
			["foo"] = 8,
		})
	end)

	it("should disconnect from all upstream bindings", function()
		local binding1, update1 = Binding.create(1)
		local binding2, update2 = Binding.create(2)

		local joined = Binding.join({ binding1, binding2 })

		local spy = jest.fn()
		local disconnect = Binding.subscribe(joined, function(...)
			spy(...)
		end)

		jestExpect(spy).never.toBeCalled()

		update1(3)
		jestExpect(spy).toBeCalledTimes(1)

		update2(3)
		jestExpect(spy).toBeCalledTimes(2)

		disconnect()
		update1(4)
		jestExpect(spy).toBeCalledTimes(2)

		update2(2)
		jestExpect(spy).toBeCalledTimes(2)

		jestExpect(joined:getValue()).toEqual({ 4, 2 })
	end)

	it("should be okay with calling disconnect multiple times", function()
		local joined = Binding.join({})

		local disconnect = Binding.subscribe(joined, function() end)

		disconnect()
		disconnect()
	end)

	it("should throw if updated directly", function()
		local joined = Binding.join({})

		jestExpect(function()
			Binding.update(joined, 0)
		end)
	end)

	if _G.__DEV__ then
		it("should throw when a non-table value is passed", function()
			jestExpect(function()
				Binding.join(("hi" :: any) :: { [string]: Binding<any> })
			end).toThrow()
		end)

		it("should throw when a non-binding value is passed via table", function()
			jestExpect(function()
				local binding = Binding.create(123)

				Binding.join({
					binding,
					("abcde" :: any) :: Binding<any>,
				})
			end).toThrow()
		end)

		it("should include a stack in DEV mode", function()
			local binding1, _ = Binding.create(1)
			local binding2, _ = Binding.create(2)
			local joinedBinding = Binding.join({ binding1, binding2 })
			jestExpect(joinedBinding._source).toContain(script.Name)
			jestExpect(joinedBinding._source).toContain("Joined binding created")
		end)
	end
end)

describe("createRef", function()
	it("should print the contained value when coerced to a string", function()
		local ref = ReactCreateRef.createRef()
		jestExpect(tostring(ref)).toBe("Ref(nil)")
		ref.current = "hello"
		jestExpect(tostring(ref)).toBe("Ref(hello)")
		ref.current = 123
		jestExpect(tostring(ref)).toBe("Ref(123)")
		ref.current = Instance.new("Folder")
		jestExpect(tostring(ref)).toBe("Ref(Folder)")
	end)

	if _G.__DEV__ then
		it("should include a stack in DEV mode", function()
			local ref = (ReactCreateRef.createRef() :: any) :: { _source: string }
			jestExpect(ref._source).toContain(script.Name)
			jestExpect(ref._source).toContain("Ref created")
		end)
	end
end) ]]
S.Children._94e73777962b8de46269960102514b82=V
local W

local X={ClassName="ModuleScript",Children={},Properties={}}
X.Name="ReactChildren.spec"
X.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/7516bdfce3f0f8c675494b5c5d0e7ae441bef1d9/packages/react/src/__tests__/ReactChildren-test.js
--!nonstrict
--\[\[
	**
	* Copyright (c) Facebook, Inc. and its affiliates.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*
	* @emails react-core
\]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local React
local ReactTestUtils
local ReactRoblox
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local expect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit

describe("ReactChildren", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		ReactRoblox = require(Packages.Dev.ReactRoblox)
		ReactTestUtils = {
			renderIntoDocument = function(element)
				local instance = Instance.new("Folder")
				local root = ReactRoblox.createLegacyRoot(instance)
				root:render(element)
				return root
			end,
		}
	end)

	it("should support identity for simple", function()
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid, index)
			-- ROBLOX DEVIATION: no "this" in luau
			-- expect(self).toBe(context)
			return kid
		end)
		local simpleKid = React.createElement("span", { key = "simple" }) -- First pass children into a component to fully simulate what happens when
		-- using structures that arrive from transforms.
		local instance = React.createElement("span", nil, simpleKid)
		React.Children.forEach(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		callback.mockClear()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		expect(mappedChildren[1]).toEqual(
			React.createElement("span", { key = ".$simple" })
		)
	end)

	it("should support Portal components", function()
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid, index)
			-- expect(self).toBe(context)
			return kid
		end)
		-- local ReactDOM = require("react-dom")
		local portalContainer = Instance.new("Folder")
		local simpleChild = React.createElement("Frame", { key = "simple" })
		local reactPortal = ReactRoblox.createPortal(simpleChild, portalContainer)
		local parentInstance = React.createElement("Frame", nil, reactPortal)
		React.Children.forEach(parentInstance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(reactPortal, 1)
		callback.mockClear()
		local mappedChildren =
			React.Children.map(parentInstance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(reactPortal, 1)
		expect(mappedChildren[1]).toEqual(reactPortal)
	end)

	it("should treat single arrayless child as being in array", function()
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid, index)
			-- expect(self).toBe(context)
			return kid
		end)
		local simpleKid = React.createElement("span", nil)
		local instance = React.createElement("div", nil, simpleKid)
		React.Children.forEach(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		callback.mockClear()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		expect(mappedChildren[1]).toEqual(React.createElement("span", { key = ".1" }))
	end)

	it("should treat single child in array as expected", function()
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid, index)
			-- expect(self).toBe(context)
			return kid
		end)
		local simpleKid = React.createElement("span", { key = "simple" })
		local instance = React.createElement("div", nil, { simpleKid })
		React.Children.forEach(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		callback.mockClear()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		expect(callback).toHaveBeenCalledWith(simpleKid, 1)
		expect(mappedChildren[1]).toEqual(
			React.createElement("span", { key = ".$simple" })
		)
	end)

	it("should be called for each child", function()
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local instance = React.createElement("div", nil, zero, one, two, three, four)
		local function assertCalls()
			-- ROBLOX DEVIATION: React.None children will be passed as nil to callback
			expect(callback).toHaveBeenCalledTimes(5)
			expect(callback).toHaveBeenCalledWith(zero, 1)
			expect(callback).toHaveBeenCalledWith(nil, 2)
			expect(callback).toHaveBeenCalledWith(two, 3)
			expect(callback).toHaveBeenCalledWith(nil, 4)
			expect(callback).toHaveBeenCalledWith(four, 5)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".$keyZero" }),
			React.createElement("div", { key = ".$keyTwo" }),
			React.createElement("div", { key = ".$keyFour" }),
		})
	end)

	it("should traverse children of different kinds", function()
		local div = React.createElement("div", { key = "divNode" })
		local span = React.createElement("span", { key = "spanNode" })
		local a = React.createElement("a", { key = "aNode" })
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local instance = React.createElement(
			"div",
			nil,
			div,
			{ { span } },
			{ a },
			"string",
			1234,
			true,
			false,
			-- Include nil children as React.None
			React.None,
			React.None
		)
		local function assertCalls()
			expect(callback).toHaveBeenCalledTimes(9)
			expect(callback).toHaveBeenCalledWith(div, 1)
			expect(callback).toHaveBeenCalledWith(span, 2)
			expect(callback).toHaveBeenCalledWith(a, 3)
			expect(callback).toHaveBeenCalledWith("string", 4)
			expect(callback).toHaveBeenCalledWith(1234, 5)
			expect(callback).toHaveBeenCalledWith(nil, 6)
			expect(callback).toHaveBeenCalledWith(nil, 7)
			expect(callback).toHaveBeenCalledWith(nil, 8)
			expect(callback).toHaveBeenCalledWith(nil, 9)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".$divNode" }),
			React.createElement("span", { key = ".2:1:$spanNode" }),
			React.createElement("a", { key = ".3:$aNode" }),
			"string",
			1234,
		})
	end)

	it("should be called for each child in nested structure", function()
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local five = React.createElement("div", { key = "keyFive" })
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			return kid
		end)
		local instance =
			React.createElement("div", nil, { { zero, one, two }, { three, four }, five })
		local function assertCalls()
			-- ROBLOX DEVIATION: React.None children are interpreted as nil in callbacks
			expect(callback).toHaveBeenCalledTimes(6)
			expect(callback).toHaveBeenCalledWith(zero, 1)
			expect(callback).toHaveBeenCalledWith(nil, 2)
			expect(callback).toHaveBeenCalledWith(two, 3)
			expect(callback).toHaveBeenCalledWith(nil, 4)
			expect(callback).toHaveBeenCalledWith(four, 5)
			expect(callback).toHaveBeenCalledWith(five, 6)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".1:$keyZero" }),
			React.createElement("div", { key = ".1:$keyTwo" }),
			React.createElement("div", { key = ".2:$keyFour" }),
			React.createElement("div", { key = ".$keyFive" }),
		})
	end)

	it("should retain key across two mappings", function()
		local zeroForceKey = React.createElement("div", { key = "keyZero" })
		local oneForceKey = React.createElement("div", { key = "keyOne" })
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local forcedKeys = React.createElement("div", nil, zeroForceKey, oneForceKey)
		local function assertCalls()
			expect(callback).toHaveBeenCalledWith(zeroForceKey, 1)
			expect(callback).toHaveBeenCalledWith(oneForceKey, 2)
			callback.mockClear()
		end
		React.Children.forEach(forcedKeys.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(forcedKeys.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".$keyZero" }),
			React.createElement("div", { key = ".$keyOne" }),
		})
	end)

	-- ROBLOX DEVIATION: Iterators are not supported by default in Roblox
	xit("should be called for each child in an iterable without keys", function()
		local threeDivIterable = {
			["@@iterator"] = function(self)
				local i = 0
				return {
					next = function(self)
						if
							(function()
								local result = i
								i += 1
								return result
							end)()
							< 3 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
						then
							return {
								value = React.createElement("div", nil),
								done = false,
							}
						else
							return { value = nil, done = true }
						end
					end,
				}
			end,
		}
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local instance
		expect(function()
			instance = React.createElement("div", nil, threeDivIterable)
			return instance
		end).toErrorDev(
			'Warning: Each child in a list should have a unique "key" prop.'
		)
		local function assertCalls()
			expect(callback).toHaveBeenCalledTimes(3)
			expect(callback).toHaveBeenCalledWith(React.createElement("div", nil), 0)
			expect(callback).toHaveBeenCalledWith(React.createElement("div", nil), 1)
			expect(callback).toHaveBeenCalledWith(React.createElement("div", nil), 2)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".0" }),
			React.createElement("div", { key = ".1" }),
			React.createElement("div", { key = ".2" }),
		})
	end)

	-- ROBLOX DEVIATION: no @@iterator in Luau
	xit("should be called for each child in an iterable with keys", function()
		local threeDivIterable = {
			["@@iterator"] = function(self)
				local i = 0
				return {
					next = function(self)
						if
							(function()
								local result = i
								i += 1
								return result
							end)()
							< 3 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
						then
							return {
								value = React.createElement(
									"div",
									{ key = "#" .. tostring(i) }
								),
								done = false,
							}
						else
							return { value = nil, done = true }
						end
					end,
				}
			end,
		}
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local instance = React.createElement("div", nil, threeDivIterable)
		local function assertCalls()
			expect(callback).toHaveBeenCalledTimes(3)
			expect(callback).toHaveBeenCalledWith(
				React.createElement("div", { key = "#1" }),
				0
			)
			expect(callback).toHaveBeenCalledWith(
				React.createElement("div", { key = "#2" }),
				1
			)
			expect(callback).toHaveBeenCalledWith(
				React.createElement("div", { key = "#3" }),
				2
			)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".$#1" }),
			React.createElement("div", { key = ".$#2" }),
			React.createElement("div", { key = ".$#3" }),
		})
	end)

	-- ROBLOX DEVIATION: Number prototype and iterables not relevant in luau
	-- it("should not enumerate enumerable numbers (#4776)", function()
	-- 	--\[\[eslint-disable no-extend-native \]\]
	-- 	-- Number.prototype["@@iterator"] = function()
	-- 	-- 	error(Error.new("number iterator called"))
	-- 	-- end
	-- 	--\[\[eslint-enable no-extend-native \]\]
	-- 	do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
	-- 		local ok, result, hasReturned = pcall(function()
	-- 			local instance = React.createElement("div", nil, 5, 12, 13)
	-- 			local context = {}
	-- 			local callback = jest.fn().mockImplementation(function(kid)
	-- 				-- expect(self).toBe(context)
	-- 				return kid
	-- 			end)
	-- 			local function assertCalls()
	-- 				expect(callback).toHaveBeenCalledTimes(3)
	-- 				expect(callback).toHaveBeenCalledWith(5, 0)
	-- 				expect(callback).toHaveBeenCalledWith(12, 1)
	-- 				expect(callback).toHaveBeenCalledWith(13, 2)
	-- 				callback.mockClear()
	-- 			end
	-- 			React.Children.forEach(instance.props.children, callback, context)
	-- 			assertCalls()
	-- 			local mappedChildren = React.Children.map(
	-- 				instance.props.children,
	-- 				callback,
	-- 				context
	-- 			)
	-- 			assertCalls()
	-- 			expect(mappedChildren).toEqual({ 5, 12, 13 })
	-- 		end)
	-- 		do
	-- 			-- Number.prototype["@@iterator"] = nil
	-- 		end
	-- 		if hasReturned then
	-- 			return result
	-- 		end
	-- 		if not ok then
	-- 			error(result)
	-- 		end
	-- 	end
	-- end)

	--ROBLOX NOTE: This test passes, but is not needed
	it("should allow extension of native prototypes", function()
		--\[\[eslint-disable no-extend-native \]\]
		-- String.prototype.key = "react"
		-- Number.prototype.key = "rocks"
		--\[\[eslint-enable no-extend-native \]\]
		local instance = React.createElement("div", nil, "a", 13)
		local context = {}
		local callback = jest.fn().mockImplementation(function(kid)
			-- expect(self).toBe(context)
			return kid
		end)
		local function assertCalls()
			expect(callback).toHaveBeenCalledTimes(2, 0)
			expect(callback).toHaveBeenCalledWith("a", 1)
			expect(callback).toHaveBeenCalledWith(13, 2)
			callback.mockClear()
		end
		React.Children.forEach(instance.props.children, callback, context)
		assertCalls()
		local mappedChildren =
			React.Children.map(instance.props.children, callback, context)
		assertCalls()
		expect(mappedChildren).toEqual({ "a", 13 })
		-- String.prototype.key = nil
		-- Number.prototype.key = nil
	end)

	it("should pass key to returned component", function()
		local function mapFn(kid, index)
			return React.createElement("div", nil, kid)
		end
		local simpleKid = React.createElement("span", { key = "simple" })
		local instance = React.createElement("div", nil, simpleKid)
		local mappedChildren = React.Children.map(instance.props.children, mapFn)
		expect(React.Children.count(mappedChildren)).toBe(1)
		expect(mappedChildren[1]).never.toBe(simpleKid)
		expect(((mappedChildren[1]).props).children).toBe(simpleKid)
		expect((mappedChildren[1]).key).toBe(".$simple")
	end)

	-- ROBLOX DEVIATION: no "this" in luau, ignore context passed to callback
	-- it("should invoke callback with the right context", function()
	-- 	local lastContext
	-- 	local function callback(kid, index)
	-- 		-- lastContext = self
	-- 		-- return self
	-- 	end -- TODO: Use an object to test, after non-object fragments has fully landed.
	-- 	local scopeTester = "scope tester"
	-- 	local simpleKid = React.createElement("span", { key = "simple" })
	-- 	local instance = React.createElement("div", nil, simpleKid)
	-- 	React.Children.forEach(instance.props.children, callback, scopeTester)
	-- 	expect(lastContext).toBe(scopeTester)
	-- 	local mappedChildren = React.Children.map(
	-- 		instance.props.children,
	-- 		callback,
	-- 		scopeTester
	-- 	)
	-- 	expect(React.Children.count(mappedChildren)).toBe(1)
	-- 	expect(mappedChildren[1]).toBe(scopeTester)
	-- end)

	it("should be called for each child 2", function()
		-- ROBLOX DEVIATION: Use React.None instead of nil
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local mapped = {
			React.createElement("div", { key = "giraffe" }), -- Key should be joined to obj key
			nil, -- Key should be added even if we don't supply it!
			React.createElement("div", nil), -- Key should be added even if not supplied!
			React.createElement("span", nil), -- Map from null to something.
			React.createElement("div", { key = "keyFour" }),
		}
		local callback = jest.fn().mockImplementation(function(kid, index)
			return mapped[index]
		end)
		local instance = React.createElement("div", nil, zero, one, two, three, four)
		React.Children.forEach(instance.props.children, callback)
		expect(callback).toHaveBeenCalledWith(zero, 1)
		-- ROBLOX DEVIATION: React.None gets treated as nil for callback
		expect(callback).toHaveBeenCalledWith(nil, 2)
		expect(callback).toHaveBeenCalledWith(two, 3)
		expect(callback).toHaveBeenCalledWith(nil, 4)
		expect(callback).toHaveBeenCalledWith(four, 5)
		callback.mockClear()
		local mappedChildren = React.Children.map(instance.props.children, callback)
		expect(callback).toHaveBeenCalledTimes(5)
		expect(React.Children.count(mappedChildren)).toBe(4) -- Keys default to indices.
		expect({
			mappedChildren[1].key,
			mappedChildren[2].key,
			mappedChildren[3].key,
			mappedChildren[4].key,
		}).toEqual({ "giraffe/.$keyZero", ".$keyTwo", ".4", ".$keyFour" })
		expect(callback).toHaveBeenCalledWith(zero, 1)
		-- ROBLOX DEVIATION: React.None gets treated as nil for callback
		expect(callback).toHaveBeenCalledWith(nil, 2)
		expect(callback).toHaveBeenCalledWith(two, 3)
		expect(callback).toHaveBeenCalledWith(nil, 4)
		expect(callback).toHaveBeenCalledWith(four, 5)
		expect(mappedChildren[1]).toEqual(
			React.createElement("div", { key = "giraffe/.$keyZero" })
		)
		expect(mappedChildren[2]).toEqual(
			React.createElement("div", { key = ".$keyTwo" })
		)
		expect(mappedChildren[3]).toEqual(React.createElement("span", { key = ".4" }))
		expect(mappedChildren[4]).toEqual(
			React.createElement("div", { key = ".$keyFour" })
		)
	end)

	it("should be called for each child in nested structure 2", function()
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local five = React.createElement("div", { key = "keyFive" })
		local zeroMapped = React.createElement("div", { key = "giraffe" }) -- Key should be overridden
		local twoMapped = React.createElement("div", nil) -- Key should be added even if not supplied!
		local fourMapped = React.createElement("div", { key = "keyFour" })
		local fiveMapped = React.createElement("div", nil)
		local callback = jest.fn().mockImplementation(function(kid)
			repeat --\[\[ ROBLOX comment: switch statement conversion \]\]
				local entered_, break_ = false, false
				local condition_ = kid
				for _, v in { zero, two, four, five } do
					if condition_ == v then
						if v == zero then
							entered_ = true
							return zeroMapped
						end
						if v == two or entered_ then
							entered_ = true
							return twoMapped
						end
						if v == four or entered_ then
							entered_ = true
							return fourMapped
						end
						if v == five or entered_ then
							entered_ = true
							return fiveMapped
						end
					end
				end
				if not break_ then
					return kid
				end
			until true
			return
		end)
		local frag = { { zero, one, two }, { three, four }, five }
		local instance = React.createElement("div", nil, { frag })
		React.Children.forEach(instance.props.children, callback)
		expect(callback).toHaveBeenCalledTimes(6)
		expect(callback).toHaveBeenCalledWith(zero, 1)
		-- ROBLOX DEVIATION: React.None gets treated as nil for callback
		expect(callback).toHaveBeenCalledWith(nil, 2)
		expect(callback).toHaveBeenCalledWith(two, 3)
		expect(callback).toHaveBeenCalledWith(nil, 4)
		expect(callback).toHaveBeenCalledWith(four, 5)
		expect(callback).toHaveBeenCalledWith(five, 6)
		callback.mockClear()
		local mappedChildren = React.Children.map(instance.props.children, callback)
		expect(callback).toHaveBeenCalledTimes(6)
		expect(callback).toHaveBeenCalledWith(zero, 1)
		-- ROBLOX DEVIATION: React.None gets treated as nil for callback
		expect(callback).toHaveBeenCalledWith(nil, 2)
		expect(callback).toHaveBeenCalledWith(two, 3)
		expect(callback).toHaveBeenCalledWith(nil, 4)
		expect(callback).toHaveBeenCalledWith(four, 5)
		expect(callback).toHaveBeenCalledWith(five, 6)
		expect(React.Children.count(mappedChildren)).toBe(4) -- Keys default to indices.
		expect({
			mappedChildren[1].key,
			mappedChildren[2].key,
			mappedChildren[3].key,
			mappedChildren[4].key,
		}).toEqual({
			"giraffe/.1:1:$keyZero",
			".1:1:$keyTwo",
			".1:2:$keyFour",
			".1:$keyFive",
		})
		expect(mappedChildren[1]).toEqual(
			React.createElement("div", { key = "giraffe/.1:1:$keyZero" })
		)
		expect(mappedChildren[2]).toEqual(
			React.createElement("div", { key = ".1:1:$keyTwo" })
		)
		expect(mappedChildren[3]).toEqual(
			React.createElement("div", { key = ".1:2:$keyFour" })
		)
		expect(mappedChildren[4]).toEqual(
			React.createElement("div", { key = ".1:$keyFive" })
		)
	end)

	it("should retain key across two mappings 2", function()
		local zeroForceKey = React.createElement("div", { key = "keyZero" })
		local oneForceKey = React.createElement("div", { key = "keyOne" }) -- Key should be joined to object key
		local zeroForceKeyMapped = React.createElement("div", { key = "giraffe" }) -- Key should be added even if we don't supply it!
		local oneForceKeyMapped = React.createElement("div", nil)
		local function mapFn(kid, index)
			return (function()
				if index == 1 then
					return zeroForceKeyMapped
				else
					return oneForceKeyMapped
				end
			end)()
		end
		local forcedKeys = React.createElement("div", nil, zeroForceKey, oneForceKey)
		local expectedForcedKeys = { "giraffe/.$keyZero", ".$keyOne" }
		local mappedChildrenForcedKeys =
			React.Children.map(forcedKeys.props.children, mapFn)
		local mappedForcedKeys = Array.map(mappedChildrenForcedKeys, function(c)
			return c.key
		end)
		expect(mappedForcedKeys).toEqual(expectedForcedKeys)
		local expectedRemappedForcedKeys = {
			"giraffe/.$giraffe/.$keyZero",
			".$.$keyOne",
		}
		local remappedChildrenForcedKeys =
			React.Children.map(mappedChildrenForcedKeys, mapFn)
		expect(Array.map(remappedChildrenForcedKeys, function(c)
			return c.key
		end)).toEqual(expectedRemappedForcedKeys)
	end)

	it("should not throw if key provided is a dupe with array key", function()
		local zero = React.createElement("div", nil)
		local one = React.createElement("div", { key = "0" })
		local function mapFn()
			return nil
		end
		local instance = React.createElement("div", nil, zero, one)
		expect(function()
			React.Children.map(instance.props.children, mapFn)
		end).never.toThrow()
	end)

	it("should use the same key for a cloned element", function()
		local instance = React.createElement("div", nil, React.createElement("div", nil))
		local mapped = React.Children.map(instance.props.children, function(element)
			return element
		end)
		local mappedWithClone = React.Children.map(
			instance.props.children,
			function(element)
				return React.cloneElement(element)
			end
		)
		expect(mapped[1].key).toBe(mappedWithClone[1].key)
	end)

	it("should use the same key for a cloned element with key", function()
		local instance = React.createElement(
			"div",
			nil,
			React.createElement("div", { key = "unique" })
		)
		local mapped = React.Children.map(instance.props.children, function(element)
			return element
		end)
		local mappedWithClone = React.Children.map(
			instance.props.children,
			function(element)
				return React.cloneElement(element, { key = "unique" })
			end
		)
		expect(mapped[1].key).toBe(mappedWithClone[1].key)
	end)

	it("should return 0 for null children", function()
		local numberOfChildren = React.Children.count(nil)
		expect(numberOfChildren).toBe(0)
	end)

	-- ROBLOX DEVIATION: This test doesn't make sense in luau, as there is no undefined
	-- it("should return 0 for undefined children", function()
	-- 	local numberOfChildren = React.Children.count(nil)
	-- 	expect(numberOfChildren).toBe(0)
	-- end)

	it("should return 1 for single child", function()
		local simpleKid = React.createElement("span", { key = "simple" })
		local instance = React.createElement("div", nil, simpleKid)
		local numberOfChildren = React.Children.count(instance.props.children)
		expect(numberOfChildren).toBe(1)
	end)

	it("should count the number of children in flat structure", function()
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local instance = React.createElement("div", nil, zero, one, two, three, four)
		local numberOfChildren = React.Children.count(instance.props.children)
		expect(numberOfChildren).toBe(5)
	end)

	it("should count the number of children in nested structure", function()
		local zero = React.createElement("div", { key = "keyZero" })
		local one = React.None
		local two = React.createElement("div", { key = "keyTwo" })
		local three = React.None
		local four = React.createElement("div", { key = "keyFour" })
		local five = React.createElement("div", { key = "keyFive" })
		local instance = React.createElement(
			"div",
			nil,
			{ { { zero, one, two }, { three, four }, five }, React.None }
		)
		local numberOfChildren = React.Children.count(instance.props.children)
		expect(numberOfChildren).toBe(7)
	end)

	it("should flatten children to an array", function()
		expect(React.Children.toArray(nil)).toEqual({})
		-- ROBLOX DEVIATION: React.None is omitted
		expect(React.Children.toArray(React.None)).toEqual({})
		expect(#(React.Children.toArray(React.createElement("div", nil)))).toBe(1)
		expect(#(React.Children.toArray({ React.createElement("div", nil) }))).toBe(1)
		expect((React.Children.toArray(React.createElement("div", nil)))[1].key).toBe(
			(React.Children.toArray({ React.createElement("div", nil) }))[1].key
		)
		local flattened = React.Children.toArray({
			{
				React.createElement("div", { key = "apple" }),
				React.createElement("div", { key = "banana" }),
				React.createElement("div", { key = "camel" }),
			},
			{
				React.createElement("div", { key = "banana" }),
				React.createElement("div", { key = "camel" }),
				React.createElement("div", { key = "deli" }),
			},
		})
		expect(#flattened).toBe(6)
		expect(flattened[2].key).toContain("banana")
		expect(flattened[4].key).toContain("banana")
		expect(flattened[2].key).never.toBe(flattened[4].key)
		local reversed = React.Children.toArray({
			{
				React.createElement("div", { key = "camel" }),
				React.createElement("div", { key = "banana" }),
				React.createElement("div", { key = "apple" }),
			},
			{
				React.createElement("div", { key = "deli" }),
				React.createElement("div", { key = "camel" }),
				React.createElement("div", { key = "banana" }),
			},
		})
		expect(flattened[1].key).toBe(reversed[3].key)
		expect(flattened[2].key).toBe(reversed[2].key)
		expect(flattened[3].key).toBe(reversed[1].key)
		expect(flattened[4].key).toBe(reversed[6].key)
		expect(flattened[5].key).toBe(reversed[5].key)
		expect(flattened[6].key).toBe(reversed[4].key)
		-- null/undefined/bool are all omitted
		-- ROBLOX DEVIATION: React.None is omitted
		expect(React.Children.toArray({ 1, "two", nil, React.None, true })).toEqual({
			1,
			"two",
		})
	end)

	it("should escape keys", function()
		local zero = React.createElement("div", { key = "1" })
		local one = React.createElement("div", { key = "1=::=2" })
		local instance = React.createElement("div", nil, zero, one)
		local mappedChildren = React.Children.map(instance.props.children, function(kid)
			return kid
		end)
		expect(mappedChildren).toEqual({
			React.createElement("div", { key = ".$1" }),
			React.createElement("div", { key = ".$1=0=2=2=02" }),
		})
	end)

	it("should combine keys when map returns an array", function()
		local instance = React.createElement(
			"div",
			nil,
			React.createElement("div", { key = "a" }),
			false,
			React.createElement("div", { key = "b" }),
			React.createElement("p", nil)
		)
		local mappedChildren = React.Children.map(
			instance.props.children,
			-- Try a few things: keyed, unkeyed, hole, and a cloned element.
			function(kid)
				return {
					React.createElement("span", { key = "x" }),
					React.None,
					React.createElement("span", { key = "y" }),
					-- ROBLOX DEVIATION: use React.None instead of nil
					kid or React.None,
					if kid and kid ~= React.None
						then React.cloneElement(kid, { key = "z" })
						else React.None,
					React.createElement("hr", nil),
				}
			end
		)
		expect(#mappedChildren).toBe(18)
		-- <div key="a">
		expect(mappedChildren[1].type).toBe("span")
		expect(mappedChildren[1].key).toBe(".$a/.$x")
		expect(mappedChildren[2].type).toBe("span")
		expect(mappedChildren[2].key).toBe(".$a/.$y")
		expect(mappedChildren[3].type).toBe("div")
		expect(mappedChildren[3].key).toBe(".$a/.$a")
		expect(mappedChildren[4].type).toBe("div")
		expect(mappedChildren[4].key).toBe(".$a/.$z")
		expect(mappedChildren[5].type).toBe("hr")
		expect(mappedChildren[5].key).toBe(".$a/.6")
		-- false
		expect(mappedChildren[6].type).toBe("span")
		expect(mappedChildren[6].key).toBe(".2/.$x")
		expect(mappedChildren[7].type).toBe("span")
		expect(mappedChildren[7].key).toBe(".2/.$y")
		expect(mappedChildren[8].type).toBe("hr")
		expect(mappedChildren[8].key).toBe(".2/.6")
		-- <div key="b">
		expect(mappedChildren[9].type).toBe("span")
		expect(mappedChildren[9].key).toBe(".$b/.$x")
		expect(mappedChildren[10].type).toBe("span")
		expect(mappedChildren[10].key).toBe(".$b/.$y")
		expect(mappedChildren[11].type).toBe("div")
		expect(mappedChildren[11].key).toBe(".$b/.$b")
		expect(mappedChildren[12].type).toBe("div")
		expect(mappedChildren[12].key).toBe(".$b/.$z")
		expect(mappedChildren[13].type).toBe("hr")
		expect(mappedChildren[13].key).toBe(".$b/.6")
		-- <p>
		expect(mappedChildren[14].type).toBe("span")
		expect(mappedChildren[14].key).toBe(".4/.$x")
		expect(mappedChildren[15].type).toBe("span")
		expect(mappedChildren[15].key).toBe(".4/.$y")
		expect(mappedChildren[16].type).toBe("p")
		expect(mappedChildren[16].key).toBe(".4/.4")
		expect(mappedChildren[17].type).toBe("p")
		expect(mappedChildren[17].key).toBe(".4/.$z")
		expect(mappedChildren[18].type).toBe("hr")
		expect(mappedChildren[18].key).toBe(".4/.6")
	end)

	-- ROBLOX DEVIATION: objects are treated as iterables in Roact, this will not throw
	-- it("should throw on object", function()
	-- 	expect(function()
	-- 		React.Children.forEach({ a = 1, b = 2 }, function() end, nil)
	-- 	end).toThrowError(
	-- 		"Objects are not valid as a React child (found: object with keys "
	-- 			.. "{a, b})."
	-- 			.. (if _G.__DEV__
	-- 				then " If you meant to render a collection of children, use an array instead."
	-- 				else "")
	-- 	)
	-- end)

	-- ROBLOX DEVIATION: no equivalent to this regex in luau
	-- it("should throw on regex", function()
	-- 	-- Really, we care about dates (#4840) but those have nondeterministic
	-- 	-- serialization (timezones) so let's test a regex instead:
	-- 	expect(function()
	-- 		React.Children.forEach(
	-- 			error("not implemented"), --\[\[ ROBLOX TODO: Unhandled node for type: RegExpLiteral \]\] --\[\[ /abc/ \]\]
	-- 			function() end,
	-- 			nil
	-- 		) --\[\[ ROBLOX CHECK: check if 'React.Children' is an Array \]\]
	-- 	end).toThrowError(
	-- 		"Objects are not valid as a React child (found: /abc/)."
	-- 			.. 	if _G.__DEV__
	-- 				then " If you meant to render a collection of children, use an array instead."
	-- 				else ""
	-- 	)
	-- end)

	--ROBLOX DEVIATION START: Tables with keys should work with React.Children
	describe("with children as a keyed table", function()
		it("should flatten to an array", function()
			-- ROBLOX TODO: should we keep the original keys?
			expect(React.Children.toArray({
				a = React.createElement("div", nil),
				b = React.createElement("div", nil),
			})).toEqual({
				React.createElement("div", { key = ".1" }),
				React.createElement("div", { key = ".2" }),
			})

			expect(React.Children.toArray({
				a = React.createElement("div", nil),
				b = {
					c = React.createElement("div", nil),
					d = React.createElement("div", nil),
				},
			})).toEqual({
				React.createElement("div", { key = ".1" }),
				React.createElement("div", { key = ".2:1" }),
				React.createElement("div", { key = ".2:2" }),
			})
		end)

		it("should count children correctly", function()
			expect(React.Children.count({
				a = React.createElement("div", nil),
				b = React.createElement("div", nil),
				c = React.createElement("div", nil),
			})).toBe(3)

			expect(React.Children.count({
				a = React.createElement("div", nil),
				b = {
					c = React.createElement("div", nil),
					d = React.createElement("div", nil),
				},
				e = {
					React.createElement("div", nil),
					React.createElement("div", nil),
				},
			})).toEqual(5)
		end)

		it("should apply function to each child with forEach", function()
			local callback = jest.fn().mockImplementation(function(kid, idx)
				return kid
			end)

			local a = React.createElement("div")
			local b = React.createElement("span")
			local c = React.createElement("p")

			local instance = React.createElement("div", nil, {
				a = a,
				b = b,
				c = c,
			})

			React.Children.forEach(instance.props.children, callback, {})
			local function assertCalls()
				expect(callback).toHaveBeenCalledTimes(3)
				-- ROBLOX DEVIATION: order is not guaranteed
				-- expect(callback).toHaveBeenCalledWith(a, 1)
				-- expect(callback).toHaveBeenCalledWith(c, 2)
				-- expect(callback).toHaveBeenCalledWith(b, 3)
				callback.mockClear()
			end
			assertCalls()
		end)

		it("should map each child with map", function()
			local callback = jest.fn().mockImplementation(function(kid, idx)
				return kid.type
			end)

			local a = React.createElement("div")
			local b = React.createElement("span")
			local c = React.createElement("p")

			local instance = React.createElement("div", nil, {
				a = a,
				b = b,
				c = c,
			})

			local mappedChildren =
				React.Children.map(instance.props.children, callback, {})
			local function assertCalls()
				expect(callback).toHaveBeenCalledTimes(3)
				expect(#mappedChildren).toEqual(3)
				expect(table.find(mappedChildren, "div")).toBeDefined()
				expect(table.find(mappedChildren, "span")).toBeDefined()
				expect(table.find(mappedChildren, "p")).toBeDefined()
				callback.mockClear()
			end
			assertCalls()
		end)
	end)
	--ROBLOX DEVIATION END: Tables with keys should work with React.Children

	describe("with fragments enabled", function()
		it("warns for keys for arrays of elements in a fragment", function()
			local ComponentReturningArray =
				React.Component:extend("ComponentReturningArray")
			function ComponentReturningArray:render()
				return {
					React.createElement("Frame", nil),
					React.createElement("Frame", nil),
				}
			end
			expect(function()
				return ReactTestUtils.renderIntoDocument(
					React.createElement(ComponentReturningArray, nil)
				)
			end).toErrorDev(
				"Warning: "
					.. 'Each child in a list should have a unique "key" prop.'
					.. " See https://reactjs.org/link/warning-keys for more information."
					.. "\n    in ComponentReturningArray (at **)"
			)
		end)

		it("does not warn when there are keys on  elements in a fragment", function()
			local ComponentReturningArray =
				React.Component:extend("ComponentReturningArray")

			function ComponentReturningArray:render()
				return {
					React.createElement("Frame", { key = "foo" }),
					React.createElement("Frame", { key = "bar" }),
				}
			end
			ReactTestUtils.renderIntoDocument(
				React.createElement(ComponentReturningArray, nil)
			)
		end)

		it("warns for keys for arrays at the top level", function()
			expect(function()
				return ReactTestUtils.renderIntoDocument({
					React.createElement("Frame", nil),
					React.createElement("Frame", nil),
				})
			end).toErrorDev(
				"Warning: "
					.. 'Each child in a list should have a unique "key" prop.'
					.. " See https://reactjs.org/link/warning-keys for more information.",
				{ withoutStack = true } -- There's nothing on the stack
			)
		end)
	end)
end) ]]
S.Children._9afa7c3c102a084a81fcd5630fdc0a4a=X
local Y

local Z={ClassName="ModuleScript",Children={},Properties={}}
Z.Name="ReactDeprecationWarnings-internal.spec"
Z.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-dom/src/__tests__/ReactDeprecationWarnings-test.internal.js
local React
local ReactFeatureFlags
local ReactNoop
local Scheduler
-- local JSXDEVRuntime
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local xit = JestGlobals.xit

describe("ReactDeprecationWarnings", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Dev.Scheduler)
		-- if Boolean.toJSBoolean(__DEV__) then
		-- 	JSXDEVRuntime = require("react/jsx-dev-runtime")
		-- end
		ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents = true
		ReactFeatureFlags.warnAboutStringRefs = true
	end)
	afterEach(function()
		ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents = false
		ReactFeatureFlags.warnAboutStringRefs = false
	end)

	-- ROBLOX deviation: we already don't support defaultProps on function components
	xit("should warn when given defaultProps", function()
		local function FunctionalComponent(_props)
			return nil
		end
		-- FunctionalComponent.defaultProps = { testProp = true }
		ReactNoop.render(React.createElement(FunctionalComponent))
		jestExpect(function()
			return jestExpect(Scheduler).toFlushWithoutYielding()
		end).toErrorDev(
			"Warning: FunctionalComponent: Support for defaultProps "
				.. "will be removed from function components in a future major "
				.. "release. Use JavaScript default parameters instead."
		)
	end)
	it("should warn when given string refs", function()
		local RefComponent = React.Component:extend("RefComponent")
		function RefComponent:render()
			return nil
		end
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement(RefComponent, { ref = "refComponent" })
		end
		ReactNoop.render(React.createElement(Component))
		local expectedName = _G.__DEV__ and "Component"
			or "<enable __DEV__ mode for component names>"
		-- ROBLOX Test Noise: jest setup config makes this hide error
		-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
		-- ROBLOX deviation: we removed string ref support ahead of upstream schedule
		jestExpect(function()
			return jestExpect(Scheduler).toFlushWithoutYielding()
		end).toThrow(
			'Component "'
				.. expectedName
				.. '" contains the string ref "refComponent". '
				.. "Support for string refs has been removed. "
				.. "We recommend using useRef() or createRef() instead. "
				.. "Learn more about using refs safely here: "
				.. "https://reactjs.org/link/strict-mode-string-ref"
			-- ROBLOX deviation: since we throw instead of warn, no stack trace in the message
			-- .. "\n    in Component (at **)"
		)
	end)
	-- ROBLOX deviation: we don't allow string refs under any circumstances
	xit("should not warn when owner and self are the same for string refs", function()
		ReactFeatureFlags.warnAboutStringRefs = false
		local RefComponent = React.Component:extend("RefComponent")
		function RefComponent:render()
			return nil
		end
		local Component = React.Component:extend("")
		function Component:render()
			return React.createElement(
				RefComponent,
				{ ref = "refComponent", __self = self }
			)
		end
		ReactNoop.renderLegacySyncRoot(React.createElement(Component))
		jestExpect(Scheduler).toFlushWithoutYielding()
	end)
	it("should warn when owner and self are different for string refs", function()
		local RefComponent = React.Component:extend("RefComponent")
		function RefComponent:render()
			return nil
		end
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement(
				RefComponent,
				{ ref = "refComponent", __self = {} }
			)
		end
		ReactNoop.render(React.createElement(Component))

		-- ROBLOX deviation: we removed string ref support ahead of upstream schedule
		local expectedName = _G.__DEV__ and "Component"
			or "<enable __DEV__ mode for component names>"
		-- ROBLOX Test Noise: jest setup config makes this hide error
		-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
		jestExpect(function()
			return jestExpect(Scheduler).toFlushWithoutYielding()
		end).toThrow(
			'Component "'
				.. expectedName
				.. '" contains the string ref "refComponent". '
				.. "Support for string refs has been removed. "
				.. "We recommend using useRef() or createRef() instead. "
				.. "Learn more about using refs safely here: "
				.. "https://reactjs.org/link/strict-mode-string-ref"
		)
	end)

	-- ROBLOX TODO: figure out how to do this without JSX internals
	-- if _G.__DEV__ then
	-- 	xit("should warn when owner and self are different for string refs", function()
	-- 		local RefComponent = React.Component:extend("")
	-- 		RefComponent.__index = RefComponent
	-- 		function RefComponent:render()
	-- 			return nil
	-- 		end
	-- 		local Component = React.Component:extend("")
	-- 		Component.__index = Component
	-- 		function Component:render()
	-- 			-- return JSXDEVRuntime:jsxDEV(
	-- 			-- 	RefComponent,
	-- 			-- 	{ ref = "refComponent" },
	-- 			-- 	nil,
	-- 			-- 	false,
	-- 			-- 	{},
	-- 			-- 	{}
	-- 			-- )
	-- 		end
	-- 		ReactNoop.render(React.createElement(Component))
	-- 		jestExpect(function()
	-- 			return jestExpect(Scheduler).toFlushWithoutYielding()
	-- 		end).toErrorDev(
	-- 			'Warning: Component "Component" contains the string ref "refComponent". '
	-- 				.. "Support for string refs will be removed in a future major release. "
	-- 				.. "This case cannot be automatically converted to an arrow function. "
	-- 				.. "We ask you to manually fix this case by using useRef() or createRef() instead. "
	-- 				.. "Learn more about using refs safely here: "
	-- 				.. "https://reactjs.org/link/strict-mode-string-ref"
	-- 		)
	-- 	end)
	-- end
end) ]]
S.Children._467b4e502b3707f381223423d002dfee=Z
local _

local aa={ClassName="ModuleScript",Children={},Properties={}}
aa.Name="ReactElement.roblox.spec"
aa.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react/src/__tests__/ReactElement-test.js

local Packages = script.Parent.Parent.Parent
local ReactElement = require(script.Parent.Parent.ReactElement)
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local isValidElementType = require(Packages.Shared).isValidElementType
local ReactSymbols = require(Packages.Shared).ReactSymbols
local element

describe("creates valid React elements", function()
	it("from strings", function()
		element = ReactElement.createElement("TextLabel")
		jestExpect(element).toBeDefined()
		jestExpect(ReactElement.isValidElement(element)).toEqual(true)
		jestExpect(element["$$typeof"]).toEqual(ReactSymbols.REACT_ELEMENT_TYPE)
		-- isValidElement considers basic ELEMENT_TYPE to be false
		jestExpect(isValidElementType(element)).toBe(false)
	end)

	it("from functions", function()
		element = ReactElement.createElement(function()
			return nil
		end)
		jestExpect(element).toBeDefined()
		jestExpect(ReactElement.isValidElement(element)).toEqual(true)
		-- isValidElement considers basic ELEMENT_TYPE to be false
		jestExpect(isValidElementType(element)).toBe(false)
	end)
end)

describe("keys", function()
	it("should leave number keys as number", function()
		element = ReactElement.createElement("Frame", {
			key = 2,
			Size = UDim2.new(1, 0, 1, 0),
		})

		jestExpect(element.key).toEqual(2)
	end)

	it("should convert table keys to string", function()
		local tableKey = {}
		element = ReactElement.createElement("Frame", {
			key = tableKey,
			Size = UDim2.new(1, 0, 1, 0),
		})

		jestExpect(element.key).toEqual(tostring(tableKey))
	end)

	it("should leave string keys as strings", function()
		element = ReactElement.createElement("Frame", {
			key = "hello",
			Size = UDim2.new(1, 0, 1, 0),
		})

		jestExpect(element.key).toEqual("hello")
	end)

	it("should have element.key == nil if no key is passed", function()
		element = ReactElement.createElement("Frame", {
			Size = UDim2.new(1, 0, 1, 0),
		})

		jestExpect(element.key).toEqual(nil)
	end)
end)

describe("should accept", function()
	it("props", function()
		element = ReactElement.createElement("StringValue", { Value = "Foo" })

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual("Foo")
		jestExpect(element.props.children).never.toBeDefined()
	end)

	it("a child and props", function()
		local child = ReactElement.createElement("IntValue")

		element = ReactElement.createElement("StringValue", { Value = "Foo" }, child)

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual("Foo")
		jestExpect(element.props.children).toBeDefined()
		jestExpect(element.props.children).toEqual(child)
	end)

	it("a child and no props", function()
		local child = ReactElement.createElement("IntValue")

		element = ReactElement.createElement("StringValue", nil, child)

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual(nil)
		jestExpect(element.props.children).toBeDefined()
		jestExpect(element.props.children).toEqual(child)
	end)

	it("multiple children and no props", function()
		local child1 = ReactElement.createElement("IntValue")
		local child2 = ReactElement.createElement("StringValue")

		element = ReactElement.createElement("StringValue", nil, child1, child2)

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual(nil)
		jestExpect(element.props.children).toBeDefined()
		jestExpect(element.props.children).toEqual({ child1, child2 })
	end)

	it("a table of children and no props", function()
		local child1 = ReactElement.createElement("IntValue")
		local child2 = ReactElement.createElement("StringValue")

		element = ReactElement.createElement("StringValue", nil, {
			Child1 = child1,
			Child2 = child2,
		})

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual(nil)
		jestExpect(element.props.children).toBeDefined()
		jestExpect(element.props.children).toEqual({
			Child1 = child1,
			Child2 = child2,
		})
	end)

	it("a false value for a boolean prop", function()
		element = ReactElement.createElement("BoolValue", { Value = false })

		jestExpect(element).toBeDefined()
		jestExpect(element.props.Value).toEqual(false)
	end)
end) ]]
S.Children._4b6df8673e9eddbd82d8be271408d6dd=aa
local ab

local ac={ClassName="ModuleScript",Children={},Properties={}}
ac.Name="ReactElementValidator-internal.spec"
ac.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit

local React
local ReactRoblox
local ReactFeatureFlags
-- ROBLOX deviation: the tests using these are currently SKIPped
local PropTypes = nil
-- ROBLOX deviation: This function is a misnomer even in upstream; here, we
-- just render it into an orphaned root
local ReactTestUtils = {
	renderIntoDocument = function(element)
		local instance = Instance.new("Folder")
		local root = ReactRoblox.createLegacyRoot(instance)
		root:render(element)
		return root
	end,
}

describe("ReactElementValidator", function()
	local ComponentClass

	beforeEach(function()
		jest.resetModules()

		-- PropTypes = require("prop-types")
		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		React = require(script.Parent.Parent)
		ReactRoblox = require(Packages.Dev.ReactRoblox)
		-- ReactTestUtils = require("react-dom/test-utils")
		ComponentClass = React.Component:extend("ComponentClass")
		function ComponentClass:render()
			return React.createElement("Frame")
		end
	end)

	it("warns for keys for arrays of elements in rest args", function()
		jestExpect(function()
			React.createElement(ComponentClass, nil, {
				React.createElement(ComponentClass),
				React.createElement(ComponentClass),
			})
		end).toErrorDev('Each child in a list should have a unique "key" prop.')
	end)

	it("warns for keys for arrays of elements with owner info", function()
		local InnerClass = React.Component:extend("InnerClass")
		function InnerClass:render()
			return React.createElement(ComponentClass, nil, self.props.childSet)
		end

		local ComponentWrapper = React.Component:extend("ComponentWrapper")
		function ComponentWrapper:render()
			return React.createElement(InnerClass, {
				childSet = {
					React.createElement(ComponentClass),
					React.createElement(ComponentClass),
				},
			})
		end

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(ComponentWrapper))
		end).toErrorDev(
			'Each child in a list should have a unique "key" prop.'
				.. "\n\nCheck the render method of `InnerClass`. "
				.. "It was passed a child from ComponentWrapper. "
		)
	end)

	it("warns for keys for arrays with no owner or parent info", function()
		-- ROBLOX deviation: we can't nil out the function's name, so use a real anonymous function
		-- local function Anonymous()
		-- 	return React.createElement("Frame")
		-- end
		-- Object.defineProperty(Anonymous, "name", {value = nil})

		local divs = {
			React.createElement("Frame"),
			React.createElement("Frame"),
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(function()
				return React.createElement("Frame")
			end, nil, divs))
		end).toErrorDev(
			"Warning: Each child in a list should have a unique "
				.. '"key" prop. See https://reactjs.org/link/warning-keys for more information.\n'
				.. "    in Frame (at **)"
		)
	end)

	it("warns for keys for arrays of elements with no owner info", function()
		local divs = {
			React.createElement("Frame"),
			React.createElement("Frame"),
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement("Frame", nil, divs))
		end).toErrorDev(
			"Warning: Each child in a list should have a unique "
				.. '"key" prop.\n\nCheck the top-level render call using <Frame>. See '
				.. "https://reactjs.org/link/warning-keys for more information.\n"
				.. "    in Frame (at **)"
		)
	end)

	it("warns for keys with component stack info", function()
		local function Component()
			return React.createElement("Frame", nil, {
				React.createElement("Frame"),
				React.createElement("Frame"),
			})
		end
		local function Parent(props)
			return React.cloneElement(props.child)
		end
		local function GrandParent()
			return React.createElement(Parent, {
				child = React.createElement(Component),
			})
		end

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(GrandParent))
		end).toErrorDev(
			"Warning: Each child in a list should have a unique "
				.. '"key" prop.\n\nCheck the render method of `Component`. See '
				.. "https://reactjs.org/link/warning-keys for more information.\n"
				.. "    in Frame (at **)\n"
				.. "    in Component (at **)\n"
				.. "    in Parent (at **)\n"
				.. "    in GrandParent (at **)"
		)
	end)

	it("does not warn for keys when passing children down", function()
		local function Wrapper(props)
			return React.createElement(
				"Frame",
				nil,
				props.children,
				React.createElement("Frame")
			)
		end

		-- ROBLOX deviation: Add expectation to make sure we get _no_ errors
		jestExpect(function()
			ReactTestUtils.renderIntoDocument(
				React.createElement(
					Wrapper,
					nil,
					React.createElement("Frame"),
					React.createElement("Frame")
				)
			)
		end).toErrorDev({})
	end)

	-- ROBLOX deviation: This test is unique to roblox; we allow children to
	-- be passed as a table, and use the keys as stable keys for the
	-- equivalent children
	it("does not warn for keys when providing keys via children tables", function()
		-- ROBLOX FIXME: Expect coercion
		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement("Frame", nil, {
				ChildA = React.createElement("Frame"),
				ChildB = React.createElement("Frame"),
			}))
		end).toErrorDev({})
	end)

	-- ROBLOX deviation: no @@iterator in Lua
	xit("warns for keys for iterables of elements in rest args", function()
		local iterable = {
			["@@iterator"] = function()
				local i = 0
				return {
					next = function()
						i = i + 1
						local done = i > 2
						local value
						if not done then
							value = React.createElement(ComponentClass)
						end
						return {
							value = value,
							done = done,
						}
					end,
				}
			end,
		}

		jestExpect(function()
			return React.createElement(ComponentClass, nil, iterable)
		end).toErrorDev('Each child in a list should have a unique "key" prop.')
	end)

	it("does not warns for arrays of elements with keys", function()
		React.createElement(ComponentClass, nil, {
			React.createElement(ComponentClass, { key = "#1" }),
			React.createElement(ComponentClass, { key = "#2" }),
		})
	end)

	-- ROBLOX deviation: no @@iterator in Lua
	xit("does not warns for iterable elements with keys", function()
		local iterable = {
			["@@iterator"] = function()
				local i = 0
				return {
					next = function()
						i = i + 1
						local done = i > 2
						return {
							value = not done and React.createElement(
								ComponentClass,
								{ key = "#" .. i }
							) or nil,
							done = done,
						}
					end,
				}
			end,
		}

		React.createElement(ComponentClass, nil, iterable)
	end)

	it("does not warn when the element is directly in rest args", function()
		React.createElement(
			ComponentClass,
			nil,
			React.createElement(ComponentClass),
			React.createElement(ComponentClass)
		)
	end)

	it("does not warn when the array contains a non-element", function()
		React.createElement(ComponentClass, nil, { {}, {} })
	end)

	-- ROBLOX TODO: implement PropTypes support
	xit("should give context for PropType errors in nested components.", function()
		-- // In this test, we're making sure that if a proptype error is found in a
		-- // component, we give a small hint as to which parent instantiated that
		-- // component as per warnings about key usage in ReactElementValidator.
		local MyComp = React.Component:extend("MyComp")
		function MyComp:render()
			return React.createElement("Frame", nil, "My color is " .. self.props.color)
		end
		MyComp.propTypes = {
			color = PropTypes.string,
		}
		local function ParentComp()
			return React.createElement(MyComp, { color = 123 })
		end

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(ParentComp))
		end).toErrorDev(
			"Warning: Failed prop type: "
				.. "Invalid prop `color` of type `number` supplied to `MyComp`, "
				.. "expected `string`.\n"
				.. "    in MyComp (at **)\n"
				.. "    in ParentComp (at **)"
		)
	end)

	it("gives a helpful error when passing invalid types", function()
		local function Foo() end

		jestExpect(function()
			React.createElement(nil)
			React.createElement(true)
			React.createElement({ x = 17 })
			React.createElement({})
			React.createElement(React.createElement("Frame"))
			React.createElement(React.createElement(Foo))
			React.createElement(React.createElement(React.createContext().Consumer))
			React.createElement({ ["$$typeof"] = "non-react-thing" })
		end).toErrorDev({
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: nil.",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: boolean.",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: table.",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: array. You likely forgot to export your "
				.. "component from the file it's defined in, or you might have mixed up "
				.. "default and named imports.",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: <Frame />. Did you accidentally export a JSX literal "
				.. "or Element instead of a component?",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: <Foo />. Did you accidentally export a JSX literal "
				.. "or Element instead of a component?",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: <Context.Consumer />. Did you accidentally "
				.. "export a JSX literal or Element instead of a component?",
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: table.\n{",
		}, { withoutStack = true })

		-- // Should not log any additional warnings
		React.createElement("Frame")
	end)

	it(
		"includes the owner name when passing null, undefined, boolean, or number",
		function()
			local function ParentComp()
				-- ROBLOX DEVIATION: The test says "null, undefined, boolean, or
				-- number", but uses `null`, which it treats differently from
				-- `undefined`. Here, we're passing a number, which should have
				-- behavior identical to upstream
				return React.createElement(1)
			end

			jestExpect(function()
				jestExpect(function()
					ReactTestUtils.renderIntoDocument(React.createElement(ParentComp))
				end).toThrowError(
					"Element type is invalid: expected a string (for built-in components) "
						.. "or a class/function (for composite components) but got: number."
						.. (
							_G.__DEV__
								and "\n\nCheck the render method of `ParentComp`."
							or ""
						)
				)
			end).toErrorDev(
				"Warning: React.createElement: type is invalid -- expected a string "
					.. "(for built-in components) or a class/function (for composite "
					.. "components) but got: number."
				-- ROBLOX FIXME: Error output differs
				-- "\n\nCheck the render method of `ParentComp`.\n    in ParentComp",
			)
		end
	)

	-- ROBLOX deviation: Regression test for error output issue
	it("includes the owner name of a PureComponent", function()
		local ParentPureComp = React.PureComponent:extend("ParentPureComp")
		function ParentPureComp:render()
			return React.createElement(1)
		end

		jestExpect(function()
			jestExpect(function()
				ReactTestUtils.renderIntoDocument(React.createElement(ParentPureComp))
			end).toThrowError(
				"Element type is invalid: expected a string (for built-in components) "
					.. "or a class/function (for composite components) but got: number."
					.. (
						_G.__DEV__
							and "\n\nCheck the render method of `ParentPureComp`."
						or ""
					)
			)
		end).toErrorDev(
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: number."
			-- ROBLOX FIXME: Error output differs
			-- "\n\nCheck the render method of `ParentPureComp`.\n    in ParentPureComp"
		)
	end)

	-- ROBLOX TODO: implement PropTypes
	it.skip("should check default prop values", function()
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement("Frame", nil, self.props.prop)
		end
		Component.propTypes = {
			prop = PropTypes.string.isRequired,
		}
		Component.defaultProps = { prop = nil }

		jestExpect(function()
			return ReactTestUtils.renderIntoDocument(React.createElement(Component))
		end).toErrorDev(
			"Warning: Failed prop type: The prop `prop` is marked as required in "
				.. "`Component`, but its value is `null`.\n"
				.. "    in Component"
		)
	end)

	-- ROBLOX TODO: implement PropTypes
	it.skip("should not check the default for explicit null", function()
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement("Frame", nil, self.props.prop)
		end
		Component.propTypes = {
			prop = PropTypes.string.isRequired,
		}
		Component.defaultProps = {
			prop = "text",
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(
				React.createElement(Component, { prop = nil })
			)
		end).toErrorDev(
			"Warning: Failed prop type: The prop `prop` is marked as required in "
				.. "`Component`, but its value is `null`.\n"
				.. "    in Component"
		)
	end)

	-- ROBLOX TODO: implement PropTypes
	it.skip("should check declared prop types", function()
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement("Frame", nil, self.props.prop)
		end
		Component.propTypes = {
			prop = PropTypes.string.isRequired,
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(Component))
			ReactTestUtils.renderIntoDocument(
				React.createElement(Component, { prop = 42 })
			)
		end).toErrorDev({
			"Warning: Failed prop type: "
				.. "The prop `prop` is marked as required in `Component`, but its value "
				.. "is `undefined`.\n"
				.. "    in Component",
			"Warning: Failed prop type: "
				.. "Invalid prop `prop` of type `number` supplied to "
				.. "`Component`, expected `string`.\n"
				.. "    in Component",
		})

		-- // Should not error for strings
		ReactTestUtils.renderIntoDocument(React.createElement(Component, {
			prop = "string",
		}))
	end)

	-- ROBLOX TODO: implement PropTypes
	it.skip("should warn if a PropType creator is used as a PropType", function()
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement("Frame", nil, self.props.myProp.value)
		end
		Component.propTypes = {
			myProp = PropTypes.shape,
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(
				React.createElement(Component, { myProp = { value = "hi" } })
			)
		end).toErrorDev(
			"Warning: Component: type specification of prop `myProp` is invalid; "
				.. "the type checker function must return `null` or an `Error` but "
				.. "returned a function. You may have forgotten to pass an argument to "
				.. "the type checker creator (arrayOf, instanceOf, objectOf, oneOf, "
				.. "oneOfType, and shape all require an argument)."
		)
	end)

	-- ROBLOX TODO: implement PropTypes
	it.skip("should warn if component declares PropTypes instead of propTypes", function()
		local MisspelledPropTypesComponent =
			React.Component:extend("MisspelledPropTypesComponent")
		function MisspelledPropTypesComponent:render()
			return React.createElement("Frame", nil, self.props.prop)
		end
		MisspelledPropTypesComponent.PropTypes = {
			prop = PropTypes.string,
		}

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(
				React.createElement(MisspelledPropTypesComponent, { prop = "Hi" })
			)
		end).toErrorDev(
			"Warning: Component MisspelledPropTypesComponent declared `PropTypes` "
				.. "instead of `propTypes`. Did you misspell the property assignment?",
			{ withoutStack = true }
		)
	end)

	it("warns for fragments with illegal attributes", function()
		local Foo = React.Component:extend("Foo")
		function Foo:render()
			-- ROBLOX deviation: Use an actual child element instead of a
			-- text instance, which is unsupported in ReactRoblox
			return React.createElement(
				React.Fragment,
				{ a = 1 },
				React.createElement("Frame")
			)
		end
		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(Foo))
		end).toErrorDev(
			"Invalid prop `a` supplied to `React.Fragment`. React.Fragment "
				.. "can only have `key` and `children` props."
		)
	end)

	if not _G.__EXPERIMENTAL__ then
		-- ROBLOX deviation: createFactory is deprecated in React so it is removed in
		-- the Lua version
		it.skip("should warn when accessing .type on an element factory", function()
			local function TestComponent()
				return React.createElement("Frame")
			end

			local TestFactory

			jestExpect(function()
				TestFactory = React.createFactory(TestComponent)
			end).toWarnDev(
				"Warning: React.createFactory() is deprecated and will be removed in a "
					.. "future major release. Consider using JSX or use React.createElement() "
					.. "directly instead.",
				{ withoutStack = true }
			)
			jestExpect(function()
				return TestFactory.type
			end).toWarnDev(
				"Warning: Factory.type is deprecated. Access the class directly before "
					.. "passing it to createFactory.",
				{ withoutStack = true }
			)

			-- // Warn once, not again
			jestExpect(TestFactory.type).toBe(TestComponent)
		end)
	end

	-- ROBLOX deviation: usage of web browser document global
	it.skip("does not warn when using DOM node as children", function()
		-- local DOMContainer = React.Component:extend("DOMContainer")
		-- function DOMContainer:render()
		-- 	return React.createElement("Frame")
		-- end
		-- function DOMContainer:componentDidMount()
		-- 	ReactDOM.findDOMNode(self).appendChild(self.props.children);
		-- end

		-- local node = document.createElement("Frame")
		-- -- // This shouldn't cause a stack overflow or any other problems (#3883)
		-- ReactTestUtils.renderIntoDocument(
		-- 	React.createElement(DOMContainer, nil, node)
		-- )
	end)

	-- ROBLOX deviation: not applicable in Lua
	it.skip("should not enumerate enumerable numbers (#4776)", function()
		-- Number.prototype['@@iterator'] = function()
		-- 	error("number iterator called")
		-- end
	end)

	it("does not blow up with inlined children", function()
		-- // We don't suggest this since it silences all sorts of warnings, but we
		-- // shouldn't blow up either.

		local child = {
			["$$typeof"] = React.createElement("Frame")["$$typeof"],
			type = "Frame",
			key = nil,
			ref = nil,
			props = {},
			_owner = nil,
		}

		React.createElement("Frame", nil, { child })
	end)

	it("does not blow up on key warning with undefined type", function()
		local Foo = nil

		jestExpect(function()
			React.createElement(Foo, {
				__source = {
					fileName = "fileName.lua",
					lineNumber = 100,
				},
			}, { React.createElement("Frame") })
		end).toErrorDev(
			"Warning: React.createElement: type is invalid -- expected a string "
				.. "(for built-in components) or a class/function (for composite "
				.. "components) but got: nil. You likely forgot to export your "
				.. "component from the file it's defined in, or you might have mixed up "
				.. "default and named imports.\n\nCheck your code at **.",
			{ withoutStack = true }
		)
	end)

	it("does not call lazy initializers eagerly", function()
		local didCall = false
		local Lazy = React.lazy(function()
			didCall = true
			return { andThen = function() end }
		end)
		React.createElement(Lazy)
		jestExpect(didCall).toBe(false)
	end)

	-- ROBLOX deviation: validate extra warning when using table keys as the
	-- keys provided to child elements
	it("warns when keys are provided via both the 'key' prop AND table keys", function()
		local Component = React.Component:extend("Component")
		function Component:render()
			return React.createElement("Frame", nil, {
				a1 = React.createElement("Frame", { key = "a2" }),
				b = React.createElement("Frame", { key = "b" }),
			})
		end

		jestExpect(function()
			ReactTestUtils.renderIntoDocument(React.createElement(Component))
		end).toErrorDev(
			'Child element received a "key" prop ("a2") in addition to a key in '
				.. 'the "children" table of its parent ("a1"). Please provide only '
				.. 'one key definition. When both are present, the "key" prop '
				.. "will take precedence.\n\nCheck the render method of `Component`. "
				.. "See https://reactjs.org/link/warning-keys for more information.\n"
				.. "    in Frame (at **)\n"
				.. "    in Component (at **)"
		)
	end)
end) ]]
S.Children._e350f3b0a12989fb3761ed147851a5d9=ac
local ad

local ae={ClassName="ModuleScript",Children={},Properties={}}
ae.Name="ReactProfiler-internal.spec"
ae.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/ReactProfiler-test.internal.js
local React
local ReactFeatureFlags
local ReactNoop
local Scheduler
local ReactCache
local ReactTestRenderer
local ReactTestRendererAct
local _SchedulerTracing
local AdvanceTime
local _AsyncText
local _ComponentWithPassiveEffect
local _Text
local TextResource
local resourcePromise
local setTimeout
local Set

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

local Promise = require(Packages.Dev.Promise)

local function loadModules(config)
	local enableProfilerTimer = (function()
		if config.enableProfilerTimer ~= nil then
			return config.enableProfilerTimer
		end
		return true
	end)()
	local enableProfilerCommitHooks = (function()
		if config.enableProfilerCommitHooks ~= nil then
			return config.enableProfilerCommitHooks
		end
		return true
	end)()
	local enableSchedulerTracing = (function()
		if config.enableSchedulerTracing ~= nil then
			return config.enableSchedulerTracing
		end
		return true
	end)()
	local replayFailedUnitOfWorkWithInvokeGuardedCallback = (function()
		if config.replayFailedUnitOfWorkWithInvokeGuardedCallback ~= nil then
			return config.replayFailedUnitOfWorkWithInvokeGuardedCallback
		end
		return false
	end)()
	local useNoopRenderer = (function()
		if config.useNoopRenderer ~= nil then
			return config.useNoopRenderer
		end
		return false
	end)()
	ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags

	ReactFeatureFlags.enableProfilerTimer = enableProfilerTimer
	ReactFeatureFlags.enableProfilerCommitHooks = enableProfilerCommitHooks
	ReactFeatureFlags.enableSchedulerTracing = enableSchedulerTracing
	ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback =
		replayFailedUnitOfWorkWithInvokeGuardedCallback

	local LuauPolyfill = require(Packages.LuauPolyfill)
	setTimeout = LuauPolyfill.setTimeout
	Set = LuauPolyfill.Set

	React = require(script.Parent.Parent)
	Scheduler = require(Packages.Dev.Scheduler)
	_SchedulerTracing = Scheduler.tracing
	ReactCache = require(Packages.Dev.ReactCache)

	if useNoopRenderer then
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		ReactTestRenderer = nil
		ReactTestRendererAct = nil
	else
		ReactNoop = nil
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		ReactTestRendererAct = ReactTestRenderer.unstable_concurrentAct
	end

	AdvanceTime = React.Component:extend("AdvanceTime")
	AdvanceTime.defaultProps = {
		byAmount = 10,
		shouldComponentUpdate = true,
	}
	function AdvanceTime:shouldComponentUpdate(nextProps)
		return nextProps.shouldComponentUpdate
	end
	function AdvanceTime:render()
		-- Simulate time passing when self component is rendered
		Scheduler.unstable_advanceTime(self.props.byAmount)
		return self.props.children or nil
	end

	resourcePromise = nil

	TextResource = ReactCache.unstable_createResource(function(args)
		local text, ms = args[1], args[2] or 0
		resourcePromise = Promise.new(function(resolve, reject)
			setTimeout(function()
				Scheduler.unstable_yieldValue(
					string.format("Promise resolved [%s]", tostring(text))
				)
				resolve(text)
			end, ms)
		end)
		return resourcePromise
	end, function(args)
		local text = args[1]
		return text
	end)

	_AsyncText = function(props)
		local ms, text = props.ms, props.text
		local ok, result = pcall(function()
			TextResource.read({ text, ms })
			Scheduler.unstable_yieldValue(string.format("AsyncText [%s]", text))
			return text
		end)
		if not ok then
			local promise = result
			if typeof(promise.andThen) == "function" then
				Scheduler.unstable_yieldValue(string.format("Suspend [%s]", text))
			else
				Scheduler.unstable_yieldValue(string.format("Error [%s]", text))
			end
			error(promise)
		end
	end

	_Text = function(props)
		local text = props.text
		Scheduler.unstable_yieldValue(string.format("Text [%s]", text))
		return text
	end

	_ComponentWithPassiveEffect = function()
		-- Intentionally schedule a passive effect so the onPostCommit hook will be called.
		React.useEffect(function() end)
		return nil
	end
end

-- ROBLOX Test Noise: in upstream, jest setup config makes these tests hide
-- the error boundary warnings they trigger (scripts/jest/setupTests.js:72)
describe("Profiler", function()
	-- ROBLOX deviation: use faketimers instead
	-- local advanceTimeBy
	-- local currentTime

	describe("works in profiling and non-profiling bundles", function()
		for _, enableSchedulerTracing in { true, false } do
			for _, enableProfilerTimer in { true, false } do
				describe("enableSchedulerTracing:" .. (function()
					if enableSchedulerTracing then
						return "enabled"
					end
					return "disabled"
				end)() .. " enableProfilerTimer:" .. (function()
					if enableProfilerTimer then
						return "enabled"
					end
					return "disabled"
				end)() .. "}", function()
					-- ROBLOX deviation START: add condition, otherwise the suite will fail because of no tests
					if _G.__DEV__ and enableProfilerTimer then
						-- ROBLOX deviation END
						beforeEach(function()
							jest.resetModules()

							loadModules({
								enableSchedulerTracing = enableSchedulerTracing,
								enableProfilerTimer = enableProfilerTimer,
								-- ROBLOX TODO: set this explicitly to false until we have the correct HostConfig for the TestRenderer setup
								replayFailedUnitOfWorkWithInvokeGuardedCallback = false,
							})
						end)
						-- ROBLOX deviation START: add condition, otherwise the suite will fail because of no tests
					end
					-- ROBLOX deviation END

					-- This will throw in production too,
					-- But the test is only interested in verifying the DEV error message.
					if _G.__DEV__ and enableProfilerTimer then
						it("should warn if required params are missing", function()
							jestExpect(function()
								ReactTestRenderer.create(
									React.createElement(React.Profiler)
								)
							end).toErrorDev(
								'Profiler must specify an "id" as a prop',
								{
									withoutStack = true,
								}
							)
						end)

						it(
							"should support an empty Profiler (with no children)",
							function()
								jestExpect(function()
									ReactTestRenderer.create(
										React.createElement(React.Profiler, {
											id = "label",
											onRender = jest.fn(),
										})
									)
										:toJSON()
									-- ROBLOX TODO: toJSON needs to work, use toMatchSnapshot
								end).never.toThrow()
							end
						)

						it("should render children", function()
							local FunctionComponent = function(props)
								local label = props.label
								return React.createElement("span", nil, label)
							end
							local renderer = ReactTestRenderer.create(
								React.createElement(
									"div",
									nil,
									React.createElement("span", nil, "outside span"),
									React.createElement(
										React.Profiler,
										{ id = "label", onRender = jest.fn() },
										React.createElement("span", nil, "inside span"),
										React.createElement(FunctionComponent, {
											label = "function component",
										})
									)
								)
							)
							jestExpect(function()
								renderer:toJSON()
							end).never.toThrow()
							-- ROBLOX TODO: toJSON needs to work, use toMatchSnapshot
							--toMatchSnapshot()
						end)

						it("should support nested Profilers", function()
							local FunctionComponent = function(props)
								local label = props.label
								return React.createElement("div", nil, label)
							end
							local ClassComponent =
								React.Component:extend("ClassComponent")
							function ClassComponent:render()
								return React.createElement("block", nil, self.props.label)
							end
							local renderer = ReactTestRenderer.create(
								React.createElement(
									React.Profiler,
									{ id = "outer", onRender = jest.fn() },
									React.createElement(FunctionComponent, {
										label = "outer function component",
									}),
									React.createElement(
										React.Profiler,
										{ id = "inner", onRender = jest.fn() },
										React.createElement(ClassComponent, {
											label = "inner class component",
										}),
										React.createElement("span", nil, "inner span")
									)
								)
							)

							jestExpect(function()
								renderer:toJSON()
							end).never.toThrow()
							-- ROBLOX TODO: implement toJSON, use toMatchSnapshot when its available
							-- .toMatchSnapshot()
						end)
					end
				end)
			end
		end
	end)

	for _, enableSchedulerTracing in { true, false } do
		describe("onRender enableSchedulerTracing:" .. (function()
			if enableSchedulerTracing then
				return "enabled"
			end
			return "disabled"
		end)(), function()
			beforeEach(function()
				jest.resetModules()

				loadModules({
					enableSchedulerTracing = enableSchedulerTracing,
					-- ROBLOX TODO: set this explicitly to false until we have the correct HostConfig for the TestRenderer setup
					replayFailedUnitOfWorkWithInvokeGuardedCallback = false,
				})
			end)

			it("should handle errors thrown", function()
				local callback = jest.fn(function(id)
					if id == "throw" then
						error("expected")
					end
				end)

				local didMount = false
				local ClassComponent = React.Component:extend("ClassComponent")
				function ClassComponent:componentDidMount()
					didMount = true
				end
				function ClassComponent:render()
					return self.props.children
				end

				-- Errors thrown from onRender should not break the commit phase,
				-- Or prevent other lifecycles from being called.
				jestExpect(function()
					ReactTestRenderer.create(
						React.createElement(
							ClassComponent,
							nil,
							React.createElement(
								React.Profiler,
								{ id = "do-not-throw", onRender = callback },
								React.createElement(React.Profiler, {
									id = "throw",
									onRender = callback,
								}, React.createElement("div"))
							)
						)
					)
				end).toThrow("expected")
				jestExpect(didMount).toBe(true)
				jestExpect(callback).toHaveBeenCalledTimes(2)
			end)

			it("is not invoked until the commit phase", function()
				local callback = jest.fn()

				local Yield = function(props)
					local value = props.value
					Scheduler.unstable_yieldValue(value)
					return nil
				end

				ReactTestRenderer.create(
					React.createElement(
						React.Profiler,
						{ id = "test", onRender = callback },
						React.createElement(Yield, { value = "first" }),
						React.createElement(Yield, { value = "last" })
					),
					{
						unstable_isConcurrent = true,
					}
				)

				-- Times are logged until a render is committed.
				jestExpect(Scheduler).toFlushAndYieldThrough({ "first" })
				jestExpect(callback).toHaveBeenCalledTimes(0)
				jestExpect(Scheduler).toFlushAndYield({ "last" })
				jestExpect(callback).toHaveBeenCalledTimes(1)
			end)

			-- skipped translating some tests

			it("does not report work done on a sibling", function()
				local callback = jest.fn()

				local DoesNotUpdate = React.memo(function()
					Scheduler.unstable_advanceTime(10)
					return nil
				end, function()
					return true
				end)

				local updateProfilerSibling

				local function ProfilerSibling()
					local count, setCount = React.useState(0)
					updateProfilerSibling = function()
						setCount(count + 1)
					end
					return nil
				end

				local function App()
					return React.createElement(
						React.Fragment,
						nil,
						React.createElement(React.Profiler, {
							id = "test",
							onRender = callback,
						}, React.createElement(DoesNotUpdate)),
						React.createElement(ProfilerSibling)
					)
				end

				local renderer = ReactTestRenderer.create(React.createElement(App))

				jestExpect(callback).toHaveBeenCalledTimes(1)

				local call = callback.mock.calls[1]

				jestExpect(call).toHaveLength((function()
					if enableSchedulerTracing then
						return 7
					else
						return 6
					end
				end)())
				jestExpect(call[1]).toBe("test")
				jestExpect(call[2]).toBe("mount")
				jestExpect(call[3]).toBe(10) -- actual time
				jestExpect(call[4]).toBe(10) -- base time
				jestExpect(call[5]).toBe(0) -- start time
				jestExpect(call[6]).toBe(10) -- commit time
				jestExpect(call[7]).toEqual((function()
					if enableSchedulerTracing then
						return Set.new()
					else
						return nil
					end
				end)()) -- intersection events

				callback:mockReset()

				Scheduler.unstable_advanceTime(20) -- 10 -> 30

				renderer.update(React.createElement(App))

				-- ROBLOX deviation: we don't support dynamic/gated flags, so hard-code the path
				-- 						if (gate(flags => flags.new)) {
				-- None of the Profiler's subtree was rendered because App bailed out before the Profiler.
				-- So we expect onRender not to be called.
				jestExpect(callback).never.toHaveBeenCalled()
				-- 						} else {
				-- Updating a parent reports a re-render,
				-- since React technically did a little bit of work between the Profiler and the bailed out subtree.
				-- This is not optimal but it's how the old reconciler fork works.
				--   jestExpect(callback).toHaveBeenCalledTimes(1)

				--   call = callback.mock.calls[1]

				--   jestExpect(call).toHaveLength((function()
				-- 	if enableSchedulerTracing then
				-- 		return 7
				-- 	else
				-- 		return 6
				-- 	end
				-- 	end)())
				--   jestExpect(call[1]).toBe('test')
				--   jestExpect(call[2]).toBe('update')
				--   jestExpect(call[3]).toBe(0) -- actual time
				--   jestExpect(call[4]).toBe(10) -- base time
				--   jestExpect(call[5]).toBe(30) -- start time
				--   jestExpect(call[6]).toBe(30) -- commit time
				--   jestExpect(call[7]).toEqual((function()
				-- 	if enableSchedulerTracing then
				-- 		return {}
				-- 	else
				-- 		return nil
				-- 	end
				-- end)()) -- intersection events

				--   callback.mockReset()
				-- }

				Scheduler.unstable_advanceTime(20) -- 30 -> 50

				-- Updating a sibling should not report a re-render.
				ReactTestRendererAct(updateProfilerSibling)

				jestExpect(callback).never.toHaveBeenCalled()
			end)

			it("logs render times for both mount and update", function()
				local callback = jest.fn()

				Scheduler.unstable_advanceTime(5) -- 0 -> 5

				local renderer = ReactTestRenderer.create(
					React.createElement(
						React.Profiler,
						{ id = "test", onRender = callback },
						React.createElement(AdvanceTime)
					)
				)

				jestExpect(callback).toHaveBeenCalledTimes(1)

				local call = callback.mock.calls[1]

				jestExpect(call).toHaveLength((function()
					if enableSchedulerTracing then
						return 7
					else
						return 6
					end
				end)())
				jestExpect(call[1]).toBe("test")
				jestExpect(call[2]).toBe("mount")
				jestExpect(call[3]).toBe(10) -- actual time
				jestExpect(call[4]).toBe(10) -- base time
				jestExpect(call[5]).toBe(5) -- start time
				jestExpect(call[6]).toBe(15) -- commit time
				jestExpect(call[7]).toEqual((function()
					if enableSchedulerTracing then
						return Set.new()
					else
						return nil
					end
				end)()) -- intersection events

				callback.mockReset()

				Scheduler.unstable_advanceTime(20) -- 15 -> 35

				renderer.update(React.createElement(React.Profiler, {
					id = "test",
					onRender = callback,
				}, React.createElement(AdvanceTime)))

				jestExpect(callback).toHaveBeenCalledTimes(1)

				call = callback.mock.calls[1]

				jestExpect(call).toHaveLength((function()
					if enableSchedulerTracing then
						return 7
					else
						return 6
					end
				end)())
				jestExpect(call[1]).toBe("test")
				jestExpect(call[2]).toBe("update")
				jestExpect(call[3]).toBe(10) -- actual time
				jestExpect(call[4]).toBe(10) -- base time
				jestExpect(call[5]).toBe(35) -- start time
				jestExpect(call[6]).toBe(45) -- commit time
				jestExpect(call[7]).toEqual((function()
					if enableSchedulerTracing then
						return Set.new()
					else
						return nil
					end
				end)()) -- intersection events

				callback.mockReset()

				Scheduler.unstable_advanceTime(20) -- 45 -> 65

				renderer.update(React.createElement(React.Profiler, {
					id = "test",
					onRender = callback,
				}, React.createElement(AdvanceTime, { byAmount = 4 })))

				jestExpect(callback).toHaveBeenCalledTimes(1)

				call = callback.mock.calls[1]

				jestExpect(call).toHaveLength((function()
					if enableSchedulerTracing then
						return 7
					else
						return 6
					end
				end)())
				jestExpect(call[1]).toBe("test")
				jestExpect(call[2]).toBe("update")
				jestExpect(call[3]).toBe(4) -- actual time
				jestExpect(call[4]).toBe(4) -- base time
				jestExpect(call[5]).toBe(65) -- start time
				jestExpect(call[6]).toBe(69) -- commit time
				jestExpect(call[7]).toEqual((function()
					if enableSchedulerTracing then
						return Set.new()
					else
						return nil
					end
				end)()) -- intersection events
			end)

			it(
				"includes render times of nested Profilers in their parent times",
				function()
					local callback = jest.fn()

					Scheduler.unstable_advanceTime(5) -- 0 -> 5

					ReactTestRenderer.create(
						React.createElement(
							React.Fragment,
							nil,
							React.createElement(
								React.Profiler,
								{ id = "parent", onRender = callback },
								React.createElement(
									AdvanceTime,
									{ byAmount = 10 },
									React.createElement(
										React.Profiler,
										{ id = "child", onRender = callback },
										React.createElement(
											AdvanceTime,
											{ byAmount = 20 }
										)
									)
								)
							)
						)
					)

					jestExpect(callback).toHaveBeenCalledTimes(2)

					-- Callbacks bubble (reverse order).
					local childCall, parentCall =
						callback.mock.calls[1], callback.mock.calls[2]
					jestExpect(childCall[1]).toBe("child")
					jestExpect(parentCall[1]).toBe("parent")

					-- Parent times should include child times
					jestExpect(childCall[3]).toBe(20) -- actual time
					jestExpect(childCall[4]).toBe(20) -- base time
					jestExpect(childCall[5]).toBe(15) -- start time
					jestExpect(childCall[6]).toBe(35) -- commit time
					jestExpect(parentCall[3]).toBe(30) -- actual time
					jestExpect(parentCall[4]).toBe(30) -- base time
					jestExpect(parentCall[5]).toBe(5) -- start time
					jestExpect(parentCall[6]).toBe(35) -- commit time
				end
			)

			it("traces sibling Profilers separately", function()
				local callback = jest.fn()

				Scheduler.unstable_advanceTime(5) -- 0 -> 5

				ReactTestRenderer.create(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(React.Profiler, {
							id = "first",
							onRender = callback,
						}, React.createElement(AdvanceTime, { byAmount = 20 })),
						React.createElement(React.Profiler, {
							id = "second",
							onRender = callback,
						}, React.createElement(AdvanceTime, { byAmount = 5 }))
					)
				)

				jestExpect(callback).toHaveBeenCalledTimes(2)

				-- Callbacks bubble (reverse order).
				local firstCall, secondCall =
					callback.mock.calls[1], callback.mock.calls[2]
				jestExpect(firstCall[1]).toBe("first")
				jestExpect(secondCall[1]).toBe("second")

				-- Parent times should include child times
				jestExpect(firstCall[3]).toBe(20) -- actual time
				jestExpect(firstCall[4]).toBe(20) -- base time
				jestExpect(firstCall[5]).toBe(5) -- start time
				jestExpect(firstCall[6]).toBe(30) -- commit time
				jestExpect(secondCall[3]).toBe(5) -- actual time
				jestExpect(secondCall[4]).toBe(5) -- base time
				jestExpect(secondCall[5]).toBe(25) -- start time
				jestExpect(secondCall[6]).toBe(30) -- commit time
			end)

			it("does not include time spent outside of profile root", function()
				local callback = jest.fn()

				Scheduler.unstable_advanceTime(5) -- 0 -> 5

				ReactTestRenderer.create(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(AdvanceTime, { byAmount = 20 }),
						React.createElement(React.Profiler, {
							id = "test",
							onRender = callback,
						}, React.createElement(AdvanceTime, { byAmount = 5 })),
						React.createElement(AdvanceTime, { byAmount = 20 })
					)
				)

				jestExpect(callback).toHaveBeenCalledTimes(1)

				-- Callbacks bubble (reverse order).
				local call = callback.mock.calls[1]
				jestExpect(call[1]).toBe("test")
				jestExpect(call[3]).toBe(5) -- actual time
				jestExpect(call[4]).toBe(5) -- base time
				jestExpect(call[5]).toBe(25) -- start time
				jestExpect(call[6]).toBe(50) -- commit time
			end)

			it("is not called when blocked by sCU false", function()
				local callback = jest.fn()

				local instance
				local Updater = React.Component:extend("Updater")
				function Updater:init()
					self.state = {}
				end
				function Updater:render()
					instance = self
					return self.props.children
				end

				local renderer = ReactTestRenderer.create(
					React.createElement(
						React.Profiler,
						{ id = "outer", onRender = callback },
						React.createElement(
							Updater,
							nil,
							React.createElement(
								React.Profiler,
								{ id = "inner", onRender = callback },
								React.createElement("div")
							)
						)
					)
				)

				-- All profile callbacks are called for initial render
				jestExpect(callback).toHaveBeenCalledTimes(2)

				callback:mockReset()

				renderer.unstable_flushSync(function()
					instance:setState({
						count = 1,
					})
				end)

				-- Only call onRender for paths that have re-rendered.
				-- Since the Updater's props didn't change,
				-- React does not re-render its children.
				jestExpect(callback).toHaveBeenCalledTimes(1)
				jestExpect(callback.mock.calls[1][1]).toBe("outer")
			end)

			it(
				"decreases actual time but not base time when sCU prevents an update",
				function()
					local callback = jest.fn()

					Scheduler.unstable_advanceTime(5) -- 0 -> 5

					local renderer = ReactTestRenderer.create(
						React.createElement(
							React.Profiler,
							{ id = "test", onRender = callback },
							React.createElement(
								AdvanceTime,
								{ byAmount = 10 },
								React.createElement(
									AdvanceTime,
									{ byAmount = 13, shouldComponentUpdate = false }
								)
							)
						)
					)

					jestExpect(callback).toHaveBeenCalledTimes(1)

					Scheduler.unstable_advanceTime(30) -- 28 -> 58

					renderer.update(
						React.createElement(
							React.Profiler,
							{ id = "test", onRender = callback },
							React.createElement(
								AdvanceTime,
								{ byAmount = 4 },
								React.createElement(
									AdvanceTime,
									{ byAmount = 7, shouldComponentUpdate = false }
								)
							)
						)
					)

					jestExpect(callback).toHaveBeenCalledTimes(2)

					local mountCall, updateCall =
						callback.mock.calls[1], callback.mock.calls[2]

					jestExpect(mountCall[2]).toBe("mount")
					jestExpect(mountCall[3]).toBe(23) -- actual time
					jestExpect(mountCall[4]).toBe(23) -- base time
					jestExpect(mountCall[5]).toBe(5) -- start time
					jestExpect(mountCall[6]).toBe(28) -- commit time

					jestExpect(updateCall[2]).toBe("update")
					jestExpect(updateCall[3]).toBe(4) -- actual time
					jestExpect(updateCall[4]).toBe(17) -- base time
					jestExpect(updateCall[5]).toBe(58) -- start time
					jestExpect(updateCall[6]).toBe(62) -- commit time
				end
			)

			it("includes time spent in render phase lifecycles", function()
				local WithLifecycles = React.Component:extend("WithLifecycles")
				function WithLifecycles:init()
					self.state = {}
				end
				WithLifecycles.getDerivedStateFromProps = function()
					Scheduler.unstable_advanceTime(3)
					return nil
				end
				function WithLifecycles:shouldComponentUpdate()
					Scheduler.unstable_advanceTime(7)
					return true
				end
				function WithLifecycles:render()
					Scheduler.unstable_advanceTime(5)
					return nil
				end

				local callback = jest.fn()

				Scheduler.unstable_advanceTime(5) -- 0 -> 5

				local renderer = ReactTestRenderer.create(
					React.createElement(
						React.Profiler,
						{ id = "test", onRender = callback },
						React.createElement(WithLifecycles)
					)
				)

				Scheduler.unstable_advanceTime(15) -- 13 -> 28

				renderer.update(
					React.createElement(
						React.Profiler,
						{ id = "test", onRender = callback },
						React.createElement(WithLifecycles)
					)
				)

				jestExpect(callback).toHaveBeenCalledTimes(2)

				local mountCall, updateCall =
					callback.mock.calls[1], callback.mock.calls[2]

				jestExpect(mountCall[2]).toBe("mount")
				jestExpect(mountCall[3]).toBe(8) -- actual time
				jestExpect(mountCall[4]).toBe(8) -- base time
				jestExpect(mountCall[5]).toBe(5) -- start time
				jestExpect(mountCall[6]).toBe(13) -- commit time

				jestExpect(updateCall[2]).toBe("update")
				jestExpect(updateCall[3]).toBe(15) -- actual time
				jestExpect(updateCall[4]).toBe(15) -- base time
				jestExpect(updateCall[5]).toBe(28) -- start time
				jestExpect(updateCall[6]).toBe(43) -- commit time
			end)

			describe("with regard to interruptions", function()
				for _, replayFailedUnitOfWorkWithInvokeGuardedCallback in { true, false } do
					describe(
						"replayFailedUnitOfWorkWithInvokeGuardedCallback "
							.. (function()
								if replayFailedUnitOfWorkWithInvokeGuardedCallback then
									return "enabled"
								end
								return "disabled"
							end)(),
						function()
							beforeEach(function()
								jest.resetModules()

								loadModules({
									replayFailedUnitOfWorkWithInvokeGuardedCallback = replayFailedUnitOfWorkWithInvokeGuardedCallback,
								})
							end)

							it(
								"should accumulate actual time after an error handled by componentDidCatch()",
								function()
									local callback = jest.fn()

									local ThrowsError = function(props)
										local _unused = props.unused
										Scheduler.unstable_advanceTime(3)
										error("expected error")
									end

									local ErrorBoundary =
										React.Component:extend("ErrorBoundary")
									function ErrorBoundary:init()
										self.state = { error_ = nil }
									end
									function ErrorBoundary:componentDidCatch(error_)
										self:setState({ error_ = error_ })
									end
									function ErrorBoundary:render()
										Scheduler.unstable_advanceTime(2)
										return (function()
											if self.state.error_ == nil then
												return self.props.children
											end
											return React.createElement(
												AdvanceTime,
												{ byAmount = 20 }
											)
										end)()
									end

									Scheduler.unstable_advanceTime(5) -- 0 -> 5

									ReactTestRenderer.create(
										React.createElement(
											React.Profiler,
											{ id = "test", onRender = callback },
											React.createElement(
												ErrorBoundary,
												nil,
												React.createElement(
													AdvanceTime,
													{ byAmount = 9 }
												),
												React.createElement(ThrowsError)
											)
										)
									)

									jestExpect(callback).toHaveBeenCalledTimes(2)

									-- Callbacks bubble (reverse order).
									local mountCall, updateCall =
										callback.mock.calls[1], callback.mock.calls[2]

									-- The initial mount only includes the ErrorBoundary (which takes 2)
									-- But it spends time rendering all of the failed subtree also.
									jestExpect(mountCall[2]).toBe("mount")
									-- actual time includes: 2 (ErrorBoundary) + 9 (AdvanceTime) + 3 (ThrowsError)
									-- We don't count the time spent in replaying the failed unit of work (ThrowsError)
									jestExpect(mountCall[3]).toBe(14)
									-- base time includes: 2 (ErrorBoundary)
									-- Since the tree is empty for the initial commit
									jestExpect(mountCall[4]).toBe(2)
									-- start time
									jestExpect(mountCall[5]).toBe(5)
									-- commit time: 5 initially + 14 of work
									-- Add an additional 3 (ThrowsError) if we replayed the failed work
									jestExpect(mountCall[6]).toBe((function()
										if
											_G.__DEV__
											and replayFailedUnitOfWorkWithInvokeGuardedCallback
										then
											return 22
										end
										return 19
									end)())

									-- The update includes the ErrorBoundary and its fallback child
									jestExpect(updateCall[2]).toBe("update")
									-- actual time includes: 2 (ErrorBoundary) + 20 (AdvanceTime)
									jestExpect(updateCall[3]).toBe(22)
									-- base time includes: 2 (ErrorBoundary) + 20 (AdvanceTime)
									jestExpect(updateCall[4]).toBe(22)
									-- start time
									jestExpect(updateCall[5]).toBe((function()
										if
											_G.__DEV__
											and replayFailedUnitOfWorkWithInvokeGuardedCallback
										then
											return 22
										end
										return 19
									end)())

									-- commit time: 19 (startTime) + 2 (ErrorBoundary) + 20 (AdvanceTime)
									-- Add an additional 3 (ThrowsError) if we replayed the failed work
									jestExpect(updateCall[6]).toBe((function()
										if
											_G.__DEV__
											and replayFailedUnitOfWorkWithInvokeGuardedCallback
										then
											return 44
										end
										return 41
									end)())
								end
							)

							it(
								"should accumulate actual time after an error handled by getDerivedStateFromError()",
								function()
									local callback = jest.fn()

									local ThrowsError = function(props)
										local _unused = props.unused
										Scheduler.unstable_advanceTime(10)
										error("expected error")
									end

									local ErrorBoundary =
										React.Component:extend("ErrorBoundary")
									function ErrorBoundary:init()
										self.state = { error_ = nil }
									end
									function ErrorBoundary.getDerivedStateFromError(
										error_
									)
										return { error_ = error_ }
									end
									function ErrorBoundary:render()
										Scheduler.unstable_advanceTime(2)
										return (function()
											if self.state.error_ == nil then
												return self.props.children
											end
											return React.createElement(
												AdvanceTime,
												{ byAmount = 20 }
											)
										end)()
									end

									Scheduler.unstable_advanceTime(5) -- 0 -> 5

									ReactTestRenderer.create(
										React.createElement(
											React.Profiler,
											{ id = "test", onRender = callback },
											React.createElement(
												ErrorBoundary,
												nil,
												React.createElement(
													AdvanceTime,
													{ byAmount = 5 }
												),
												React.createElement(ThrowsError)
											)
										)
									)

									jestExpect(callback).toHaveBeenCalledTimes(1)

									-- Callbacks bubble (reverse order).
									local mountCall = callback.mock.calls[1]

									-- The initial mount includes the ErrorBoundary's error state,
									-- But it also spends actual time rendering UI that fails and isn't included.
									jestExpect(mountCall[2]).toBe("mount")
									-- actual time includes: 2 (ErrorBoundary) + 5 (AdvanceTime) + 10 (ThrowsError)
									-- Then the re-render: 2 (ErrorBoundary) + 20 (AdvanceTime)
									-- We don't count the time spent in replaying the failed unit of work (ThrowsError)
									jestExpect(mountCall[3]).toBe(39)
									-- base time includes: 2 (ErrorBoundary) + 20 (AdvanceTime)
									jestExpect(mountCall[4]).toBe(22)
									-- start time
									jestExpect(mountCall[5]).toBe(5)
									-- commit time
									jestExpect(mountCall[6]).toBe((function()
										if
											_G.__DEV__
											and replayFailedUnitOfWorkWithInvokeGuardedCallback
										then
											return 54
										end
										return 44
									end)())
								end
							)

							it(
								'should reset the fiber stack correct after a "complete" phase error',
								function()
									jest.resetModules()

									loadModules({
										useNoopRenderer = true,
										replayFailedUnitOfWorkWithInvokeGuardedCallback = replayFailedUnitOfWorkWithInvokeGuardedCallback,
									})

									-- Simulate a renderer error during the "complete" phase.
									-- This mimics behavior like React Native's View/Text nesting validation.
									ReactNoop.render(
										React.createElement(
											React.Profiler,
											{ id = "profiler", onRender = jest.fn() },
											React.createElement(
												"errorInCompletePhase",
												nil,
												"hi"
											)
										)
									)
									jestExpect(Scheduler).toFlushAndThrow(
										"Error in host config."
									)

									-- A similar case we've seen caused by an invariant in ReactDOM.
									-- It didn't reproduce without a host component inside.
									ReactNoop.render(
										React.createElement(
											React.Profiler,
											{ id = "profiler", onRender = jest.fn() },
											React.createElement(
												"errorInCompletePhase",
												nil,
												React.createElement("span", nil, "hi")
											)
										)
									)
									jestExpect(Scheduler).toFlushAndThrow(
										"Error in host config."
									)

									-- So long as the profiler timer's fiber stack is reset correctly,
									-- Subsequent renders should not error.
									ReactNoop.render(
										React.createElement(
											React.Profiler,
											{ id = "profiler", onRender = jest.fn() },
											React.createElement("span", nil, "hi")
										)
									)
									jestExpect(Scheduler).toFlushWithoutYielding()
								end
							)
						end
					)
				end
			end)
		end)
	end
end) ]]
S.Children._5761ed950c400f23b8813ba9385d30d2=ae
local af

local ag={ClassName="ModuleScript",Children={},Properties={}}
ag.Name="ReactProfilerDevToolsIntegration-internal.spec"
ag.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/ReactProfilerDevToolsIntegration-test.internal.js
local Packages = script.Parent.Parent.Parent
local React
local Scheduler
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
local JestGlobals = require(Packages.Dev.JestGlobals)
local describe = JestGlobals.describe

describe("ReactProfiler DevTools integration", function()
	local jestExpect = JestGlobals.expect
	local jest = JestGlobals.jest
	local it = JestGlobals.it
	local beforeEach = JestGlobals.beforeEach
	local afterEach = JestGlobals.afterEach
	local ReactFeatureFlags
	local ReactTestRenderer
	local SchedulerTracing
	local AdvanceTime
	local hook
	local originalDevtoolsState

	beforeEach(function()
		hook = {
			inject = function() end,
			onCommitFiberRoot = jest.fn(function(rendererId, root) end),
			onCommitFiberUnmount = function() end,
			supportsFiber = true,
		}
		originalDevtoolsState = _G.__REACT_DEVTOOLS_GLOBAL_HOOK__
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook

		jest.resetModules()

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.enableProfilerTimer = true
		ReactFeatureFlags.enableSchedulerTracing = true
		Scheduler = require(Packages.Dev.Scheduler)
		-- ROBLOX deviation: import tracing from top-level Scheduler export to avoid direct file access
		SchedulerTracing = Scheduler.tracing
		React = require(Packages.React)
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)

		AdvanceTime = React.Component:extend("AdvanceTime")
		AdvanceTime.defaultProps = {
			byAmount = 10,
			shouldComponentUpdate = true,
		}
		function AdvanceTime:shouldComponentUpdate(nextProps)
			return nextProps.shouldComponentUpdate
		end
		function AdvanceTime:render()
			-- Simulate time passing when this component is rendered
			Scheduler.unstable_advanceTime(self.props.byAmount)
			return self.props.children or nil
		end
	end)

	afterEach(function()
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = originalDevtoolsState
	end)

	it("should auto-Profile all fibers if the DevTools hook is detected", function()
		-- ROBLOX deviation: hoist declaration so the value is captured correctly
		local onRender = jest.fn(function() end)
		local App = function(props)
			local multiplier = props.multiplier

			Scheduler.unstable_advanceTime(2)

			return React.createElement(
				React.Profiler,
				{
					id = "Profiler",
					onRender = onRender,
				},
				React.createElement(AdvanceTime, {
					byAmount = 3 * multiplier,
					shouldComponentUpdate = true,
				}),
				React.createElement(AdvanceTime, {
					byAmount = 7 * multiplier,
					shouldComponentUpdate = false,
				})
			)
		end

		local rendered =
			ReactTestRenderer.create(React.createElement(App, { multiplier = 1 }))

		jestExpect(hook.onCommitFiberRoot).toHaveBeenCalledTimes(1)

		-- Measure observable timing using the Profiler component.
		-- The time spent in App (above the Profiler) won't be included in the durations,
		-- But needs to be accounted for in the offset times.
		jestExpect(onRender).toHaveBeenCalledTimes(1)
		jestExpect(onRender).toHaveBeenCalledWith(
			"Profiler",
			"mount",
			10,
			10,
			2,
			12,
			Set.new()
		)
		onRender.mockClear()

		-- Measure unobservable timing required by the DevTools profiler.
		-- At this point, the base time should include both:
		-- The time 2ms in the App component itself, and
		-- The 10ms spend in the Profiler sub-tree beneath.
		jestExpect(rendered.root:findByType(App):_currentFiber().treeBaseDuration).toBe(
			12
		)

		rendered.update(React.createElement(App, { multiplier = 2 }))

		-- Measure observable timing using the Profiler component.
		-- The time spent in App (above the Profiler) won't be included in the durations,
		-- But needs to be accounted for in the offset times.
		jestExpect(onRender).toHaveBeenCalledTimes(1)
		jestExpect(onRender).toHaveBeenCalledWith(
			"Profiler",
			"update",
			6,
			13,
			14,
			20,
			Set.new()
		)

		-- Measure unobservable timing required by the DevTools profiler.
		-- At this point, the base time should include both:
		-- The initial 9ms for the components that do not re-render, and
		-- The updated 6ms for the component that does.
		jestExpect(rendered.root:findByType(App):_currentFiber().treeBaseDuration).toBe(
			15
		)
	end)

	it(
		"should reset the fiber stack correctly after an error when profiling host roots",
		function()
			Scheduler.unstable_advanceTime(20)

			local rendered = ReactTestRenderer.create(
				React.createElement(
					"div",
					nil,
					React.createElement(AdvanceTime, { byAmount = 2 })
				)
			)

			Scheduler.unstable_advanceTime(20)

			jestExpect(function()
				rendered.update(React.createElement("div", {
					ref = "this-will-cause-an-error",
				}, React.createElement(AdvanceTime, { byAmount = 3 })))
			end).toThrow()

			Scheduler.unstable_advanceTime(20)

			-- But this should render correctly, if the profiler's fiber stack has been reset.
			rendered.update(
				React.createElement(
					"div",
					nil,
					React.createElement(AdvanceTime, { byAmount = 7 })
				)
			)

			-- Measure unobservable timing required by the DevTools profiler.
			-- At this point, the base time should include only the most recent (not failed) render.
			-- It should not include time spent on the initial render,
			-- Or time that elapsed between any of the above renders.
			jestExpect(rendered.root:findByType("div"):_currentFiber().treeBaseDuration).toBe(
				7
			)
		end
	)

	it(
		"should store traced interactions on the HostNode so DevTools can access them",
		function()
			-- Render without an interaction
			local rendered = ReactTestRenderer.create(React.createElement("div"))

			local root = rendered.root:_currentFiber().return_
			jestExpect(root.stateNode.memoizedInteractions).toContainNoInteractions()

			Scheduler.unstable_advanceTime(10)

			local eventTime = Scheduler.unstable_now()

			-- Render with an interaction
			SchedulerTracing.unstable_trace("some event", eventTime, function()
				rendered.update(React.createElement("div"))
			end)

			jestExpect(root.stateNode.memoizedInteractions).toMatchInteractions({
				{
					name = "some event",
					timestamp = eventTime,
				},
			})
		end
	)

	it("regression test: #17159", function()
		local function Text(props)
			local text = props.text

			Scheduler.unstable_yieldValue(text)

			return text
		end

		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })

		-- Commit something
		root.update(React.createElement(Text, {
			text = "A",
		}))
		jestExpect(Scheduler).toFlushAndYield({
			"A",
		})
		jestExpect(root).toMatchRenderedOutput("A")

		-- Advance time by many seconds, larger than the default expiration time
		-- for updates.
		Scheduler.unstable_advanceTime(10000)
		root.update(React.createElement(Text, {
			text = "B",
		}))

		-- Update B should not instantly expire.
		jestExpect(Scheduler).toFlushExpired({})
		jestExpect(Scheduler).toFlushAndYield({
			"B",
		})
		jestExpect(root).toMatchRenderedOutput("B")
	end)
end) ]]
S.Children._e717827804d79be1150c8719d9caa462=ag
local ah

local ai={ClassName="ModuleScript",Children={},Properties={}}
ai.Name="ReactStrictMode.spec"
ai.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react/src/__tests__/ReactStrictMode-test.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--!strict

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
-- local ReactDOM
-- local ReactDOMServer
local Scheduler
-- local PropTypes
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit

-- ROBLOX TODO: split non-DOM test into separate file, make upstream PR for this division

local jestExpect = JestGlobals.expect

describe("ReactStrictMode", function()
	beforeEach(function()
		jest.resetModules()

		-- ROBLOX deviation: workaround because our flag is currently always set to false
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = true
		React = require(script.Parent.Parent)

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
	end)
	-- ROBLOX TODO: Untranslated ReactDOMInvalidARIAHook file throws the error this test checks
	-- xit('should appear in the client component stack', function()
	--     local function Foo()
	--         return React.createElement('div', {
	--             ariaTypo = '',
	--         })
	--     end

	--     jestExpect(function()
	--         -- ROBLOX deviation: use ReactNoop to render instead of ReactDOM
	--         ReactNoop.render(React.createElement(React.StrictMode, nil, React.createElement(Foo)))
	--     end).toErrorDev('Invalid ARIA attribute `ariaTypo`. ' .. 'ARIA attributes follow the pattern aria-* and must be lowercase.\n' .. '    in div (at **)\n' .. '    in Foo (at **)')
	-- end)
	-- ROBLOX TODO: Untranslated ReactDOMInvalidARIAHook file throws the error this test checks
	-- xit('should appear in the SSR component stack', function()
	--     local function Foo()
	--         return React.createElement('div', {
	--             ariaTypo = '',
	--         })
	--     end

	--     jestExpect(function()
	--         -- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOMServer.renderToString
	--         ReactNoop.render(React.createElement(React.StrictMode, nil, React.createElement(Foo)))
	--     end).toErrorDev('Invalid ARIA attribute `ariaTypo`. ' .. 'ARIA attributes follow the pattern aria-* and must be lowercase.\n' .. '    in div (at **)\n' .. '    in Foo (at **)')
	-- end)
	it("should invoke precommit lifecycle methods twice", function()
		local log = {}
		local shouldComponentUpdate = false
		local ClassComponent = React.Component:extend("ClassComponent")

		function ClassComponent.getDerivedStateFromProps()
			table.insert(log, "getDerivedStateFromProps")

			return nil
		end
		function ClassComponent:init()
			-- ROBLOX deviation: silence analyze with explicit state
			self.state = {}
			table.insert(log, "constructor")
		end
		function ClassComponent:componentDidMount()
			table.insert(log, "componentDidMount")
		end
		function ClassComponent:componentDidUpdate()
			table.insert(log, "componentDidUpdate")
		end
		function ClassComponent:componentWillUnmount()
			table.insert(log, "componentWillUnmount")
		end
		function ClassComponent:shouldComponentUpdate()
			table.insert(log, "shouldComponentUpdate")

			return shouldComponentUpdate
		end
		function ClassComponent:render()
			table.insert(log, "render")

			return nil
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					React.StrictMode,
					nil,
					React.createElement(ClassComponent)
				)
			)
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"constructor",
				"constructor",
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"render",
				"render",
				"componentDidMount",
			})
		else
			jestExpect(log).toEqual({
				"constructor",
				"getDerivedStateFromProps",
				"render",
				"componentDidMount",
			})
		end

		log = {}
		shouldComponentUpdate = true

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					React.StrictMode,
					nil,
					React.createElement(ClassComponent)
				)
			)
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"shouldComponentUpdate",
				"render",
				"render",
				"componentDidUpdate",
			})
		else
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"render",
				"componentDidUpdate",
			})
		end

		log = {}
		shouldComponentUpdate = false

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					React.StrictMode,
					nil,
					React.createElement(ClassComponent)
				)
			)
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"shouldComponentUpdate",
			})
		else
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
			})
		end
	end)
	it("should invoke setState callbacks twice", function()
		local instance
		local ClassComponent = React.Component:extend("ClassComponent")

		function ClassComponent:init()
			self.state = { count = 1 }
		end
		function ClassComponent:render()
			instance = self
			return nil
		end

		local setStateCount = 0

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					React.StrictMode,
					nil,
					React.createElement(ClassComponent)
				)
			)
		end)

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM, needs flushSync
		ReactNoop.flushSync(function()
			instance:setState(function(state: { count: number })
				setStateCount = setStateCount + 1
				return {
					count = state.count + 1,
				}
			end)
		end)
		-- Callback should be invoked twice in DEV
		jestExpect(setStateCount).toEqual((function()
			if _G.__DEV__ then
				return 2
			end

			return 1
		end)())
		-- But each time `state` should be the previous value
		jestExpect(instance.state.count).toEqual(2)
	end)
	it("should invoke precommit lifecycle methods twice in DEV", function()
		local StrictMode = React.StrictMode
		local log = {}
		local shouldComponentUpdate = false

		local ClassComponent = React.Component:extend("ClassComponent")

		function ClassComponent:init(props)
			-- ROBLOX deviation: silence analyze with explicit state
			self.state = {}
			table.insert(log, "constructor")
		end
		function ClassComponent.getDerivedStateFromProps()
			table.insert(log, "getDerivedStateFromProps")
			return nil
		end
		function ClassComponent:componentDidMount()
			table.insert(log, "componentDidMount")
		end
		function ClassComponent:componentDidUpdate()
			table.insert(log, "componentDidUpdate")
		end
		function ClassComponent:componentWillUnmount()
			table.insert(log, "componentWillUnmount")
		end
		function ClassComponent:shouldComponentUpdate()
			table.insert(log, "shouldComponentUpdate")

			return shouldComponentUpdate
		end
		function ClassComponent:render()
			table.insert(log, "render")

			return nil
		end

		local function Root()
			return React.createElement(
				StrictMode,
				nil,
				React.createElement(ClassComponent)
			)
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Root))
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"constructor",
				"constructor",
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"render",
				"render",
				"componentDidMount",
			})
		else
			jestExpect(log).toEqual({
				"constructor",
				"getDerivedStateFromProps",
				"render",
				"componentDidMount",
			})
		end

		log = {}
		shouldComponentUpdate = true

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Root))
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"shouldComponentUpdate",
				"render",
				"render",
				"componentDidUpdate",
			})
		else
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"render",
				"componentDidUpdate",
			})
		end

		log = {}
		shouldComponentUpdate = false

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Root))
		end)

		if _G.__DEV__ then
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
				"shouldComponentUpdate",
			})
		else
			jestExpect(log).toEqual({
				"getDerivedStateFromProps",
				"shouldComponentUpdate",
			})
		end
	end)
	it("should invoke setState callbacks twice in DEV", function()
		local StrictMode = React.StrictMode
		local instance
		local ClassComponent = React.Component:extend("ClassComponent")

		function ClassComponent:init()
			self.state = {
				count = 1,
			}
		end

		function ClassComponent:render()
			instance = self

			return nil
		end

		local setStateCount = 0

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(StrictMode, nil, React.createElement(ClassComponent))
			)
		end)

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop.flushSync(function()
			instance:setState(function(state: { count: number })
				setStateCount = setStateCount + 1

				return {
					count = state.count + 1,
				}
			end)
		end)
		-- Callback should be invoked twice (in DEV)
		jestExpect(setStateCount).toEqual((function()
			if _G.__DEV__ then
				return 2
			end

			return 1
		end)())
		-- But each time `state` should be the previous value
		jestExpect(instance.state.count).toEqual(2)
	end)
end)
describe("Concurrent Mode", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
	end)
	it(
		"should warn about unsafe legacy lifecycle methods anywhere in the tree",
		function()
			local function Wrapper(props)
				local children = props.children

				return React.createElement("div", nil, children)
			end

			local Foo = React.Component:extend("Foo")

			function Foo:UNSAFE_componentWillReceiveProps() end
			function Foo:render()
				return nil
			end

			local Bar = React.Component:extend("Bar")

			function Bar:UNSAFE_componentWillReceiveProps() end
			function Bar:render()
				return nil
			end

			local AsyncRoot = React.Component:extend("AsyncRoot")

			function AsyncRoot:UNSAFE_componentWillMount() end
			function AsyncRoot:UNSAFE_componentWillUpdate() end
			function AsyncRoot:render()
				return React.createElement(
					"div",
					nil,
					React.createElement(Wrapper, nil, React.createElement(Foo)),
					React.createElement(
						"div",
						nil,
						React.createElement(Bar),
						React.createElement(Foo)
					)
				)
			end

			-- ROBLOX deviation: using ReactNoop in place of ReactDOM
			local root = ReactNoop.createRoot()

			root.render(React.createElement(AsyncRoot))
			jestExpect(function()
				return Scheduler.unstable_flushAll()
			end).toErrorDev({

				\[\[Warning: Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: AsyncRoot\]\],

				\[\[Warning: Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: Bar, Foo\]\],

				\[\[Warning: Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: AsyncRoot\]\],
			}, { withoutStack = true })
			root.render(React.createElement(AsyncRoot))
			Scheduler.unstable_flushAll()
		end
	)
	it("should coalesce warnings by lifecycle name", function()
		local Child = React.Component:extend("Child")
		function Child:UNSAFE_componentWillReceiveProps() end
		function Child:render()
			return nil
		end

		local Parent = React.Component:extend("Parent")
		function Parent:componentWillMount() end
		function Parent:componentWillUpdate() end
		function Parent:componentWillReceiveProps() end
		function Parent:render()
			return React.createElement(Child)
		end

		local AsyncRoot = React.Component:extend("AsyncRoot")
		function AsyncRoot:UNSAFE_componentWillMount() end
		function AsyncRoot:UNSAFE_componentWillUpdate() end
		function AsyncRoot:render()
			return React.createElement(Parent)
		end

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		local root = ReactNoop.createRoot()

		root.render(React.createElement(AsyncRoot))
		jestExpect(function()
			jestExpect(function()
				return Scheduler.unstable_flushAll()
			end).toErrorDev({
				-- ROBLOX deviation: below warnings all remove "To rename all deprecated lifecycles..." line which are unique instructions for Node.js

				\[\[Warning: Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: AsyncRoot\]\],

				\[\[Warning: Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: Child\]\],

				\[\[Warning: Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: AsyncRoot\]\],
			}, { withoutStack = true })
		end).toWarnDev({

			\[\[Warning: componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: Parent\]\],

			\[\[Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: Parent\]\],

			\[\[Warning: componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: Parent\]\],
		}, { withoutStack = true })
		root.render(React.createElement(AsyncRoot))
		Scheduler.unstable_flushAll()
	end)
	it("should warn about components not present during the initial render", function()
		local Foo = React.Component:extend("Foo")

		function Foo:UNSAFE_componentWillMount() end
		function Foo:render()
			return nil
		end

		local Bar = React.Component:extend("Bar")

		function Bar:UNSAFE_componentWillMount() end
		function Bar:render()
			return nil
		end

		local AsyncRoot = React.Component:extend("AsyncRoot")

		function AsyncRoot:render()
			return (function()
				if self.props.foo then
					return React.createElement(Foo)
				end

				return React.createElement(Bar)
			end)()
		end

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		local root = ReactNoop.createRoot()

		root.render(React.createElement(AsyncRoot, { foo = true }))
		jestExpect(function()
			return Scheduler.unstable_flushAll()
		end).toErrorDev(
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			{ withoutStack = true }
		)

		root.render(React.createElement(AsyncRoot, { foo = false }))
		jestExpect(function()
			return Scheduler.unstable_flushAll()
		end).toErrorDev(
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			{ withoutStack = true }
		)

		root.render(React.createElement(AsyncRoot, { foo = true }))
		Scheduler.unstable_flushAll()

		root.render(React.createElement(AsyncRoot, { foo = false }))
		Scheduler.unstable_flushAll()
	end)
	it('should also warn inside of "strict" mode trees', function()
		local StrictMode = React.StrictMode

		local Foo = React.Component:extend("Foo")
		function Foo:UNSAFE_componentWillReceiveProps() end
		function Foo:render()
			return nil
		end

		local Bar = React.Component:extend("Bar")
		function Bar:UNSAFE_componentWillReceiveProps() end
		function Bar:render()
			return nil
		end

		local function Wrapper(props)
			return React.createElement(
				"div",
				nil,
				React.createElement(Bar),
				React.createElement(Foo)
			)
		end

		local SyncRoot = React.Component:extend("SyncRoot")
		function SyncRoot:UNSAFE_componentWillMount() end
		function SyncRoot:UNSAFE_componentWillUpdate() end
		function SyncRoot:UNSAFE_componentWillReceiveProps() end
		function SyncRoot:render()
			return React.createElement(StrictMode, nil, React.createElement(Wrapper))
		end

		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		jestExpect(function()
			return root.render(React.createElement(SyncRoot))
		end).toErrorDev(
			"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
			{ withoutStack = true }
		)

		-- Dedupe
		root.render(React.createElement(SyncRoot))
	end)
end)
describe("symbol checks", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
	end)
	it("should switch from StrictMode to a Fragment and reset state", function()
		local Fragment, StrictMode = React.Fragment, React.StrictMode

		local ChildComponent = React.Component:extend("ChildComponent")

		function ChildComponent:init()
			self.state = {
				count = 0,
			}
		end

		function ChildComponent.getDerivedStateFromProps(nextProps, prevState)
			return {
				count = prevState.count + 1,
			}
		end
		function ChildComponent:render()
			return string.format("count:%s", self.state.count)
		end

		local function ParentComponent(props)
			local useFragment = props.useFragment

			return (function()
				if useFragment then
					return React.createElement(
						Fragment,
						nil,
						React.createElement(ChildComponent)
					)
				end

				return React.createElement(
					StrictMode,
					nil,
					React.createElement(ChildComponent)
				)
			end)()
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(ParentComponent, { useFragment = false })
			)
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:1")

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(ParentComponent, { useFragment = true }))
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:1")
	end)
	it("should switch from a Fragment to StrictMode and reset state", function()
		local Fragment, StrictMode = React.Fragment, React.StrictMode

		local ChildComponent = React.Component:extend("ChildComponent")

		function ChildComponent:init()
			self.state = {
				count = 0,
			}
		end
		function ChildComponent.getDerivedStateFromProps(nextProps, prevState)
			return {
				count = prevState.count + 1,
			}
		end
		function ChildComponent:render()
			return string.format("count:%s", self.state.count)
		end

		local function ParentComponent(props)
			local useFragment = props.useFragment

			return (function()
				if useFragment then
					return React.createElement(
						Fragment,
						nil,
						React.createElement(ChildComponent)
					)
				end

				return React.createElement(
					StrictMode,
					nil,
					React.createElement(ChildComponent)
				)
			end)()
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(ParentComponent, { useFragment = false })
			)
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:1")

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(ParentComponent, { useFragment = true }))
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:1")
	end)
	it("should update with StrictMode without losing state", function()
		local StrictMode = React.StrictMode

		local ChildComponent = React.Component:extend("ChildComponent")

		function ChildComponent:init()
			self.state = {
				count = 0,
			}
		end
		function ChildComponent.getDerivedStateFromProps(nextProps, prevState)
			return {
				count = prevState.count + 1,
			}
		end
		function ChildComponent:render()
			return string.format("count:%s", self.state.count)
		end

		local function ParentComponent()
			return React.createElement(
				StrictMode,
				nil,
				React.createElement(ChildComponent)
			)
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(ParentComponent))
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:1")

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(ParentComponent))
		end)
		jestExpect(ReactNoop.getChildren()[1].text).toEqual("count:2")
	end)
end)
-- ROBLOX deviation START: we removed support for string refs, so skip test
describe("string refs", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
	end)

	xit("should warn within a strict tree", function()
		-- local StrictMode = React.StrictMode
		-- local OuterComponent = React.Component:extend("OuterComponent")

		-- local InnerComponent = React.Component:extend("InnerComponent")

		-- function InnerComponent:render()
		--     return nil
		-- end

		-- function OuterComponent:render()
		--     return React.createElement(StrictMode, nil, React.createElement(InnerComponent, {
		--         ref = 'somestring',
		--     }))
		-- end

		-- jestExpect(function()
		--     -- ROBLOX deviation: using ReactNoop in place of ReactDOM
		--     ReactNoop.act(function()
		--         ReactNoop.render(React.createElement(OuterComponent))
		--     end)
		-- end).toErrorDev(
		--     'Warning: A string ref, "somestring", has been found within a strict mode tree. ' ..
		--         'String refs are a source of potential bugs and should be avoided. ' ..
		--         'We recommend using useRef() or createRef() instead. ' ..
		--         'Learn more about using refs safely here: ' ..
		--         'https://reactjs.org/link/strict-mode-string-ref\n' ..
		--         '    in OuterComponent (at **)'
		-- )

		-- -- Dedup
		-- -- ROBLOX deviation: using ReactNoop in place of ReactDOM
		-- ReactNoop.act(function()
		--     ReactNoop.render(React.createElement(OuterComponent))
		-- end)
	end)

	xit("should warn within a strict tree 2", function()
		-- local StrictMode = React.StrictMode

		-- local MiddleComponent = React.Component:extend("MiddleComponent")

		-- function MiddleComponent:render()
		--     return nil
		-- end

		-- local InnerComponent = React.Component:extend("InnerComponent")

		-- function InnerComponent:render()
		--     return React.createElement(MiddleComponent, {
		--         ref = 'somestring',
		--     })
		-- end

		-- local OuterComponent = React.Component:extend("OuterComponent")

		-- function OuterComponent:render()
		--     return React.createElement(StrictMode, nil, React.createElement(InnerComponent))
		-- end

		-- jestExpect(function()
		--     -- ROBLOX deviation: using ReactNoop in place of ReactDOM
		--     ReactNoop.act(function()
		--         ReactNoop.render(React.createElement(OuterComponent))
		--     end)
		-- end).toErrorDev(
		--     'Warning: A string ref, "somestring", has been found within a strict mode tree. ' ..
		--         'String refs are a source of potential bugs and should be avoided. ' ..
		--         'We recommend using useRef() or createRef() instead. ' ..
		--         'Learn more about using refs safely here: ' ..
		--         'https://reactjs.org/link/strict-mode-string-ref\n' ..
		--         '    in InnerComponent (at **)\n' ..
		--         '    in OuterComponent (at **)'
		-- )
		-- -- Dedup
		-- -- ROBLOX deviation: using ReactNoop in place of ReactDOM
		-- ReactNoop.act(function()
		--     ReactNoop.render(React.createElement(OuterComponent))
		-- end)
	end)
end)
-- ROBLOX deviation END
describe("context legacy", function()
	beforeEach(function()
		jest.resetModules()
		React = require(script.Parent.Parent)
		-- ROBLOX deviation: using ReactNoop in place of ReactDOM
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
		-- PropTypes = require('prop-types')
	end)
	-- ROBLOX TODO: Proptypes
	xit("should warn if the legacy context API have been used in strict mode", function()

		--     local function FunctionalLegacyContextConsumer()
		--         return nil
		--     end

		--     local LegacyContextConsumer = React.Component:extend("LegacyContextConsumer")

		--     function LegacyContextConsumer:render()
		--         return nil
		--     end

		--     local StrictMode = React.StrictMode

		--     LegacyContextConsumer.contextTypes = {
		--         color = PropTypes.string,
		--     }
		--     FunctionalLegacyContextConsumer.contextTypes = {
		--         color = PropTypes.string,
		--     }

		--     local LegacyContextProvider = React.Component:extend("LegacyContextProvider")

		--     function LegacyContextProvider:getChildContext()
		--         return{
		--             color = 'purple',
		--         }
		--     end
		--     function LegacyContextProvider:render()
		--         return React.createElement('div', nil, React.createElement(LegacyContextConsumer), React.createElement(FunctionalLegacyContextConsumer))
		--     end

		--     LegacyContextProvider.childContextTypes = {
		--         color = PropTypes.string,
		--     }

		--     local Root = React.Component:extend("Root")

		--     function Root:render()
		--         return React.createElement('div', nil, React.createElement(StrictMode, nil, React.createElement(LegacyContextProvider)))
		--     end

		--     jestExpect(function()
		--         ReactNoop.render(React.createElement(Root))
		--     end).toErrorDev('Warning: Legacy context API has been detected within a strict-mode tree.' .. '\n\nThe old API will be supported in all 16.x releases, but applications ' .. 'using it should migrate to the new version.' .. '\n\nPlease update the following components: ' .. 'FunctionalLegacyContextConsumer, LegacyContextConsumer, LegacyContextProvider' .. '\n\nLearn more about this warning here: ' .. 'https://reactjs.org/link/legacy-context' .. '\n    in LegacyContextProvider (at **)' .. '\n    in div (at **)' .. '\n    in Root (at **)')
		--     ReactNoop.render(React.createElement(Root))
	end)
end) ]]
S.Children._d62cfde03d0bf78c13658ea60dab8deb=ai
local aj

local ak={ClassName="ModuleScript",Children={},Properties={}}
ak.Name="ReactUpdates.spec"
ak.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-dom/src/__tests__/ReactUpdates-test.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local React
local ReactTestRenderer
-- local ReactDOM
-- local ReactDOMServer
local Scheduler
-- local PropTypes
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

-- ROBLOX note: in upstream, this file is in react-dom, but we're submitting a PR that moves it to a generic place
-- ROBLOX TODO: split non-DOM test into separate file, make upstream PR for this division

local jestExpect = JestGlobals.expect

-- ROBLOX Test Noise: in upstream, jest setup config makes these tests hide
-- the error boundary warnings they trigger (scripts/jest/setupTests.js:72)
describe("ReactUpdates", function()
	beforeEach(function()
		jest.resetModules()

		-- ROBLOX deviation: workaround because our flag is currently always set to false
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = true
		React = require(script.Parent.Parent)

		-- ROBLOX deviation: using React Test Renderer in place of ReactDOM
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)

		-- ReactDOM = require('react-dom')
		-- ReactDOMServer = require('react-dom/server')
		Scheduler = require(Packages.Dev.Scheduler)
	end)

	it("should batch state when updating state twice", function()
		local instance
		local updateCount = 0
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = { x = 0 }
		end
		function Component:componentDidUpdate()
			(function()
				local result = updateCount
				updateCount += 1
				return result
			end)()
		end
		function Component:render()
			instance = self
			return React.createElement("div", nil, self.state.x)
		end

		ReactTestRenderer.create(React.createElement(Component))
		jestExpect(instance.state.x).toBe(0)
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 })
			instance:setState({ x = 2 })
			jestExpect(instance.state.x).toBe(0)
			jestExpect(updateCount).toBe(0)
		end)
		jestExpect(instance.state.x).toBe(2)
		jestExpect(updateCount).toBe(1)
	end)

	it("should batch state when updating two different state keys", function()
		local instance
		local updateCount = 0
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = { x = 0, y = 0 }
		end
		function Component:componentDidUpdate()
			(function()
				local result = updateCount
				updateCount += 1
				return result
			end)()
		end
		function Component:render()
			instance = self
			return React.createElement(
				"div",
				nil,
				string.format("(%s, %s)", self.state.x, self.state.y)
			)
		end
		ReactTestRenderer.create(React.createElement(Component))
		jestExpect(instance.state.x).toBe(0)
		jestExpect(instance.state.y).toBe(0)
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 })
			instance:setState({ y = 2 })
			jestExpect(instance.state.x).toBe(0)
			jestExpect(instance.state.y).toBe(0)
			jestExpect(updateCount).toBe(0)
		end)
		jestExpect(instance.state.x).toBe(1)
		jestExpect(instance.state.y).toBe(2)
		jestExpect(updateCount).toBe(1)
	end)

	it("should batch state and props together", function()
		local instance
		local updateCount = 0
		local Component = React.Component:extend("Component")
		function Component:init()
			instance = self
			self.state = { y = 0 }
		end
		function Component:componentDidUpdate()
			(function()
				local result = updateCount
				updateCount += 1
				return result
			end)()
		end
		function Component:render()
			return React.createElement(
				"div",
				nil,
				string.format("(%s, %s)", tostring(self.props.x), tostring(self.state.y))
			)
		end
		local root = ReactTestRenderer.create(React.createElement(Component, { x = 0 }))
		jestExpect(instance.props.x).toBe(0)
		jestExpect(instance.state.y).toBe(0)
		ReactTestRenderer.unstable_batchedUpdates(function()
			root.update(React.createElement(Component, { x = 1 }))
			instance:setState({ y = 2 })
			jestExpect(instance.props.x).toBe(0)
			jestExpect(instance.state.y).toBe(0)
			jestExpect(updateCount).toBe(0)
		end)
		jestExpect(instance.props.x).toBe(1)
		jestExpect(instance.state.y).toBe(2)
		jestExpect(updateCount).toBe(1)
	end)

	it("should batch parent/child state updates together", function()
		local instance
		local Child = React.Component:extend("Child")
		local parentUpdateCount = 0
		local Parent = React.Component:extend("Parent")
		function Parent:init()
			instance = self
			self.state = { x = 0 }
		end
		function Parent:componentDidUpdate()
			(function()
				local result = parentUpdateCount
				parentUpdateCount += 1
				return result
			end)()
		end
		local childRef = React.createRef()
		function Parent:render()
			return React.createElement(
				"div",
				nil,
				React.createElement(Child, { ref = childRef, x = self.state.x })
			)
		end
		local childUpdateCount = 0
		function Child:init()
			self.state = { y = 0 }
		end
		function Child:componentDidUpdate()
			(function()
				local result = childUpdateCount
				childUpdateCount += 1
				return result
			end)()
		end
		function Child:render()
			return React.createElement(
				"div",
				nil,
				tostring(self.props.x) .. tostring(self.state.y)
			)
		end
		ReactTestRenderer.create(React.createElement(Parent))
		local child = childRef.current
		jestExpect(instance.state.x).toBe(0)
		jestExpect(child.state.y).toBe(0)
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 })
			child:setState({ y = 2 })
			jestExpect(instance.state.x).toBe(0)
			jestExpect(child.state.y).toBe(0)
			jestExpect(parentUpdateCount).toBe(0)
			jestExpect(childUpdateCount).toBe(0)
		end)
		jestExpect(instance.state.x).toBe(1)
		jestExpect(child.state.y).toBe(2)
		jestExpect(parentUpdateCount).toBe(1)
		jestExpect(childUpdateCount).toBe(1)
	end)
	it("should batch child/parent state updates together", function()
		local Child = React.Component:extend("Child")
		local instance
		local parentUpdateCount = 0
		local Parent = React.Component:extend("Parent")
		function Parent:init()
			instance = self
			self.state = { x = 0 }
		end
		function Parent:componentDidUpdate()
			(function()
				local result = parentUpdateCount
				parentUpdateCount += 1
				return result
			end)()
		end
		local childRef = React.createRef()
		function Parent:render()
			return React.createElement(
				"div",
				nil,
				React.createElement(Child, { ref = childRef, x = self.state.x })
			)
		end
		local childUpdateCount = 0
		function Child:init()
			self.state = { y = 0 }
		end
		function Child:componentDidUpdate()
			(function()
				local result = childUpdateCount
				childUpdateCount += 1
				return result
			end)()
		end
		function Child:render()
			return React.createElement(
				"div",
				nil,
				tostring(self.props.x) .. tostring(self.state.y)
			)
		end
		ReactTestRenderer.create(React.createElement(Parent))
		local child = childRef.current
		jestExpect(instance.state.x).toBe(0)
		jestExpect(child.state.y).toBe(0)
		ReactTestRenderer.unstable_batchedUpdates(function()
			child:setState({ y = 2 })
			instance:setState({ x = 1 })
			jestExpect(instance.state.x).toBe(0)
			jestExpect(child.state.y).toBe(0)
			jestExpect(parentUpdateCount).toBe(0)
			jestExpect(childUpdateCount).toBe(0)
		end)
		jestExpect(instance.state.x).toBe(1)
		jestExpect(child.state.y).toBe(2)
		jestExpect(parentUpdateCount).toBe(1)

		-- Batching reduces the number of updates here to 1.
		jestExpect(childUpdateCount).toBe(1)
	end)

	it("should support chained state updates", function()
		local instance
		local updateCount = 0
		local Component = React.Component:extend("Component")
		function Component:init()
			instance = self
			self.state = { x = 0 }
		end
		function Component:componentDidUpdate()
			(function()
				local result = updateCount
				updateCount += 1
				return result
			end)()
		end
		function Component:render()
			return React.createElement("div", nil, self.state.x)
		end
		ReactTestRenderer.create(React.createElement(Component))
		jestExpect(instance.state.x).toBe(0)
		local innerCallbackRun = false
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 }, function()
				instance:setState({ x = 2 }, function(self)
					jestExpect(self).toBe(instance)
					innerCallbackRun = true
					jestExpect(instance.state.x).toBe(2)
					jestExpect(updateCount).toBe(2)
				end)
				jestExpect(instance.state.x).toBe(1)
				jestExpect(updateCount).toBe(1)
			end)
			jestExpect(instance.state.x).toBe(0)
			jestExpect(updateCount).toBe(0)
		end)
		jestExpect(innerCallbackRun).toBeTruthy()
		jestExpect(instance.state.x).toBe(2)
		jestExpect(updateCount).toBe(2)
	end)
	it("should batch forceUpdate together", function()
		local instance
		local shouldUpdateCount = 0
		local updateCount = 0
		local Component = React.Component:extend("Component")
		function Component:init()
			instance = self
			self.state = { x = 0 }
		end
		function Component:shouldComponentUpdate()
			(function()
				local result = shouldUpdateCount
				shouldUpdateCount += 1
				return result
			end)()
			return false
		end
		function Component:componentDidUpdate()
			(function()
				local result = updateCount
				updateCount += 1
				return result
			end)()
		end
		function Component:render()
			return React.createElement("div", nil, self.state.x)
		end
		ReactTestRenderer.create(React.createElement(Component))
		jestExpect(instance.state.x).toBe(0)
		local callbacksRun = 0
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 }, function()
				(function()
					local result = callbacksRun
					callbacksRun += 1
					return result
				end)()
			end)
			instance:forceUpdate(function()
				(function()
					local result = callbacksRun
					callbacksRun += 1
					return result
				end)()
			end)
			jestExpect(instance.state.x).toBe(0)
			jestExpect(updateCount).toBe(0)
		end)

		jestExpect(callbacksRun).toBe(2)
		-- shouldComponentUpdate shouldn't be called since we're forcing
		jestExpect(shouldUpdateCount).toBe(0)
		jestExpect(instance.state.x).toBe(1)
		jestExpect(updateCount).toBe(1)
	end)

	it("should update children even if parent blocks updates", function()
		local instance
		local Child = React.Component:extend("Child")
		local parentRenderCount = 0
		local childRenderCount = 0
		local Parent = React.Component:extend("Parent")
		function Parent:init()
			instance = self
		end
		function Parent:shouldComponentUpdate()
			return false
		end
		local childRef = React.createRef()
		function Parent:render()
			(function()
				local result = parentRenderCount
				parentRenderCount += 1
				return result
			end)()
			return React.createElement(Child, { ref = childRef })
		end
		function Child:render()
			(function()
				local result = childRenderCount
				childRenderCount += 1
				return result
			end)()
			return React.createElement("div")
		end
		jestExpect(parentRenderCount).toBe(0)
		jestExpect(childRenderCount).toBe(0)
		local ParentElement = React.createElement(Parent)
		ReactTestRenderer.create(ParentElement)
		jestExpect(parentRenderCount).toBe(1)
		jestExpect(childRenderCount).toBe(1)
		ReactTestRenderer.unstable_batchedUpdates(function()
			instance:setState({ x = 1 })
		end)
		jestExpect(parentRenderCount).toBe(1)
		jestExpect(childRenderCount).toBe(1)
		ReactTestRenderer.unstable_batchedUpdates(function()
			childRef.current:setState({ x = 1 })
		end)
		jestExpect(parentRenderCount).toBe(1)
		jestExpect(childRenderCount).toBe(2)
	end)
	it("should not reconcile children passed via props", function()
		local Bottom = React.Component:extend("Bottom")
		local Middle = React.Component:extend("Middle")
		local numMiddleRenders = 0
		local numBottomRenders = 0
		local Top = React.Component:extend("Top")
		function Top:render()
			return React.createElement(Middle, nil, React.createElement(Bottom))
		end
		function Middle:componentDidMount()
			self:forceUpdate()
		end
		function Middle:render()
			(function()
				local result = numMiddleRenders
				numMiddleRenders += 1
				return result
			end)()
			return React.Children.only(self.props.children)
		end
		function Bottom:render()
			(function()
				local result = numBottomRenders
				numBottomRenders += 1
				return result
			end)()
			return nil
		end
		ReactTestRenderer.create(React.createElement(Top))
		jestExpect(numMiddleRenders).toBe(2)
		jestExpect(numBottomRenders).toBe(1)
	end)

	-- ROBLOX FIXME: need to figure out how to make these work with test renderers
	it.skip("should flow updates correctly", function()
		-- 	local willUpdates = {}
		-- 	local didUpdates = {}
		-- 	local UpdateLoggingMixin = {
		-- 		UNSAFE_componentWillUpdate = function(self)
		-- 			willUpdates:push(self.constructor.displayName)
		-- 		end,
		-- 		componentDidUpdate = function(self)
		-- 			didUpdates:push(self.constructor.displayName)
		-- 		end,
		-- 	}
		-- 	local Box = React.Component:extend("")
		-- 	Box.__index = Box
		-- 	function Box:render()
		-- 		return React.createElement("div", { ref = "boxDiv" }, self.props.children)
		-- 	end
		-- 	Object:assign(Box.prototype, UpdateLoggingMixin)
		-- 	local Child = React.Component:extend("")
		-- 	Child.__index = Child
		-- 	function Child:render()
		-- 		return React.createElement("span", { ref = "span" }, "child")
		-- 	end
		-- 	Object:assign(Child.prototype, UpdateLoggingMixin)
		-- 	local Switcher = React.Component:extend("")
		-- 	Switcher.__index = Switcher
		-- 	function Switcher:render()
		-- 		local child = self.props.children
		-- 		return React.createElement(
		-- 			Box,
		-- 			{ ref = "box" },
		-- 			React.createElement(
		-- 				"div",
		-- 				{
		-- 					ref = "switcherDiv",
		-- 					style = { display = self.state.tabKey == child.key and "" or "none" },
		-- 				},
		-- 				child
		-- 			)
		-- 		)
		-- 	end
		-- 	Object:assign(Switcher.prototype, UpdateLoggingMixin)
		-- 	local App = React.Component:extend("")
		-- 	App.__index = App
		-- 	function App:render()
		-- 		return React.createElement(
		-- 			Switcher,
		-- 			{ ref = "switcher" },
		-- 			React.createElement(Child, { key = "hello", ref = "child" })
		-- 		)
		-- 	end
		-- 	Object:assign(App.prototype, UpdateLoggingMixin)
		-- 	local root = React.createElement(App)
		-- 	root = ReactTestUtils:renderIntoDocument(root)
		-- 	local function expectUpdates(desiredWillUpdates, desiredDidUpdates)
		-- 		local i
		-- 		error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
		-- 		--\[\[ for (i = 0; i < desiredWillUpdates; i++) {
		--     jestExpect(willUpdates).toContain(desiredWillUpdates[i]);
		--   } \]\]
		-- 		error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
		-- 		--\[\[ for (i = 0; i < desiredDidUpdates; i++) {
		--     jestExpect(didUpdates).toContain(desiredDidUpdates[i]);
		--   } \]\]
		-- 		willUpdates = {}
		-- 		didUpdates = {}
		-- 	end
		-- 	local function triggerUpdate(c)
		-- 		c:setState({ x = 1 })
		-- 	end
		-- 	local function testUpdates(components, desiredWillUpdates, desiredDidUpdates)
		-- 		local i
		-- 		ReactTestRenderer.unstable_batchedUpdates(function()
		-- 			error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
		-- 			--\[\[ for (i = 0; i < components.length; i++) {
		--       triggerUpdate(components[i]);
		--     } \]\]
		-- 		end)
		-- 		expectUpdates(desiredWillUpdates, desiredDidUpdates)
		-- 		-- Try them in reverse order
		--      ReactTestRenderer.unstable_batchedUpdates(function()
		-- 			error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
		-- 			--\[\[ for (i = components.length - 1; i >= 0; i--) {
		--       triggerUpdate(components[i]);
		--     } \]\]
		-- 		end)
		-- 		expectUpdates(desiredWillUpdates, desiredDidUpdates)
		-- 	end
		-- 	testUpdates(
		-- 		{ root.refs.switcher.refs.box, root.refs.switcher },
		--      -- Owner-child relationships have inverse will and did
		-- 		{ "Switcher", "Box" },
		-- 		{ "Box", "Switcher" }
		-- 	)
		-- 	testUpdates(
		-- 		{ root.refs.child, root.refs.switcher.refs.box },
		--      -- Not owner-child so reconcile independently
		-- 		{ "Box", "Child" },
		-- 		{ "Box", "Child" }
		-- 	)
		-- 	testUpdates(
		-- 		{ root.refs.child, root.refs.switcher },
		--      -- Switcher owns Box and Child, Box does not own Child
		-- 		{ "Switcher", "Box", "Child" },
		-- 		{ "Box", "Switcher", "Child" }
		-- 	)
	end)

	it.skip("should queue mount-ready handlers across different roots", function()
		-- We'll define two components A and B, then update both of them. When A's
		-- componentDidUpdate handlers is called, B's DOM should already have been
		-- updated.
		-- local bContainer = document:createElement("div")
		-- local b
		-- local aUpdated = false
		-- local A = React.Component:extend("")
		-- A.__index = A
		-- function A:componentDidUpdate()
		-- 	jestExpect(ReactTestRenderer.findDOMNode(b).textContent).toBe("B1")
		-- 	aUpdated = true
		-- end
		-- function A:render()
		-- 	local portal = nil
		-- 	portal = ReactTestRenderer.createPortal(
		-- 		React.createElement(B, {
		-- 			ref = function(n)
		-- 				b = n
		-- 				return b
		-- 			end,
		-- 		}),
		-- 		bContainer
		-- 	)
		-- 	return React.createElement("div", nil, "A", self.state.x, portal)
		-- end
		-- local B = React.Component:extend("")
		-- B.__index = B
		-- function B:render()
		-- 	return React.createElement("div", nil, "B", self.state.x)
		-- end
		-- local a = ReactTestUtils:renderIntoDocument(React.createElement(A))
		-- ReactTestRenderer.unstable_batchedUpdates(function()
		-- 	a:setState({ x = 1 })
		-- 	b:setState({ x = 1 })
		-- end)
		-- jestExpect(aUpdated).toBe(true)
	end)
	it("should flush updates in the correct order", function()
		local instance
		local Inner = React.Component:extend("Inner")
		local updates = {}
		local Outer = React.Component:extend("Outer")
		function Outer:init()
			instance = self
			self.state = { x = 0 }
		end
		local innerRef = React.createRef()
		function Outer:render()
			table.insert(updates, "Outer-render-" .. tostring(self.state.x))
			return React.createElement(
				"div",
				nil,
				React.createElement(Inner, { x = self.state.x, ref = innerRef })
			)
		end
		function Outer:componentDidUpdate()
			local x = self.state.x
			table.insert(updates, "Outer-didUpdate-" .. tostring(x))
			table.insert(updates, "Inner-setState-" .. tostring(x))
			innerRef.current:setState({ x = x }, function()
				table.insert(updates, "Inner-callback-" .. tostring(x))
			end)
		end
		function Inner:init()
			self.state = { x = 0 }
		end
		function Inner:render()
			table.insert(
				updates,
				"Inner-render-" .. tostring(self.props.x) .. "-" .. tostring(self.state.x)
			)
			return React.createElement("div")
		end
		function Inner:componentDidUpdate()
			table.insert(
				updates,
				"Inner-didUpdate-"
					.. tostring(self.props.x)
					.. "-"
					.. tostring(self.state.x)
			)
		end
		ReactTestRenderer.create(React.createElement(Outer))
		table.insert(updates, "Outer-setState-1")
		instance:setState({ x = 1 }, function()
			table.insert(updates, "Outer-callback-1")
			table.insert(updates, "Outer-setState-2")
			instance:setState({ x = 2 }, function()
				table.insert(updates, "Outer-callback-2")
			end)
		end)
		jestExpect(updates).toEqual({
			"Outer-render-0",
			"Inner-render-0-0",

			"Outer-setState-1",
			"Outer-render-1",
			"Inner-render-1-0",
			"Inner-didUpdate-1-0",
			"Outer-didUpdate-1",
			-- Happens in a batch, so don't re-render yet
			"Inner-setState-1",
			"Outer-callback-1",

			-- Happens in a batch
			"Outer-setState-2",

			-- Flush batched updates all at once
			"Outer-render-2",
			"Inner-render-2-1",
			"Inner-didUpdate-2-1",
			"Inner-callback-1",
			"Outer-didUpdate-2",
			"Inner-setState-2",
			"Outer-callback-2",
			"Inner-render-2-2",
			"Inner-didUpdate-2-2",
			"Inner-callback-2",
		})
	end)
	it("should flush updates in the correct order across roots", function()
		local instances = {}
		local updates = {}
		local MockComponent = React.Component:extend("MockComponent")
		function MockComponent:render()
			table.insert(updates, self.props.depth)
			return React.createElement("div")
		end
		function MockComponent:componentDidMount()
			table.insert(instances, self)
			if
				self.props.depth
				< self.props.count --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
			then
				ReactTestRenderer.create(
					React.createElement(
						MockComponent,
						{ depth = self.props.depth + 1, count = self.props.count }
					)
				)
			end
		end
		ReactTestRenderer.create(
			React.createElement(MockComponent, { depth = 0, count = 2 })
		)
		jestExpect(updates).toEqual({ 0, 1, 2 })
		ReactTestRenderer.unstable_batchedUpdates(function()
			-- Simulate update on each component from top to bottom.
			Array.forEach(instances, function(instance)
				instance:forceUpdate()
			end)
		end)
		jestExpect(updates).toEqual({ 0, 1, 2, 0, 1, 2 })
	end)

	it("should queue nested updates", function()
		-- See https://github.com/facebook/react/issues/1147
		local x
		local y
		local Y = React.Component:extend("Y")
		local Z = React.Component:extend("Z")
		local X = React.Component:extend("X")
		function X:init()
			x = self
			self.state = { s = 0 }
		end
		function X:render()
			if self.state.s == 0 then
				return React.createElement(
					"div",
					nil,
					React.createElement("span", nil, "0")
				)
			else
				return React.createElement("div", nil, "1")
			end
		end
		function X:go()
			self:setState({ s = 1 })
			self:setState({ s = 0 })
			self:setState({ s = 1 })
		end

		function Y:render()
			y = self
			return React.createElement("div", nil, React.createElement(Z))
		end
		function Z:render()
			return React.createElement("div")
		end
		function Z:UNSAFE_componentWillUpdate()
			x:go()
		end
		local root = ReactTestRenderer.create(React.createElement(X))
		ReactTestRenderer.create(React.createElement(Y))
		-- ROBLOX TODO: need a toMatchRenderedOutput to work with the test *and* noop renderers
		jestExpect(root.toJSON().children[1].children[1]).toBe("0")
		y:forceUpdate()
		jestExpect(root.toJSON().children[1]).toBe("1")
	end)
	it("should queue updates from during mount", function()
		-- See https://github.com/facebook/react/issues/1353

		local a
		local A = React.Component:extend("")
		function A:init()
			self.state = { x = 0 }
		end
		function A:UNSAFE_componentWillMount()
			a = self
		end
		function A:render()
			return React.createElement("div", nil, "A" .. tostring(self.state.x))
		end
		local B = React.Component:extend("")
		function B:UNSAFE_componentWillMount()
			a:setState({ x = 1 })
		end
		function B:render()
			return React.createElement("div")
		end
		local root
		ReactTestRenderer.unstable_batchedUpdates(function()
			root = ReactTestRenderer.create(
				React.createElement(
					"div",
					nil,
					React.createElement(A),
					React.createElement(B)
				)
			)
		end)
		jestExpect(a.state.x).toBe(1)
		-- ROBLOX TODO: need a toMatchRenderedOutput to work with the test *and* noop renderers
		jestExpect(root.toJSON().children[1].children[1]).toBe("A1")
	end)
	-- ROBLOX FIXME: cWRP never gets called
	it.skip("calls componentWillReceiveProps setState callback properly", function()
		local callbackCount = 0
		local A = React.Component:extend("")
		function A:init()
			self.state = { x = self.props.x }
		end
		function A:UNSAFE_componentWillReceiveProps(nextProps)
			local newX = nextProps.x
			self:setState({ x = newX }, function()
				-- State should have updated by the time this callback gets called
				jestExpect(self.state.x).toBe(newX);
				(function()
					local result = callbackCount
					callbackCount += 1
					return result
				end)()
			end)
		end
		function A:render()
			return React.createElement("div", nil, self.state.x)
		end
		ReactTestRenderer.create(React.createElement(A, { x = 1 }))
		ReactTestRenderer.create(React.createElement(A, { x = 2 }))
		jestExpect(callbackCount).toBe(1)
	end)
	it("does not call render after a component as been deleted", function()
		local renderCount = 0
		local componentB = nil
		local componentA = nil
		local B = React.Component:extend("")
		function B:init()
			self.state = { updates = 0 }
		end
		function B:componentDidMount()
			componentB = self
		end
		function B:render()
			(function()
				local result = renderCount
				renderCount += 1
				return result
			end)()
			return React.createElement("div")
		end
		local A = React.Component:extend("")
		function A:init()
			componentA = self
			self.state = { showB = true }
		end
		function A:render()
			return (function()
				if Boolean.toJSBoolean(self.state.showB) then
					return React.createElement(B)
				else
					return React.createElement("div")
				end
			end)()
		end
		ReactTestRenderer.create(React.createElement(A))
		ReactTestRenderer.unstable_batchedUpdates(function()
			-- B will have scheduled an update but the batching should ensure that its
			-- update never fires.
			componentB:setState({ updates = 1 })
			componentA:setState({ showB = false })
		end)
		jestExpect(renderCount).toBe(1)
	end)

	it("throws in setState if the update callback is not a function", function()
		-- ROBLOX deviation: this captures the instance since we aren't using the DOM test helper
		local component

		local A = React.Component:extend("A")
		function A:init()
			self.state = {}
		end

		function A:render()
			component = self
			return React.createElement("div")
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactTestRenderer.create(React.createElement(A))

		jestExpect(function()
			jestExpect(function()
				component:setState({}, "no" :: any)
			end).toErrorDev(
				"setState(...): Expected the last optional `callback` argument to be "
					.. "a function. Instead received: no.",
				{ withoutStack = true }
			)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: no"
		)
		ReactTestRenderer.create(React.createElement(A))

		local invalidCallback = { foo = "bar" }

		jestExpect(function()
			jestExpect(function()
				component:setState({}, invalidCallback :: any)
			end).toErrorDev(
				"setState(...): Expected the last optional `callback` argument to be "
					.. "a function. Instead received: table."
			)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: table"
		)

		-- Make sure the warning is deduplicated and doesn't fire again
		ReactTestRenderer.create(React.createElement(A))
		jestExpect(function()
			component:setState({}, invalidCallback :: any)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: table"
		)
	end)

	it("throws in forceUpdate if the update callback is not a function", function()
		-- ROBLOX deviation: this captures the instance since we aren't using the DOM test helper
		local component

		local A = React.Component:extend("A")
		function A:init()
			self.state = {}
		end

		function A:render()
			component = self
			return React.createElement("div")
		end

		-- ROBLOX deviation: use ReactNoop.render to render instead of ReactDOM.render
		ReactTestRenderer.create(React.createElement(A))

		jestExpect(function()
			jestExpect(function()
				component:forceUpdate("no" :: any)
			end).toErrorDev(
				"forceUpdate(...): Expected the last optional `callback` argument to be "
					.. "a function. Instead received: no.",
				{ withoutStack = true }
			)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: no"
		)
		ReactTestRenderer.create(React.createElement(A))

		local invalidCallback = { foo = "bar" }

		jestExpect(function()
			jestExpect(function()
				component:forceUpdate(invalidCallback :: any)
			end).toErrorDev(
				"forceUpdate(...): Expected the last optional `callback` argument to be "
					.. "a function. Instead received: table."
			)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: table"
		)

		-- Make sure the warning is deduplicated and doesn't fire again
		ReactTestRenderer.create(React.createElement(A))
		jestExpect(function()
			component:forceUpdate(invalidCallback :: any)
		end).toThrowError(
			"Invalid argument passed as callback. Expected a function. Instead "
				.. "received: table"
		)
	end)

	it("does not update one component twice in a batch (#2410)", function()
		local parent
		local Child = React.Component:extend("Child")
		local childRef = React.createRef()
		local Parent = React.Component:extend("Parent")
		function Parent:getChild()
			return childRef.current
		end
		function Parent:render()
			parent = self
			return React.createElement(Child, { ref = childRef })
		end
		local renderCount = 0
		local postRenderCount = 0
		local once = false
		function Child:init()
			self.state = { updated = false }
		end
		function Child:UNSAFE_componentWillUpdate()
			if not Boolean.toJSBoolean(once) then
				once = true
				self:setState({ updated = true })
			end
		end
		function Child:componentDidMount()
			jestExpect(renderCount).toBe(postRenderCount + 1);
			(function()
				local result = postRenderCount
				postRenderCount += 1
				return result
			end)()
		end
		function Child:componentDidUpdate()
			jestExpect(renderCount).toBe(postRenderCount + 1);
			(function()
				local result = postRenderCount
				postRenderCount += 1
				return result
			end)()
		end
		function Child:render()
			jestExpect(renderCount).toBe(postRenderCount);
			(function()
				local result = renderCount
				renderCount += 1
				return result
			end)()
			return React.createElement("div")
		end
		ReactTestRenderer.create(React.createElement(Parent))
		local child = parent:getChild()
		ReactTestRenderer.unstable_batchedUpdates(function()
			parent:forceUpdate()
			child:forceUpdate()
		end)
	end)

	-- it("does not update one component twice in a batch (#6371)", function()
	--     local callbacks = {}
	--     local function emitChange()
	--         callbacks:forEach(function(c)
	--             return c()
	--         end)
	--     end
	--     local App = React.Component:extend("")
	--     App.__index = App
	--     function App.new(props)
	--         local self = setmetatable({}, App) --\[\[ ROBLOX TODO: super constructor may be used \]\](
	--             error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: Super \]\]
	--             --\[\[ super \]\]
	--         )(props)
	--         self.state = { showChild = true }
	--         return self
	--     end
	--     function App:componentDidMount()
	--         self:setState({ showChild = false })
	--     end
	--     function App:render()
	--         return React.createElement(
	--             "div",
	--             nil,
	--             React.createElement(ForceUpdatesOnChange),
	--             (function()
	--                 if Boolean.toJSBoolean(self.state.showChild) then
	--                     return React.createElement(EmitsChangeOnUnmount)
	--                 else
	--                     return self.state.showChild
	--                 end
	--             end)()
	--         )
	--     end
	--     local EmitsChangeOnUnmount = React.Component:extend("")
	--     EmitsChangeOnUnmount.__index = EmitsChangeOnUnmount
	--     function EmitsChangeOnUnmount:componentWillUnmount()
	--         emitChange()
	--     end
	--     function EmitsChangeOnUnmount:render()
	--         return nil
	--     end
	--     local ForceUpdatesOnChange = React.Component:extend("")
	--     ForceUpdatesOnChange.__index = ForceUpdatesOnChange
	--     function ForceUpdatesOnChange:componentDidMount()
	--         self.onChange = function()
	--             return self:forceUpdate()
	--         end
	--         self:onChange()
	--         callbacks:push(self.onChange)
	--     end
	--     function ForceUpdatesOnChange:componentWillUnmount()
	--         callbacks = callbacks:filter(function(c)
	--             return c ~= self.onChange
	--         end)
	--     end
	--     function ForceUpdatesOnChange:render()
	--         return React.createElement("div", { key = Math:random(), onClick = function(self) end })
	--     end
	--     ReactTestRenderer.create(React.createElement(App), document:createElement("div"))
	-- end)
	it("unstable_batchedUpdates should return value from a callback", function()
		local result = ReactTestRenderer.unstable_batchedUpdates(function()
			return 42
		end)
		jestExpect(result).toEqual(42)
	end)
	it.skip("unmounts and remounts a root in the same batch", function()
		local root = ReactTestRenderer.create(React.createElement("span", nil, "a"))
		ReactTestRenderer.unstable_batchedUpdates(function()
			-- ROBLOX FIXME: how to do this with the test renderer?
			-- ReactTestRenderer.unmount()
			root:update(React.createElement("span", nil, "b"))
		end)
		-- ROBLOX TODO: need a toMatchRenderedOutput to work with the test *and* noop renderers
		jestExpect(root.toJSON().children[1]).toBe("b")
	end)
	-- it("handles reentrant mounting in synchronous mode", function()
	--     local mounts = 0
	--     local Editor = React.Component:extend("")
	--     Editor.__index = Editor
	--     function Editor:render()
	--         return React.createElement("div", nil, self.props.text)
	--     end
	--     function Editor:componentDidMount()
	--         (function()
	--             local result = mounts
	--             mounts += 1
	--             return result
	--         end)()
	--         if not Boolean.toJSBoolean(self.props.rendered) then
	--             self.props:onChange({ rendered = true })
	--         end
	--     end
	--     local container = document:createElement("div")
	--     local function render()
	--         ReactTestRenderer.create(
	--             React.createElement(
	--                 Editor,
	--                 _extends({
	--                     onChange = function(newProps)
	--                         props = Object.assign({}, props, newProps)
	--                         render()
	--                     end,
	--                 }, props)
	--             ),
	--             container
	--         )
	--     end
	--     local props = { text = "hello", rendered = false }
	--     render()
	--     props = Object.assign({}, props, { text = "goodbye" })
	--     render()
	--     jestExpect(container.textContent).toBe("goodbye")
	--     jestExpect(mounts).toBe(1)
	-- end)
	-- it("mounts and unmounts are sync even in a batch", function()
	--     local ops = {}
	--     local container = document:createElement("div")
	--     ReactTestRenderer.unstable_batchedUpdates(function()
	--         ReactTestRenderer.create(React.createElement("div", nil, "Hello"), container)
	--         table.insert(ops, container.textContent)
	--         ReactTestRenderer.unmountComponentAtNode(container)
	--         table.insert(ops, container.textContent)
	--     end)
	--     jestExpect(ops).toEqual({ "Hello", "" })
	-- end)
	-- it(
	--     "in legacy mode, updates in componentWillUpdate and componentDidUpdate "
	--         .. "should both flush in the immediately subsequent commit",
	--     function()
	--         local ops = {}
	--         local Foo = React.Component:extend("")
	--         Foo.__index = Foo
	--         function Foo:UNSAFE_componentWillUpdate(_, nextState)
	--             if not Boolean.toJSBoolean(nextState.a) then
	--                 self:setState({ a = true })
	--             end
	--         end
	--         function Foo:componentDidUpdate()
	--             table.insert(ops, "Foo updated")
	--             if not Boolean.toJSBoolean(self.state.b) then
	--                 self:setState({ b = true })
	--             end
	--         end
	--         function Foo:render()
	--             table.insert(ops, string.format("a: %s, b: %s", self.state.a, self.state.b))
	--             return nil
	--         end
	--         local container = document:createElement("div")
	--         ReactTestRenderer.create(React.createElement(Foo), container)
	--         ReactTestRenderer.create(React.createElement(Foo), container)
	--         jestExpect(ops).toEqual({
	--             "a: false, b: false",
	--             "a: false, b: false",
	--             "Foo updated",
	--             "a: true, b: true",
	--             "Foo updated",
	--         })
	--     end
	-- )
	-- it(
	--     "in legacy mode, updates in componentWillUpdate and componentDidUpdate "
	--         .. "(on a sibling) should both flush in the immediately subsequent commit",
	--     function()
	--         local ops = {}
	--         local Foo = React.Component:extend("")
	--         Foo.__index = Foo
	--         function Foo:UNSAFE_componentWillUpdate(_, nextState)
	--             if not Boolean.toJSBoolean(nextState.a) then
	--                 self:setState({ a = true })
	--             end
	--         end
	--         function Foo:componentDidUpdate()
	--             table.insert(ops, "Foo updated")
	--         end
	--         function Foo:render()
	--             table.insert(ops, string.format("a: %s", self.state.a))
	--             return nil
	--         end
	--         local Bar = React.Component:extend("")
	--         Bar.__index = Bar
	--         function Bar:componentDidUpdate()
	--             table.insert(ops, "Bar updated")
	--             if not Boolean.toJSBoolean(self.state.b) then
	--                 self:setState({ b = true })
	--             end
	--         end
	--         function Bar:render()
	--             table.insert(ops, string.format("b: %s", self.state.b))
	--             return nil
	--         end
	--         local container = document:createElement("div")
	--         ReactTestRenderer.create(
	--             React.createElement(
	--                 "div",
	--                 nil,
	--                 React.createElement(Foo),
	--                 React.createElement(Bar)
	--             ),
	--             container
	--         )
	--         ReactTestRenderer.create(
	--             React.createElement(
	--                 "div",
	--                 nil,
	--                 React.createElement(Foo),
	--                 React.createElement(Bar)
	--             ),
	--             container
	--         )
	--         jestExpect(ops).toEqual({
	--             "a: false",
	--             "b: false",
	--             "a: false",
	--             "b: false",
	--             "Foo updated",
	--             "Bar updated",
	--             "a: true",
	--             "b: true",
	--             "Foo updated",
	--             "Bar updated",
	--         })
	--     end
	-- )
	it("uses correct base state for setState inside render phase", function()
		local ops = {}
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = { step = 0 }
		end
		function Foo:render()
			local memoizedStep = self.state.step
			self:setState(function(baseState)
				local baseStep = baseState.step
				table.insert(
					ops,
					string.format(
						"base: %s, memoized: %s",
						tostring(baseStep),
						memoizedStep
					)
				)
				return baseStep == 0 and { step = 1 } or nil
			end)
			return nil
		end
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(Foo))
		end).toErrorDev("Cannot update during an existing state transition")
		jestExpect(ops).toEqual({ "base: 0, memoized: 0", "base: 1, memoized: 1" })
	end)
	it("does not re-render if state update is null", function()
		local instance
		local ops = {}
		local Foo = React.Component:extend("Foo")
		function Foo:render()
			instance = self
			table.insert(ops, "render")
			return React.createElement("div")
		end
		ReactTestRenderer.create(React.createElement(Foo))
		ops = {}
		instance:setState(function()
			return nil
		end)
		jestExpect(ops).toEqual({})
	end)

	-- Will change once we switch to async by default
	it("synchronously renders hidden subtrees", function()
		local ops = {}
		local function Baz()
			table.insert(ops, "Baz")
			return nil
		end
		local function Bar()
			table.insert(ops, "Bar")
			return nil
		end
		local function Foo()
			table.insert(ops, "Foo")
			return React.createElement(
				"div",
				nil,
				React.createElement("div", { hidden = true }, React.createElement(Bar)),
				React.createElement(Baz)
			)
		end

		-- Mount
		ReactTestRenderer.create(React.createElement(Foo))
		jestExpect(ops).toEqual({ "Foo", "Bar", "Baz" })
		ops = {}

		-- Update
		ReactTestRenderer.create(React.createElement(Foo))
		jestExpect(ops).toEqual({ "Foo", "Bar", "Baz" })
	end)
	-- @gate experimental
	-- it("delays sync updates inside hidden subtrees in Concurrent Mode", function()
	--     local container = document:createElement("div")
	--     local function Baz()
	--         Scheduler:unstable_yieldValue("Baz")
	--         return React.createElement("p", nil, "baz")
	--     end
	--     local setCounter
	--     local function Bar()
	--         local counter, _setCounter = table.unpack(React.useState(0), 1, 2)
	--         setCounter = _setCounter
	--         Scheduler:unstable_yieldValue("Bar")
	--         return React.createElement("p", nil, "bar ", counter)
	--     end
	--     local function Foo()
	--         Scheduler:unstable_yieldValue("Foo")
	--         React.useEffect(function()
	--             Scheduler:unstable_yieldValue("Foo#effect")
	--         end)
	--         return React.createElement(
	--             "div",
	--             nil,
	--             React.createElement(
	--                 LegacyHiddenDiv,
	--                 { mode = "hidden" },
	--                 React.createElement(Bar)
	--             ),
	--             React.createElement(Baz)
	--         )
	--     end
	--     local root = ReactTestRenderer.createRoot(container)
	--     local hiddenDiv
	--     act(function()
	--         root:render(React.createElement(Foo))
	--         jestExpect(Scheduler).toFlushAndYieldThrough({ "Foo", "Baz", "Foo#effect" })
	--         hiddenDiv = container.firstChild.firstChild
	--         jestExpect(hiddenDiv.hidden).toBe(true)
	--         jestExpect(hiddenDiv.innerHTML).toBe("")
	--         jestExpect(Scheduler).toFlushAndYield({ "Bar" })
	--         jestExpect(hiddenDiv.hidden).toBe(true)
	--         jestExpect(hiddenDiv.innerHTML).toBe("<p>bar 0</p>")
	--     end)
	--     ReactTestRenderer.flushSync(function()
	--         setCounter(1)
	--     end)
	--     jestExpect(hiddenDiv.innerHTML).toBe("<p>bar 0</p>")
	--     jestExpect(Scheduler).toFlushAndYield({ "Bar" })
	--     jestExpect(hiddenDiv.innerHTML).toBe("<p>bar 1</p>")
	-- end)
	-- it(
	--     "can render ridiculously large number of roots without triggering infinite update loop error",
	--     function()
	--         local Foo = React.Component:extend("Foo")
	--         Foo.__index = Foo
	--         function Foo:componentDidMount()
	--             local limit = 1200
	--             error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
	--             --\[\[ for (let i = 0; i < limit; i++) {
	--       if (i < limit - 1) {
	--         ReactDOM.render( /*#__PURE__*/React.createElement("div", null), document.createElement('div'));
	--       } else {
	--         ReactDOM.render( /*#__PURE__*/React.createElement("div", null), document.createElement('div'), () => {
	--           // The "nested update limit" error isn't thrown until setState
	--           this.setState({});
	--         });
	--       }
	--     } \]\]
	--         end
	--         function Foo:render()
	--             return nil
	--         end
	--         local container = document:createElement("div")
	--         ReactTestRenderer.create(React.createElement(Foo), container)

	-- end)
	-- it("resets the update counter for unrelated updates", function()
	--     local container = document:createElement("div")
	--     local ref = React.createRef()
	--     local EventuallyTerminating = React.Component:extend("")
	--     EventuallyTerminating.__index = EventuallyTerminating
	--     function EventuallyTerminating:componentDidMount()
	--         self:setState({ step = 1 })
	--     end
	--     function EventuallyTerminating:componentDidUpdate()
	--         if
	--             self.state.step
	--             < limit --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	--         then
	--             self:setState({ step = self.state.step + 1 })
	--         end
	--     end
	--     function EventuallyTerminating:render()
	--         return self.state.step
	--     end
	--     local limit = 55
	--     jestExpect(function()
	--         ReactTestRenderer.create(React.createElement(EventuallyTerminating, { ref = ref }), container)
	--     end).toThrow("Maximum")
	--     limit -= 10
	--     ReactTestRenderer.create(React.createElement(EventuallyTerminating, { ref = ref }), container)
	--     jestExpect(container.textContent).toBe(tostring(limit))
	--     ref.current:setState({ step = 0 })
	--     jestExpect(container.textContent).toBe(tostring(limit))
	--     ref.current:setState({ step = 0 })
	--     jestExpect(container.textContent).toBe(tostring(limit))
	--     limit += 10
	--     jestExpect(function()
	--         ref.current:setState({ step = 0 })
	--     end).toThrow("Maximum")
	--     jestExpect(ref.current).toBe(nil)
	-- end)
	-- it("does not fall into an infinite update loop", function()
	--     local NonTerminating = React.Component:extend("")
	--     NonTerminating.__index = NonTerminating
	--     function NonTerminating:componentDidMount()
	--         self:setState({ step = 1 })
	--     end
	--     function NonTerminating:UNSAFE_componentWillUpdate()
	--         self:setState({ step = 2 })
	--     end
	--     function NonTerminating:render()
	--         return React.createElement("div", nil, "Hello ", self.props.name, self.state.step)
	--     end
	--     local container = document:createElement("div")
	--     jestExpect(function()
	--         ReactTestRenderer.create(React.createElement(NonTerminating), container)
	--     end).toThrow("Maximum")
	-- end)
	it("does not fall into an infinite update loop with useLayoutEffect", function()
		local function NonTerminating()
			local step, setStep = React.useState(0)
			React.useLayoutEffect(function()
				setStep(function(x)
					return x + 1
				end)
			end)
			return step
		end
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(NonTerminating))
		end).toThrow("Maximum")
	end)
	it("can recover after falling into an infinite update loop", function()
		local NonTerminating = React.Component:extend("NonTerminating")
		function NonTerminating:init()
			self.state = { step = 0 }
		end
		function NonTerminating:componentDidMount()
			self:setState({ step = 1 })
		end
		function NonTerminating:componentDidUpdate()
			self:setState({ step = 2 })
		end
		function NonTerminating:render()
			return self.state.step
		end
		local Terminating = React.Component:extend("Terminating")
		function Terminating:init()
			self.state = { step = 0 }
		end
		function Terminating:componentDidMount()
			self:setState({ step = 1 })
		end
		function Terminating:render()
			return self.state.step
		end
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(NonTerminating))
		end).toThrow("Maximum")
		local container = ReactTestRenderer.create(React.createElement(Terminating))
		jestExpect(container.toJSON()).toBe("1")
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(NonTerminating))
		end).toThrow("Maximum")
		container = ReactTestRenderer.create(React.createElement(Terminating))
		jestExpect(container.toJSON()).toBe("1")
	end)
	-- ROBLOX TODO: figure out how to do this with test renderer
	it.skip(
		"does not fall into mutually recursive infinite update loop with same container",
		function()
			-- Note: this test would fail if there were two or more different roots.
			local B = React.Component:extend("B")
			local container = ReactTestRenderer.create(React.createElement("div"))
			local A = React.Component:extend("A")
			function A:componentDidMount()
				container:update(React.createElement(B))
			end
			function A:render()
				return nil
			end
			function B:componentDidMount()
				container:update(React.createElement(A))
			end
			function B:render()
				return nil
			end
			jestExpect(function()
				container:update(React.createElement(A))
			end).toThrow("Maximum")
		end
	)
	it("does not fall into an infinite error loop", function()
		local function BadRender()
			error(Error.new("error"))
		end
		local ErrorBoundary = React.Component:extend("ErrorBoundary")
		function ErrorBoundary:componentDidCatch()
			-- Schedule a no-op state update to avoid triggering a DEV warning in the test.
			self:setState({})
			self.props.parent:remount()
		end
		function ErrorBoundary:render()
			return React.createElement(BadRender)
		end
		local NonTerminating = React.Component:extend("NonTerminating")
		function NonTerminating:init()
			self.state = { step = 0 }
		end
		function NonTerminating:remount()
			self:setState(function(state: { step: number })
				return { step = state.step + 1 }
			end)
		end
		function NonTerminating:render()
			return React.createElement(
				ErrorBoundary,
				{ key = self.state.step, parent = self }
			)
		end
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(NonTerminating))
		end).toThrow("Maximum")
	end)
	-- it(
	--     "can schedule ridiculously many updates within the same batch without triggering a maximum update error",
	--     function()
	--         local subscribers = {}
	--         local Child = React.Component:extend("")
	--         Child.__index = Child
	--         function Child:componentDidMount()
	--             subscribers:push(self)
	--         end
	--         function Child:render()
	--             return nil
	--         end
	--         local App = React.Component:extend("")
	--         App.__index = App
	--         function App:render()
	--             local children = {}
	--             error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: ForStatement \]\]
	--             --\[\[ for (let i = 0; i < 1200; i++) {
	--       children.push( /*#__PURE__*/React.createElement(Child, {
	--         key: i
	--       }));
	--     } \]\]
	--             return children
	--         end
	--         local container = document:createElement("div")
	--         ReactTestRenderer.create(React.createElement(App), container)
	--         ReactTestRenderer.unstable_batchedUpdates(function()
	--             subscribers:forEach(function(s)
	--                 s:setState({ value = "update" })
	--             end)
	--         end)
	--     end
	-- )
	-- if Boolean.toJSBoolean(__DEV__) then
	--     it("warns about a deferred infinite update loop with useEffect", function()
	--         local function NonTerminating()
	--             local step, setStep = table.unpack(React.useState(0), 1, 2)
	--             React.useEffect(function()
	--                 setStep(function(x)
	--                     return x + 1
	--                 end)
	--                 Scheduler:unstable_yieldValue(step)
	--             end)
	--             return step
	--         end
	--         local function App()
	--             return React.createElement(NonTerminating)
	--         end
	--         local error_ = nil
	--         local stack = nil
	--         local originalConsoleError = console.error_
	--         console.error_ = function(e, s)
	--             error_ = e
	--             stack = s
	--         end
	--         do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
	--             local ok, result, hasReturned = pcall(function()
	--                 local container = document:createElement("div")
	--                 jestExpect(function()
	--                     act(function()
	--                         ReactTestRenderer.create(React.createElement(App), container)
	--                         error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: WhileStatement \]\]
	--                         --\[\[ while (error === null) {
	--           Scheduler.unstable_flushNumberOfYields(1);
	--           Scheduler.unstable_clearYields();
	--         } \]\]
	--                         jestExpect(error_).toContain("Warning: Maximum update depth exceeded.")
	--                         jestExpect(stack).toContain(" NonTerminating")
	--                         error(error_)
	--                     end)
	--                 end).toThrow("Maximum update depth exceeded.")
	--             end)
	--             do
	--                 console.error_ = originalConsoleError
	--             end
	--             if hasReturned then
	--                 return result
	--             end
	--             if not ok then
	--                 error(result)
	--             end
	--         end
	--     end)
	it("can have nested updates if they do not cross the limit", function()
		local _setStep
		local LIMIT = 50
		local function Terminating()
			local step, setStep = React.useState(0)
			_setStep = setStep
			React.useEffect(function()
				if
					step
					< LIMIT --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
				then
					setStep(function(x)
						return x + 1
					end)
				end
			end)
			Scheduler.unstable_yieldValue(step)
			return step
		end
		local container
		ReactTestRenderer.act(function()
			container = ReactTestRenderer.create(React.createElement(Terminating))
		end)
		jestExpect(container.toJSON()).toBe("50")
		ReactTestRenderer.act(function()
			_setStep(0)
		end)
		jestExpect(container.toJSON()).toBe("50")
	end)
	it("can have many updates inside useEffect without triggering a warning", function()
		-- ROBLOX deviation START: increase loop count to test our object caching logic
		local function Terminating()
			local step, setStep = React.useState(0)
			React.useEffect(function()
				for i = 1, 10000 do
					setStep(function(x)
						return x + 1
					end)
				end
				Scheduler.unstable_yieldValue("Done")
			end, {})
			return step
		end
		local container
		ReactTestRenderer.act(function()
			container = ReactTestRenderer.create(React.createElement(Terminating))
		end)
		jestExpect(Scheduler).toHaveYielded({ "Done" })
		jestExpect(container.toJSON()).toBe("10000")
		-- ROBLOX deviation END
	end)
end) ]]
S.Children._49d9995f30e7663759fb4cb7ba0d54ef=ak
local al

local am={ClassName="ModuleScript",Children={},Properties={}}
am.Name="SetStateInConstructor.roblox.spec"
am.Properties.Source=[[ -- ROBLOX: tests deviant logic for Roblox react which permits use of setState() in component constructor

local Packages = script.Parent.Parent.Parent
local React, Shared, ReactNoop
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach

beforeEach(function()
	jest.resetModules()
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	React = require(script.Parent.Parent)
	Shared = require(Packages.Shared)
end)

local function initTests(defineInitMethod: (any, string | number, any) -> (), name)
	it("has correct state populated in render w/ " .. name, function()
		local Component = React.Component:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState

		function Component:render()
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component))
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
		})
	end)

	it("has derived state populated in render w/ " .. name, function()
		local Component = React.Component:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState

		function Component:render()
			capturedState = self.state
		end

		function Component.getDerivedStateFromProps(props, state)
			return {
				name = state.name,
				surname = props.surname,
			}
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component, { surname = "Smith" }))
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
			surname = "Smith",
		})
	end)

	it("respects React.None in derived state w/ " .. name, function()
		local Component = React.Component:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState

		function Component:render()
			capturedState = self.state
		end

		function Component.getDerivedStateFromProps(props, state)
			return {
				name = React.None,
				surname = props.surname,
			}
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component, { surname = "Smith" }))
		end)

		jestExpect(capturedState).toEqual({
			surname = "Smith",
		})
	end)

	it("updates state correctly w/ " .. name, function()
		local Component = React.Component:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState
		local capturedSetState

		function Component:render()
			capturedSetState = function(...)
				self:setState(...)
			end
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component))
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
		})

		ReactNoop.act(function()
			capturedSetState({
				surname = "Smith",
			})
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
			surname = "Smith",
		})
	end)

	it("updates state correctly with functional setState w/ " .. name, function()
		local Component = React.Component:extend("Component")

		defineInitMethod(Component, "count", 0)

		local capturedState
		local capturedSetState

		function Component:render()
			capturedSetState = function(...)
				self:setState(...)
			end
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component))
		end)

		jestExpect(capturedState).toEqual({
			count = 0,
		})

		ReactNoop.act(function()
			capturedSetState(function(state, props)
				return {
					count = state.count + 1,
				}
			end)
		end)

		jestExpect(capturedState).toEqual({
			count = 1,
		})
	end)
	it("updates a pure component when state changes w/ " .. name, function()
		local Component = React.PureComponent:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState
		local capturedSetState
		local renderCount = 0

		function Component:render()
			capturedSetState = function(...)
				self:setState(...)
			end
			capturedState = self.state
			renderCount += 1
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component))
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
		})

		local renderCountAfterFirst = renderCount

		ReactNoop.act(function()
			capturedSetState({
				name = "Bob",
			})
		end)

		jestExpect(capturedState).toEqual({
			name = "Bob",
		})

		jestExpect(renderCountAfterFirst < renderCount).toEqual(true)
	end)
	it("does not update a pure component with a no-op setState w/ " .. name, function()
		local Component = React.PureComponent:extend("Component")

		defineInitMethod(Component, "name", "Mike")

		local capturedState
		local capturedSetState
		local renderCount = 0

		function Component:render()
			capturedSetState = function(...)
				self:setState(...)
			end
			capturedState = self.state
			renderCount += 1
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component))
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
		})

		local renderCountAfterFirst = renderCount

		ReactNoop.act(function()
			capturedSetState({
				name = "Mike",
			})
		end)

		jestExpect(capturedState).toEqual({
			name = "Mike",
		})

		jestExpect(renderCountAfterFirst).toEqual(renderCount)
	end)
end

-- runs tests using setState in constructor
initTests(function(component, key, value)
	function component:init()
		self:setState({
			[key] = value,
		})
	end
end, "setState in constructor")

-- runs tests using self.state in constructor
initTests(function(component, key, value)
	function component:init()
		self.state = {
			[key] = value,
		}
	end
end, "self.state in constructor")

describe("setState-specific behavior", function()
	it("allows multiple setStates in sequence during init", function()
		local MyComponent = React.Component:extend("MyComponent")
		local capturedState
		function MyComponent:init()
			self:setState({ value = 1 })
			self:setState({ otherValue = 2 })
		end
		function MyComponent:render()
			return nil
		end
		function MyComponent:componentDidMount()
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)

		jestExpect(capturedState).toEqual({ value = 1, otherValue = 2 })
	end)

	it("accounts for `None` values", function()
		local MyComponent = React.Component:extend("MyComponent")
		local capturedState
		function MyComponent:init()
			self:setState({ a = 1, b = 2 })
			self:setState({ a = React.None })
		end
		function MyComponent:render()
			return nil
		end
		function MyComponent:componentDidMount()
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)

		jestExpect(capturedState).toEqual({ b = 2 })
	end)

	it("provides an empty table to functional setState on first run", function()
		local MyComponent = React.Component:extend("MyComponent")
		local capturedState, capturedPrevState
		function MyComponent:init()
			self:setState(function(prevState)
				capturedPrevState = prevState
				return { value = 1 }
			end)
		end
		function MyComponent:render()
			return nil
		end
		function MyComponent:componentDidMount()
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)

		-- The UninitializedState object uses a metatable to emit warnings
		-- when read from, so this expectation ends up being noisy due to
		-- jest poking around:
		-- jestExpect(capturedPrevState).toEqual(Shared.UninitializedState)

		-- Instead, use a simple assert:
		assert(
			capturedPrevState == Shared.UninitializedState,
			"captured previous state differs from UninitializedState placeholder"
		)
		jestExpect(capturedState).toEqual({ value = 1 })
	end)

	it("warns on accessing the initial empty state table", function()
		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:init()
			self:setState(function(prevState)
				return { value = (prevState.value or 0) + 1 }
			end)
		end
		function MyComponent:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(MyComponent))
			end)
		end).toWarnDev(
			"Attempted to access uninitialized state. Use setState to initialize state"
		)
	end)

	it("allows functional setState", function()
		local MyComponent = React.Component:extend("MyComponent")
		local capturedState
		function MyComponent:init()
			self:setState({ value = 1 })
			self:setState(function(prevState)
				return { value = prevState.value + 1 }
			end)
		end
		function MyComponent:render()
			return nil
		end
		function MyComponent:componentDidMount()
			capturedState = self.state
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)

		jestExpect(capturedState).toEqual({ value = 2 })
	end)

	it("warns when given a `callback` argument", function()
		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:init()
			self:setState({ value = 1 }, function() end)
		end
		function MyComponent:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(MyComponent))
			end)
		end).toWarnDev(
			"Received a `callback` argument to `setState` during "
				.. 'initialization of "MyComponent". The callback behavior '
				.. "is not supported when using `setState` in `init`.\n\n"
				.. "Consider defining similar behavior in a "
				.. "`compontentDidMount` method instead."
		)
	end)

	it("throws when given an invalid state payload", function()
		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:init()
			self:setState(true)
		end
		function MyComponent:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(MyComponent))
				end)
			end).toErrorDev("The above error occurred in the <MyComponent> component")
		end).toThrow(
			"setState(...): takes an object of state variables to update "
				.. "or a function which returns an object of state variables."
		)
	end)
end) ]]
S.Children._cfb6be7306770fee4ef2589ab8c6a040=am
local an

local ao={ClassName="ModuleScript",Children={},Properties={}}
ao.Name="createSignal.spec"
ao.Properties.Source=[[ local createSignal = require(script.Parent.Parent["createSignal.roblox"])

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest

local it = JestGlobals.it

it("should fire subscribers and disconnect them", function()
	local subscribe, fire = createSignal()

	local spy = jest.fn()
	local disconnect = subscribe(function(...)
		spy(...)
	end)

	jestExpect(spy).never.toBeCalled()

	local a = 1
	local b = {}
	local c = "hello"
	fire(a, b, c)

	jestExpect(spy).toBeCalledTimes(1)
	jestExpect(spy).toBeCalledWith(a, b, c)

	disconnect()

	fire()

	jestExpect(spy).toBeCalledTimes(1)
end)

it("should handle multiple subscribers", function()
	local subscribe, fire = createSignal()

	local spyA = jest.fn()
	local spyB = jest.fn()

	local disconnectA = subscribe(function(...)
		spyA(...)
	end)
	local disconnectB = subscribe(function(...)
		spyB(...)
	end)

	jestExpect(spyA).never.toBeCalled()
	jestExpect(spyB).never.toBeCalled()

	local a = {}
	local b = 67
	fire(a, b)

	jestExpect(spyA).toBeCalledTimes(1)
	jestExpect(spyA).toBeCalledWith(a, b)

	jestExpect(spyB).toBeCalledTimes(1)
	jestExpect(spyB).toBeCalledWith(a, b)

	disconnectA()

	fire(b, a)

	jestExpect(spyA).toBeCalledTimes(1)

	jestExpect(spyB).toBeCalledTimes(2)
	jestExpect(spyB).toBeCalledWith(b, a)

	disconnectB()
end)

it("should stop firing a connection if disconnected mid-fire", function()
	local subscribe, fire = createSignal()

	-- In this test, we'll connect two listeners that each try to disconnect
	-- the other. Because the order of listeners firing isn't defined, we
	-- have to be careful to handle either case.

	local disconnectA
	local disconnectB

	local spyA = jest.fn(function()
		disconnectB()
	end)

	local spyB = jest.fn(function()
		disconnectA()
	end)

	disconnectA = subscribe(function(...)
		spyA(...)
	end)
	disconnectB = subscribe(function(...)
		spyB(...)
	end)

	fire()

	jestExpect(#spyA.mock.calls + #spyB.mock.calls).toBe(1)
end) ]]
S.Children._a8ab0d030f7094263dfb9de22468f57e=ao
local ap

local aq={ClassName="ModuleScript",Children={},Properties={}}
aq.Name="forwardRef-internal.spec"
aq.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/forwardRef-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]
-- ROBLOX FIXME Luau: this doesn't play nicely with Object.assign
--!nonstrict

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach
local Error = require(Packages.LuauPolyfill).Error
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local React
local ReactFeatureFlags
local ReactNoop
local Scheduler

beforeEach(function()
	jest.resetModules()
	ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags

	ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
	React = require(script.Parent.Parent)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Dev.Scheduler)
end)

it("should work without a ref to be forwarded", function()
	local Child = React.Component:extend("Child")
	function Child:render()
		Scheduler.unstable_yieldValue(self.props.value)
		return nil
	end

	local function Wrapper(props)
		return React.createElement(
			Child,
			Object.assign({}, props, { ref = props.forwardedRef })
		)
	end

	local RefForwardingComponent = React.forwardRef(function(props, ref)
		return React.createElement(
			Wrapper,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	ReactNoop.render(React.createElement(RefForwardingComponent, { value = 123 }))
	jestExpect(Scheduler).toFlushAndYield({ 123 })
end)

it("should forward a ref for a single child", function()
	local Child = React.Component:extend("Child")
	function Child:render()
		Scheduler.unstable_yieldValue(self.props.value)
		return nil
	end

	local function Wrapper(props)
		return React.createElement(
			Child,
			Object.assign({}, props, { ref = props.forwardedRef })
		)
	end

	local RefForwardingComponent = React.forwardRef(function(props, ref)
		return React.createElement(
			Wrapper,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	local ref = React.createRef()

	ReactNoop.render(
		React.createElement(RefForwardingComponent, { ref = ref, value = 123 })
	)
	jestExpect(Scheduler).toFlushAndYield({ 123 })
	-- jestExpect(Object.instanceof(ref.current, Child)).toBe(true)
	jestExpect(getmetatable(ref.current).__index).toBe(Child)
end)

it("should forward a ref for multiple children", function()
	local Child = React.Component:extend("Child")
	function Child:render()
		Scheduler.unstable_yieldValue(self.props.value)
		return nil
	end

	local function Wrapper(props)
		return React.createElement(
			Child,
			Object.assign({}, props, { ref = props.forwardedRef })
		)
	end

	local RefForwardingComponent = React.forwardRef(function(props, ref)
		return React.createElement(
			Wrapper,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	local ref = React.createRef()

	ReactNoop.render(
		React.createElement(
			"div",
			{},
			React.createElement("div"),
			React.createElement(RefForwardingComponent, { ref = ref, value = 123 }),
			React.createElement("div")
		)
	)
	jestExpect(Scheduler).toFlushAndYield({ 123 })
	-- ROBLOX FIXME: When instanceof is implemented, use it
	-- jestExpect(Object.instanceof(ref.current, Child)).toBe(true)
	jestExpect(getmetatable(ref.current).__index).toBe(Child)
end)

it("should maintain child instance and ref through updates", function()
	local Child = React.Component:extend("Child")
	function Child:render()
		Scheduler.unstable_yieldValue(self.props.value)
		return nil
	end

	local function Wrapper(props)
		return React.createElement(
			Child,
			Object.assign({}, props, { ref = props.forwardedRef })
		)
	end

	local RefForwardingComponent = React.forwardRef(function(props, ref)
		return React.createElement(
			Wrapper,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	local setRefCount = 0
	local ref

	local setRef = function(r)
		setRefCount += 1
		ref = r
	end

	ReactNoop.render(
		React.createElement(RefForwardingComponent, { ref = setRef, value = 123 })
	)
	jestExpect(Scheduler).toFlushAndYield({ 123 })
	-- ROBLOX FIXME: When instanceof is implemented, use it
	-- jestExpect(Object.instanceof(ref, Child)).toBe(true)
	jestExpect(getmetatable(ref).__index).toBe(Child)
	jestExpect(setRefCount).toBe(1)
	ReactNoop.render(
		React.createElement(RefForwardingComponent, { ref = setRef, value = 456 })
	)
	jestExpect(Scheduler).toFlushAndYield({ 456 })
	-- ROBLOX FIXME: When instanceof is implemented, use it
	-- jestExpect(Object.instanceof(ref, Child)).toBe(true)
	jestExpect(getmetatable(ref).__index).toBe(Child)
	jestExpect(setRefCount).toBe(1)
end)

it("should not break lifecycle error handling", function()
	local ErrorBoundary = React.Component:extend("ErrorBoundary")
	function ErrorBoundary:init()
		self.state = { error = nil }
	end
	function ErrorBoundary:componentDidCatch(error_)
		Scheduler.unstable_yieldValue("ErrorBoundary.componentDidCatch")
		self:setState({ error = error_ })
	end
	function ErrorBoundary:render()
		if self.state.error then
			Scheduler.unstable_yieldValue("ErrorBoundary.render: catch")
			return nil
		end
		Scheduler.unstable_yieldValue("ErrorBoundary.render: try")
		return self.props.children
	end

	local BadRender = React.Component:extend("BadRender")
	function BadRender:render()
		Scheduler.unstable_yieldValue("BadRender throw")
		error(Error.new("oops!"))
	end

	local function Wrapper(props)
		local forwardedRef = props.forwardedRef
		Scheduler.unstable_yieldValue("Wrapper")
		return React.createElement(
			BadRender,
			Object.assign({}, props, { ref = forwardedRef })
		)
	end

	local RefForwardingComponent = React.forwardRef(function(props, ref)
		return React.createElement(
			Wrapper,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	local ref = React.createRef()

	ReactNoop.render(
		React.createElement(
			ErrorBoundary,
			nil,
			React.createElement(RefForwardingComponent, { ref = ref })
		)
	)
	-- ROBLOX Test Noise: jest setup config makes this hide error
	-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
	jestExpect(Scheduler).toFlushAndYield({
		"ErrorBoundary.render: try",
		"Wrapper",
		"BadRender throw",

		-- React retries one more time
		"ErrorBoundary.render: try",
		"Wrapper",
		"BadRender throw",

		-- Errored again on retry. Now handle it.
		"ErrorBoundary.componentDidCatch",
		"ErrorBoundary.render: catch",
	})
	jestExpect(ref.current).toBe(nil)
end)

it("should not re-run the render callback on a deep setState", function()
	local inst

	local Inner = React.Component:extend("Inner")
	function Inner:render()
		Scheduler.unstable_yieldValue("Inner")
		inst = self
		return React.createElement("div", { ref = self.props.forwardedRef })
	end

	local function Middle(props)
		Scheduler.unstable_yieldValue("Middle")
		return React.createElement(Inner, props)
	end

	local Forward = React.forwardRef(function(props, ref)
		Scheduler.unstable_yieldValue("Forward")
		return React.createElement(
			Middle,
			Object.assign({}, props, { forwardedRef = ref })
		)
	end)

	local function App()
		Scheduler.unstable_yieldValue("App")
		return React.createElement(Forward)
	end

	ReactNoop.render(React.createElement(App))
	jestExpect(Scheduler).toFlushAndYield({ "App", "Forward", "Middle", "Inner" })

	inst:setState({})
	jestExpect(Scheduler).toFlushAndYield({ "Inner" })
end) ]]
S.Children._27d09cfe4cfd402915d04e16751f4dd1=aq
local ar

local as={ClassName="ModuleScript",Children={},Properties={}}
as.Name="forwardRef.spec"
as.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]
-- ROBLOX FIXME Luau: this doesn't play nicely with Object.assign
--!strict

-- ROBLOX deviation: prompted by selene to add a type
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type ComparisonTestsProps = {
	a: number?,
	b: number?,
	c: number?,
}

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit

-- local PropTypes
local React
local ReactNoop
local Scheduler

describe("forwardRef", function()
	beforeEach(function()
		jest.resetModules()

		-- PropTypes = require('prop-types')
		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Dev.Scheduler)
	end)

	it("should update refs when switching between children", function()
		local function FunctionComponent(props)
			local forwardedRef = props.forwardedRef
			local setRefOnDiv = props.setRefOnDiv
			-- deviation: clearer to express this way, since we don't have real ternaries
			local firstRef, secondRef
			if setRefOnDiv then
				firstRef = forwardedRef
			else
				secondRef = forwardedRef
			end
			return React.createElement(
				"section",
				nil,
				React.createElement(
					"div",
					{ ref = firstRef },
					React.createElement("TextLabel", { Text = "First" })
				),
				React.createElement(
					"span",
					{ ref = secondRef },
					React.createElement("TextLabel", { Text = "Second" })
				)
			)
		end

		local RefForwardingComponent = React.forwardRef(function(props, ref)
			return React.createElement(
				FunctionComponent,
				Object.assign({}, props, { forwardedRef = ref })
			)
		end)

		local ref = React.createRef()

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, setRefOnDiv = true })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ref.current.type).toBe("div")

		ReactNoop.render(
			React.createElement(
				RefForwardingComponent,
				{ ref = ref, setRefOnDiv = false }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ref.current.type).toBe("span")
	end)

	it("should support rendering nil", function()
		local RefForwardingComponent = React.forwardRef(function(props, ref)
			return nil
		end)

		local ref = React.createRef()

		ReactNoop.render(React.createElement(RefForwardingComponent, { ref = ref }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ref.current).toBe(nil)
	end)

	it("should support rendering nil for multiple children", function()
		local RefForwardingComponent = React.forwardRef(function(props, ref)
			return nil
		end)

		local ref = React.createRef()

		ReactNoop.render(
			React.createElement(
				"div",
				nil,
				React.createElement("div"),
				React.createElement(RefForwardingComponent, { ref = ref }),
				React.createElement("div")
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ref.current).toBe(nil)
	end)

	-- ROBLOX TODO: PropTypes not yet supported
	xit("should support propTypes and defaultProps", function()
		-- local function FunctionComponent(props)
		--   local forwardedRef = props.forwardedRef
		--   local optional = props.optional
		--   local required = props.required
		--   return React.createElement("div", {ref=forwardedRef}, {
		--     optional,
		--     required,
		--   })
		-- end

		-- local RefForwardingComponent = React.forwardRef(function NamedFunction(
		--   props,
		--   ref,
		-- )
		--   return <FunctionComponent {...props} forwardedRef={ref} />
		-- })
		-- RefForwardingComponent.propTypes = {
		--   optional: PropTypes.string,
		--   required: PropTypes.string.isRequired,
		-- end
		-- RefForwardingComponent.defaultProps = {
		--   optional: 'default',
		-- end

		-- local ref = React.createRef()

		-- ReactNoop.render(
		--   <RefForwardingComponent ref={ref} optional="foo" required="bar" />,
		-- )
		-- jestExpect(Scheduler).toFlushWithoutYielding()
		-- jestExpect(ref.current.children).toEqual([
		--   {text: 'foo', hidden: false},
		--   {text: 'bar', hidden: false},
		-- ])

		-- ReactNoop.render(<RefForwardingComponent ref={ref} required="foo" />)
		-- jestExpect(Scheduler).toFlushWithoutYielding()
		-- jestExpect(ref.current.children).toEqual([
		--   {text: 'default', hidden: false},
		--   {text: 'foo', hidden: false},
		-- ])

		-- jestExpect(() =>
		--   ReactNoop.render(<RefForwardingComponent ref={ref} optional="foo" />),
		-- ).toErrorDev(
		--   'Warning: Failed prop type: The prop `required` is marked as required in ' +
		--     '`ForwardRef(NamedFunction)`, but its value is `undefined`.\n' +
		--     '    in NamedFunction (at **)',
		-- )
	end)

	it("should warn if not provided a callback during creation", function()
		-- deviation: no `undefined` in Lua
		-- jestExpect(function()
		--   React.forwardRef(nil)
		-- end).toErrorDev(
		--   "forwardRef requires a render function but was given undefined.",
		--   {withoutStack: true},
		-- )
		jestExpect(function()
			-- ROBLOX deviation: requires casting away type safety to run and see the warning
			(React.forwardRef :: any)(nil)
		end).toErrorDev(
			"forwardRef requires a render function but was given nil.",
			{ withoutStack = true }
		)
		jestExpect(function()
			-- ROBLOX deviation: requires casting away type safety to run and see the warning
			(React.forwardRef :: any)("foo")
		end).toErrorDev(
			"forwardRef requires a render function but was given string.",
			{ withoutStack = true }
		)
	end)

	it("should warn if no render function is provided", function()
		jestExpect(React.forwardRef).toErrorDev(
			"forwardRef requires a render function but was given nil.",
			{
				withoutStack = true,
			}
		)
	end)

	-- ROBLOX deviation: Functions can't have attributes; this test isn't needed
	xit(
		"should warn if the render function provided has propTypes or defaultProps attributes",
		function()
			-- function renderWithPropTypes(props, ref)
			--   return nil
			-- end
			-- renderWithPropTypes.propTypes = {}

			-- function renderWithDefaultProps(props, ref)
			--   return nil
			-- end
			-- renderWithDefaultProps.defaultProps = {}

			-- jestExpect(function()
			--   React.forwardRef(renderWithPropTypes)
			-- ).toErrorDev(
			--   "forwardRef render functions do not support propTypes or defaultProps. " ..
			--     "Did you accidentally pass a React component?",
			--   {withoutStack: true}
			-- )
			-- jestExpect(function()
			--   React.forwardRef(renderWithDefaultProps)
			-- ).toErrorDev(
			--   "forwardRef render functions do not support propTypes or defaultProps. " ..
			--     "Did you accidentally pass a React component?",
			--   {withoutStack: true}
			-- )
		end
	)

	it(
		"should not warn if the render function provided does not use any parameter",
		function()
			-- ROBLOX deviation: remove the function name, and don't try to access arguments that don't exist
			React.forwardRef(function()
				return React.createElement("div", { ref = "" })
			end)
		end
	)

	it(
		"should warn if the render function provided does not use the forwarded ref parameter",
		function()
			local function arityOfOne(props)
				return React.createElement("div", props)
			end

			jestExpect(function()
				React.forwardRef(arityOfOne)
			end).toErrorDev(
				"forwardRef render functions accept exactly two parameters: props and ref. "
					.. "Did you forget to use the ref parameter?",
				{ withoutStack = true }
			)
		end
	)

	it(
		"should not warn if the render function provided use exactly two parameters",
		function()
			local function arityOfTwo(_props, ref)
				React.createElement("div", { ref = ref })
			end
			React.forwardRef(arityOfTwo)
		end
	)

	it(
		"should warn if the render function provided expects to use more than two parameters",
		function()
			local function arityOfThree(_props, ref, _x)
				return React.createElement("div", { ref = ref })
			end

			jestExpect(function()
				-- ROBLOX deviation: requires casting away type safety to run and see the warning
				(React.forwardRef :: any)(arityOfThree)
			end).toErrorDev(
				"forwardRef render functions accept exactly two parameters: props and ref. "
					.. "Any additional parameter will be undefined.",
				{ withoutStack = true }
			)
		end
	)

	-- ROBLOX TODO: Support PropTypes
	xit(
		"should honor a displayName if set on the forwardRef wrapper in warnings",
		function()
			-- local Component = function(props)
			--   return React.createElement("div", props)
			-- end

			-- local RefForwardingComponent = React.forwardRef(function(props, ref)
			--   return React.createElement(Component, Object.assign({}, props, {forwardedRef=ref}))
			-- end)

			-- RefForwardingComponent.displayName = 'Foo'

			-- RefForwardingComponent.propTypes = {
			--   optional: PropTypes.string,
			--   required: PropTypes.string.isRequired,
			-- end

			-- RefForwardingComponent.defaultProps = {
			--   optional: 'default',
			-- end

			-- local ref = React.createRef()

			-- jestExpect(() =>
			--   ReactNoop.render(<RefForwardingComponent ref={ref} optional="foo" />),
			-- ).toErrorDev(
			--   'Warning: Failed prop type: The prop `required` is marked as required in ' +
			--     '`Foo`, but its value is `undefined`.\n' +
			--     '    in Foo (at **)',
			-- )
		end
	)

	-- ROBLOX deviation: Cannot add displayName attribute to function
	xit("should honor a displayName in stacks if set on the inner function", function()
		-- local Component = props => <div {...props} />

		-- local inner = (props, ref) => <Component {...props} forwardedRef={ref} />
		-- inner.displayName = 'Foo'
		-- local RefForwardingComponent = React.forwardRef(inner)

		-- RefForwardingComponent.propTypes = {
		--   optional: PropTypes.string,
		--   required: PropTypes.string.isRequired,
		-- end

		-- RefForwardingComponent.defaultProps = {
		--   optional: 'default',
		-- end

		-- local ref = React.createRef()

		-- jestExpect(() =>
		--   ReactNoop.render(<RefForwardingComponent ref={ref} optional="foo" />),
		-- ).toErrorDev(
		--   'Warning: Failed prop type: The prop `required` is marked as required in ' +
		--     '`ForwardRef(Foo)`, but its value is `undefined`.\n' +
		--     '    in Foo (at **)',
		-- )
	end)

	it("should not bailout if forwardRef is not wrapped in memo", function()
		local Component = function(props)
			return React.createElement("div", props)
		end

		local renderCount = 0

		local RefForwardingComponent = React.forwardRef(function(props, ref)
			renderCount += 1
			return React.createElement(
				Component,
				Object.assign({}, props, { forwardedRef = ref })
			)
		end)

		local ref = React.createRef()

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, optional = "foo" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, optional = "foo" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 4 or 2)
	end)

	it("should bailout if forwardRef is wrapped in memo", function()
		local Component = function(props)
			return React.createElement("div", { ref = props.forwardedRef })
		end

		local renderCount = 0

		local RefForwardingComponent = React.memo(React.forwardRef(function(props, ref)
			renderCount += 1
			return React.createElement(
				Component,
				Object.assign({}, props, { forwardedRef = ref })
			)
		end))

		local ref = React.createRef()

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, optional = "foo" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)

		jestExpect(ref.current.type).toBe("div")

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, optional = "foo" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)

		local differentRef = React.createRef()

		ReactNoop.render(
			React.createElement(
				RefForwardingComponent,
				{ ref = differentRef, optional = "foo" }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 4 or 2)

		jestExpect(ref.current).toBe(nil)
		jestExpect(differentRef.current.type).toBe("div")

		ReactNoop.render(
			React.createElement(RefForwardingComponent, { ref = ref, optional = "bar" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 6 or 3)
	end)

	it("should custom memo comparisons to compose", function()
		local Component = function(props)
			return React.createElement("div", { ref = props.forwardedRef })
		end

		local renderCount = 0

		local RefForwardingComponent = React.memo(
			React.forwardRef(function(props: ComparisonTestsProps, ref)
				renderCount += 1
				return React.createElement(
					Component,
					Object.assign({}, props, { forwardedRef = ref })
				)
			end),
			-- ROBLOX FIXME Luau: needs normalization:
			function(o: ComparisonTestsProps, p: ComparisonTestsProps)
				return o.a == p.a and o.b == p.b
			end :: any
		)

		local ref = React.createRef()

		ReactNoop.render(
			React.createElement(
				RefForwardingComponent,
				{ ref = ref, a = "0", b = "0", c = "1" }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)

		jestExpect(ref.current.type).toBe("div")

		-- Changing either a or b rerenders
		ReactNoop.render(
			React.createElement(
				RefForwardingComponent,
				{ ref = ref, a = "0", b = "1", c = "1" }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 4 or 2)

		-- Changing c doesn't rerender
		ReactNoop.render(
			React.createElement(
				RefForwardingComponent,
				{ ref = ref, a = "0", b = "1", c = "2" }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 4 or 2)

		local ComposedMemo = React.memo(
			RefForwardingComponent,
			function(o: ComparisonTestsProps, p: ComparisonTestsProps)
				return o.a == p.a and o.c == p.c
			end
		)

		ReactNoop.render(
			React.createElement(ComposedMemo, { ref = ref, a = "0", b = "0", c = "0" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 6 or 3)

		-- Changing just b no longer updates
		ReactNoop.render(
			React.createElement(ComposedMemo, { ref = ref, a = "0", b = "1", c = "0" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 6 or 3)

		-- Changing just a and c updates
		ReactNoop.render(
			React.createElement(ComposedMemo, { ref = ref, a = "2", b = "2", c = "2" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 8 or 4)

		-- Changing just c does not update
		ReactNoop.render(
			React.createElement(ComposedMemo, { ref = ref, a = "2", b = "2", c = "3" })
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 8 or 4)

		-- Changing ref still rerenders
		local differentRef = React.createRef()

		ReactNoop.render(
			React.createElement(
				ComposedMemo,
				{ ref = differentRef, a = "2", b = "2", c = "3" }
			)
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(renderCount).toBe(_G.__DEV__ and 10 or 5)

		jestExpect(ref.current).toBe(nil)
		jestExpect(differentRef.current.type).toBe("div")
	end)

	it("warns on forwardRef(memo(...))", function()
		jestExpect(function()
			-- ROBLOX deviation: this vioaltes strong types, so we have to cast away safety to test runtime check
			(React.forwardRef :: any)(React.memo(function(props, ref)
				return nil
			end))
		end).toErrorDev({
			"Warning: forwardRef requires a render function but received a `memo` "
				.. "component. Instead of forwardRef(memo(...)), use "
				.. "memo(forwardRef(...)).",
		}, {
			withoutStack = true,
		})
	end)

	-- ROBLOX deviation: Regression test for bad metatable logic
	it("allows new fields to be assigned on it", function()
		local MyComponent = React.forwardRef(function(_props, _ref)
			return nil
		end)
		MyComponent.SomeEnum = { ValueA = 1, ValueB = 2 }

		jestExpect(MyComponent.SomeEnum).never.toBeNil()
		jestExpect(MyComponent.SomeEnum.ValueA).toBe(1)
		jestExpect(MyComponent.SomeEnum.ValueB).toBe(2)
	end)
end) ]]
S.Children._e1812e2293920e75ea5a0b320779993d=as
local at

local au={ClassName="ModuleScript",Children={},Properties={}}
au.Name="createSignal.roblox"
au.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/Roblox/roact/blob/master/src/createSignal.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

type Function = (...any) -> ...any
--\[\[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
\]\]

type Connection = { callback: Function, disconnected: boolean }
type Map<K, V> = { [K]: V }

local function createSignal(): ((Function) -> (() -> ()), (...any) -> ())
	local connections: Map<Function, Connection> = {}
	local suspendedConnections = {}
	local firing = false

	local function subscribe(callback)
		assert(
			typeof(callback) == "function",
			"Can only subscribe to signals with a function."
		)

		local connection = {
			callback = callback,
			disconnected = false,
		}

		-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable
		-- the existing one.
		if firing and not connections[callback] then
			suspendedConnections[callback] = connection
		end

		connections[callback] = connection

		local function disconnect()
			assert(
				not connection.disconnected,
				"Listeners can only be disconnected once."
			)

			connection.disconnected = true
			connections[callback] = nil
			suspendedConnections[callback] = nil
		end

		return disconnect
	end

	local function fire(...)
		firing = true
		for callback, connection in connections do
			if not connection.disconnected and not suspendedConnections[callback] then
				callback(...)
			end
		end

		firing = false

		-- ROBLOX performance: use table.clear
		table.clear(suspendedConnections)
	end

	return subscribe, fire
end

return createSignal ]]
m.Children._2b3001d9191f9a788c1162942516a1f7=au
local av

local aw={ClassName="ModuleScript",Children={},Properties={}}
aw.Name="ReactCache"
aw.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-cache/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
-- ROBLOX deviation START: simplify
-- local Packages --\[\[ ROBLOX comment: must define Packages module \]\]
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Object = LuauPolyfill.Object
-- local exports = {}
--
-- Object.assign(exports, require(script.src.ReactCacheOld))
-- return exports
return require(script.ReactCacheOld)
-- ROBLOX deviation END ]]
c.Children._aea7b946f147338237e0e9e1684f2310=aw
local ax
local ay={ClassName="ModuleScript",Children={},Properties={}}
ay.Name="LRU"
ay.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-cache/src/LRU.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object
local exports = {}
-- ROBLOX deviation START: fix import
-- local Scheduler = require(Packages.scheduler) -- Intentionally not named imports because Rollup would
local Scheduler = require(Packages.Scheduler)
-- ROBLOX deviation END
-- use dynamic dispatch for CommonJS interop named imports.
local scheduleCallback, IdlePriority =
	Scheduler.unstable_scheduleCallback, Scheduler.unstable_IdlePriority
-- ROBLOX deviation START: use next_ instead
-- type Entry<T> = { value: T, onDelete: () -> unknown, previous: Entry<T>, next: Entry<T> }
export type Entry<T> = {
	value: T,
	onDelete: () -> ...unknown,
	previous: Entry<T>,
	next_: Entry<T>,
}
-- ROBLOX deviation END
local function createLRU<T>(limit: number)
	-- ROBLOX deviation START: add predeclared methods to fix declaration ordering problems
	local deleteLeastRecentlyUsedEntries
	local cleanUp
	-- ROBLOX deviation END
	local LIMIT = limit -- Circular, doubly-linked list
	local first: Entry<T> | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] =
		nil
	local size: number = 0
	local cleanUpIsScheduled: boolean = false
	local function scheduleCleanUp()
		if
			cleanUpIsScheduled == false
			and size > LIMIT --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
		then
			-- The cache size exceeds the limit. Schedule a callback to delete the
			-- least recently used entries.
			cleanUpIsScheduled = true
			scheduleCallback(IdlePriority, cleanUp)
		end
	end
	-- ROBLOX deviation START: predeclared function
	-- local function cleanUp()
	function cleanUp()
		-- ROBLOX deviation END
		cleanUpIsScheduled = false
		deleteLeastRecentlyUsedEntries(LIMIT)
	end
	-- ROBLOX deviation START: predeclared function
	-- local function deleteLeastRecentlyUsedEntries(targetSize: number)
	function deleteLeastRecentlyUsedEntries(targetSize: number)
		-- ROBLOX deviation END
		-- Delete entries from the cache, starting from the end of the list.
		if first ~= nil then
			local resolvedFirst: Entry<T> = first :: any
			-- ROBLOX deviation START: explicitly type last
			-- local last = resolvedFirst.previous
			local last: Entry<T>? = resolvedFirst.previous
			-- ROBLOX deviation END
			while
				size > targetSize --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
				and last ~= nil
			do
				local onDelete = last.onDelete
				local previous = last.previous
				last.onDelete = nil :: any -- Remove from the list
				-- ROBLOX deviation START: use next_ instead
				-- last.next = nil :: any
				-- last.previous = last.next
				last.next_ = nil :: any
				last.previous = last.next_
				-- ROBLOX deviation END
				if last == first then
					-- Reached the head of the list.
					last = nil
					first = last
				else
					(first :: any).previous = previous
					-- ROBLOX deviation START: use next_ instead
					-- previous.next = first :: any
					previous.next_ = first :: any
					-- ROBLOX deviation END
					last = previous
				end
				size -= 1 -- Call the destroy method after removing the entry from the list. If it
				-- throws, the rest of cache will not be deleted, but it will be in a
				-- valid state.
				onDelete()
			end
		end
	end
	local function add(value: Object, onDelete: () -> unknown): Entry<Object>
		local entry = {
			value = value,
			onDelete = onDelete,
			-- ROBLOX deviation START: use next_ instead
			-- next = nil :: any,
			next_ = nil :: any,
			-- ROBLOX deviation END
			previous = nil :: any,
			-- ROBLOX deviation START: need to cast to Entry<any>
			-- }
		} :: Entry<any>
		-- ROBLOX deviation END
		if first == nil then
			-- ROBLOX deviation START: use next_ instead
			-- entry.next = entry
			-- entry.previous = entry.next
			entry.next_ = entry
			entry.previous = entry.next_
			-- ROBLOX deviation END
			first = entry
		else
			-- Append to head
			local last = first.previous
			-- ROBLOX deviation START: use next_ instead
			-- last.next = entry
			last.next_ = entry
			-- ROBLOX deviation END
			entry.previous = last
			first.previous = entry
			-- ROBLOX deviation START: use next_ instead
			-- entry.next = first
			entry.next_ = first
			-- ROBLOX deviation END
			first = entry
		end
		size += 1
		return entry
	end
	local function update(entry: Entry<T>, newValue: T): ()
		entry.value = newValue
	end
	local function access(entry: Entry<T>): T
		-- ROBLOX deviation START: use next_ instead
		-- local next_ = entry.next
		local next_ = entry.next_
		-- ROBLOX deviation END
		if next_ ~= nil then
			-- Entry already cached
			local resolvedFirst: Entry<T> = first :: any
			if first ~= entry then
				-- Remove from current position
				local previous = entry.previous
				-- ROBLOX deviation START: use next_ instead
				-- previous.next = next_
				previous.next_ = next_
				-- ROBLOX deviation END
				next_.previous = previous -- Append to head
				local last = resolvedFirst.previous
				-- ROBLOX deviation START: use next_ instead
				-- last.next = entry
				last.next_ = entry
				-- ROBLOX deviation END
				entry.previous = last
				resolvedFirst.previous = entry
				-- ROBLOX deviation START: use next_ instead
				-- entry.next = resolvedFirst
				entry.next_ = resolvedFirst
				-- ROBLOX deviation END
				first = entry
			end
		else
			-- Cannot access a deleted entry
			-- TODO: Error? Warning?
		end
		scheduleCleanUp()
		return entry.value
	end
	local function setLimit(newLimit: number)
		LIMIT = newLimit
		scheduleCleanUp()
	end
	return { add = add, update = update, access = access, setLimit = setLimit }
end
exports.createLRU = createLRU
return exports ]]
ax.Children._88b5ba91171ea114f810ce4b2fbd5c63=ay
local az

local aA={ClassName="ModuleScript",Children={},Properties={}}
aA.Name="ReactCacheOld"
aA.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-cache/src/ReactCacheOld.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: unnecessary import
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
-- ROBLOX deviation START: add inspect to print objects
local inspect = LuauPolyfill.util.inspect
-- ROBLOX deviation END
-- ROBLOX deviation START: not needed
-- local Error = LuauPolyfill.Error
-- local Map = LuauPolyfill.Map
-- ROBLOX deviation END
-- ROBLOX deviation START: use console from React Shared
-- local console = LuauPolyfill.console
local console = require(Packages.Shared).console
-- ROBLOX deviation END
type Map<T, U> = LuauPolyfill.Map<T, U>
local exports = {}
-- ROBLOX deviation START: add predeclared methods to fix declaration ordering
local deleteEntry
-- ROBLOX deviation END
-- ROBLOX deviation START: fix import
-- local sharedReactTypesModule = require(Packages.shared.ReactTypes)
-- type Thenable = sharedReactTypesModule.Thenable
local ReactTypes = require(Packages.Shared)
type Thenable<R> = ReactTypes.Thenable<R>
-- ROBLOX deviation END
local React = require(Packages.React)
local createLRU = require(script.Parent.LRU).createLRU
-- ROBLOX deviation START: add this type in an attempt to tighten up the types to detect bugs found manually
local LRU = require(script.Parent.LRU)
type Entry<T> = LRU.Entry<T>
type Record<K, V> = { [K]: V }
-- ROBLOX deviation END
-- ROBLOX deviation START: change then to andThen
-- type Suspender = { ["then"]: (resolve: () -> unknown, reject: () -> unknown) -> unknown } --\[\[ ROBLOX CHECK: inexact type upstream which is not supported by Luau. Verify if it doesn't break the analyze \]\]
type Suspender = {
	andThen: (
		self: Suspender,
		resolve: (...any) -> () | Suspender,
		reject: (...any) -> () | Suspender
	) -> () | Suspender,
}
-- ROBLOX deviation END
type PendingResult = {
	status: number,--\[\[ ROBLOX NOTE: changed '0' to 'number' as Luau doesn't support numeric singleton types \]\]
	value: Suspender,
}
type ResolvedResult<V> = {
	status: number,--\[\[ ROBLOX NOTE: changed '1' to 'number' as Luau doesn't support numeric singleton types \]\]
	value: V,
}
type RejectedResult = {
	status: number,--\[\[ ROBLOX NOTE: changed '2' to 'number' as Luau doesn't support numeric singleton types \]\]
	value: unknown,
}
type Result<V> = PendingResult | ResolvedResult<V> | RejectedResult
type Resource<I, V> = { read: (I) -> V, preload: (I) -> () } --\[\[ ROBLOX CHECK: inexact type upstream which is not supported by Luau. Verify if it doesn't break the analyze \]\]
local Pending = 0
local Resolved = 1
local Rejected = 2
local ReactCurrentDispatcher =
	-- ROBLOX deviation START: import from Shared package
	-- React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
	require(Packages.Shared).ReactSharedInternals.ReactCurrentDispatcher
-- ROBLOX deviation END
local function readContext(Context, observedBits)
	local dispatcher = ReactCurrentDispatcher.current
	if dispatcher == nil then
		error(
			"react-cache: read and preload may only be called from within a "
				.. "component's render. They are not supported in event handlers or "
				.. "lifecycle methods."
		)
	end
	-- ROBLOX deviation START: use dot notation and additional cast as Luau doesn't narrow type to non-nil
	-- return dispatcher:readContext(Context, observedBits)
	return (dispatcher :: any).readContext(Context, observedBits)
	-- ROBLOX deviation END
end
local function identityHashFn(input)
	-- ROBLOX deviation START: remove unnecessary toJSBoolean and use _G
	-- if Boolean.toJSBoolean(__DEV__) then
	if _G.__DEV__ then
		-- ROBLOX deviation END
		if
			typeof(input) ~= "string"
			and typeof(input) ~= "number"
			and typeof(input) ~= "boolean"
			and input ~= nil
			-- ROBLOX deviation START: unnecessary duplicated condition - no difference between null and undefined
			-- and input ~= nil
			-- ROBLOX deviation END
		then
			console.error(
				"Invalid key type. Expected a string, number, symbol, or boolean, "
					.. "but instead received: %s"
					.. "\n\nTo use non-primitive values as keys, you must pass a hash "
					.. "function as the second argument to createResource().",
				-- ROBLOX deviation START: use inspect to print object
				-- input
				inspect(input)
				-- ROBLOX deviation END
			)
		end
	end
	return input
end
local CACHE_LIMIT = 500
local lru = createLRU(CACHE_LIMIT)
-- ROBLOX deviation START: tightened this up versus upstream to try and detect more bugs
-- local entries: Map<Resource<any, any>, Map<any, any>> = Map.new()
local entries: Record<Resource<any, any>, Record<number, Entry<any>>> = {}
-- ROBLOX deviation END
local CacheContext = React.createContext(nil)
local function accessResult<I, K, V>(
	resource: any,
	fetch: (I) -> Thenable<V>,
	input: I,
	key: K
): Result<V>
	-- ROBLOX deviation START: use regular indexing instead
	-- local entriesForResource = entries:get(resource)
	local entriesForResource = entries[resource]
	-- ROBLOX deviation END
	if entriesForResource == nil then
		-- ROBLOX deviation START: use table instead
		-- entriesForResource = Map.new()
		entriesForResource = {}
		-- ROBLOX deviation END
		-- ROBLOX deviation START: cast as Luau doesn't narrow type on itself and use regular index setting
		-- entries:set(resource, entriesForResource)
		entries[resource] = entriesForResource :: Record<number, Entry<any>>
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation START: cast as Luau doesn't narrow type on itself
	-- local entry = entriesForResource:get(key)
	local entriesForResource_ = (
		entriesForResource :: Record<any, Entry<any>>
	) :: Record<K, Entry<any>>
	local entry = entriesForResource_[key]
	-- ROBLOX deviation END
	if entry == nil then
		local thenable = fetch(input)
		-- ROBLOX deviation START: add reordered declaration so newResults so it can be referenced in andThen()
		local newResult: PendingResult = {
			status = Pending,
			value = thenable :: any,
		}
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use andThen
		-- thenable:then_(function(value)
		thenable:andThen(function(value)
			-- ROBLOX deviation END
			if newResult.status == Pending then
				local resolvedResult: ResolvedResult<V> = newResult :: any
				resolvedResult.status = Resolved
				resolvedResult.value = value
			end
			-- ROBLOX deviation START: explicit return type
			-- end, function(error_)
		end, function(error_): ()
			-- ROBLOX deviation END
			if newResult.status == Pending then
				local rejectedResult: RejectedResult = newResult :: any
				rejectedResult.status = Rejected
				rejectedResult.value = error_
			end
		end)
		-- ROBLOX deviation START: skip reordered code
		-- local newResult: PendingResult = { status = Pending, value = thenable }
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use dot notation
		-- local newEntry = lru:add(newResult, function(...)
		local newEntry = lru.add(newResult, function(...)
			-- ROBLOX deviation END
			-- ROBLOX deviation START: deleteEntry doesn't use 'self'
			-- return deleteEntry(nil, resource, key, ...)
			return deleteEntry(resource, key :: any)
			-- ROBLOX deviation END
		end)
		-- ROBLOX deviation START: use casted variable as Luau doesn't narrow type on itself
		-- entriesForResource:set(key, newEntry)
		entriesForResource_[key] = newEntry
		-- ROBLOX deviation END
		return newResult
	else
		-- ROBLOX deviation START: use dot notation
		-- return lru:access(entry) :: any
		return lru.access(entry) :: any
		-- ROBLOX deviation END
	end
end
-- ROBLOX deviation START: predeclared function
-- local function deleteEntry(resource, key)
function deleteEntry(resource, key): ()
	-- ROBLOX deviation END
	-- ROBLOX deviation START: use regular indexer
	-- local entriesForResource = entries:get(resource)
	local entriesForResource = entries[resource]
	-- ROBLOX deviation END
	if entriesForResource ~= nil then
		-- ROBLOX deviation START: set property to nil instead
		-- entriesForResource:delete(key)
		entriesForResource[key] = nil
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use # operator instead
		-- if entriesForResource.size == 0 then
		if #entriesForResource == 0 then
			-- ROBLOX deviation END
			-- ROBLOX deviation START: set property to nil instead
			-- entries:delete(resource)
			entries[resource] = nil
			-- ROBLOX deviation END
		end
	end
end
local function unstable_createResource<
	I,
	K, --\[\[ ROBLOX CHECK: upstream type uses type constraint which is not supported by Luau \]\] --\[\[ K: string | number \]\]
	V
>(
	fetch: (
		I
	) -> Thenable<V>,
	maybeHashInput: (
		(I) -> K
	)?
): Resource<
	I,
	V
>
	local hashInput: (I) -> K = if maybeHashInput ~= nil
		then maybeHashInput
		else identityHashFn :: any
	-- ROBLOX deviation START: split declaration and assignment
	-- local resource = {
	local resource
	resource = {
		-- ROBLOX deviation END
		-- ROBLOX deviation START: no self param
		-- read = function(self, input: I): V
		read = function(input: I): V
			-- ROBLOX deviation END
			-- react-cache currently doesn't rely on context, but it may in the
			-- future, so we read anyway to prevent access outside of render.
			readContext(CacheContext)
			local key = hashInput(input)
			local result: Result<V> = accessResult(resource, fetch, input, key)
			-- ROBLOX deviation START: simplify switch statement conversion
			-- repeat --\[\[ ROBLOX comment: switch statement conversion \]\]
			-- 	local entered_, break_ = false, false
			-- 	local condition_ = result.status
			-- 	for _, v in ipairs({ Pending, Resolved, Rejected }) do
			-- 		if condition_ == v then
			-- 			if v == Pending then
			-- 				entered_ = true
			-- 				do
			-- 					local suspender = result.value
			-- 					error(suspender)
			-- 				end
			-- 			end
			-- 			if v == Resolved or entered_ then
			-- 				entered_ = true
			-- 				do
			-- 					local value = result.value
			-- 					return value
			-- 				end
			-- 			end
			-- 			if v == Rejected or entered_ then
			-- 				entered_ = true
			-- 				do
			-- 					local error_ = result.value
			-- 					error(error_)
			-- 				end
			-- 			end
			-- 		end
			-- 	end
			-- 	if not break_ then
			-- 		-- Should be unreachable
			-- 		return nil :: any
			-- 	end
			-- until true
			if result.status == Pending then
				local suspender = result.value
				error(suspender)
			elseif result.status == Resolved then
				local value = result.value
				-- ROBLOX deviation START: needs cast to narrow type
				-- return value
				return value :: V
				-- ROBLOX deviation END
			elseif result.status == Rejected then
				local error_ = result.value
				error(error_)
			else
				-- Should be unreachable
				return nil :: any
			end
			-- ROBLOX deviation END
		end,
		-- ROBLOX deviation START: no self param
		-- preload = function(self, input: I): ()
		preload = function(input: I): ()
			-- ROBLOX deviation END
			-- react-cache currently doesn't rely on context, but it may in the
			-- future, so we read anyway to prevent access outside of render.
			readContext(CacheContext)
			local key = hashInput(input)
			accessResult(resource, fetch, input, key)
		end,
	}
	return resource
end
exports.unstable_createResource = unstable_createResource
local function unstable_setGlobalCacheLimit(limit: number)
	-- ROBLOX deviation START: use dot notation
	-- lru:setLimit(limit)
	lru.setLimit(limit)
	-- ROBLOX deviation END
end
exports.unstable_setGlobalCacheLimit = unstable_setGlobalCacheLimit
return exports ]]
ax.Children._7889371d09e9908d89037908d18f2cfb=aA
local aB

local aC={ClassName="Folder",Children={},Properties={}}
aC.Name="__tests__"
ax.Children._fd041b8407b893d6649c901e39d93079=aC
local aD
local aE={ClassName="ModuleScript",Children={},Properties={}}
aE.Name="ReactCacheOld-internal.spec"
aE.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-cache/src/__tests__/ReactCacheOld-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: unused imports
-- local Array = LuauPolyfill.Array
-- local Boolean = LuauPolyfill.Boolean
-- local Error = LuauPolyfill.Error
-- ROBLOX deviation END
-- ROBLOX deviation START: add additional types
type Error = LuauPolyfill.Error
-- ROBLOX deviation END
local setTimeout = LuauPolyfill.setTimeout
-- ROBLOX deviation START: import promise from dev dependencies
-- local Promise = require(Packages.Promise)
local Promise = require(Packages.Dev.Promise)
-- ROBLOX deviation END
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest

local ReactCache
local createResource
local React
local ReactFeatureFlags
local ReactTestRenderer
local Scheduler
local Suspense
local TextResource
local textResourceShouldFail
describe("ReactCache", function()
	beforeEach(function()
		jest.resetModules()
		-- ROBLOX deviation START: add useFakeTimers call
		jest.useFakeTimers()
		-- ROBLOX deviation END
		-- ROBLOX deviation START: fix require
		-- ReactFeatureFlags = require_("shared/ReactFeatureFlags")
		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		-- ROBLOX deviation END
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		-- ROBLOX deviation START: fix require
		-- React = require_("react")
		React = require(Packages.React)
		-- ROBLOX deviation END
		Suspense = React.Suspense
		-- ROBLOX deviation START: fix require
		-- ReactCache = require_("react-cache")
		ReactCache = require(script.Parent.Parent)
		-- ROBLOX deviation END
		createResource = ReactCache.unstable_createResource
		-- ROBLOX deviation START: fix requires
		-- ReactTestRenderer = require_("react-test-renderer")
		-- Scheduler = require_("scheduler")
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		Scheduler = require(Packages.Scheduler)
		-- ROBLOX deviation END
		-- ROBLOX deviation START: explicit type
		-- TextResource = createResource(function(ref0)
		-- 	local text = ref0[1]
		TextResource = createResource(function(ref0: { string | number })
			local text = ref0[1] :: string
			-- ROBLOX deviation END
			-- ROBLOX deviation START: simplify
			-- local ms = (function()
			-- 	local element = table.unpack(ref0, 2, 2)
			-- 	if element == nil then
			-- 		return 0
			-- 	else
			-- 		return element
			-- 	end
			-- end)()
			local ms = ref0[2] or 0
			-- ROBLOX deviation END
			local listeners = nil
			local status = "pending"
			-- ROBLOX deviation START: explicit type
			-- local value = nil
			local value = nil :: string | Error | nil
			-- ROBLOX deviation END
			return {
				-- ROBLOX deviation START: use andThen
				-- ["then"] = function(self, resolve, reject)
				andThen = function(self, resolve, reject)
					-- ROBLOX deviation END
					-- ROBLOX deviation START: simplify switch statement conversion
					-- repeat --\[\[ ROBLOX comment: switch statement conversion \]\]
					-- 	local condition_ = status
					-- 	if condition_ == "pending" then
					-- 		do
					-- 			if listeners == nil then
					-- 				listeners = { { resolve = resolve, reject = reject } }
					-- 				setTimeout(function()
					-- 					if
					-- 						Boolean.toJSBoolean(textResourceShouldFail)
					-- 					then
					-- 						Scheduler:unstable_yieldValue(
					-- 							("Promise rejected [%s]"):format(
					-- 								tostring(text)
					-- 							)
					-- 						)
					-- 						status = "rejected"
					-- 						value = Error.new(
					-- 							"Failed to load: " .. tostring(text)
					-- 						)
					-- 						Array.forEach(listeners, function(listener)
					-- 							return listener:reject(value)
					-- 						end) --\[\[ ROBLOX CHECK: check if 'listeners' is an Array \]\]
					-- 					else
					-- 						Scheduler:unstable_yieldValue(
					-- 							("Promise resolved [%s]"):format(
					-- 								tostring(text)
					-- 							)
					-- 						)
					-- 						status = "resolved"
					-- 						value = text
					-- 						Array.forEach(listeners, function(listener)
					-- 							return listener:resolve(value)
					-- 						end) --\[\[ ROBLOX CHECK: check if 'listeners' is an Array \]\]
					-- 					end
					-- 				end, ms)
					-- 			else
					-- 				table.insert(
					-- 					listeners,
					-- 					{ resolve = resolve, reject = reject }
					-- 				) --\[\[ ROBLOX CHECK: check if 'listeners' is an Array \]\]
					-- 			end
					-- 			break
					-- 		end
					-- 	elseif condition_ == "resolved" then
					-- 		do
					-- 			resolve(value)
					-- 			break
					-- 		end
					-- 	elseif condition_ == "rejected" then
					-- 		do
					-- 			reject(value)
					-- 			break
					-- 		end
					-- 	end
					-- until true
					if status == "pending" then
						if listeners == nil then
							listeners = { { resolve = resolve, reject = reject } }
							LuauPolyfill.setTimeout(function()
								if textResourceShouldFail then
									Scheduler.unstable_yieldValue(
										string.format("Promise rejected [%s]", text)
									)
									status = "rejected"
									value =
										LuauPolyfill.Error.new("Failed to load: " .. text)
									for _, listener in listeners do
										listener.reject(value)
									end
								else
									Scheduler.unstable_yieldValue(
										string.format("Promise resolved [%s]", text)
									)
									status = "resolved"
									value = text
									for _, listener in listeners do
										listener.resolve(value)
									end
								end
							end, ms)
						else
							table.insert(
								listeners,
								{ resolve = resolve, reject = reject }
							)
						end
					elseif status == "resolved" then
						resolve(value)
					elseif status == "rejected" then
						reject(value)
					end
					-- ROBLOX deviation END
				end,
			}
		end, function(ref0)
			-- ROBLOX deviation START: ms not used
			-- local text, ms = table.unpack(ref0, 1, 2)
			-- return text
			return ref0[1]
			-- ROBLOX deviation END
		end)
		textResourceShouldFail = false
	end)
	local function Text(props)
		-- ROBLOX deviation START: use dot notation
		-- Scheduler:unstable_yieldValue(props.text)
		Scheduler.unstable_yieldValue(props.text)
		-- ROBLOX deviation END
		return props.text
	end
	-- ROBLOX deviation START: explicit type
	-- local function AsyncText(props)
	local function AsyncText(props: { ms: number, text: string | number })
		-- ROBLOX deviation END
		local text = props.text
		do --\[\[ ROBLOX COMMENT: try-catch block conversion \]\]
			-- ROBLOX deviation START: use pcall
			-- local ok, result, hasReturned = xpcall(function()
			local ok, result = pcall(function()
				-- ROBLOX deviation END
				-- ROBLOX deviation START: use dot notation
				-- TextResource:read({ props.text, props.ms })
				-- Scheduler:unstable_yieldValue(text)
				TextResource.read({ props.text :: string | number, props.ms })
				Scheduler.unstable_yieldValue(text)
				-- ROBLOX deviation END
				-- ROBLOX deviation START: using pcall
				-- 	return text, true
				-- end, function(promise)
				return text
			end)
			if not ok then
				local promise = result
				-- ROBLOX deviation END
				-- ROBLOX deviation START: use andThen
				-- if typeof(promise["then"]) == "function" then
				if typeof(promise.andThen) == "function" then
					-- ROBLOX deviation END
					-- ROBLOX deviation START: use dot notation
					-- Scheduler:unstable_yieldValue(
					Scheduler.unstable_yieldValue(
						-- ROBLOX deviation END
						("Suspend! [%s]"):format(tostring(text))
					)
				else
					-- ROBLOX deviation START: use dot notation
					-- Scheduler:unstable_yieldValue(("Error! [%s]"):format(tostring(text)))
					Scheduler.unstable_yieldValue(("Error! [%s]"):format(tostring(text)))
					-- ROBLOX deviation END
				end
				error(promise)
				-- ROBLOX deviation START: using pcall
				-- end)
				-- if hasReturned then
				-- 	return result
				-- end
			end
			return result
			-- ROBLOX deviation END
		end
	end
	it("throws a promise if the requested value is not in the cache", function()
		local function App()
			return React.createElement(
				Suspense,
				{ fallback = React.createElement(Text, { text = "Loading..." }) },
				React.createElement(AsyncText, { ms = 100, text = "Hi" })
			)
		end
		ReactTestRenderer.create(
			React.createElement(App, nil),
			{ unstable_isConcurrent = true }
		)
		expect(Scheduler).toFlushAndYield({ "Suspend! [Hi]", "Loading..." })
		jest.advanceTimersByTime(100)
		expect(Scheduler).toHaveYielded({ "Promise resolved [Hi]" })
		expect(Scheduler).toFlushAndYield({ "Hi" })
	end)
	it("throws an error on the subsequent read if the promise is rejected", function()
		return Promise.resolve():andThen(function()
			local function App()
				return React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(AsyncText, { ms = 100, text = "Hi" })
				)
			end
			local root = ReactTestRenderer.create(
				React.createElement(App, nil),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toFlushAndYield({ "Suspend! [Hi]", "Loading..." })
			textResourceShouldFail = true
			jest.advanceTimersByTime(100)
			expect(Scheduler).toHaveYielded({ "Promise rejected [Hi]" })
			expect(Scheduler).toFlushAndThrow("Failed to load: Hi")
			expect(Scheduler).toHaveYielded({ "Error! [Hi]", "Error! [Hi]" }) -- Should throw again on a subsequent read
			-- ROBLOX deviation START: use dot notation
			-- root:update(React.createElement(App, nil))
			root.update(React.createElement(App, nil))
			-- ROBLOX deviation END
			expect(Scheduler).toFlushAndThrow("Failed to load: Hi")
			expect(Scheduler).toHaveYielded({ "Error! [Hi]", "Error! [Hi]" })
		end)
	end)
	it(
		"warns if non-primitive key is passed to a resource without a hash function",
		function()
			-- ROBLOX deviation START: explicit type
			-- local BadTextResource = createResource(function(ref0)
			-- 	local text = ref0[1]
			local BadTextResource = createResource(function(ref0: { string | number })
				local text = ref0[1] :: string
				-- ROBLOX deviation END
				-- ROBLOX deviation START: simplify
				-- local ms = (function()
				-- 	local element = table.unpack(ref0, 2, 2)
				-- 	if element == nil then
				-- 		return 0
				-- 	else
				-- 		return element
				-- 	end
				-- end)()
				local ms = ref0[2] or 0
				-- ROBLOX deviation END
				return Promise.new(function(resolve, reject)
					return setTimeout(function()
						resolve(text)
					end, ms)
				end)
			end)
			local function App()
				-- ROBLOX deviation START: use dot notation and cast type because luau doesn't support mixed arrays
				-- Scheduler:unstable_yieldValue("App")
				-- return BadTextResource:read({ "Hi", 100 })
				Scheduler.unstable_yieldValue("App")
				return BadTextResource.read({ "Hi" :: string | number, 100 })
				-- ROBLOX deviation END
			end
			ReactTestRenderer.create(
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(App, nil)
				),
				{ unstable_isConcurrent = true }
			)
			-- ROBLOX deviation START: remove toJSBoolean and use _G
			-- if Boolean.toJSBoolean(__DEV__) then
			if _G.__DEV__ then
				-- ROBLOX deviation END
				expect(function()
					expect(Scheduler).toFlushAndYield({ "App", "Loading..." })
				end).toErrorDev({
					"Invalid key type. Expected a string, number, symbol, or "
						-- ROBLOX deviation START: FIXME - make console polyfill format arrays the same as JS
						-- .. "boolean, but instead received: Hi,100\n\n"
						.. 'boolean, but instead received: ["Hi", 100]\n\n'
						-- ROBLOX deviation END
						.. "To use non-primitive values as keys, you must pass a hash "
						.. "function as the second argument to createResource().",
				})
			else
				expect(Scheduler).toFlushAndYield({ "App", "Loading..." })
			end
		end
	)
	it("evicts least recently used values", function()
		return Promise.resolve():andThen(function()
			-- ROBLOX deviation START: use dot notation
			-- ReactCache:unstable_setGlobalCacheLimit(3) -- Render 1, 2, and 3
			ReactCache.unstable_setGlobalCacheLimit(3)
			-- ROBLOX deviation END
			local root = ReactTestRenderer.create(
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(AsyncText, { ms = 100, text = 1 }),
					React.createElement(AsyncText, { ms = 100, text = 2 }),
					React.createElement(AsyncText, { ms = 100, text = 3 })
				),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toFlushAndYield({
				"Suspend! [1]",
				"Suspend! [2]",
				"Suspend! [3]",
				"Loading...",
			})
			jest.advanceTimersByTime(100)
			expect(Scheduler).toHaveYielded({
				"Promise resolved [1]",
				"Promise resolved [2]",
				"Promise resolved [3]",
			})
			expect(Scheduler).toFlushAndYield({ 1, 2, 3 })
			expect(root).toMatchRenderedOutput("123") -- Render 1, 4, 5
			-- ROBLOX deviation START: use dot notation
			-- root:update(
			root.update(
				-- ROBLOX deviation END
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(AsyncText, { ms = 100, text = 1 }),
					React.createElement(AsyncText, { ms = 100, text = 4 }),
					React.createElement(AsyncText, { ms = 100, text = 5 })
				)
			)
			expect(Scheduler).toFlushAndYield({
				-- ROBLOX deviation START: Luau doesn't support mixed arrays
				-- 1,
				1 :: number | string,
				-- ROBLOX deviation END
				"Suspend! [4]",
				"Suspend! [5]",
				"Loading...",
			})
			jest.advanceTimersByTime(100)
			expect(Scheduler).toHaveYielded({
				"Promise resolved [4]",
				"Promise resolved [5]",
			})
			expect(Scheduler).toFlushAndYield({ 1, 4, 5 })
			expect(root).toMatchRenderedOutput("145") -- We've now rendered values 1, 2, 3, 4, 5, over our limit of 3. The least
			-- recently used values are 2 and 3. They should have been evicted.
			-- ROBLOX deviation START: use dot notation
			-- root:update(
			root.update(
				-- ROBLOX deviation END
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(AsyncText, { ms = 100, text = 1 }),
					React.createElement(AsyncText, { ms = 100, text = 2 }),
					React.createElement(AsyncText, { ms = 100, text = 3 })
				)
			)
			expect(Scheduler).toFlushAndYield({
				-- 1 is still cached
				-- ROBLOX deviation START: Luau doesn't support mixed arrays
				-- 1,
				1 :: number | string,
				-- ROBLOX deviation END
				-- 2 and 3 suspend because they were evicted from the cache
				"Suspend! [2]",
				"Suspend! [3]",
				"Loading...",
			})
			jest.advanceTimersByTime(100)
			expect(Scheduler).toHaveYielded({
				"Promise resolved [2]",
				"Promise resolved [3]",
			})
			expect(Scheduler).toFlushAndYield({ 1, 2, 3 })
			expect(root).toMatchRenderedOutput("123")
		end)
	end, 9999999999)
	it("preloads during the render phase", function()
		return Promise.resolve():andThen(function()
			local function App()
				-- ROBLOX deviation START: use dot notation
				-- TextResource:preload({ "B", 1000 })
				-- TextResource:read({ "A", 1000 })
				-- TextResource:read({ "B", 1000 })
				TextResource.preload({ "B", 1000 })
				TextResource.read({ "A", 1000 })
				TextResource.read({ "B", 1000 })
				-- ROBLOX deviation END
				return React.createElement(Text, { text = "Result" })
			end
			local root = ReactTestRenderer.create(
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(App, nil)
				),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toFlushAndYield({ "Loading..." })
			jest.advanceTimersByTime(1000)
			expect(Scheduler).toHaveYielded({
				"Promise resolved [B]",
				"Promise resolved [A]",
			})
			expect(Scheduler).toFlushAndYield({ "Result" })
			expect(root).toMatchRenderedOutput("Result")
		end)
	end)
	it(
		"if a thenable resolves multiple times, does not update the first cached value",
		function()
			local resolveThenable
			local BadTextResource = createResource(function(ref0)
				-- ROBLOX deviation START: unused
				-- local text = ref0[1]
				-- local ms = (function()
				-- 	local element = table.unpack(ref0, 2, 2)
				-- 	if element == nil then
				-- 		return 0
				-- 	else
				-- 		return element
				-- 	end
				-- end)()
				-- ROBLOX deviation END
				local listeners = nil
				local value = nil
				return {
					-- ROBLOX deviation START: use andThen
					-- ["then"] = function(self, resolve, reject)
					andThen = function(self, resolve, reject)
						-- ROBLOX deviation END
						if value ~= nil then
							resolve(value)
						else
							if listeners == nil then
								listeners = { resolve }
								resolveThenable = function(v)
									-- ROBLOX deviation START: use for..in loop instead
									-- Array.forEach(listeners, function(listener)
									-- 	return listener(v)
									-- end) --\[\[ ROBLOX CHECK: check if 'listeners' is an Array \]\]
									for _, listener in listeners do
										listener(v)
									end
									-- ROBLOX deviation END
								end
							else
								table.insert(listeners, resolve) --\[\[ ROBLOX CHECK: check if 'listeners' is an Array \]\]
							end
						end
					end,
				}
				-- ROBLOX deviation START: explicit type
				-- end, function(ref0)
			end, function(ref0: { any })
				-- ROBLOX deviation END
				-- ROBLOX deviation START: ms not used
				-- local text, ms = table.unpack(ref0, 1, 2)
				-- return text
				return ref0[1]
				-- ROBLOX deviation END
			end)
			local function BadAsyncText(props)
				local text = props.text
				do --\[\[ ROBLOX COMMENT: try-catch block conversion \]\]
					-- ROBLOX deviation START: use pcall
					-- local ok, result, hasReturned = xpcall(function()
					local ok, result = pcall(function()
						-- ROBLOX deviation END
						-- ROBLOX deviation START: use dot notation
						-- local actualText = BadTextResource:read({ props.text, props.ms })
						-- Scheduler:unstable_yieldValue(actualText)
						local actualText = BadTextResource.read({ props.text, props.ms })
						Scheduler.unstable_yieldValue(actualText)
						-- ROBLOX deviation END
						-- ROBLOX deviation START: using pcall
						-- 	return actualText, true
						-- end, function(promise)
						return actualText
					end)
					if not ok then
						local promise = result
						-- ROBLOX deviation END
						-- ROBLOX deviation START: use andThen
						-- if typeof(promise["then"]) == "function" then
						if typeof(promise.andThen) == "function" then
							-- ROBLOX deviation END
							-- ROBLOX deviation START: use dot notation
							-- Scheduler:unstable_yieldValue(
							Scheduler.unstable_yieldValue(
								-- ROBLOX deviation END
								("Suspend! [%s]"):format(tostring(text))
							)
						else
							-- ROBLOX deviation START: use dot notation
							-- Scheduler:unstable_yieldValue(
							Scheduler.unstable_yieldValue(
								-- ROBLOX deviation END
								("Error! [%s]"):format(tostring(text))
							)
						end
						error(promise)
						-- ROBLOX deviation START: using pcall
						-- end)
						-- if hasReturned then
						-- 	return result
						-- end
					end
					return result
					-- ROBLOX deviation END
				end
			end
			local root = ReactTestRenderer.create(
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(BadAsyncText, { text = "Hi" })
				),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toFlushAndYield({ "Suspend! [Hi]", "Loading..." })
			resolveThenable("Hi") -- This thenable improperly resolves twice. We should not update the
			-- cached value.
			resolveThenable("Hi muahahaha I am different")
			-- ROBLOX deviation START: use dot notation
			-- root:update(
			root.update(
				-- ROBLOX deviation END
				React.createElement(
					Suspense,
					{ fallback = React.createElement(Text, { text = "Loading..." }) },
					React.createElement(BadAsyncText, { text = "Hi" })
				),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toHaveYielded({})
			expect(Scheduler).toFlushAndYield({ "Hi" })
			expect(root).toMatchRenderedOutput("Hi")
		end
	)
	it("throws if read is called outside render", function()
		expect(function()
			-- ROBLOX deviation START: use dot notation
			-- return TextResource:read({ "A", 1000 })
			TextResource.read({ "A", 1000 })
			-- ROBLOX deviation END
		end).toThrow(
			"read and preload may only be called from within a component's render"
		)
	end)
	it("throws if preload is called outside render", function()
		expect(function()
			-- ROBLOX deviation START: use dot notation
			-- return TextResource:preload({ "A", 1000 })
			TextResource.preload({ "A", 1000 })
			-- ROBLOX deviation END
		end).toThrow(
			"read and preload may only be called from within a component's render"
		)
	end)
end) ]]
aD.Children._16719c0d1abadf88f91ca7970a8da1e9=aE
local aF

local aG={ClassName="ModuleScript",Children={},Properties={}}
aG.Name="ReactDebugTools"
aG.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]
-- ROBLOX deviation START: simplify and re-export types
-- local Packages --\[\[ ROBLOX comment: must define Packages module \]\]
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Object = LuauPolyfill.Object
-- local exports = {}
-- Object.assign(exports, require(script.src.ReactDebugTools))
-- return exports
local reactDebugToolsModule = require(script.ReactDebugTools)
export type HooksNode = reactDebugToolsModule.HooksNode
export type HooksTree = reactDebugToolsModule.HooksTree
return reactDebugToolsModule
-- ROBLOX deviation END ]]
c.Children._0b95e1f34c1b1f333aea7895d0ad0928=aG
local aH
local aI={ClassName="ModuleScript",Children={},Properties={}}
aI.Name="ReactDebugHooks"
aI.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/src/ReactDebugHooks.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
type void = nil --\[\[ ROBLOX FIXME: adding `void` type alias to make it easier to use Luau `void` equivalent when supported \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
-- ROBLOX deviation START: not needed
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Error = LuauPolyfill.Error
type Map<T, U> = LuauPolyfill.Map<T, U>
-- ROBLOX deviation START: add additional imports
type Object = LuauPolyfill.Object
local String = LuauPolyfill.String
-- ROBLOX deviation END
local exports = {}
-- local sharedReactTypesModule = require(Packages.shared.ReactTypes)
-- type MutableSource = sharedReactTypesModule.MutableSource
-- type MutableSourceGetSnapshotFn = sharedReactTypesModule.MutableSourceGetSnapshotFn
-- type MutableSourceSubscribeFn = sharedReactTypesModule.MutableSourceSubscribeFn
-- type ReactContext = sharedReactTypesModule.ReactContext
-- type ReactProviderType = sharedReactTypesModule.ReactProviderType
local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>

-- ROBLOX deviation END
-- ROBLOX deviation START: add import type that is a built-in in flow
type React_Node = ReactTypes.React_Node
-- ROBLOX deviation END

-- ROBLOX deviation START: add binding support
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END
-- ROBLOX deviation START: fix import
-- local reactReconcilerSrcReactInternalTypesModule =
-- 	require(Packages["react-reconciler"].src.ReactInternalTypes)
local reactReconcilerSrcReactInternalTypesModule = require(Packages.ReactReconciler)
-- ROBLOX deviation END
type Fiber = reactReconcilerSrcReactInternalTypesModule.Fiber
type DispatcherType = reactReconcilerSrcReactInternalTypesModule.Dispatcher
-- ROBLOX deviation START: fix import - import from Shared
-- local reactReconcilerSrcReactFiberHostConfigModule =
-- 	require(Packages["react-reconciler"].src.ReactFiberHostConfig)
local reactReconcilerSrcReactFiberHostConfigModule = require(Packages.Shared)
-- ROBLOX deviation END
type OpaqueIDType = reactReconcilerSrcReactFiberHostConfigModule.OpaqueIDType
-- ROBLOX deviation START: fix import
-- local NoMode = require(Packages["react-reconciler"].src.ReactTypeOfMode).NoMode
local ReconcilerModule = require(Packages.ReactReconciler)({})
local NoMode = ReconcilerModule.ReactTypeOfMode.NoMode
-- ROBLOX deviation END
-- ROBLOX deviation START: add inline ErrorStackParser implementation
-- local ErrorStackParser = require(Packages["error-stack-parser"]).default
type StackFrame = {
	source: string?,
	functionName: string?,
}
local ErrorStackParser = {
	parse = function(error_: Error): Array<StackFrame>
		if error_.stack == nil then
			return {}
		end
		local filtered = Array.filter(
			string.split(error_.stack :: string, "\n"),
			function(line)
				return string.find(line, "^LoadedCode") ~= nil
			end
		)
		return Array.map(filtered, function(stackTraceLine)
			-- ROBLOX FIXME Luau: shouldn't need to explicitly provide nilable field
			local functionName = string.match(stackTraceLine, "function (%w+)$")
			return { source = stackTraceLine, functionName = functionName }
		end)
	end,
}
-- ROBLOX deviation END
-- ROBLOX deviation START: import from Shared
-- local ReactSharedInternals = require(Packages.shared.ReactSharedInternals).default
-- local REACT_OPAQUE_ID_TYPE = require(Packages.shared.ReactSymbols).REACT_OPAQUE_ID_TYPE
local SharedModule = require(Packages.Shared)
local ReactSharedInternals = SharedModule.ReactSharedInternals
local ReactSymbols = SharedModule.ReactSymbols
local REACT_OPAQUE_ID_TYPE = ReactSymbols.REACT_OPAQUE_ID_TYPE
-- ROBLOX deviation END
-- ROBLOX deviation START: fix import - get from ReconcilerModule
-- local reactReconcilerSrcReactWorkTagsModule =
-- 	require(Packages["react-reconciler"].src.ReactWorkTags)
local reactReconcilerSrcReactWorkTagsModule = ReconcilerModule.ReactWorkTags
-- ROBLOX deviation END
local FunctionComponent = reactReconcilerSrcReactWorkTagsModule.FunctionComponent
local SimpleMemoComponent = reactReconcilerSrcReactWorkTagsModule.SimpleMemoComponent
local ContextProvider = reactReconcilerSrcReactWorkTagsModule.ContextProvider
local ForwardRef = reactReconcilerSrcReactWorkTagsModule.ForwardRef
local Block = reactReconcilerSrcReactWorkTagsModule.Block
-- ROBLOX deviation START: fix import
-- type CurrentDispatcherRef = typeof(ReactSharedInternals_ReactCurrentDispatcher) -- Used to track hooks called during a render
type CurrentDispatcherRef = typeof(ReactSharedInternals.ReactCurrentDispatcher)
-- ROBLOX deviation END
type HookLogEntry = { primitive: string, stackError: Error, value: unknown } --\[\[ ROBLOX CHECK: inexact type upstream which is not supported by Luau. Verify if it doesn't break the analyze \]\]
local hookLog: Array<HookLogEntry> = {} -- Primitives
type BasicStateAction<S> = (S) -> S | S
type Dispatch<A> = (A) -> ()
local primitiveStackCache: nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] | Map<string, Array<any>> =
	nil
local currentFiber: Fiber | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] =
	nil
type Hook = {
	memoizedState: any,
	next: Hook | nil,--\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
}
-- ROBLOX deviation START: add predefined variable
local Dispatcher: DispatcherType
-- ROBLOX deviation END
local function getPrimitiveStackCache(): Map<string, Array<any>>
	-- This initializes a cache of all primitive hooks so that the top
	-- most stack frames added by calling the primitive hook can be removed.
	if primitiveStackCache == nil then
		local cache = Map.new()
		local readHookLog
		do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
			-- ROBLOX deviation START: doesn't return
			-- local ok, result, hasReturned = pcall(function()
			local ok, result = pcall(function()
				-- ROBLOX deviation END
				-- Use all hooks here to add them to the hook log.
				-- ROBLOX deviation START: use dot notation
				-- Dispatcher:useContext({ _currentValue = nil } :: any)
				-- Dispatcher:useState(nil)
				-- Dispatcher:useReducer(function(s, a)
				Dispatcher.useContext({ _currentValue = nil } :: any)
				Dispatcher.useState(nil)
				Dispatcher.useReducer(function(s, a)
					-- ROBLOX deviation END
					return s
				end, nil)
				-- ROBLOX deviation START: use dot notation
				-- Dispatcher:useRef(nil)
				-- Dispatcher:useLayoutEffect(function() end)
				-- Dispatcher:useEffect(function() end)
				-- Dispatcher:useImperativeHandle(nil, function()
				Dispatcher.useRef(nil)
				Dispatcher.useLayoutEffect(function() end)
				Dispatcher.useEffect(function() end)
				Dispatcher.useImperativeHandle(nil, function()
					-- ROBLOX deviation END
					return nil
				end)
				-- ROBLOX deviation START: use dot notation
				-- Dispatcher:useDebugValue(nil)
				-- Dispatcher:useCallback(function() end)
				-- Dispatcher:useMemo(function()
				Dispatcher.useDebugValue(nil)
				Dispatcher.useCallback(function() end)
				Dispatcher.useMemo(function()
					-- ROBLOX deviation END
					return nil
				end)
			end)
			do
				readHookLog = hookLog
				hookLog = {}
			end
			-- ROBLOX deviation START: doesn't return
			-- if hasReturned then
			-- 	return result
			-- end
			-- ROBLOX deviation END
			if not ok then
				error(result)
			end
		end
		-- ROBLOX deviation START: use for in loop instead of while
		-- do
		-- 	local i = 0
		-- 	while
		-- 		i
		-- 		< readHookLog.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
		-- 	do
		-- 		local hook = readHookLog[tostring(i)]
		-- 		cache:set(hook.primitive, ErrorStackParser:parse(hook.stackError))
		-- 		i += 1
		-- 	end
		-- end
		for i = 1, #readHookLog do
			local hook = readHookLog[i]
			cache:set(hook.primitive, ErrorStackParser.parse(hook.stackError))
		end
		-- ROBLOX deviation END
		primitiveStackCache = cache
	end
	-- ROBLOX deviation START: needs cast
	-- return primitiveStackCache
	return primitiveStackCache :: Map<string, Array<any>>
	-- ROBLOX deviation END
end
local currentHook: nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] | Hook =
	nil
local function nextHook(
): nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] | Hook
	local hook = currentHook
	if hook ~= nil then
		currentHook = hook.next
	end
	return hook
end
local function readContext<T>(
	context: ReactContext<T>,
	observedBits: void | number | boolean
): T
	-- For now we don't expose readContext usage in the hooks debugging info.
	return context._currentValue
end
local function useContext<T>(
	context: ReactContext<T>,
	observedBits: void | number | boolean
): T
	table.insert(
		hookLog,
		{ primitive = "Context", stackError = Error.new(), value = context._currentValue }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	return context._currentValue
end
-- ROBLOX deviation START: return 2 values instead of a tuple
-- local function useState<S>(
-- 	initialState: () -> S | S
-- ): any --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [S, Dispatch<BasicStateAction<S>>] \]\]
local function useState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	-- ROBLOX deviation END
	local hook = nextHook()
	local state: S = if hook ~= nil
		then hook.memoizedState
		else if typeof(initialState) == "function"
			then -- $FlowFixMe: Flow doesn't like mixed types
				initialState()
			else initialState
	table.insert(
		hookLog,
		{ primitive = "State", stackError = Error.new(), value = state }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	-- ROBLOX deviation START: return 2 values instead of a tuple
	-- return { state, function(action: BasicStateAction<S>) end }
	return state, function(action: BasicStateAction<S>) end
	-- ROBLOX deviation END
end
-- ROBLOX deviation START: return 2 values instead of a tuple
-- local function useReducer<S, I, A>(
-- 	reducer: (S, A) -> S,
-- 	initialArg: I,
-- 	init: ((I) -> S)?
-- ): any --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [S, Dispatch<A>] \]\]
local function useReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	-- ROBLOX deviation END
	local hook = nextHook()
	local state
	if hook ~= nil then
		state = hook.memoizedState
	else
		state = if init ~= nil then init(initialArg) else (initialArg :: any) :: S
	end
	table.insert(
		hookLog,
		{ primitive = "Reducer", stackError = Error.new(), value = state }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	-- ROBLOX deviation START: return 2 values instead of a tuple
	-- return { state, function(action: A) end }
	return state, function(action: A) end
	-- ROBLOX deviation END
end
-- ROBLOX deviation START: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
-- local function useRef<T>(initialValue: T): { current: T }
local function useRef<T>(initialValue: T): { current: T | nil }
	-- ROBLOX deviation END
	local hook = nextHook()
	local ref = if hook ~= nil then hook.memoizedState else { current = initialValue }
	table.insert(
		hookLog,
		{ primitive = "Ref", stackError = Error.new(), value = ref.current }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	return ref
end
-- ROBLOX deviation START: add binding support; these aren't fully working hooks, so this
-- is just an approximation modeled off of the `ref` hook above
local function useBinding<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
	local hook = nextHook()
	local binding = if hook ~= nil
		then hook.memoizedState
		else ({
			getValue = function(_self)
				return initialValue
			end,
		} :: any) :: ReactBinding<T>

	table.insert(hookLog, {
		primitive = "Binding",
		stackError = Error.new(),
		value = binding:getValue(),
	})

	return binding, function(_value) end
end
-- ROBLOX deviation END
local function useLayoutEffect(
	-- ROBLOX deviation START: Luau needs union type packs for this type to translate idiomatically
	-- create: () -> () -> () | void,
	create: (() -> ()) | (() -> (() -> ())),
	-- ROBLOX deviation END
	inputs: Array<unknown> | void | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
): ()
	nextHook()
	table.insert(
		hookLog,
		{ primitive = "LayoutEffect", stackError = Error.new(), value = create }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
end
local function useEffect(
	-- ROBLOX deviation START: Luau needs union type packs for this type to translate idiomatically
	-- create: () -> () -> () | void,
	create: (() -> ()) | (() -> (() -> ())),
	-- ROBLOX deviation END
	inputs: Array<unknown> | void | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
): ()
	nextHook()
	table.insert(
		hookLog,
		{ primitive = "Effect", stackError = Error.new(), value = create }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
end
local function useImperativeHandle<T>(
	ref: {
		current: T | nil,--\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
	} | (
		inst: T | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
	) -> unknown | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\] | void,
	create: () -> T,
	inputs: Array<unknown> | void | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
): ()
	nextHook() -- We don't actually store the instance anywhere if there is no ref callback
	-- and if there is a ref callback it might not store it but if it does we
	-- have no way of knowing where. So let's only enable introspection of the
	-- ref itself if it is using the object form.
	local instance = nil
	if ref ~= nil and typeof(ref) == "table" then
		instance = ref.current
	end
	table.insert(
		hookLog,
		{ primitive = "ImperativeHandle", stackError = Error.new(), value = instance }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
end
-- ROBLOX deviation START: add generic params
-- local function useDebugValue(value: any, formatterFn: ((value: any) -> any)?)
local function useDebugValue<T>(value: T, formatterFn: ((value: T) -> any)?): ()
	-- ROBLOX deviation END
	table.insert(hookLog, {
		primitive = "DebugValue",
		stackError = Error.new(),
		value = if typeof(formatterFn) == "function" then formatterFn(value) else value,
	}) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
end
local function useCallback<T>(
	callback: T,
	inputs: Array<unknown> | void | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
): T
	local hook = nextHook()
	table.insert(hookLog, {
		primitive = "Callback",
		stackError = Error.new(),
		value = if hook ~= nil
			then hook.memoizedState[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			]
			else callback,
	}) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	return callback
end
-- ROBLOX deviation START: FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
-- local function useMemo<T>(
-- 	nextCreate: () -> T,
-- 	inputs: Array<unknown> | void | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
-- ): T
local function useMemo<T...>(nextCreate: () -> T..., inputs: Array<any> | nil): ...any
	-- ROBLOX deviation END
	local hook = nextHook()
	-- ROBLOX deviation START: Wrap memoized values in a table and unpack to allow for multiple return values
	-- local value = if hook ~= nil
	-- 	then hook.memoizedState[
	-- 		1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
	-- 	]
	-- 	else nextCreate()
	local value = if hook ~= nil then hook.memoizedState[1] else { nextCreate() }
	-- ROBLOX deviation END

	table.insert(hookLog, { primitive = "Memo", stackError = Error.new(), value = value }) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	-- ROBLOX deviation START: unwrap memoized values in a table
	-- return value
	return table.unpack(value)
	-- ROBLOX deviation END
end
local function useMutableSource<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<
		Source,
		Snapshot
	>,
	subscribe: MutableSourceSubscribeFn<
		Source,
		Snapshot
	>
): Snapshot
	-- useMutableSource() composes multiple hooks internally.
	-- Advance the current hook index the same number of times
	-- so that subsequent hooks have the right memoized state.
	nextHook() -- MutableSource
	nextHook() -- State
	nextHook() -- Effect
	nextHook() -- Effect
	local value = getSnapshot(source._source)
	table.insert(
		hookLog,
		{ primitive = "MutableSource", stackError = Error.new(), value = value }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	return value
end
-- ROBLOX deviation START: enable these once they are fully enabled in the Dispatcher type and in ReactFiberHooks' myriad dispatchers
-- local function useTransition(
-- ): any --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [(() => void) => void, boolean] \]\]
-- 	-- useTransition() composes multiple hooks internally.
-- 	-- Advance the current hook index the same number of times
-- 	-- so that subsequent hooks have the right memoized state.
-- 	nextHook() -- State
-- 	nextHook() -- Callback
-- 	table.insert(
-- 		hookLog,
-- 		{ primitive = "Transition", stackError = Error.new(), value = nil }
-- 	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
-- 	return { function(callback) end, false }
-- end
-- local function useDeferredValue<T>(value: T): T
-- 	-- useDeferredValue() composes multiple hooks internally.
-- 	-- Advance the current hook index the same number of times
-- 	-- so that subsequent hooks have the right memoized state.
-- 	nextHook() -- State
-- 	nextHook() -- Effect
-- 	table.insert(
-- 		hookLog,
-- 		{ primitive = "DeferredValue", stackError = Error.new(), value = value }
-- 	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
-- 	return value
-- end
-- ROBLOX deviation END
local function useOpaqueIdentifier(): OpaqueIDType | void
	local hook = nextHook() -- State
	-- ROBLOX deviation START: simplify
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(currentFiber)
	-- 			then currentFiber.mode == NoMode
	-- 			else currentFiber
	-- 	)
	-- then
	if currentFiber and currentFiber.mode == NoMode then
		-- ROBLOX deviation END
		nextHook() -- Effect
	end
	local value = if hook == nil then nil else hook.memoizedState
	-- ROBLOX deviation START: simplify
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(value)
	-- 			then value["$$typeof"] == REACT_OPAQUE_ID_TYPE
	-- 			else value
	-- 	)
	-- then
	if value and (value :: any)["$$typeof"] == REACT_OPAQUE_ID_TYPE then
		-- ROBLOX deviation END
		value = nil
	end
	table.insert(
		hookLog,
		{ primitive = "OpaqueIdentifier", stackError = Error.new(), value = value }
	) --\[\[ ROBLOX CHECK: check if 'hookLog' is an Array \]\]
	return value
end
-- ROBLOX deviation START: predefined variable
-- local Dispatcher: DispatcherType = {
Dispatcher = {
	-- ROBLOX deviation END
	readContext = readContext,
	useCallback = useCallback,
	useContext = useContext,
	useEffect = useEffect,
	-- ROBLOX deviation START: needs cast
	-- useImperativeHandle = useImperativeHandle,
	useImperativeHandle = useImperativeHandle :: any,
	-- ROBLOX deviation END
	useDebugValue = useDebugValue,
	useLayoutEffect = useLayoutEffect,
	-- ROBLOX deviation START: needs cast
	-- useMemo = useMemo,
	useMemo = useMemo :: any,
	-- ROBLOX deviation END
	useReducer = useReducer,
	useRef = useRef,
	-- ROBLOX deviation START: add useBinding
	useBinding = useBinding,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: needs cast
	-- useState = useState,
	useState = useState :: any,
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not implemented
	-- useTransition = useTransition,
	-- ROBLOX deviation END
	useMutableSource = useMutableSource,
	-- ROBLOX deviation START: not implemented
	-- useDeferredValue = useDeferredValue,
	-- ROBLOX deviation END
	useOpaqueIdentifier = useOpaqueIdentifier,
} -- Inspect
export type HooksNode = {
	id: number | nil,--\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
	isStateEditable: boolean,
	name: string,
	value: unknown,
	subHooks: Array<HooksNode>,
} --\[\[ ROBLOX CHECK: inexact type upstream which is not supported by Luau. Verify if it doesn't break the analyze \]\]
export type HooksTree = Array<HooksNode> -- Don't assume
--
-- We can't assume that stack frames are nth steps away from anything.
-- E.g. we can't assume that the root call shares all frames with the stack
-- of a hook call. A simple way to demonstrate this is wrapping `new Error()`
-- in a wrapper constructor like a polyfill. That'll add an extra frame.
-- Similar things can happen with the call to the dispatcher. The top frame
-- may not be the primitive. Likewise the primitive can have fewer stack frames
-- such as when a call to useState got inlined to use dispatcher.useState.
--
-- We also can't assume that the last frame of the root call is the same
-- frame as the last frame of the hook call because long stack traces can be
-- truncated to a stack trace limit.
-- ROBLOX deviation START: adapt to 1-based indexing
-- local mostLikelyAncestorIndex = 0
local mostLikelyAncestorIndex = 1
-- ROBLOX deviation END
-- ROBLOX deviation START: explicit type
-- local function findSharedIndex(hookStack, rootStack, rootIndex)
local function findSharedIndex(hookStack, rootStack, rootIndex: number)
	-- ROBLOX deviation END
	-- ROBLOX deviation START: don't use tostring
	-- local source = rootStack[tostring(rootIndex)].source
	local source = rootStack[rootIndex].source
	-- ROBLOX deviation END
	-- ROBLOX deviation START: implement LabeledStatement
	-- 	error("not implemented") --\[\[ ROBLOX TODO: Unhandled node for type: LabeledStatement \]\] --\[\[ hookSearch: for (let i = 0; i < hookStack.length; i++) {
	--     if (hookStack[i].source === source) {
	--       // This looks like a match. Validate that the rest of both stack match up.
	--       for (let a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {
	--         if (hookStack[b].source !== rootStack[a].source) {
	--           // If not, give up and try a different match.
	--           continue hookSearch;
	--         }
	--       }

	--       return i;
	--     }
	--   } \]\]
	for i = 1, #hookStack do
		if hookStack[i].source == source then
			-- This looks like a match. Validate that the rest of both stack match up.
			-- ROBLOX deviation: rewrite complex loop
			local a = rootIndex + 1
			local b = i + 1
			local skipReturn = false
			while a <= #rootStack and b <= #hookStack do
				if hookStack[b].source ~= rootStack[a].source then
					-- If not, give up and try a different match.
					skipReturn = true
					break
				end
				a += 1
				b += 1
			end
			if not skipReturn then
				return i
			end
		end
	end
	-- ROBLOX deviation END
	return -1
end
local function findCommonAncestorIndex(rootStack, hookStack)
	local rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex)
	if rootIndex ~= -1 then
		return rootIndex
	end -- If the most likely one wasn't a hit, try any other frame to see if it is shared.
	-- If that takes more than 5 frames, something probably went wrong.
	-- ROBLOX deviation START: use numeric for loop
	-- do
	-- 	local i = 0
	-- 	while
	-- 		i < rootStack.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 		and i < 5 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 	do
	-- 		rootIndex = findSharedIndex(hookStack, rootStack, i)
	-- 		if rootIndex ~= -1 then
	-- 			mostLikelyAncestorIndex = i
	-- 			return rootIndex
	-- 		end
	-- 		i += 1
	-- 	end
	-- end
	for i = 1, math.min(#rootStack, 5) do
		rootIndex = findSharedIndex(hookStack, rootStack, i)
		if rootIndex ~= -1 then
			mostLikelyAncestorIndex = i
			return rootIndex
		end
	end
	-- ROBLOX deviation END
	return -1
end
local function isReactWrapper(functionName, primitiveName)
	-- ROBLOX deviation START: simplify
	-- if not Boolean.toJSBoolean(functionName) then
	if not functionName or functionName == "" then
		-- ROBLOX deviation END
		return false
	end
	local expectedPrimitiveName = "use" .. tostring(primitiveName)
	-- ROBLOX deviation START: fix length implementation + Luau doesn't understand the guard above
	-- if
	-- 	functionName.length
	-- 	< expectedPrimitiveName.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- then
	if string.len(functionName :: string) < string.len(expectedPrimitiveName) then
		-- ROBLOX deviation END
		return false
	end
	-- ROBLOX deviation START: fix length implementation + Luau doesn't understand the guard above
	-- return functionName:lastIndexOf(expectedPrimitiveName)
	-- 	== functionName.length - expectedPrimitiveName.length
	return String.lastIndexOf(functionName :: string, expectedPrimitiveName)
		== (string.len(functionName :: string) - string.len(expectedPrimitiveName) + 1)
	-- ROBLOX deviation END
end
local function findPrimitiveIndex(hookStack, hook)
	local stackCache = getPrimitiveStackCache()
	local primitiveStack = stackCache:get(hook.primitive)
	if primitiveStack == nil then
		return -1
	end
	-- ROBLOX deviation START: use numeric for loop and precompute iteration count
	-- do
	-- 	local i = 0
	-- 	while
	-- 		i < primitiveStack.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 		and i < hookStack.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 	do
	-- 		if primitiveStack[tostring(i)].source ~= hookStack[tostring(i)].source then
	-- 			-- If the next two frames are functions called `useX` then we assume that they're part of the
	-- 			-- wrappers that the React packager or other packages adds around the dispatcher.
	-- 			if
	-- 				Boolean.toJSBoolean(
	-- 					i < hookStack.length - 1 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 						and isReactWrapper(
	-- 							hookStack[tostring(i)].functionName,
	-- 							hook.primitive
	-- 						)
	-- 				)
	-- 			then
	-- 				i += 1
	-- 			end
	-- 			if
	-- 				Boolean.toJSBoolean(
	-- 					i < hookStack.length - 1 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 						and isReactWrapper(
	-- 							hookStack[tostring(i)].functionName,
	-- 							hook.primitive
	-- 						)
	-- 				)
	-- 			then
	-- 				i += 1
	-- 			end
	-- 			return i
	-- 		end
	-- 		i += 1
	-- 	end
	-- end
	for i = 1, math.min(#primitiveStack :: Array<any>, #hookStack) do
		if (primitiveStack :: Array<any>)[i].source ~= hookStack[i].source then
			-- If the next two frames are functions called `useX` then we assume that they're part of the
			-- wrappers that the React packager or other packages adds around the dispatcher.
			-- ROBLOX NOTE: 1-indexed so drop -1
			if
				i < #hookStack
				and isReactWrapper(hookStack[i].functionName, hook.primitive)
			then
				i += 1
			end
			-- ROBLOX NOTE: 1-indexed so drop -1
			if
				i < #hookStack
				and isReactWrapper(hookStack[i].functionName, hook.primitive)
			then
				i += 1
			end
			return i
		end
	end
	-- ROBLOX deviation END
	return -1
end
-- ROBLOX deviation START: Luau doesn't infer Array<StackFrame> | nil like it should
-- local function parseTrimmedStack(rootStack, hook)
local function parseTrimmedStack(rootStack, hook): Array<StackFrame>?
	-- ROBLOX deviation END
	-- Get the stack trace between the primitive hook function and
	-- the root function call. I.e. the stack frames of custom hooks.
	-- ROBLOX deviation START: use dot notation
	-- local hookStack = ErrorStackParser:parse(hook.stackError)
	local hookStack = ErrorStackParser.parse(hook.stackError)
	-- ROBLOX deviation END
	local rootIndex = findCommonAncestorIndex(rootStack, hookStack)
	local primitiveIndex = findPrimitiveIndex(hookStack, hook)
	if
		rootIndex == -1
		or primitiveIndex == -1
		or rootIndex - primitiveIndex < 2 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	then
		-- Something went wrong. Give up.
		return nil
	end
	return Array.slice(hookStack, primitiveIndex, rootIndex - 1) --\[\[ ROBLOX CHECK: check if 'hookStack' is an Array \]\]
end
local function parseCustomHookName(functionName: void | string): string
	-- ROBLOX deviation START: simplify
	-- if not Boolean.toJSBoolean(functionName) then
	if not functionName then
		-- ROBLOX deviation END
		return ""
	end
	-- ROBLOX deviation START: fix implementation
	-- local startIndex = functionName:lastIndexOf(".")
	local startIndex = String.lastIndexOf(functionName :: string, ".")
	-- ROBLOX deviation END
	if startIndex == -1 then
		-- ROBLOX deviation START: adapt for 1-based indexing
		-- startIndex = 0
		startIndex = 1
		-- ROBLOX deviation END
	end
	-- ROBLOX deviation START: fix implementation
	-- if functionName:substr(startIndex, 3) == "use" then
	if String.substr(functionName :: string, startIndex, 3) == "use" then
		-- ROBLOX deviation END
		startIndex += 3
	end
	-- ROBLOX deviation START: fix implementation
	-- return functionName:substr(startIndex)
	return String.substr(functionName :: string, startIndex)
	-- ROBLOX deviation END
end
-- ROBLOX deviation START: add predefined function
local processDebugValues
-- ROBLOX deviation END
-- ROBLOX deviation START: explicit type
-- local function buildTree(rootStack, readHookLog): HooksTree
local function buildTree(rootStack, readHookLog: Array<any>): HooksTree
	-- ROBLOX deviation END
	local rootChildren = {}
	local prevStack = nil
	local levelChildren = rootChildren
	-- ROBLOX deviation START: adjust for 1-based indexing
	-- local nativeHookID = 0
	local nativeHookID = 1
	-- ROBLOX deviation END
	local stackOfChildren = {}
	-- ROBLOX deviation START: use numeric for loop
	-- do
	-- 	local i = 0
	-- 	while
	-- 		i
	-- 		< readHookLog.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 	do
	-- 		local hook = readHookLog[tostring(i)]
	-- 		local stack = parseTrimmedStack(rootStack, hook)
	-- 		if stack ~= nil then
	-- 			-- Note: The indices 0 <= n < length-1 will contain the names.
	-- 			-- The indices 1 <= n < length will contain the source locations.
	-- 			-- That's why we get the name from n - 1 and don't check the source
	-- 			-- of index 0.
	-- 			local commonSteps = 0
	-- 			if prevStack ~= nil then
	-- 				-- Compare the current level's stack to the new stack.
	-- 				while
	-- 					commonSteps < stack.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 					and commonSteps < prevStack.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
	-- 				do
	-- 					local stackSource =
	-- 						stack[tostring(stack.length - commonSteps - 1)].source
	-- 					local prevSource =
	-- 						prevStack[tostring(prevStack.length - commonSteps - 1)].source
	-- 					if stackSource ~= prevSource then
	-- 						break
	-- 					end
	-- 					commonSteps += 1
	-- 				end -- Pop back the stack as many steps as were not common.
	-- 				do
	-- 					local j = prevStack.length - 1
	-- 					while
	-- 						j
	-- 						> commonSteps --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
	-- 					do
	-- 						levelChildren = table.remove(stackOfChildren) --\[\[ ROBLOX CHECK: check if 'stackOfChildren' is an Array \]\]
	-- 						j -= 1
	-- 					end
	-- 				end
	-- 			end -- The remaining part of the new stack are custom hooks. Push them
	-- 			-- to the tree.
	-- 			do
	-- 				local j = stack.length - commonSteps - 1
	-- 				while
	-- 					j
	-- 					>= 1 --\[\[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number \]\]
	-- 				do
	-- 					local children = {}
	-- 					table.insert(levelChildren, {
	-- 						id = nil,
	-- 						isStateEditable = false,
	-- 						name = parseCustomHookName(
	-- 							stack[tostring(j - 1)].functionName
	-- 						),
	-- 						value = nil,
	-- 						subHooks = children,
	-- 					}) --\[\[ ROBLOX CHECK: check if 'levelChildren' is an Array \]\]
	-- 					table.insert(stackOfChildren, levelChildren) --\[\[ ROBLOX CHECK: check if 'stackOfChildren' is an Array \]\]
	-- 					levelChildren = children
	-- 					j -= 1
	-- 				end
	-- 			end
	-- 			prevStack = stack
	-- 		end
	-- 		local primitive = hook.primitive -- For now, the "id" of stateful hooks is just the stateful hook index.
	-- 		-- Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
	-- 		local id = if primitive == "Context" or primitive == "DebugValue"
	-- 			then nil
	-- 			else (function()
	-- 				local ref = nativeHookID
	-- 				nativeHookID += 1
	-- 				return ref
	-- 			end)() -- For the time being, only State and Reducer hooks support runtime overrides.
	-- 		local isStateEditable = primitive == "Reducer" or primitive == "State"
	-- 		table.insert(levelChildren, {
	-- 			id = id,
	-- 			isStateEditable = isStateEditable,
	-- 			name = primitive,
	-- 			value = hook.value,
	-- 			subHooks = {},
	-- 		}) --\[\[ ROBLOX CHECK: check if 'levelChildren' is an Array \]\]
	-- 		i += 1
	-- 	end
	-- end -- Associate custom hook values (useDebugValue() hook entries) with the correct hooks.
	for i = 1, #readHookLog do
		local hook = readHookLog[i]
		local stack = parseTrimmedStack(rootStack, hook)

		if stack ~= nil then
			-- Note: The indices 0 <= n < length-1 will contain the names.
			-- The indices 1 <= n < length will contain the source locations.
			-- That's why we get the name from n - 1 and don't check the source
			-- of index 0.
			local commonSteps = 0
			if prevStack ~= nil then
				-- Compare the current level's stack to the new stack.
				while commonSteps < #stack and commonSteps < #prevStack do
					local stackSource = stack[#stack - commonSteps].source
					local prevSource = prevStack[#prevStack - commonSteps].source

					if stackSource ~= prevSource then
						break
					end

					commonSteps += 1
				end
				-- Pop back the stack as many steps as were not common.
				for j = #prevStack - 1, commonSteps + 1, -1 do
					levelChildren =
						table.remove(stackOfChildren :: Array<any>) :: Array<any>
				end
			end

			-- The remaining part of the new stack are custom hooks. Push them
			-- to the tree.
			for j = #stack - commonSteps, 2, -1 do
				local children = {}
				table.insert(levelChildren, {
					-- ROBLOX FIXME Luau: Luau should infer number | nil here by (at least) looking at the function-level usage
					id = nil :: number | nil,
					isStateEditable = false,
					name = parseCustomHookName(stack[j - 1].functionName),
					value = nil,
					subHooks = children,
				})
				table.insert(stackOfChildren, levelChildren)
				levelChildren = children
			end

			prevStack = stack
		end

		local function POSTFIX_INCREMENT()
			local prev = nativeHookID
			nativeHookID += 1
			return prev
		end

		local primitive = hook.primitive

		-- For now, the "id" of stateful hooks is just the stateful hook index.
		-- Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).
		-- ROBLOX FIXME Luau: Luau doesn't infer number | nil like it should
		local id = if primitive == "Context" or primitive == "DebugValue"
			then nil
			else POSTFIX_INCREMENT()
		-- For the time being, only State and Reducer hooks support runtime overrides.
		local isStateEditable = primitive == "Reducer" or primitive == "State"

		table.insert(levelChildren, {
			id = id,
			isStateEditable = isStateEditable,
			name = primitive,
			value = hook.value,
			subHooks = {},
		})
	end
	-- ROBLOX deviation END
	processDebugValues(rootChildren, nil)
	return rootChildren
end -- Custom hooks support user-configurable labels (via the special useDebugValue() hook).
-- That hook adds user-provided values to the hooks tree,
-- but these values aren't intended to appear alongside of the other hooks.
-- Instead they should be attributed to their parent custom hook.
-- This method walks the tree and assigns debug values to their custom hook owners.
-- ROBLOX deviation START: predefined function
-- local function processDebugValues(
function processDebugValues(
	-- ROBLOX deviation END
	hooksTree: HooksTree,
	parentHooksNode: HooksNode | nil --\[\[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` \]\]
): ()
	local debugValueHooksNodes: Array<HooksNode> = {}
	do
		-- ROBLOX deviation START: adapt for 1-based indexing
		-- local i = 0
		local i = 1
		-- ROBLOX deviation END
		-- ROBLOX deviation START: fix length implementation
		-- while
		-- 	i
		-- 	< hooksTree.length --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
		-- do
		while i <= #hooksTree do
			-- ROBLOX deviation END
			-- ROBLOX deviation START: don't use tostring for iterating an array
			-- local hooksNode = hooksTree[tostring(i)]
			local hooksNode = hooksTree[i]
			-- ROBLOX deviation END
			-- ROBLOX deviation START: fix length implementation
			-- if hooksNode.name == "DebugValue" and hooksNode.subHooks.length == 0 then
			if hooksNode.name == "DebugValue" and #hooksNode.subHooks == 0 then
				-- ROBLOX deviation END
				Array.splice(hooksTree, i, 1) --\[\[ ROBLOX CHECK: check if 'hooksTree' is an Array \]\]
				i -= 1
				table.insert(debugValueHooksNodes, hooksNode) --\[\[ ROBLOX CHECK: check if 'debugValueHooksNodes' is an Array \]\]
			else
				processDebugValues(hooksNode.subHooks, hooksNode)
			end
			i += 1
		end
	end -- Bubble debug value labels to their custom hook owner.
	-- If there is no parent hook, just ignore them for now.
	-- (We may warn about this in the future.)
	if parentHooksNode ~= nil then
		-- ROBLOX deviation START: fix length implementation
		-- if debugValueHooksNodes.length == 1 then
		if #debugValueHooksNodes == 1 then
			-- ROBLOX deviation END
			parentHooksNode.value = debugValueHooksNodes[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			].value
			-- ROBLOX deviation START: fix length implementation
			-- elseif
			-- 	debugValueHooksNodes.length
			-- 	> 1 --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
			-- then
		elseif #debugValueHooksNodes > 1 then
			-- ROBLOX deviation END
			parentHooksNode.value = Array.map(debugValueHooksNodes, function(ref0)
				local value = ref0.value
				return value
			end) --\[\[ ROBLOX CHECK: check if 'debugValueHooksNodes' is an Array \]\]
		end
	end
end
local function inspectHooks<Props>(
	renderFunction: (Props) -> React_Node --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: React$Node \]\],
	props: Props,
	currentDispatcher: CurrentDispatcherRef?
): HooksTree
	-- DevTools will pass the current renderer's injected dispatcher.
	-- Other apps might compile debug hooks as part of their app though.
	if
		currentDispatcher == nil --\[\[ ROBLOX CHECK: loose equality used upstream \]\]
	then
		currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
	end
	-- ROBLOX deviation START: Luau doesn't understand that currentDispatcher is not nil
	-- local previousDispatcher = currentDispatcher.current
	local previousDispatcher = (currentDispatcher :: CurrentDispatcherRef).current
	-- ROBLOX deviation END
	local readHookLog;
	-- ROBLOX deviation START: Luau doesn't understand that currentDispatcher is not nil
	-- currentDispatcher.current = Dispatcher
	(currentDispatcher :: CurrentDispatcherRef).current = Dispatcher
	-- ROBLOX deviation END
	local ancestorStackError
	do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
		-- ROBLOX deviation START: doesn't return
		-- local ok, result, hasReturned = pcall(function()
		local ok, result = pcall(function()
			-- ROBLOX deviation END
			ancestorStackError = Error.new()
			renderFunction(props)
		end)
		do
			readHookLog = hookLog
			hookLog = {};
			-- ROBLOX deviation START: Luau doesn't understand that currentDispatcher is not nil
			-- currentDispatcher.current = previousDispatcher
			(currentDispatcher :: CurrentDispatcherRef).current = previousDispatcher
			-- ROBLOX deviation END
		end
		-- ROBLOX deviation START: doesn't return
		-- if hasReturned then
		-- 	return result
		-- end
		-- ROBLOX deviation END
		if not ok then
			error(result)
		end
	end
	-- ROBLOX deviation START: use dot notation
	-- local rootStack = ErrorStackParser:parse(ancestorStackError)
	local rootStack = ErrorStackParser.parse(ancestorStackError)
	-- ROBLOX deviation END
	return buildTree(rootStack, readHookLog)
end
exports.inspectHooks = inspectHooks
local function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber)
	local current = fiber
	-- ROBLOX deviation START: toJSBoolean not needed
	-- while Boolean.toJSBoolean(current) do
	while current do
		-- ROBLOX deviation END
		if current.tag == ContextProvider then
			local providerType: ReactProviderType<any> = current.type
			local context: ReactContext<any> = providerType._context
			-- ROBLOX deviation START: toJSBoolean not needed
			-- if not Boolean.toJSBoolean(contextMap:has(context)) then
			if not contextMap:has(context) then
				-- ROBLOX deviation END
				-- Store the current value that we're going to restore later.
				contextMap:set(context, context._currentValue) -- Set the inner most provider value on the context.
				context._currentValue = current.memoizedProps.value
			end
		end
		-- ROBLOX deviation START: use return_
		-- current = current["return"]
		current = current.return_ :: Fiber
		-- ROBLOX deviation END
	end
end
local function restoreContexts(contextMap: Map<ReactContext<any>, any>)
	-- ROBLOX deviation START: use for..in loop
	-- Array.forEach(contextMap, function(value, context)
	-- 	context._currentValue = value
	-- 	return context._currentValue
	-- end) --\[\[ ROBLOX CHECK: check if 'contextMap' is an Array \]\]
	for _, ref in contextMap do
		local context, value = ref[1], ref[2]
		context._currentValue = value
	end
	-- ROBLOX deviation END
end
local function inspectHooksOfForwardRef<Props, Ref>(
	renderFunction: (Props, Ref) -> React_Node --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: React$Node \]\],
	props: Props,
	ref: Ref,
	currentDispatcher: CurrentDispatcherRef
): HooksTree
	local previousDispatcher = currentDispatcher.current
	local readHookLog
	currentDispatcher.current = Dispatcher
	local ancestorStackError
	do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
		-- ROBLOX deviation START: doesn't return
		-- local ok, result, hasReturned = pcall(function()
		local ok, result = pcall(function()
			-- ROBLOX deviation END
			ancestorStackError = Error.new()
			renderFunction(props, ref)
		end)
		do
			readHookLog = hookLog
			hookLog = {}
			currentDispatcher.current = previousDispatcher
		end
		-- ROBLOX deviation START: doesn't return
		-- if hasReturned then
		-- 	return result
		-- end
		-- ROBLOX deviation END
		if not ok then
			error(result)
		end
	end
	-- ROBLOX deviation START: use dot notation
	-- local rootStack = ErrorStackParser:parse(ancestorStackError)
	local rootStack = ErrorStackParser.parse(ancestorStackError)
	-- ROBLOX deviation END
	return buildTree(rootStack, readHookLog)
end
-- ROBLOX deviation START: explicit type
-- local function resolveDefaultProps(Component, baseProps)
local function resolveDefaultProps(Component, baseProps: Object)
	-- ROBLOX deviation END
	-- ROBLOX deviation START: toJSBoolean not needed
	-- if
	-- 	Boolean.toJSBoolean(
	-- 		if Boolean.toJSBoolean(Component) then Component.defaultProps else Component
	-- 	)
	-- then
	if typeof(Component) == "table" and Component.defaultProps then
		-- ROBLOX deviation END
		-- Resolve default props. Taken from ReactElement
		local props = Object.assign({}, baseProps)
		local defaultProps = Component.defaultProps
		for propName in defaultProps do
			-- ROBLOX deviation START: needs cast
			-- if props[tostring(propName)] == nil then
			-- 	props[tostring(propName)] = defaultProps[tostring(propName)]
			if (props :: Object)[propName] == nil then
				(props :: Object)[propName] = defaultProps[propName]
			end
			-- ROBLOX deviation END
		end
		return props
	end
	return baseProps
end
local function inspectHooksOfFiber(fiber: Fiber, currentDispatcher: CurrentDispatcherRef?)
	-- DevTools will pass the current renderer's injected dispatcher.
	-- Other apps might compile debug hooks as part of their app though.
	if
		currentDispatcher == nil --\[\[ ROBLOX CHECK: loose equality used upstream \]\]
	then
		currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
	end
	currentFiber = fiber
	if
		fiber.tag ~= FunctionComponent
		and fiber.tag ~= SimpleMemoComponent
		and fiber.tag ~= ForwardRef
		and fiber.tag ~= Block
	then
		error(
			Error.new("Unknown Fiber. Needs to be a function component to inspect hooks.")
		)
	end -- Warm up the cache so that it doesn't consume the currentHook.
	getPrimitiveStackCache()
	local type_ = fiber.type
	local props = fiber.memoizedProps
	if type_ ~= fiber.elementType then
		props = resolveDefaultProps(type_, props)
	end -- Set up the current hook so that we can step through and read the
	-- current state from them.
	currentHook = fiber.memoizedState :: Hook
	local contextMap = Map.new()
	do --\[\[ ROBLOX COMMENT: try-finally block conversion \]\]
		-- ROBLOX deviation START: doesn't need conditional return
		-- local ok, result, hasReturned = pcall(function()
		local ok, result = pcall(function()
			-- ROBLOX deviation END
			setupContexts(contextMap, fiber)
			if fiber.tag == ForwardRef then
				return inspectHooksOfForwardRef(
					type_.render,
					props,
					fiber.ref,
					-- ROBLOX deviation START: needs cast
					-- currentDispatcher
					currentDispatcher :: CurrentDispatcherRef
					-- ROBLOX deviation END
				)
			end
			return inspectHooks(type_, props, currentDispatcher)
		end)
		do
			currentHook = nil
			restoreContexts(contextMap)
		end
		-- ROBLOX deviation START: doesn't need conditional return
		-- if hasReturned then
		-- 	return result
		-- end
		-- ROBLOX deviation END
		if not ok then
			error(result)
		end
		-- ROBLOX deviation START: add return
		return result
		-- ROBLOX deviation END
	end
end
exports.inspectHooksOfFiber = inspectHooksOfFiber
return exports ]]
aH.Children._bc316df264f5b2f4fd362ad463f82379=aI
local aJ

local aK={ClassName="ModuleScript",Children={},Properties={}}
aK.Name="ReactDebugTools"
aK.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/src/ReactDebugTools.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local exports = {}
local reactDebugHooksModule = require(script.Parent.ReactDebugHooks)
-- ROBLOX deviation START: add re-exporting of types
export type HooksNode = reactDebugHooksModule.HooksNode
export type HooksTree = reactDebugHooksModule.HooksTree
-- ROBLOX deviation END
local inspectHooks = reactDebugHooksModule.inspectHooks
local inspectHooksOfFiber = reactDebugHooksModule.inspectHooksOfFiber
exports.inspectHooks = inspectHooks
exports.inspectHooksOfFiber = inspectHooksOfFiber
return exports ]]
aH.Children._663bfd87e734063a7a8e837734658e53=aK
local aL

local aM={ClassName="Folder",Children={},Properties={}}
aM.Name="__tests__"
aH.Children._743fe0f10608f88e43c62d3b0bcf42fa=aM
local aN
local aO={ClassName="ModuleScript",Children={},Properties={}}
aO.Name="ReactDevToolsHooksIntegration.spec"
aO.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/src/__tests__/ReactDevToolsHooksIntegration-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 \]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: not needed
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
local Error = LuauPolyfill.Error
local JestGlobals = require(Packages.Dev.JestGlobals)
-- ROBLOX deviation START: add additional import
local afterEach = JestGlobals.afterEach
-- ROBLOX deviation END
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("React hooks DevTools integration", function()
	local React
	local ReactDebugTools
	local ReactTestRenderer
	local Scheduler
	local act
	local overrideHookState
	local scheduleUpdate
	local setSuspenseHandler
	beforeEach(function()
		-- ROBLOX deviation START: use _G instead of global
		-- global.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
			-- ROBLOX deviation END
			inject = function(injected)
				overrideHookState = injected.overrideHookState
				scheduleUpdate = injected.scheduleUpdate
				setSuspenseHandler = injected.setSuspenseHandler
			end,
			supportsFiber = true,
			onCommitFiberRoot = function() end,
			onCommitFiberUnmount = function() end,
		}
		jest.resetModules()
		-- ROBLOX deviation START: fix requires
		-- React = require_("react")
		-- ReactDebugTools = require_("react-debug-tools")
		-- ReactTestRenderer = require_("react-test-renderer")
		-- Scheduler = require_("scheduler")
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		React = require(Packages.Dev.React)
		ReactDebugTools = require(Packages.ReactDebugTools)
		Scheduler = require(Packages.Dev.Scheduler)
		-- ROBLOX deviation END
		act = ReactTestRenderer.act
	end)
	-- ROBLOX deviation START: add afterEach to revert global flag
	afterEach(function()
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = nil
	end)
	-- ROBLOX deviation END
	it("should support editing useState hooks", function()
		local setCountFn
		local function MyComponent()
			-- ROBLOX deviation START: useState returns 2 values
			-- local count, setCount = table.unpack(React.useState(0), 1, 2)
			local count, setCount = React.useState(0)
			-- ROBLOX deviation END
			setCountFn = setCount
			-- ROBLOX deviation START: use TextLabel instead
			-- return React.createElement("div", nil, "count:", count)
			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Text = "count:" }),
				React.createElement("TextLabel", { Text = tostring(count) })
			)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(MyComponent, nil))
		expect(renderer:toJSON()).toEqual({
			-- ROBLOX deviation START: use Frame instead
			-- type = "div",
			type = "Frame",
			-- ROBLOX deviation END
			props = {},
			-- ROBLOX deviation START: use TextLabels instead
			-- children = { "count:", "0" },
			children = {
				{ type = "TextLabel", props = { Text = "count:" } },
				{ type = "TextLabel", props = { Text = "0" } },
			},
			-- ROBLOX deviation END
		})
		local fiber = renderer.root:findByType(MyComponent):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(fiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(fiber)
		-- ROBLOX deviation END
		local stateHook = tree[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]
		expect(stateHook.isStateEditable).toBe(true)
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			overrideHookState(fiber, stateHook.id, {}, 10)
			expect(renderer:toJSON()).toEqual({
				-- ROBLOX deviation START: use Frame instead
				-- type = "div",
				type = "Frame",
				-- ROBLOX deviation END
				props = {},
				-- ROBLOX deviation START: use TextLabels instead
				-- children = { "count:", "10" },
				children = {
					{ type = "TextLabel", props = { Text = "count:" } },
					{ type = "TextLabel", props = { Text = "10" } },
				},
				-- ROBLOX deviation END
			})
			act(function()
				return setCountFn(function(count)
					return count + 1
				end)
			end)
			expect(renderer:toJSON()).toEqual({
				-- ROBLOX deviation START: use Frame instead
				-- type = "div",
				type = "Frame",
				-- ROBLOX deviation END
				props = {},
				-- ROBLOX deviation START: use TextLabels instead
				-- children = { "count:", "11" },
				children = {
					{ type = "TextLabel", props = { Text = "count:" } },
					{ type = "TextLabel", props = { Text = "11" } },
				},
				-- ROBLOX deviation END
			})
		end
	end)
	it("should support editable useReducer hooks", function()
		local initialData = { foo = "abc", bar = 123 }
		local function reducer(state, action)
			local condition_ = action.type
			if condition_ == "swap" then
				return { foo = state.bar, bar = state.foo }
			else
				error(Error.new())
			end
		end
		local dispatchFn
		local function MyComponent()
			-- ROBLOX deviation START: returns 2 values
			-- local state, dispatch =
			-- 	table.unpack(React.useReducer(reducer, initialData), 1, 2)
			-- ROBLOX deviation END
			local state, dispatch = React.useReducer(reducer, initialData)
			dispatchFn = dispatch
			-- ROBLOX deviation START: use Frame and TextLabels instead
			-- return React.createElement("div", nil, "foo:", state.foo, ", bar:", state.bar)
			return React.createElement(
				"Frame",
				{},
				React.createElement("TextLabel", { Text = "foo:" }),
				React.createElement("TextLabel", { Text = tostring(state.foo) }),
				React.createElement("TextLabel", { Text = ", bar:" }),
				React.createElement("TextLabel", { Text = tostring(state.bar) })
			)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(MyComponent, nil))
		expect(renderer:toJSON()).toEqual({
			-- ROBLOX deviation START: use Frame instead
			-- type = "div",
			type = "Frame",
			-- ROBLOX deviation END
			props = {},
			-- ROBLOX deviation START: use TextLabels instead
			-- children = { "foo:", "abc", ", bar:", "123" },
			children = {
				{ type = "TextLabel", props = { Text = "foo:" } },
				{ type = "TextLabel", props = { Text = "abc" } },
				{ type = "TextLabel", props = { Text = ", bar:" } },
				{ type = "TextLabel", props = { Text = "123" } },
			},
			-- ROBLOX deviation END
		})
		local fiber = renderer.root:findByType(MyComponent):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(fiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(fiber)
		-- ROBLOX deviation END
		local reducerHook = tree[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]
		expect(reducerHook.isStateEditable).toBe(true)
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			overrideHookState(fiber, reducerHook.id, { "foo" }, "def")
			expect(renderer:toJSON()).toEqual({
				-- ROBLOX deviation START: use Frame instead
				-- type = "div",
				type = "Frame",
				-- ROBLOX deviation END
				props = {},
				-- ROBLOX deviation START: use TextLabels instead
				-- children = { "foo:", "def", ", bar:", "123" },
				children = {
					{ type = "TextLabel", props = { Text = "foo:" } },
					{ type = "TextLabel", props = { Text = "def" } },
					{ type = "TextLabel", props = { Text = ", bar:" } },
					{ type = "TextLabel", props = { Text = "123" } },
				},
				-- ROBLOX deviation END
			})
			act(function()
				return dispatchFn({ type = "swap" })
			end)
			expect(renderer:toJSON()).toEqual({
				-- ROBLOX deviation START: use Frame instead
				-- type = "div",
				type = "Frame",
				-- ROBLOX deviation END
				props = {},
				-- ROBLOX deviation START: use TextLabels instead
				-- children = { "foo:", "123", ", bar:", "def" },
				children = {
					{ type = "TextLabel", props = { Text = "foo:" } },
					{ type = "TextLabel", props = { Text = "123" } },
					{ type = "TextLabel", props = { Text = ", bar:" } },
					{ type = "TextLabel", props = { Text = "def" } },
				},
				-- ROBLOX deviation END
			})
		end
	end) -- This test case is based on an open source bug report:
	-- facebookincubator/redux-react-hook/issues/34#issuecomment-466693787
	it(
		"should handle interleaved stateful hooks (e.g. useState) and non-stateful hooks (e.g. useContext)",
		function()
			local MyContext = React.createContext(1)
			local setStateFn
			local function useCustomHook()
				local context = React.useContext(MyContext)
				-- ROBLOX deviation START: returns 2 values
				-- local state, setState =
				-- 	table.unpack(React.useState({ count = context }), 1, 2)
				local state, setState = React.useState({ count = context })
				-- ROBLOX deviation END
				React.useDebugValue(state.count)
				setStateFn = setState
				return state.count
			end
			local function MyComponent()
				local count = useCustomHook()
				-- ROBLOX deviation START: use Frame and TextLabels instead
				-- return React.createElement("div", nil, "count:", count)
				return React.createElement(
					"Frame",
					nil,
					React.createElement("TextLabel", { Text = "count:" }),
					React.createElement("TextLabel", { Text = tostring(count) })
				)
				-- ROBLOX deviation END
			end
			local renderer =
				ReactTestRenderer.create(React.createElement(MyComponent, nil))
			expect(renderer:toJSON()).toEqual({
				-- ROBLOX deviation START: use Frame instead
				-- type = "div",
				type = "Frame",
				-- ROBLOX deviation END
				props = {},
				-- ROBLOX deviation START: use TextLabels instead
				-- children = { "count:", "1" },
				children = {
					{ type = "TextLabel", props = { Text = "count:" } },
					{ type = "TextLabel", props = { Text = "1" } },
				},
				-- ROBLOX deviation END
			})
			local fiber = renderer.root:findByType(MyComponent):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(fiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(fiber)
			-- ROBLOX deviation END
			local stateHook = tree[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			].subHooks[
				2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			]
			expect(stateHook.isStateEditable).toBe(true)
			-- ROBLOX deviation START: use _G.__DEV__
			-- if Boolean.toJSBoolean(__DEV__) then
			if _G.__DEV__ then
				-- ROBLOX deviation END
				overrideHookState(fiber, stateHook.id, { "count" }, 10)
				expect(renderer:toJSON()).toEqual({
					-- ROBLOX deviation START: use Frame instead
					-- type = "div",
					type = "Frame",
					-- ROBLOX deviation END
					props = {},
					-- ROBLOX deviation START: use TextLabels instead
					-- children = { "count:", "10" },
					children = {
						{ type = "TextLabel", props = { Text = "count:" } },
						{ type = "TextLabel", props = { Text = "10" } },
					},
					-- ROBLOX deviation END
				})
				act(function()
					return setStateFn(function(state)
						return { count = state.count + 1 }
					end)
				end)
				expect(renderer:toJSON()).toEqual({
					-- ROBLOX deviation START: use Frame instead
					-- type = "div",
					type = "Frame",
					-- ROBLOX deviation END
					props = {},
					-- ROBLOX deviation START: use TextLabels instead
					-- children = { "count:", "11" },
					children = {
						{ type = "TextLabel", props = { Text = "count:" } },
						{ type = "TextLabel", props = { Text = "11" } },
					},
					-- ROBLOX deviation END
				})
			end
		end
	)
	it("should support overriding suspense in legacy mode", function()
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			-- Lock the first render
			setSuspenseHandler(function()
				return true
			end)
		end
		local function MyComponent()
			-- ROBLOX deviation START: use TextLabel instead
			-- return "Done"
			return React.createElement("TextLabel", { Text = "Done" })
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(
			-- ROBLOX deviation START: use Frame instead
			-- "div",
			"Frame",
			-- ROBLOX deviation END
			nil,
			React.createElement(
				React.Suspense,
				-- ROBLOX deviation START: use TextLabel instead
				-- { fallback = "Loading" },
				{ fallback = React.createElement("TextLabel", { Text = "Loading" }) },
				-- ROBLOX deviation END
				React.createElement(MyComponent, nil)
			)
		))
		local fiber = renderer.root:_currentFiber().child
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			-- First render was locked
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" }) -- Release the lock
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return false
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" }) -- Lock again
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return true
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" }) -- Release the lock again
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return false
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" }) -- Ensure it checks specific fibers.
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function(f)
				return f == fiber or f == fiber.alternate
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function(f)
				return f ~= fiber and f ~= fiber.alternate
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
		else
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
		end
	end)
	it("should support overriding suspense in concurrent mode", function()
		-- ROBLOX deviation START: add useFakeTimers
		jest.useFakeTimers()
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			-- Lock the first render
			setSuspenseHandler(function()
				return true
			end)
		end
		local function MyComponent()
			-- ROBLOX deviation START: use TextLabel instead
			-- return "Done"
			return React.createElement("TextLabel", { Text = "Done" })
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(
			React.createElement(
				"div",
				nil,
				React.createElement(
					React.Suspense,
					-- ROBLOX deviation START: use TextLabel instead
					-- { fallback = "Loading" },
					{ fallback = React.createElement("TextLabel", { Text = "Loading" }) },
					-- ROBLOX deviation END
					React.createElement(MyComponent, nil)
				)
			),
			{ unstable_isConcurrent = true }
		)
		expect(Scheduler).toFlushAndYield({}) -- Ensure we timeout any suspense time.
		jest.advanceTimersByTime(1000)
		local fiber = renderer.root:_currentFiber().child
		-- ROBLOX deviation START: use _G.__DEV__
		-- if Boolean.toJSBoolean(__DEV__) then
		if _G.__DEV__ then
			-- ROBLOX deviation END
			-- First render was locked
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" }) -- Release the lock
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return false
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use dot notation
			-- Scheduler:unstable_flushAll()
			Scheduler.unstable_flushAll()
			-- ROBLOX deviation END
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" }) -- Lock again
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return true
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" }) -- Release the lock again
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function()
				return false
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" }) -- Ensure it checks specific fibers.
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function(f)
				return f == fiber or f == fiber.alternate
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Loading" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Loading" },
				},
			})
			-- ROBLOX deviation END
			setSuspenseHandler(function(f)
				return f ~= fiber and f ~= fiber.alternate
			end)
			scheduleUpdate(fiber) -- Re-render
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
			-- ROBLOX deviation END
		else
			-- ROBLOX deviation START: use TextLabel instead
			-- expect(renderer:toJSON().children).toEqual({ "Done" })
			expect(renderer:toJSON().children).toEqual({
				{
					type = "TextLabel",
					props = { Text = "Done" },
				},
			})
		end
		-- ROBLOX deviation START: add useRealTimers
		jest.useRealTimers()
		-- ROBLOX deviation END
	end)
end) ]]
aN.Children._a2a05fcce9e0b469878d90b3fe67bb05=aO
local aP

local aQ={ClassName="ModuleScript",Children={},Properties={}}
aQ.Name="ReactHooksInspection.spec"
aQ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/src/__tests__/ReactHooksInspection-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 \]\]
local Packages = script.Parent.Parent.Parent
-- ROBLOX deviation START: not needed
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest

local React
local ReactDebugTools
describe("ReactHooksInspection", function()
	beforeEach(function()
		jest.resetModules()
		-- ROBLOX deviation START: fix requires
		-- React = require_("react")
		-- ReactDebugTools = require_("react-debug-tools")
		React = require(Packages.Dev.React)
		ReactDebugTools = require(Packages.ReactDebugTools)
		-- ROBLOX deviation END
	end)
	it("should inspect a simple useState hook", function()
		local function Foo(props)
			-- ROBLOX deviation START: useState returns 2 values
			-- local state = React.useState("hello world")[1]
			local state = React.useState("hello world")
			-- ROBLOX deviation END
			return React.createElement("div", nil, state)
		end
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooks(Foo, {})
		local tree = ReactDebugTools.inspectHooks(Foo, {})
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = "hello world",
				subHooks = {},
			},
		})
	end)
	it("should inspect a simple custom hook", function()
		local function useCustom(value)
			local state = React.useState(value)[1]
			React.useDebugValue("custom hook label")
			return state
		end
		local function Foo(props)
			local value = useCustom("hello world")
			return React.createElement("div", nil, value)
		end
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooks(Foo, {})
		local tree = ReactDebugTools.inspectHooks(Foo, {})
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				id = nil,
				name = "Custom",
				-- ROBLOX deviation START: use _G.__DEV__
				-- value = if Boolean.toJSBoolean(__DEV__) then "custom hook label" else nil,
				value = if _G.__DEV__ then "custom hook label" else nil,
				-- ROBLOX deviation END
				subHooks = {
					{
						isStateEditable = true,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 0,
						id = 1,
						-- ROBLOX deviation END
						name = "State",
						value = "hello world",
						subHooks = {},
					},
				},
			},
		})
	end)
	it("should inspect a tree of multiple hooks", function()
		local function effect() end
		local function useCustom(value)
			-- ROBLOX deviation START: useState returns 2 values
			-- local state = React.useState(value)[1]
			local state = React.useState(value)
			-- ROBLOX deviation END
			React.useEffect(effect)
			return state
		end
		local function Foo(props)
			local value1 = useCustom("hello")
			local value2 = useCustom("world")
			return React.createElement("div", nil, value1, " ", value2)
		end
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooks(Foo, {})
		local tree = ReactDebugTools.inspectHooks(Foo, {})
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				id = nil,
				name = "Custom",
				value = nil,
				subHooks = {
					{
						isStateEditable = true,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 0,
						id = 1,
						-- ROBLOX deviation END
						name = "State",
						subHooks = {},
						-- ROBLOX deviation START: tell Luau to type this field loosely
						value = "hello" :: any,
						-- ROBLOX deviation END
					},
					{
						isStateEditable = false,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 1,
						id = 2,
						-- ROBLOX deviation END
						name = "Effect",
						subHooks = {},
						value = effect,
					},
				},
			},
			{
				isStateEditable = false,
				id = nil,
				name = "Custom",
				value = nil,
				subHooks = {
					{
						isStateEditable = true,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 2,
						id = 3,
						-- ROBLOX deviation END
						name = "State",
						-- ROBLOX deviation START: Luau doesn't support mixed arrays
						-- value = "world",
						value = "world" :: any,
						-- ROBLOX deviation END
						subHooks = {},
					},
					{
						isStateEditable = false,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 3,
						id = 4,
						-- ROBLOX deviation END
						name = "Effect",
						value = effect,
						subHooks = {},
					},
				},
			},
		})
	end)
	it("should inspect a tree of multiple levels of hooks", function()
		local function effect() end
		local function useCustom(value)
			local state = React.useReducer(function(s, a)
				return s
				-- ROBLOX deviation START: useReducer returns 2 values
				-- end, value)[1]
			end, value)
			-- ROBLOX deviation END
			React.useEffect(effect)
			return state
		end
		local function useBar(value)
			local result = useCustom(value)
			React.useLayoutEffect(effect)
			return result
		end
		local function useBaz(value)
			React.useLayoutEffect(effect)
			local result = useCustom(value)
			return result
		end
		local function Foo(props)
			local value1 = useBar("hello")
			local value2 = useBaz("world")
			return React.createElement("div", nil, value1, " ", value2)
		end
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooks(Foo, {})
		local tree = ReactDebugTools.inspectHooks(Foo, {})
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				-- ROBLOX deviation START: tell Luau to type this field loosely
				id = nil :: number?,
				-- ROBLOX deviation END
				name = "Bar",
				value = nil,
				subHooks = {
					{
						isStateEditable = false,
						-- ROBLOX deviation START: Luau doesn't support mixed arrays
						-- id = nil,
						id = nil :: number | nil,
						-- ROBLOX deviation END
						name = "Custom",
						-- ROBLOX deviation START: Luau doesn't support mixed arrays
						-- value = nil,
						value = nil :: any,
						-- ROBLOX deviation END
						subHooks = {
							{
								isStateEditable = true,
								-- ROBLOX deviation START: adjust for 1-based indexing
								-- id = 0,
								id = 1,
								-- ROBLOX deviation END
								name = "Reducer",
								-- ROBLOX deviation START: Luau doesn't support mixed arrays
								-- value = "hello",
								value = "hello" :: any,
								-- ROBLOX deviation END
								subHooks = {},
							},
							{
								isStateEditable = false,
								-- ROBLOX deviation START: adjust for 1-based indexing
								-- id = 1,
								id = 2,
								-- ROBLOX deviation END
								name = "Effect",
								value = effect,
								subHooks = {},
							},
						},
					},
					{
						isStateEditable = false,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 2,
						id = 3,
						-- ROBLOX deviation END
						name = "LayoutEffect",
						value = effect,
						subHooks = {},
					},
				},
			},
			{
				isStateEditable = false,
				id = nil,
				name = "Baz",
				value = nil,
				subHooks = {
					{
						isStateEditable = false,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 3,
						id = 4 :: number?,
						-- ROBLOX deviation END
						name = "LayoutEffect",
						-- ROBLOX deviation START: Luau doesn't support mixed arrays
						-- value = effect,
						value = effect :: any,
						-- ROBLOX deviation END
						subHooks = {},
					},
					{
						isStateEditable = false,
						id = nil,
						name = "Custom",
						subHooks = {
							{
								isStateEditable = true,
								-- ROBLOX deviation START: adjust for 1-based indexing
								-- id = 4,
								id = 5,
								-- ROBLOX deviation END
								name = "Reducer",
								subHooks = {},
								-- ROBLOX deviation START: Luau doesn't support mixed arrays
								-- value = "world",
								value = "world" :: any,
								-- ROBLOX deviation END
							},
							{
								isStateEditable = false,
								-- ROBLOX deviation START: adjust for 1-based indexing
								-- id = 5,
								id = 6,
								-- ROBLOX deviation END
								name = "Effect",
								subHooks = {},
								value = effect,
							},
						},
						value = nil,
					},
				},
			},
		})
	end)
	it("should inspect the default value using the useContext hook", function()
		local MyContext = React.createContext("default")
		local function Foo(props)
			local value = React.useContext(MyContext)
			return React.createElement("div", nil, value)
		end
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooks(Foo, {})
		local tree = ReactDebugTools.inspectHooks(Foo, {})
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				id = nil,
				name = "Context",
				value = "default",
				subHooks = {},
			},
		})
	end)
	it("should support an injected dispatcher", function()
		local function Foo(props)
			-- ROBLOX deviation START: useState returns 2 values
			-- local state = React.useState("hello world")[1]
			local state = React.useState("hello world")
			-- ROBLOX deviation END
			return React.createElement("div", nil, state)
		end
		local initial = {}
		local current = initial
		local getterCalls = 0
		local setterCalls = {}
		-- ROBLOX deviation START: implement getter and setter
		-- local FakeDispatcherRef = {
		-- 	current = function(self)
		-- 		getterCalls += 1
		-- 		return current
		-- 	end,
		-- 	current = function(self, value)
		-- 		table.insert(setterCalls, value) --\[\[ ROBLOX CHECK: check if 'setterCalls' is an Array \]\]
		-- 		current = value
		-- 	end,
		-- }
		local FakeDispatcherRef = setmetatable({
			__getters = {
				current = function(self)
					print("getting current")
					getterCalls += 1
					return current
				end,
			},
			__setters = {
				current = function(self, value)
					print("setting current", value)
					table.insert(setterCalls, value)
					current = value
				end,
			},
		}, {
			__index = function(self, key)
				if typeof(self.__getters[key]) == "function" then
					return self.__getters[key](self)
				else
					return nil
				end
			end,
			__newindex = function(self, key, value)
				if typeof(self.__setters[key]) == "function" then
					return self.__setters[key](self, value)
				else
					return nil
				end
			end,
		}) :: any
		-- ROBLOX deviation END
		-- ROBLOX deviation START: aligned to React 18 so we get a hot path optimization in upstream
		-- expect(function()
		-- 	ReactDebugTools:inspectHooks(Foo, {}, FakeDispatcherRef)
		-- end).toThrow(
		-- 	"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
		-- 		.. " one of the following reasons:\n"
		-- 		.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
		-- 		.. "2. You might be breaking the Rules of Hooks\n"
		-- 		.. "3. You might have more than one copy of React in the same app\n"
		-- 		.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		-- )
		local didCatch = false
		expect(function()
			-- mock the Error constructor to check the internal of the error instance
			expect(function()
				ReactDebugTools.inspectHooks(Foo, {}, FakeDispatcherRef)
			end).toThrow(
				-- ROBLOX NOTE: Lua-specific error on nil deref
				"attempt to index nil with 'useState'"
			)
			didCatch = true
		end).toErrorDev(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.",
			{ withoutStack = true }
		)
		-- avoid false positive if no error was thrown at all
		expect(didCatch).toBe(true)
		-- ROBLOX deviation END
		expect(getterCalls).toBe(1)
		expect(setterCalls).toHaveLength(2)
		expect(setterCalls[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			-- ROBLOX deviation START: use never instead of ["not"]
			-- ])["not"].toBe(initial)
		]).never.toBe(initial)
		-- ROBLOX deviation END
		expect(setterCalls[
			2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]).toBe(initial)
	end)
	describe("useDebugValue", function()
		it("should be ignored when called outside of a custom hook", function()
			local function Foo(props)
				React.useDebugValue("this is invalid")
				return nil
			end
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooks(Foo, {})
			local tree = ReactDebugTools.inspectHooks(Foo, {})
			-- ROBLOX deviation END
			expect(tree).toHaveLength(0)
		end)
		it("should support an optional formatter function param", function()
			local function useCustom()
				React.useDebugValue({ bar = 123 }, function(object)
					return ("bar:%s"):format(tostring(object.bar))
				end)
				React.useState(0)
			end
			local function Foo(props)
				useCustom()
				return nil
			end
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooks(Foo, {})
			local tree = ReactDebugTools.inspectHooks(Foo, {})
			-- ROBLOX deviation END
			expect(tree).toEqual({
				{
					isStateEditable = false,
					id = nil,
					name = "Custom",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__) then "bar:123" else nil,
					value = if _G.__DEV__ then "bar:123" else nil,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 0,
							id = 1,
							-- ROBLOX deviation END
							name = "State",
							subHooks = {},
							value = 0,
						},
					},
				},
			})
		end)
	end)
end) ]]
aN.Children._e3df571efe41ce7eba2fe91f7b869fdd=aQ
local aR

local aS={ClassName="ModuleScript",Children={},Properties={}}
aS.Name="ReactHooksInspectionIntegration.spec"
aS.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-debug-tools/src/__tests__/ReactHooksInspectionIntegration-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 \]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: not needed
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
-- ROBLOX deviation START: import from dev dependencies
-- local Promise = require(Packages.Promise)
local Promise = require(Packages.Dev.Promise)
-- ROBLOX deviation END
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest
-- ROBLOX deviation START: add additional imports
local String = LuauPolyfill.String
-- ROBLOX deviation END

local React
local ReactTestRenderer
local Scheduler
local ReactDebugTools
local act
describe("ReactHooksInspectionIntegration", function()
	beforeEach(function()
		jest.resetModules()
		-- ROBLOX deviation START: fix requires
		-- React = require_("react")
		-- ReactTestRenderer = require_("react-test-renderer")
		-- Scheduler = require_("scheduler")
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		Scheduler = require(Packages.Dev.Scheduler)
		React = require(Packages.Dev.React)
		-- ROBLOX deviation END
		act = ReactTestRenderer.unstable_concurrentAct
		-- ROBLOX deviation START: fix requires
		-- ReactDebugTools = require_("react-debug-tools")
		ReactDebugTools = require(Packages.ReactDebugTools)
		-- ROBLOX deviation END
	end)
	it("should inspect the current state of useState hooks", function()
		local useState = React.useState
		local function Foo(props)
			-- ROBLOX deviation START: useState returns 2 values
			-- local state1, setState1 = table.unpack(useState("hello"), 1, 2)
			-- local state2, setState2 = table.unpack(useState("world"), 1, 2)
			local state1, setState1 = useState("hello")
			local state2, setState2 = useState("world")
			-- ROBLOX deviation END
			return React.createElement(
				-- ROBLOX deviation START: use Frame instead
				-- "div",
				"Frame",
				-- ROBLOX deviation END
				{ onMouseDown = setState1, onMouseUp = setState2 },
				state1,
				" ",
				state2
			)
		end
		local renderer =
			ReactTestRenderer.create(React.createElement(Foo, { prop = "prop" }))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = "hello",
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				name = "State",
				value = "world",
				subHooks = {},
			},
		})
		local setStateA, setStateB
		do
			-- ROBLOX deviation START: use Frame instead
			-- local ref = renderer.root:findByType("div").props
			local ref = renderer.root:findByType("Frame").props
			-- ROBLOX deviation END
			setStateA, setStateB = ref.onMouseDown, ref.onMouseUp
		end
		act(function()
			return setStateA("Hi")
		end)
		childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = "Hi",
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				name = "State",
				value = "world",
				subHooks = {},
			},
		})
		act(function()
			return setStateB("world!")
		end)
		childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = "Hi",
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				name = "State",
				value = "world!",
				subHooks = {},
			},
		})
	end)
	it("should inspect the current state of all stateful hooks", function()
		local outsideRef = React.createRef()
		local function effect() end
		local function Foo(props)
			-- ROBLOX deviation START: useState and useReducer return 2 values
			-- local state1, setState = table.unpack(React.useState("a"), 1, 2)
			-- local state2, dispatch = table.unpack(
			-- 	React.useReducer(function(s, a)
			-- 		return a.value
			-- 	end, "b"),
			-- 	1,
			-- 	2
			-- )
			local state1, setState = React.useState("a")
			local state2, dispatch = React.useReducer(function(s, a)
				return a.value
			end, "b")
			-- ROBLOX deviation END
			local ref = React.useRef("c")
			React.useLayoutEffect(effect)
			React.useEffect(effect)
			React.useImperativeHandle(outsideRef, function()
				-- Return a function so that jest treats them as non-equal.
				return function() end
			end, {})
			React.useMemo(function()
				-- ROBLOX deviation START: use string concatenation
				-- return state1 + state2
				return state1 .. state2
				-- ROBLOX deviation END
			end, { state1 })
			local function update()
				act(function()
					setState("A")
				end)
				act(function()
					dispatch({ value = "B" })
				end)
				ref.current = "C"
			end
			local memoizedUpdate = React.useCallback(update, {})
			return React.createElement(
				-- ROBLOX deviation START: use Frame instead
				-- "div",
				"Frame",
				-- ROBLOX deviation END
				{ onClick = memoizedUpdate },
				state1,
				" ",
				state2
			)
		end
		local renderer
		act(function()
			renderer =
				ReactTestRenderer.create(React.createElement(Foo, { prop = "prop" }))
		end)
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use Frame instead
		-- local updateStates = renderer.root:findByType("div").props.onClick
		local updateStates = renderer.root:findByType("Frame").props.onClick
		-- ROBLOX deviation END
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				-- ROBLOX deviation START: tell Luau to type this field loosely
				value = "a" :: any,
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				name = "Reducer",
				value = "b",
				subHooks = {},
			},
			-- ROBLOX deviation START: adjust for 1-based indexing
			-- { isStateEditable = false, id = 2, name = "Ref", value = "c", subHooks = {} },
			{ isStateEditable = false, id = 3, name = "Ref", value = "c", subHooks = {} },
			-- ROBLOX deviation END
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 3,
				id = 4,
				-- ROBLOX deviation END
				name = "LayoutEffect",
				value = effect,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 4,
				id = 5,
				-- ROBLOX deviation END
				name = "Effect",
				value = effect,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 5,
				id = 6,
				-- ROBLOX deviation END
				name = "ImperativeHandle",
				value = outsideRef.current,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 6,
				id = 7,
				-- ROBLOX deviation END
				name = "Memo",
				-- ROBLOX deviation START: useMemo wraps a value
				-- value = "ab",
				value = { "ab" },
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 7,
				id = 8,
				-- ROBLOX deviation END
				name = "Callback",
				value = updateStates,
				subHooks = {},
			},
		})
		updateStates()
		childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				-- ROBLOX deviation START: tell Luau to type this field loosely
				value = "A" :: any,
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				name = "Reducer",
				value = "B",
				subHooks = {},
			},
			-- ROBLOX deviation START: adjust for 1-based indexing
			-- { isStateEditable = false, id = 2, name = "Ref", value = "C", subHooks = {} },
			{ isStateEditable = false, id = 3, name = "Ref", value = "C", subHooks = {} },
			-- ROBLOX deviation END
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 3,
				id = 4,
				-- ROBLOX deviation END
				name = "LayoutEffect",
				value = effect,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 4,
				id = 5,
				-- ROBLOX deviation END
				name = "Effect",
				value = effect,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 5,
				id = 6,
				-- ROBLOX deviation END
				name = "ImperativeHandle",
				value = outsideRef.current,
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 6,
				id = 7,
				-- ROBLOX deviation END
				name = "Memo",
				-- ROBLOX deviation START: useMemo wraps a value
				-- value = "Ab",
				value = { "Ab" },
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 7,
				id = 8,
				-- ROBLOX deviation END
				name = "Callback",
				value = updateStates,
				subHooks = {},
			},
		})
	end)
	it("should inspect the value of the current provider in useContext", function()
		local MyContext = React.createContext("default")
		local function Foo(props)
			local value = React.useContext(MyContext)
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, value)
			return React.createElement("Frame", nil, value)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(
			React.createElement(
				MyContext.Provider,
				{ value = "contextual" },
				React.createElement(Foo, { prop = "prop" })
			)
		)
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: adjust for 1-based indexing
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				id = nil,
				name = "Context",
				value = "contextual",
				subHooks = {},
			},
		})
	end)
	it("should inspect forwardRef", function()
		local function obj() end
		local Foo = React.forwardRef(function(props, ref)
			React.useImperativeHandle(ref, function()
				return obj
			end)
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil)
			return React.createElement("Frame", nil)
			-- ROBLOX deviation END
		end)
		local ref = React.createRef()
		local renderer = ReactTestRenderer.create(React.createElement(Foo, { ref = ref }))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "ImperativeHandle",
				value = obj,
				subHooks = {},
			},
		})
	end)
	it("should inspect memo", function()
		local function InnerFoo(props)
			-- ROBLOX deviation START: useState returns 2 values
			-- local value = React.useState("hello")[1]
			local value = React.useState("hello")
			-- ROBLOX deviation END
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, value)
			return React.createElement("Frame", nil, value)
			-- ROBLOX deviation END
		end
		local Foo = React.memo(InnerFoo)
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil)) -- TODO: Test renderer findByType is broken for memo. Have to search for the inner.
		local childFiber = renderer.root:findByType(InnerFoo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = "hello",
				subHooks = {},
			},
		})
	end)
	it("should inspect custom hooks", function()
		local function useCustom()
			-- ROBLOX deviation START: useState returns 2 values
			-- local value = React.useState("hello")[1]
			local value = React.useState("hello")
			-- ROBLOX deviation END
			return value
		end
		local function Foo(props)
			local value = useCustom()
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, value)
			return React.createElement("Frame", nil, value)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				id = nil,
				name = "Custom",
				value = nil,
				subHooks = {
					{
						isStateEditable = true,
						-- ROBLOX deviation START: adjust for 1-based indexing
						-- id = 0,
						id = 1,
						-- ROBLOX deviation END
						name = "State",
						value = "hello",
						subHooks = {},
					},
				},
			},
		})
	end) -- @gate experimental
	-- ROBLOX deviation START: unstable_useTransition is not implemented
	-- it("should support composite useTransition hook", function()
	it.skip("should support composite useTransition hook", function()
		-- ROBLOX deviation END
		local function Foo(props)
			-- ROBLOX deviation START: not supported
			-- React.unstable_useTransition()
			-- ROBLOX deviation END
			local memoizedValue = React.useMemo(function()
				return "hello"
			end, {})
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, memoizedValue)
			return React.createElement("Frame", nil, memoizedValue)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				isStateEditable = false,
				name = "Transition",
				-- ROBLOX deviation START: tell Luau to type this field loosely
				value = nil :: any,
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				isStateEditable = false,
				name = "Memo",
				value = "hello",
				subHooks = {},
			},
		})
	end) -- @gate experimental
	-- ROBLOX deviation START: unstable_useDeferredValue not implemented
	-- it("should support composite useDeferredValue hook", function()
	it.skip("should support composite useDeferredValue hook", function()
		-- ROBLOX deviation END
		local function Foo(props)
			-- ROBLOX deviation START: not implemented
			-- React.unstable_useDeferredValue("abc", { timeoutMs = 500 })
			-- ROBLOX deviation END
			local state = React.useState(function()
				return "hello"
				-- ROBLOX deviation START: useState returns 2 values
				-- end, {})[1]
			end, {})
			-- ROBLOX deviation END
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, state)
			return React.createElement("Frame", nil, state)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				isStateEditable = false,
				name = "DeferredValue",
				value = "abc",
				subHooks = {},
			},
			{
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				isStateEditable = true,
				name = "State",
				value = "hello",
				subHooks = {},
			},
		})
	end) -- @gate experimental
	-- ROBLOX deviation START: unstable_useOpaqueIdentifier not implemented
	-- it("should support composite useOpaqueIdentifier hook", function()
	it.skip("should support composite useOpaqueIdentifier hook", function()
		-- ROBLOX deviation END
		local function Foo(props)
			-- ROBLOX deviation START: not implemented
			-- local id = React.unstable_useOpaqueIdentifier()
			local id = nil
			-- ROBLOX deviation END
			local state = React.useState(function()
				return "hello"
				-- ROBLOX deviation START: useState returns 2 values
				-- end, {})[1]
			end, {})
			-- ROBLOX deviation END
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", { id = id }, state)
			return React.createElement("Frame", { id = id }, state)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		local childFiber = renderer.root:findByType(Foo):_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		-- ROBLOX deviation START: fix length implementation
		-- expect(tree.length).toEqual(2)
		expect(#tree).toEqual(2)
		-- ROBLOX deviation END
		expect(tree[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		].id).toEqual(0)
		expect(tree[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		].isStateEditable).toEqual(false)
		expect(tree[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		].name).toEqual("OpaqueIdentifier")
		-- ROBLOX deviation START: use String.startsWith
		-- expect((tostring(tree[
		-- 	1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		-- ].value) .. ""):startsWith("c_")).toBe(true)
		expect(String.startsWith(tree[1].value :: string .. "", "c_")).toBe(true)
		-- ROBLOX deviation END
		expect(tree[
			2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]).toEqual({
			-- ROBLOX deviation START: adjust for 1-based indexing
			-- id = 1,
			id = 2,
			-- ROBLOX deviation END
			isStateEditable = true,
			name = "State",
			value = "hello",
			subHooks = {},
		})
	end) -- @gate experimental
	-- ROBLOX deviation START: unstable_useOpaqueIdentifier not implemented
	-- it("should support composite useOpaqueIdentifier hook in concurrent mode", function()
	it.skip(
		"should support composite useOpaqueIdentifier hook in concurrent mode",
		function()
			-- ROBLOX deviation END
			local function Foo(props)
				-- ROBLOX FIXME: type this correctly when this is supported
				local id = (React :: any).unstable_useOpaqueIdentifier()
				local state = React.useState(function()
					return "hello"
					-- ROBLOX deviation START: useState returns 2 values
					-- end, {})[1]
				end, {})
				-- ROBLOX deviation END
				-- ROBLOX deviation START: use Frame instead
				-- return React.createElement("div", { id = id }, state)
				return React.createElement("Frame", { id = id }, state)
				-- ROBLOX deviation END
			end
			local renderer = ReactTestRenderer.create(
				React.createElement(Foo, nil),
				{ unstable_isConcurrent = true }
			)
			expect(Scheduler).toFlushWithoutYielding()
			local childFiber = renderer.root:findByType(Foo):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			-- ROBLOX deviation START: fix length conversion
			-- expect(tree.length).toEqual(2)
			expect(#tree).toEqual(2)
			-- ROBLOX deviation END
			expect(tree[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			].id).toEqual(0)
			expect(tree[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			].isStateEditable).toEqual(false)
			expect(tree[
				1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			].name).toEqual("OpaqueIdentifier")
			-- ROBLOX deviation START: use String.startsWith
			-- expect((tostring(tree[
			-- 	1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			-- ].value) .. ""):startsWith("c_")).toBe(true)
			expect(String.startsWith(tree[1].value :: string .. "", "c_")).toBe(true)
			-- ROBLOX deviation END
			expect(tree[
				2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			]).toEqual({
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 1,
				id = 2,
				-- ROBLOX deviation END
				isStateEditable = true,
				name = "State",
				value = "hello",
				subHooks = {},
			})
		end
	)
	describe("useDebugValue", function()
		it("should support inspectable values for multiple custom hooks", function()
			local function useLabeledValue(label)
				-- ROBLOX deviation START: useState returns 2 values
				-- local value = React.useState(label)[1]
				local value = React.useState(label)
				-- ROBLOX deviation END
				React.useDebugValue(("custom label %s"):format(tostring(label)))
				return value
			end
			local function useAnonymous(label)
				-- ROBLOX deviation START: useState returns 2 values
				-- local value = React.useState(label)[1]
				local value = React.useState(label)
				-- ROBLOX deviation END
				return value
			end
			local function Example()
				useLabeledValue("a")
				React.useState("b")
				useAnonymous("c")
				useLabeledValue("d")
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(Example, nil))
			local childFiber = renderer.root:findByType(Example):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			expect(tree).toEqual({
				{
					isStateEditable = false,
					-- ROBLOX deviation START: tell Luau to type this field loosely
					id = nil :: number?,
					-- ROBLOX deviation END
					name = "LabeledValue",
					-- ROBLOX deviation START: use _G.__DEV__ and cast
					-- value = if Boolean.toJSBoolean(__DEV__)
					-- 	then "custom label a"
					-- 	else nil,
					value = (if _G.__DEV__ then "custom label a" else nil) :: any,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 0,
							id = 1,
							-- ROBLOX deviation END
							name = "State",
							value = "a",
							subHooks = {},
						},
					},
				},
				{
					isStateEditable = true,
					-- ROBLOX deviation START: adjust for 1-based indexing
					-- id = 1,
					id = 2,
					-- ROBLOX deviation END
					name = "State",
					value = "b",
					subHooks = {},
				},
				{
					isStateEditable = false,
					id = nil,
					name = "Anonymous",
					value = nil,
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 2,
							id = 3,
							-- ROBLOX deviation END
							name = "State",
							value = "c",
							subHooks = {},
						},
					},
				},
				{
					isStateEditable = false,
					id = nil,
					name = "LabeledValue",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__)
					value = if _G.__DEV__
						-- ROBLOX deviation END
						then "custom label d"
						else nil,
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 3,
							id = 4,
							-- ROBLOX deviation END
							name = "State",
							value = "d",
							subHooks = {},
						},
					},
				},
			})
		end)
		it("should support inspectable values for nested custom hooks", function()
			local function useInner()
				React.useDebugValue("inner")
				React.useState(0)
			end
			local function useOuter()
				React.useDebugValue("outer")
				useInner()
			end
			local function Example()
				useOuter()
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(Example, nil))
			local childFiber = renderer.root:findByType(Example):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			expect(tree).toEqual({
				{
					isStateEditable = false,
					id = nil,
					name = "Outer",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__) then "outer" else nil,
					value = if _G.__DEV__ then "outer" else nil,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = false,
							id = nil,
							name = "Inner",
							-- ROBLOX deviation START: use _G.__DEV__
							-- value = if Boolean.toJSBoolean(__DEV__) then "inner" else nil,
							value = if _G.__DEV__ then "inner" else nil,
							-- ROBLOX deviation END
							subHooks = {
								{
									isStateEditable = true,
									-- ROBLOX deviation START: adjust for 1-based indexing
									-- id = 0,
									id = 1,
									-- ROBLOX deviation END
									name = "State",
									value = 0,
									subHooks = {},
								},
							},
						},
					},
				},
			})
		end)
		it("should support multiple inspectable values per custom hooks", function()
			local function useMultiLabelCustom()
				React.useDebugValue("one")
				React.useDebugValue("two")
				React.useDebugValue("three")
				React.useState(0)
			end
			local function useSingleLabelCustom(value)
				React.useDebugValue(("single %s"):format(tostring(value)))
				React.useState(0)
			end
			local function Example()
				useSingleLabelCustom("one")
				useMultiLabelCustom()
				useSingleLabelCustom("two")
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(Example, nil))
			local childFiber = renderer.root:findByType(Example):_currentFiber()
			-- ROBLOX deviation START: adjust for 1-based indexing
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			expect(tree).toEqual({
				{
					isStateEditable = false,
					-- ROBLOX deviation START: Luau doesn't support mixed arrays
					-- id = nil,
					id = nil :: number | nil,
					-- ROBLOX deviation END
					name = "SingleLabelCustom",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__) then "single one" else nil,
					value = (if _G.__DEV__ then "single one" else nil) :: any,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 0,
							id = 1,
							-- ROBLOX deviation END
							name = "State",
							value = 0,
							subHooks = {},
						},
					},
				},
				{
					isStateEditable = false,
					id = nil,
					name = "MultiLabelCustom",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__)
					value = if _G.__DEV__
						-- ROBLOX deviation END
						then { "one", "two", "three" }
						else nil,
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 1,
							id = 2,
							-- ROBLOX deviation END
							name = "State",
							value = 0,
							subHooks = {},
						},
					},
				},
				{
					isStateEditable = false,
					id = nil,
					name = "SingleLabelCustom",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__) then "single two" else nil,
					value = if _G.__DEV__ then "single two" else nil,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 2,
							id = 3,
							-- ROBLOX deviation END
							name = "State",
							value = 0,
							subHooks = {},
						},
					},
				},
			})
		end)
		it("should ignore useDebugValue() made outside of a custom hook", function()
			local function Example()
				React.useDebugValue("this is invalid")
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(Example, nil))
			local childFiber = renderer.root:findByType(Example):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			expect(tree).toHaveLength(0)
		end)
		it("should support an optional formatter function param", function()
			local function useCustom()
				React.useDebugValue({ bar = 123 }, function(object)
					return ("bar:%s"):format(tostring(object.bar))
				end)
				React.useState(0)
			end
			local function Example()
				useCustom()
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(Example, nil))
			local childFiber = renderer.root:findByType(Example):_currentFiber()
			-- ROBLOX deviation START: use dot notation
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
			-- ROBLOX deviation END
			expect(tree).toEqual({
				{
					isStateEditable = false,
					id = nil,
					name = "Custom",
					-- ROBLOX deviation START: use _G.__DEV__
					-- value = if Boolean.toJSBoolean(__DEV__) then "bar:123" else nil,
					value = if _G.__DEV__ then "bar:123" else nil,
					-- ROBLOX deviation END
					subHooks = {
						{
							isStateEditable = true,
							-- ROBLOX deviation START: adjust for 1-based indexing
							-- id = 0,
							id = 1,
							-- ROBLOX deviation END
							name = "State",
							subHooks = {},
							value = 0,
						},
					},
				},
			})
		end)
	end)
	-- ROBLOX deviation START: defaultProps not supported for function components yet
	-- it("should support defaultProps and lazy", function()
	it.skip("should support defaultProps and lazy", function()
		-- ROBLOX deviation END
		return Promise.resolve():andThen(function()
			-- ROBLOX deviation START: defaultProps not supported for function components yet
			-- local Suspense = React.Suspense
			-- local function Foo(props)
			-- 	local value = React.useState(props.defaultValue:substr(0, 3))[1]
			-- 	return React.createElement("div", nil, value)
			-- end
			-- Foo.defaultProps = { defaultValue = "default" }
			-- local function fakeImport(result)
			-- 	return Promise.resolve():andThen(function()
			-- 		return { default = result }
			-- 	end)
			-- end
			-- local LazyFoo = React.lazy(function()
			-- 	return fakeImport(Foo)
			-- end)
			-- local renderer = ReactTestRenderer.create(
			-- 	React.createElement(
			-- 		Suspense,
			-- 		{ fallback = "Loading..." },
			-- 		React.createElement(LazyFoo, nil)
			-- 	)
			-- )
			-- LazyFoo:expect()
			-- Scheduler:unstable_flushAll()
			-- local childFiber = renderer.root:_currentFiber()
			-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
			-- expect(tree).toEqual({
			-- 	{
			-- 		isStateEditable = true,
			-- 		id = 0,
			-- 		name = "State",
			-- 		value = "def",
			-- 		subHooks = {},
			-- 	},
			-- })
			-- ROBLOX deviation END
		end)
	end)
	it("should support an injected dispatcher", function()
		local function Foo(props)
			-- ROBLOX deviation START: useState returns 2 values
			-- local state = React.useState("hello world")[1]
			local state = React.useState("hello world")
			-- ROBLOX deviation END
			-- ROBLOX deviation START: use Frame instead
			-- return React.createElement("div", nil, state)
			return React.createElement("Frame", nil, state)
			-- ROBLOX deviation END
		end
		local initial = {}
		local current = initial
		local getterCalls = 0
		local setterCalls = {}
		-- ROBLOX deviation START: implement getter and setter
		-- local FakeDispatcherRef = {
		-- 	current = function(self)
		-- 		getterCalls += 1
		-- 		return current
		-- 	end,
		-- 	current = function(self, value)
		-- 		table.insert(setterCalls, value) --\[\[ ROBLOX CHECK: check if 'setterCalls' is an Array \]\]
		-- 		current = value
		-- 	end,
		-- }
		local FakeDispatcherRef = setmetatable({
			__getters = {
				current = function(self)
					getterCalls += 1
					return current
				end,
			},
			__setters = {
				current = function(self, value)
					table.insert(setterCalls, value)
					current = value
				end,
			},
		}, {
			__index = function(self, key)
				if typeof(self.__getters[key]) == "function" then
					return self.__getters[key](self)
				else
					return nil
				end
			end,
			__newindex = function(self, key, value)
				if typeof(self.__setters[key]) == "function" then
					return self.__setters[key](self, value)
				else
					return nil
				end
			end,
		}) :: any
		-- ROBLOX deviation END
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		local childFiber = renderer.root:_currentFiber()
		expect(function()
			-- ROBLOX deviation START: use dot notation
			-- ReactDebugTools:inspectHooksOfFiber(childFiber, FakeDispatcherRef)
			ReactDebugTools.inspectHooksOfFiber(childFiber, FakeDispatcherRef)
			-- ROBLOX deviation END
		end).toThrow(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
		expect(getterCalls).toBe(1)
		expect(setterCalls).toHaveLength(2)
		expect(setterCalls[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
			-- ROBLOX deviation START: use never instead of not
			-- ])["not"].toBe(initial)
		]).never.toBe(initial)
		-- ROBLOX deviation END
		expect(setterCalls[
			2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]).toBe(initial)
	end) -- This test case is based on an open source bug report:
	-- facebookincubator/redux-react-hook/issues/34#issuecomment-466693787
	it("should properly advance the current hook for useContext", function()
		local MyContext = React.createContext(1)
		local incrementCount
		local function Foo(props)
			local context = React.useContext(MyContext)
			-- ROBLOX deviation START: useState returns 2 values
			-- local data, setData = table.unpack(React.useState({ count = context }), 1, 2)
			local data, setData = React.useState({ count = context })
			-- ROBLOX deviation END
			incrementCount = function()
				return setData(function(ref0)
					local count = ref0.count
					return { count = count + 1 }
				end)
			end
			-- ROBLOX deviation START: use FRame instead
			-- return React.createElement("div", nil, "count: ", data.count)
			return React.createElement("Frame", nil, "count: ", data.count)
			-- ROBLOX deviation END
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
		expect(renderer:toJSON()).toEqual({
			-- ROBLOX deviation START: use Frame instead
			-- type = "div",
			type = "Frame",
			-- ROBLOX deviation END
			props = {},
			children = { "count: ", "1" },
		})
		act(incrementCount)
		expect(renderer:toJSON()).toEqual({
			-- ROBLOX deviation START: use Frame instead
			-- type = "div",
			type = "Frame",
			-- ROBLOX deviation END
			props = {},
			children = { "count: ", "2" },
		})
		local childFiber = renderer.root:_currentFiber()
		-- ROBLOX deviation START: use dot notation
		-- local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
		local tree = ReactDebugTools.inspectHooksOfFiber(childFiber)
		-- ROBLOX deviation END
		expect(tree).toEqual({
			{
				isStateEditable = false,
				-- ROBLOX deviation START: Luau doesn't support mixed arrays
				-- id = nil,
				id = nil :: number | nil,
				-- ROBLOX deviation END
				name = "Context",
				-- ROBLOX deviation START: Luau doesn't support mixed arrays
				-- value = 1,
				value = 1 :: any,
				-- ROBLOX deviation END
				subHooks = {},
			},
			{
				isStateEditable = true,
				-- ROBLOX deviation START: adjust for 1-based indexing
				-- id = 0,
				id = 1,
				-- ROBLOX deviation END
				name = "State",
				value = { count = 2 },
				subHooks = {},
			},
		})
	end)
	-- ROBLOX deviation START: no experimental features
	-- if Boolean.toJSBoolean(__EXPERIMENTAL__) then
	-- 	it("should support composite useMutableSource hook", function()
	-- 		local mutableSource = React.unstable_createMutableSource({}, function()
	-- 			return 1
	-- 		end)
	-- 		local function Foo(props)
	-- 			React.unstable_useMutableSource(mutableSource, function()
	-- 				return "snapshot"
	-- 			end, function() end)
	-- 			React.useMemo(function()
	-- 				return "memo"
	-- 			end, {})
	-- 			return React.createElement("div", nil)
	-- 		end
	-- 		local renderer = ReactTestRenderer.create(React.createElement(Foo, nil))
	-- 		local childFiber = renderer.root:findByType(Foo):_currentFiber()
	-- 		local tree = ReactDebugTools:inspectHooksOfFiber(childFiber)
	-- 		expect(tree).toEqual({
	-- 			{
	-- 				id = 0,
	-- 				isStateEditable = false,
	-- 				name = "MutableSource",
	-- 				value = "snapshot",
	-- 				subHooks = {},
	-- 			},
	-- 			{
	-- 				id = 1,
	-- 				isStateEditable = false,
	-- 				name = "Memo",
	-- 				value = "memo",
	-- 				subHooks = {},
	-- 			},
	-- 		})
	-- 	end)
	-- end
	-- ROBLOX deviation END
end) ]]
aN.Children._441973d2732ac0e6936cdea45d34975e=aS
local aT

local aU={ClassName="ModuleScript",Children={},Properties={}}
aU.Name="ReactDevtoolsExtensions"
aU.Properties.Source=[[ -- ROBLOX note: no upstream
-- ROBLOX note: The setup function adds the glue required for DeveloperTools to initialize the Roact devtools correctly
local Packages = script.Parent

return {
	setup = function(debugMode: boolean)
		-- ROBLOX note: Set globals for React devtools to work
		_G.__DEV__ = true
		_G.__DEBUG__ = debugMode or false
		_G.__PROFILE__ = true
		_G.__EXPERIMENTAL__ = true
		-- ROBLOX note: Don't hide host coomponents as the current Developer Inspector uses on these to preserve a
		-- direct mapping between the Inspector tree and the Explorer tree as requested by design.
		_G.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = {}

		local ReactDevtoolsShared = require(Packages.ReactDevtoolsShared)
		local setup = require(Packages.ReactDevtoolsExtensions.backend).setup
		local installHook = ReactDevtoolsShared.hook.installHook
		local Store = ReactDevtoolsShared.devtools.store

		-- ROBLOX note: Ensure that the global hook is installed before the injection into DevTools
		installHook(_G)

		-- ROBLOX note: Ensure that ReactRoblox is loaded after injection so that the ReactHostConfig is populated correctly
		require(Packages.React)
		require(Packages.ReactRoblox)

		local hook = _G.__REACT_DEVTOOLS_GLOBAL_HOOK__

		-- ROBLOX note: Make sure that this method was called before ReactRoblox was first required,
		-- otherwise the profiler will not be enabled for the session.
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		if not ReactFeatureFlags.enableSchedulingProfiler then
			warn(
				"[DeveloperTools] React was initialized before DeveloperTools. Call inspector.setupReactDevtools before requiring React to enable profiling."
			)
		end

		local result = setup(hook)

		-- ROBLOX note: The DeveloperTools library is only passed the ReactDevtoolsExtensions API to keep the
		-- devtools init process compact for users. Initialize the store so DeveloperTools doesn't also need to be
		-- passed the ReactDevtoolsShared API.
		return {
			agent = result.agent,
			bridge = result.bridge,
			hook = result.hook,
			store = Store.new(result.bridge),
		}
	end,
} ]]
c.Children._91010ef8ceac796cf03fdd01c35f367b=aU
local aV
local aW={ClassName="Folder",Children={},Properties={}}
aW.Name="__tests__"
aV.Children._f76c244b5afa8403c974e27e8bd5dd1d=aW
local aX
local aY={ClassName="ModuleScript",Children={},Properties={}}
aY.Name="devtools-integration.roblox.spec"
aY.Properties.Source=[[ --\[\[
	This test is currently run manually to verify the DeveloperTools library integrates into roact-alignment
\]\]
type Function = (...any) -> any?

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local xit = JestGlobals.xit

describe("Devtools Integration", function()
	local inspector
	local ReactDevtoolsExtensions
	local React

	beforeEach(function()
		React = require(Packages.React)
		jest.resetModules()
		jest.useFakeTimers()
		local DeveloperTools = require(Packages.Dev.DeveloperTools)
		ReactDevtoolsExtensions = require(Packages.ReactDevtoolsExtensions)

		inspector = DeveloperTools.forLibrary("UniversalApp", {})
		inspector:initRoact(ReactDevtoolsExtensions)
	end)

	afterEach(function()
		jest.resetModules()
		jest.useRealTimers()
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = nil
	end)

	-- Devtools naturally relies on using DEV mode, so this test only makes
	-- sense when it's enabled
	local itSkipIfNonDEV = it
	if not _G.__DEV__ then
		itSkipIfNonDEV = xit :: any
	end

	-- ROBLOX FIXME: This test doesn't seem to work when focused
	itSkipIfNonDEV(
		"can connect to a Roact tree and inspect its children and child branch nodes",
		function()
			local ReactRoblox = require(Packages.ReactRoblox)

			local function act(callback: Function): ()
				local actTestRenderer = require(Packages.Dev.ReactTestRenderer).act

				actTestRenderer(function()
					callback()
				end)

				while jest.getTimerCount() > 0 do
					actTestRenderer(function()
						jest.runAllTimers()
					end)
				end
			end

			-- Create a Roact root
			act(function()
				local root = ReactRoblox.createRoot(Instance.new("Frame"))
				return root:render(React.createElement("TextLabel", { Text = "Test" }))
			end)

			-- Deliver new root to the store
			local devtools = inspector.workers.reactTargetWatcher.devtools
			devtools.bridge:_flush()

			-- Check that the target has been added
			local _, target = next(inspector.targets)

			jestExpect(target.name).toBe("#1")

			-- Attach to the tree
			target.listener.onEvent("TEST")

			local worker = inspector.workers[target.id]

			-- Stub the message handler
			local spy = jest.fn()
			worker.send = spy
			worker:showChildren({})

			jestExpect(spy).toBeCalledWith(worker, {
				eventName = "RoactInspector.ShowChildren",
				path = {},
				children = {
					["1.2"] = {
						Children = {},
						Icon = "Branch",
						Name = "TextLabel",
						Path = { "1.2" },
					},
				},
			})

			worker:showBranch({ "1.2" })

			jestExpect(spy.mock.calls[2][2].eventName).toBe("RoactInspector.ShowBranch")
			jestExpect(spy.mock.calls[2][2].branch).toEqual({
				{
					Icon = "Branch",
					Name = "Root",
					Link = "",
					Source = "",
				},
				{
					Name = "TextLabel",
					Link = "",
					Source = "",
				} :: any, -- TODO Luau: Allow elements of an array to have different types.
			})
		end
	)
end) ]]
aX.Children._b28d9f71f9c1dfebde0580e61240a07d=aY
local aZ

local a_={ClassName="ModuleScript",Children={},Properties={}}
a_.Name="backend"
a_.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-devtools-extensions/src/backend.js
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
-- ROBLOX deviation START: not needed
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
type Array<T> = LuauPolyfill.Array<T>
-- Do not use imports or top-level requires here!
-- Running module factories is intentionally delayed until we know the hook exists.
-- This is to avoid issues like: https://github.com/facebook/react-devtools/issues/1039
--\[\[* @flow \]\]

-- ROBLOX deviation START: not needed
-- local function welcome(event)
-- 	if event.source ~= window or event.data.source ~= "react-devtools-content-script" then
-- 		return
-- 	end
-- 	window:removeEventListener("message", welcome)
-- 	setup(window.__REACT_DEVTOOLS_GLOBAL_HOOK__)
-- end
-- window:addEventListener("message", welcome)
-- ROBLOX deviation END
-- ROBLOX deviation START: add types for BridgeListener
type BridgeEvent = {
	source: string,
	event: any,
	payload: any,
}
type BridgeListener = (BridgeEvent) -> ()
-- ROBLOX deviation END
local function setup(hook)
	-- ROBLOX deviation START: add bridgeListeners instead of listening to messages
	local bridgeListeners: Array<BridgeListener> = {}
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not needed
	-- if
	-- 	hook == nil --\[\[ ROBLOX CHECK: loose equality used upstream \]\]
	-- then
	-- 	-- DevTools didn't get injected into this page (maybe b'c of the contentType).
	-- 	return
	-- end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: fix imports
	-- local Agent = require_("react-devtools-shared/src/backend/agent").default
	-- local Bridge = require_("react-devtools-shared/src/bridge").default
	-- local initBackend = require_("react-devtools-shared/src/backend").initBackend
	local ReactDevtoolsShared = require(Packages.ReactDevtoolsShared)
	local backend = ReactDevtoolsShared.backend
	local Agent = backend.agent
	local Bridge = ReactDevtoolsShared.bridge
	local initBackend = backend.initBackend
	-- ROBLOX deviation END
	-- ROBLOX deviation START: not needed
	-- local setupNativeStyleEditor = require_(
	-- 	"react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor"
	-- ).default
	-- ROBLOX deviation END
	local bridge = Bridge.new({
		-- ROBLOX deviation START: no self param needed
		-- listen = function(self, fn)
		listen = function(fn: BridgeListener)
			-- ROBLOX deviation END
			-- ROBLOX deviation START: Because we don't listen for all messages on window like in browser, we don't need to verify their source
			-- local function listener(event)
			-- 	if
			-- 		event.source ~= window
			-- 		or not Boolean.toJSBoolean(event.data)
			-- 		or event.data.source ~= "react-devtools-content-script"
			-- 		or not Boolean.toJSBoolean(event.data.payload)
			-- 	then
			-- 		return
			-- 	end
			-- 	fn(event.data.payload)
			-- end
			-- window:addEventListener("message", listener)
			-- return function()
			-- 	window:removeEventListener("message", listener)
			-- end
			table.insert(bridgeListeners, fn)
			return function()
				for index, value in bridgeListeners do
					if value == fn then
						table.remove(bridgeListeners, index)
						return
					end
				end
			end
			-- ROBLOX deviation END
		end,
		-- ROBLOX deviation START: no self param needed
		-- send = function(self, event: string, payload: any, transferable: Array<any>?)
		send = function(event: string, payload: any, transferable: Array<any>?)
			-- ROBLOX deviation END
			-- ROBLOX deviation START: custom implementation
			-- window:postMessage({
			-- 	source = "react-devtools-bridge",
			-- 	payload = { event = event, payload = payload },
			-- }, "*", transferable)
			for _, fn in bridgeListeners do
				fn({
					source = "react-devtools-bridge",
					event = event,
					payload = payload,
				})
			end
			-- ROBLOX deviation END
		end,
	})
	local agent = Agent.new(bridge)
	agent:addListener("shutdown", function()
		-- If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,
		-- and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.
		-- ROBLOX deviation START: use dot notation
		-- hook:emit("shutdown")
		hook.emit("shutdown")
		-- ROBLOX deviation END
	end)
	-- ROBLOX deviation START: use _G instead of window
	-- initBackend(hook, agent, window) -- Let the frontend know that the backend has attached listeners and is ready for messages.
	initBackend(hook, agent, _G)
	-- ROBLOX deviation END
	-- This covers the case of syncing saved values after reloading/navigating while DevTools remain open.
	bridge:send("extensionBackendInitialized") -- Setup React Native style editor if a renderer like react-native-web has injected it.
	-- ROBLOX deviation START: not needed
	-- if Boolean.toJSBoolean(hook.resolveRNStyle) then
	-- 	setupNativeStyleEditor(
	-- 		bridge,
	-- 		agent,
	-- 		hook.resolveRNStyle,
	-- 		hook.nativeStyleEditorValidAttributes
	-- 	)
	-- end
	-- ROBLOX deviation END
	-- ROBLOX deviation START: add return
	return {
		agent = agent,
		hook = hook,
		bridge = bridge,
	}
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: add return
return {
	setup = setup,
}
-- ROBLOX deviation END ]]
aV.Children._1a325d52ab198e2eb20bc185c5ad455d=a_
local a0

local a1={ClassName="ModuleScript",Children={},Properties={}}
a1.Name="ReactDevtoolsShared"
a1.Properties.Source=[[ -- ROBLOX note: upstream doesn't have a root index.js, we may want to contribute a proper contract upstream
return {
	backend = require(script.backend),
	bridge = require(script.bridge),
	devtools = require(script.devtools),
	hydration = require(script.hydration),
	hook = require(script.hook),
	utils = require(script.utils),
} ]]
c.Children._c145c1dc3e1fb896862276ce0077c850=a1
local a2
local a3={ClassName="Folder",Children={},Properties={}}
a3.Name="__tests__"
a2.Children._f631d984ea6b3b025cff9584d2ddea37=a3
local a4
local a5={ClassName="Folder",Children={},Properties={}}
a5.Name="__snapshots__"
a4.Children._dc7d2a9427f88aa78e20c8ed3f9b97ad=a5
local a6
local a7={ClassName="ModuleScript",Children={},Properties={}}
a7.Name="storeComponentFilters.spec.snap"
a7.Properties.Source=[[ -- Jest Roblox Snapshot v1, http://roblox.github.io/jest-roblox/snapshot-testing
local exports = {}
exports[ [=[Store component filters should filter HOCs: 1: mount 1]=] ] = [=[

"[root]
  ▾ <Component> [Bar][Foo]
    ▾ <Component> [Foo]
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should filter HOCs: 2: hide all HOCs 1]=] ] = [=[

"[root]
  ▾ <Component> [Bar][Foo]
    ▾ <Component> [Foo]
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should filter HOCs: 3: disable HOC filter 1]=] ] = [=[

"[root]
  ▾ <Component> [Bar][Foo]
    ▾ <Component> [Foo]
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should filter by display name: 1: mount 1]=] ] = [=[

"[root]
  ▾ <Foo key=\"1\">
      <Text>
  ▾ <Bar key=\"2\">
      <Text>
  ▾ <Baz key=\"3\">
      <Text>"
]=]

exports[ [=[Store component filters should filter by display name: 2: filter "Foo" 1]=] ] = [=[

"[root]
  ▾ <Foo key=\"1\">
      <Text>
  ▾ <Bar key=\"2\">
      <Text>
  ▾ <Baz key=\"3\">
      <Text>"
]=]

exports[ [=[Store component filters should filter by display name: 3: filter "Ba" 1]=] ] = [=[

"[root]
  ▾ <Foo key=\"1\">
      <Text>
  ▾ <Bar key=\"2\">
      <Text>
  ▾ <Baz key=\"3\">
      <Text>"
]=]

exports[ [=[Store component filters should filter by display name: 4: filter "B.z" 1]=] ] = [=[

"[root]
  ▾ <Foo key=\"1\">
      <Text>
  ▾ <Bar key=\"2\">
      <Text>
  ▾ <Baz key=\"3\">
      <Text>"
]=]

exports[ [=[Store component filters should filter by path: 1: mount 1]=] ] = [=[

"[root]
  ▾ <Component>
      <TextLabel>"
]=]

exports[ [=[Store component filters should filter by path: 2: hide all components declared within this test filed 1]=] ] = [=[

"[root]
  ▾ <Component>
      <TextLabel>"
]=]

exports[ [=[Store component filters should filter by path: 3: hide components in a made up fake path 1]=] ] = [=[

"[root]
  ▾ <Component>
      <TextLabel>"
]=]

exports[ [=[Store component filters should ignore invalid ElementTypeRoot filter: 1: mount 1]=] ] = [=[

"[root]
  ▾ <Root>
      <TextLabel>"
]=]

exports[ [=[Store component filters should ignore invalid ElementTypeRoot filter: 2: add invalid filter 1]=] ] = [=[

"[root]
  ▾ <Root>
      <TextLabel>"
]=]

exports[ [=[Store component filters should support filtering by element type: 1: mount 1]=] ] = [=[

"[root]
  ▾ <Root>
    ▾ <Frame>
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should support filtering by element type: 2: hide host components 1]=] ] = [=[

"[root]
  ▾ <Root>
    ▾ <Frame>
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should support filtering by element type: 3: hide class components 1]=] ] = [=[

"[root]
  ▾ <Root>
    ▾ <Frame>
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should support filtering by element type: 4: hide class and function components 1]=] ] = [=[

"[root]
  ▾ <Root>
    ▾ <Frame>
      ▾ <Component>
          <TextLabel>"
]=]

exports[ [=[Store component filters should support filtering by element type: 5: disable all filters 1]=] ] = [=[

"[root]
  ▾ <Root>
    ▾ <Frame>
      ▾ <Component>
          <TextLabel>"
]=]

return exports ]]
a6.Children._d68e0db970028122410762c11e44db34=a7
local a8

local a9={ClassName="ModuleScript",Children={},Properties={}}
a9.Name="bridge.spec"
a9.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/bridge-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest

describe("bridge", function()
	local Bridge

	beforeEach(function()
		jest.resetModules()
		jest.useFakeTimers()
		Bridge = require(script.Parent.Parent.bridge)
	end)

	it("should shutdown properly", function()
		local wall = {
			listen = jest.fn(function()
				return function() end
			end),
			send = jest.fn(),
		}
		local bridge = Bridge.new(wall)

		-- Check that we're wired up correctly.
		bridge:send("reloadAppForProfiling")
		jest.runAllTimers()
		jestExpect(wall.send).toHaveBeenCalledWith("reloadAppForProfiling")

		-- Should flush pending messages and then shut down.
		wall.send.mockClear()
		bridge:send("update", "1")
		bridge:send("update", "2")
		bridge:shutdown()
		jest.runAllTimers()
		jestExpect(wall.send).toHaveBeenCalledWith("update", "1")
		jestExpect(wall.send).toHaveBeenCalledWith("update", "2")
		jestExpect(wall.send).toHaveBeenCalledWith("shutdown")

		-- Verify that the Bridge doesn't send messages after shutdown.

		wall.send.mockClear()
		-- ROBLOX deviation: instead of spying on console, use toWarnDev matcher
		jestExpect(function()
			bridge:send("should not send")
		end).toWarnDev(
			'Cannot send message "should not send" through a Bridge that has been shutdown.',
			{ withoutStack = true }
		)
		jest.runAllTimers()
		jestExpect(wall.send).never.toHaveBeenCalled()
	end)
end) ]]
a4.Children._6687124b565a1e039e58a3c44674d49a=a9
local ba

local bb={ClassName="ModuleScript",Children={},Properties={}}
bb.Name="console.spec"
bb.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/console-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local describe = JestGlobals.describe
local xit = JestGlobals.xit
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest

-- ROBLOX deviation: Use lua's _G global table
local global = _G

-- ROBLOX deviation: Stub for now
local Console = {
	patch = function(...)
		print("Console.patch", ...)
	end,
	unpatch = function(...)
		print("Console.unpatch", ...)
	end,
	dangerous_setTargetConsoleForTesting = function(...) end,
	registerRenderer = function(...) end,
}

local React
local ReactRoblox
local utils = require(script.Parent.utils)

describe("console", function()
	local act
	local fakeConsole
	local mockError
	local mockInfo
	local mockLog
	local mockWarn
	local patchConsole
	local unpatchConsole

	beforeEach(function()
		jest.resetModules()

		patchConsole = Console.patch
		unpatchConsole = Console.unpatch

		-- Patch a fake console so we can verify with tests below.
		-- Patching the real console is too complicated,
		-- because Jest itself has hooks into it as does our test env setup.
		mockError = jest.fn()
		mockInfo = jest.fn()
		mockLog = jest.fn()
		mockWarn = jest.fn()
		fakeConsole = {
			error = mockError,
			info = mockInfo,
			log = mockLog,
			warn = mockWarn,
		}

		Console.dangerous_setTargetConsoleForTesting(fakeConsole)

		-- Note the Console module only patches once,
		-- so it's important to patch the test console before injection.
		patchConsole({
			appendComponentStack = true,
			breakOnWarn = false,
		})

		local inject = global.__REACT_DEVTOOLS_GLOBAL_HOOK__.inject
		global.__REACT_DEVTOOLS_GLOBAL_HOOK__.inject = function(internals)
			inject(internals)

			Console.registerRenderer(internals)
		end

		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)

		act = utils.act
	end)

	local function normalizeCodeLocInfo(str)
		-- ROBLOX deviation: Lua stack traces won't match JS ones
		-- ROBLOX TODO: verify this
		return str
	end

	xit(
		"should not patch console methods that do not receive component stacks",
		function()
			jestExpect(fakeConsole.error).never.toBe(mockError)
			jestExpect(fakeConsole.info).toBe(mockInfo)
			jestExpect(fakeConsole.log).toBe(mockLog)
			jestExpect(fakeConsole.warn).never.toBe(mockWarn)
		end
	)

	xit("should only patch the console once", function()
		local prevError = fakeConsole.error
		local prevWarn = fakeConsole.warn

		patchConsole({
			appendComponentStack = true,
			breakOnWarn = false,
		})
		jestExpect(fakeConsole.error).toBe(prevError)
		jestExpect(fakeConsole.warn).toBe(prevWarn)
	end)

	xit("should un-patch when requested", function()
		jestExpect(fakeConsole.error).never.toBe(mockError)
		jestExpect(fakeConsole.warn).never.toBe(mockWarn)
		unpatchConsole()
		jestExpect(fakeConsole.error).toBe(mockError)
		jestExpect(fakeConsole.warn).toBe(mockWarn)
	end)

	xit("should pass through logs when there is no current fiber", function()
		jestExpect(mockLog).toHaveBeenCalledTimes(0)
		jestExpect(mockWarn).toHaveBeenCalledTimes(0)
		jestExpect(mockError).toHaveBeenCalledTimes(0)
		fakeConsole.log("log")
		fakeConsole.warn("warn")
		fakeConsole.error("error")
		jestExpect(mockLog).toHaveBeenCalledTimes(1)
		jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
		jestExpect(mockLog.mock.calls[0][0]).toBe("log")
		jestExpect(mockWarn).toHaveBeenCalledTimes(1)
		jestExpect(mockWarn.mock.calls[0]).toHaveLength(1)
		jestExpect(mockWarn.mock.calls[0][0]).toBe("warn")
		jestExpect(mockError).toHaveBeenCalledTimes(1)
		jestExpect(mockError.mock.calls[0]).toHaveLength(1)
		jestExpect(mockError.mock.calls[0][0]).toBe("error")
	end)

	xit("should not append multiple stacks", function()
		local Child = function()
			fakeConsole.warn("warn\n    in Child (at fake.js:123)")
			fakeConsole.error("error", "\n    in Child (at fake.js:123)")
			return nil
		end

		-- ROBLOX deviation: Use createRoot instead of DOM element
		local root = ReactRoblox.createRoot(Instance.new("Frame"))

		act(function()
			return root:render(React.createElement(Child))
		end)
		jestExpect(mockWarn).toHaveBeenCalledTimes(1)
		jestExpect(mockWarn.mock.calls[0]).toHaveLength(1)
		-- ROBLOX TODO: What is printed instead of this?
		jestExpect(mockWarn.mock.calls[0][0]).toBe("warn\n    in Child (at fake.js:123)")
		jestExpect(mockError).toHaveBeenCalledTimes(1)
		jestExpect(mockError.mock.calls[0]).toHaveLength(2)
		jestExpect(mockError.mock.calls[0][0]).toBe("error")
		jestExpect(mockError.mock.calls[0][1]).toBe("\n    in Child (at fake.js:123)")
	end)

	xit(
		"should append component stacks to errors and warnings logged during render",
		function()
			local Intermediate = function(_ref2)
				local children = _ref2.children
				return children
			end
			-- ROBLOX deviation: switched ordering for variable definition order
			local Child = function(_ref4)
				local _children = _ref4.children

				fakeConsole.error("error")
				fakeConsole.log("log")
				fakeConsole.warn("warn")

				return nil
			end
			local Parent = function(_ref3)
				local _children = _ref3.children
				return React.createElement(
					Intermediate,
					nil,
					React.createElement(Child, nil)
				)
			end

			-- ROBLOX deviation: Use createRoot instead of DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Parent, nil))
			end)
			jestExpect(mockLog).toHaveBeenCalledTimes(1)
			jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[0][0]).toBe("log")
			jestExpect(mockWarn).toHaveBeenCalledTimes(1)
			jestExpect(mockWarn.mock.calls[0]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[0][0]).toBe("warn")
			-- ROBLOX TODO: What is printed instead of this?
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[0][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError).toHaveBeenCalledTimes(1)
			jestExpect(mockError.mock.calls[0]).toHaveLength(2)
			jestExpect(mockError.mock.calls[0][0]).toBe("error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[0][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
		end
	)
	xit(
		"should append component stacks to errors and warnings logged from effects",
		function()
			local Intermediate = function(_ref5)
				local children = _ref5.children
				return children
			end
			-- ROBLOX deviation: switched ordering for variable definition order
			local Child = function(_ref7)
				local _children = _ref7.children

				React.useLayoutEffect(function()
					fakeConsole.error("active error")
					fakeConsole.log("active log")
					fakeConsole.warn("active warn")
				end)
				React.useEffect(function()
					fakeConsole.error("passive error")
					fakeConsole.log("passive log")
					fakeConsole.warn("passive warn")
				end)

				return nil
			end
			local Parent = function(_ref6)
				local _children = _ref6.children

				return React.createElement(
					Intermediate,
					nil,
					React.createElement(Child, nil)
				)
			end

			-- ROBLOX deviation: Use createRoot instead of DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Parent, nil))
			end)
			jestExpect(mockLog).toHaveBeenCalledTimes(2)
			jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[0][0]).toBe("active log")
			jestExpect(mockLog.mock.calls[1]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[1][0]).toBe("passive log")
			jestExpect(mockWarn).toHaveBeenCalledTimes(2)
			jestExpect(mockWarn.mock.calls[0]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[0][0]).toBe("active warn")
			-- ROBLOX TODO: What is printed instead of this?
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[0][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockWarn.mock.calls[1]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[1][0]).toBe("passive warn")
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[1][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError).toHaveBeenCalledTimes(2)
			jestExpect(mockError.mock.calls[0]).toHaveLength(2)
			jestExpect(mockError.mock.calls[0][0]).toBe("active error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[0][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError.mock.calls[1]).toHaveLength(2)
			jestExpect(mockError.mock.calls[1][0]).toBe("passive error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[1][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
		end
	)
	xit(
		"should append component stacks to errors and warnings logged from commit hooks",
		function()
			local Intermediate = function(_ref8)
				local children = _ref8.children

				return children
			end
			-- ROBLOX deviation: switched ordering for variable definition order
			local Child = React.Component:extend("Child")
			local Parent = function(_ref9)
				local _children = _ref9.children

				return React.createElement(
					Intermediate,
					nil,
					React.createElement(Child, nil)
				)
			end

			function Child:componentDidMount()
				fakeConsole.error("didMount error")
				fakeConsole.log("didMount log")
				fakeConsole.warn("didMount warn")
			end
			function Child:componentDidUpdate()
				fakeConsole.error("didUpdate error")
				fakeConsole.log("didUpdate log")
				fakeConsole.warn("didUpdate warn")
			end
			function Child:render()
				return nil
			end

			-- ROBLOX deviation: Use createRoot instead of DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Parent, nil))
			end)
			act(function()
				return root:render(React.createElement(Parent, nil))
			end)
			jestExpect(mockLog).toHaveBeenCalledTimes(2)
			jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[0][0]).toBe("didMount log")
			jestExpect(mockLog.mock.calls[1]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[1][0]).toBe("didUpdate log")
			jestExpect(mockWarn).toHaveBeenCalledTimes(2)
			jestExpect(mockWarn.mock.calls[0]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[0][0]).toBe("didMount warn")
			-- ROBLOX TODO: What is printed instead of this?
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[0][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockWarn.mock.calls[1]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[1][0]).toBe("didUpdate warn")
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[1][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError).toHaveBeenCalledTimes(2)
			jestExpect(mockError.mock.calls[0]).toHaveLength(2)
			jestExpect(mockError.mock.calls[0][0]).toBe("didMount error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[0][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError.mock.calls[1]).toHaveLength(2)
			jestExpect(mockError.mock.calls[1][0]).toBe("didUpdate error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[1][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
		end
	)
	xit(
		"should append component stacks to errors and warnings logged from gDSFP",
		function()
			local Intermediate = function(props)
				local children = props.children
				return children
			end
			-- ROBLOX deviation: switched ordering for variable definition order
			local Child = React.Component:extend("Child")
			local Parent = function(props)
				local _children = props.children
				return React.createElement(Intermediate, nil, React.createElement(Child))
			end

			function Child.getDerivedStateFromProps()
				fakeConsole.error("error")
				fakeConsole.log("log")
				fakeConsole.warn("warn")
				return nil
			end
			function Child:render()
				return nil
			end

			-- ROBLOX deviation: Use createRoot instead of DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Parent, nil))
			end)
			jestExpect(mockLog).toHaveBeenCalledTimes(1)
			jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
			jestExpect(mockLog.mock.calls[0][0]).toBe("log")
			jestExpect(mockWarn).toHaveBeenCalledTimes(1)
			jestExpect(mockWarn.mock.calls[0]).toHaveLength(2)
			jestExpect(mockWarn.mock.calls[0][0]).toBe("warn")
			-- ROBLOX TODO: What is printed instead of this?
			jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[0][1])).toEqual(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
			jestExpect(mockError).toHaveBeenCalledTimes(1)
			jestExpect(mockError.mock.calls[0]).toHaveLength(2)
			jestExpect(mockError.mock.calls[0][0]).toBe("error")
			jestExpect(normalizeCodeLocInfo(mockError.mock.calls[0][1])).toBe(
				"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
			)
		end
	)
	xit("should append stacks after being uninstalled and reinstalled", function()
		local Child = function(_ref12)
			local _children = _ref12.children

			fakeConsole.warn("warn")
			fakeConsole.error("error")

			return nil
		end

		unpatchConsole()

		-- ROBLOX deviation: Use createRoot instead of DOM element
		local root = ReactRoblox.createRoot(Instance.new("Frame"))

		act(function()
			return root:render(React.createElement(Child, nil))
		end)
		jestExpect(mockWarn).toHaveBeenCalledTimes(1)
		jestExpect(mockWarn.mock.calls[0]).toHaveLength(1)
		jestExpect(mockWarn.mock.calls[0][0]).toBe("warn")
		jestExpect(mockError).toHaveBeenCalledTimes(1)
		jestExpect(mockError.mock.calls[0]).toHaveLength(1)
		jestExpect(mockError.mock.calls[0][0]).toBe("error")
		patchConsole({
			appendComponentStack = true,
			breakOnWarn = false,
		})
		act(function()
			return root:render(React.createElement(Child, nil))
		end)
		jestExpect(mockWarn).toHaveBeenCalledTimes(2)
		jestExpect(mockWarn.mock.calls[1]).toHaveLength(2)
		jestExpect(mockWarn.mock.calls[1][0]).toBe("warn")
		-- ROBLOX TODO: What is printed instead of this?
		jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[1][1])).toEqual(
			"\n    in Child (at **)"
		)
		jestExpect(mockError).toHaveBeenCalledTimes(2)
		jestExpect(mockError.mock.calls[1]).toHaveLength(2)
		jestExpect(mockError.mock.calls[1][0]).toBe("error")
		jestExpect(normalizeCodeLocInfo(mockError.mock.calls[1][1])).toBe(
			"\n    in Child (at **)"
		)
	end)
	xit("should be resilient to prepareStackTrace", function()
		-- ROBLOX TODO: what is a suitable alternative for this?
		-- Error.prepareStackTrace = function(error, callsites)
		-- 	local stack = {
		-- 		'An error occurred:',
		-- 		error.message,
		-- 	}

		-- 	for i=0, callsites.length - 1 do
		-- 		local callsite = callsites[i]

		-- 		stack.push('\t' + callsite.getFunctionName(), '\t\tat ' + callsite.getFileName(), '\t\ton line ' + callsite.getLineNumber())
		-- 	end

		-- 	return stack.join('\n')
		-- end

		local Intermediate = function(_ref13)
			local children = _ref13.children
			return children
		end
		-- ROBLOX deviation: switched ordering for variable definition order
		local Child = function(_ref15)
			fakeConsole.error("error")
			fakeConsole.log("log")
			fakeConsole.warn("warn")

			return nil
		end
		local Parent = function(_ref14)
			local _children = _ref14.children
			return React.createElement(Intermediate, nil, React.createElement(Child, nil))
		end

		-- ROBLOX deviation: Use createRoot instead of DOM element
		local root = ReactRoblox.createRoot(Instance.new("Frame"))

		act(function()
			return root:render(React.createElement(Parent, nil))
		end)
		jestExpect(mockLog).toHaveBeenCalledTimes(1)
		jestExpect(mockLog.mock.calls[0]).toHaveLength(1)
		jestExpect(mockLog.mock.calls[0][0]).toBe("log")
		jestExpect(mockWarn).toHaveBeenCalledTimes(1)
		jestExpect(mockWarn.mock.calls[0]).toHaveLength(2)
		jestExpect(mockWarn.mock.calls[0][0]).toBe("warn")
		-- ROBLOX TODO: What is printed instead of this?
		jestExpect(normalizeCodeLocInfo(mockWarn.mock.calls[0][1])).toEqual(
			"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
		)
		jestExpect(mockError).toHaveBeenCalledTimes(1)
		jestExpect(mockError.mock.calls[0]).toHaveLength(2)
		jestExpect(mockError.mock.calls[0][0]).toBe("error")
		jestExpect(normalizeCodeLocInfo(mockError.mock.calls[0][1])).toBe(
			"\n    in Child (at **)\n    in Intermediate (at **)\n    in Parent (at **)"
		)
	end)
end) ]]
a4.Children._ea89b31aa60bb99c77b374e78f8e346b=bb
local bc

local bd={ClassName="ModuleScript",Children={},Properties={}}
bd.Name="events.spec"
bd.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/events-test.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  *
--  * LICENSE file in the root directory of this source tree.
--  * @flow
--  */

local Packages = script.Parent.Parent.Parent
local Error = require(Packages.LuauPolyfill).Error
local JestGlobals = require(Packages.Dev.JestGlobals)
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest

describe("events", function()
	local dispatcher
	beforeEach(function()
		jest.resetModules()
		local EventEmitter = require(script.Parent.Parent.events)
		dispatcher = EventEmitter.new()
	end)

	it("can dispatch an event with no listeners", function()
		dispatcher:emit("event", 123)
	end)

	it("handles a listener being attached multiple times", function()
		local callback = jest.fn()
		dispatcher:addListener("event", callback)
		dispatcher:addListener("event", callback)
		dispatcher:emit("event", 123)
		jestExpect(callback).toHaveBeenCalledTimes(1)
		jestExpect(callback).toHaveBeenCalledWith(123)
	end)

	it("notifies all attached listeners of events", function()
		local callback1 = jest.fn()
		local callback2 = jest.fn()
		local callback3 = jest.fn()
		dispatcher:addListener("event", callback1)
		dispatcher:addListener("event", callback2)
		dispatcher:addListener("other-event", callback3)
		dispatcher:emit("event", 123)
		jestExpect(callback1).toHaveBeenCalledTimes(1)
		jestExpect(callback1).toHaveBeenCalledWith(123)
		jestExpect(callback2).toHaveBeenCalledTimes(1)
		jestExpect(callback2).toHaveBeenCalledWith(123)
		jestExpect(callback3).never.toHaveBeenCalled()
	end)

	it("calls later listeners before re-throwing if an earlier one throws", function()
		local callbackThatThrows = jest.fn(function()
			error(Error.new("expected"))
		end)
		local callback = jest.fn()
		dispatcher:addListener("event", callbackThatThrows)
		dispatcher:addListener("event", callback)
		jestExpect(function()
			dispatcher:emit("event", 123)
		end).toThrow("expected")
		jestExpect(callbackThatThrows).toHaveBeenCalledTimes(1)
		jestExpect(callbackThatThrows).toHaveBeenCalledWith(123)
		jestExpect(callback).toHaveBeenCalledTimes(1)
		jestExpect(callback).toHaveBeenCalledWith(123)
	end)

	it("removes attached listeners", function()
		local callback1 = jest.fn()
		local callback2 = jest.fn()
		dispatcher:addListener("event", callback1)
		dispatcher:addListener("other-event", callback2)
		dispatcher:removeListener("event", callback1)
		dispatcher:emit("event", 123)
		jestExpect(callback1).never.toHaveBeenCalled()
		dispatcher:emit("other-event", 123)
		jestExpect(callback2).toHaveBeenCalledTimes(1)
		jestExpect(callback2).toHaveBeenCalledWith(123)
	end)

	it("removes all listeners", function()
		local callback1 = jest.fn()
		local callback2 = jest.fn()
		local callback3 = jest.fn()
		dispatcher:addListener("event", callback1)
		dispatcher:addListener("event", callback2)
		dispatcher:addListener("other-event", callback3)
		dispatcher:removeAllListeners()
		dispatcher:emit("event", 123)
		dispatcher:emit("other-event", 123)
		jestExpect(callback1).never.toHaveBeenCalled()
		jestExpect(callback2).never.toHaveBeenCalled()
		jestExpect(callback3).never.toHaveBeenCalled()
	end)

	it(
		"should call the initial listeners even if others are added or removed during a dispatch",
		function()
			local callback2, callback3
			local callback1 = jest.fn(function()
				dispatcher:removeListener("event", callback2)
				dispatcher:addListener("event", callback3)
			end)
			callback2 = jest.fn()
			callback3 = jest.fn()
			dispatcher:addListener("event", callback1)
			dispatcher:addListener("event", callback2)
			dispatcher:emit("event", 123)
			jestExpect(callback1).toHaveBeenCalledTimes(1)
			jestExpect(callback1).toHaveBeenCalledWith(123)
			jestExpect(callback2).toHaveBeenCalledTimes(1)
			jestExpect(callback2).toHaveBeenCalledWith(123)
			jestExpect(callback3).never.toHaveBeenCalled()
			dispatcher:emit("event", 456)
			jestExpect(callback1).toHaveBeenCalledTimes(2)
			jestExpect(callback1).toHaveBeenCalledWith(456)
			jestExpect(callback2).toHaveBeenCalledTimes(1)
			jestExpect(callback3).toHaveBeenCalledTimes(1)
			jestExpect(callback3).toHaveBeenCalledWith(456)
		end
	)
end) ]]
a4.Children._acad89bb12cf0037458a3a23f10a8484=bd
local be

local bf={ClassName="ModuleScript",Children={},Properties={}}
bf.Name="profilerStore.spec"
bf.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/profilerStore-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect
local xdescribe = JestGlobals.xdescribe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach

local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store

local global = _G

xdescribe("ProfilerStore", function()
	local React
	local ReactRoblox
	local LuauPolyfill
	local store: Store
	local utils
	local act

	beforeEach(function()
		utils = require(script.Parent.utils)
		act = utils.act

		store = global.store
		store:setCollapseNodesByDefault(false)
		store:setRecordChangeDescriptions(true)

		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		LuauPolyfill = require(Packages.LuauPolyfill)

		utils.beforeEachProfiling()
	end)

	it("should not remove profiling data when roots are unmounted", function()
		local function Child()
			return React.createElement("Frame")
		end

		local function Parent(props)
			local count = props.count

			local arr = table.create(count) :: any
			for index = 1, count do
				arr[index] = React.createElement(
					Child,
					{ key = tostring(index), duration = index }
				)
			end
			return arr
		end

		local containerA = ReactRoblox.createRoot(Instance.new("Frame"))
		local containerB = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			containerA:render(React.createElement(Parent, { key = "A", count = 3 }))
			containerB:render(React.createElement(Parent, { key = "B", count = 2 }))
		end)
		act(function()
			store._profilerStore:startProfiling()
		end)
		act(function()
			containerA:render(React.createElement(Parent, { key = "A", count = 4 }))
			containerB:render(React.createElement(Parent, { key = "B", count = 1 }))
		end)
		act(function()
			store._profilerStore:stopProfiling()
		end)
		local rootA = store:getRoots()[1]
		local rootB = store:getRoots()[2]
		act(function()
			containerB:render(nil)
		end)
		jestExpect(store._profilerStore:getDataForRoot(rootA)).never.toBeNull()
		act(function()
			containerA:render(nil)
		end)
		jestExpect(store._profilerStore:getDataForRoot(rootB)).never.toBeNull()
	end)
	it(
		"should not allow new/saved profiling data to be set while profiling is in progress",
		function()
			act(function()
				return store._profilerStore:startProfiling()
			end)
			local fauxProfilingData = {
				-- ROLBLOX deviation START: upstream doesn't typecheck, needs mandatory imported field
				dataForRoots = LuauPolyfill.Map.new(),
				imported = false,
				-- ROBLOX deviation END
			}

			-- ROBLOX deviation: spyOn console.warn workaround
			local mockWarn = jest.fn().mockName("console.warn")
			LuauPolyfill.console.warn = mockWarn

			store._profilerStore:profilingData(fauxProfilingData)
			jestExpect(store._profilerStore.profilingData).never.toBe(fauxProfilingData)
			jestExpect(mockWarn).toHaveBeenCalledTimes(1)
			jestExpect(mockWarn).toHaveBeenCalledWith(
				"Profiling data cannot be updated while profiling is in progress."
			)

			act(function()
				return store._profilerStore:stopProfiling()
			end)

			store._profilerStore:profilingData(fauxProfilingData)
			jestExpect(store._profilerStore:profilingData()).toBe(fauxProfilingData)
		end
	)

	--\[\[ ROBLOX note: This seems to test edges that aren't present in our environment
		-- This test covers current broken behavior (arguably) with the synthetic event system.
		it("should filter empty commits", function()
			local inputRef = React.createRef()
			local function ControlledInput()
				local name, setName = React.useState("foo")
				local function handleChange(event)
					return setName(event.target.value)
				end
				return React.createElement(
					"input",
					{ ref = inputRef, value = name, onChange = handleChange }
				)
			end

			local container = Instance.new("Frame") -- This element has to be in the <body> for the event system to work.
			-document.body:appendChild(container) -- It's important that this test uses legacy sync mode.
			-- The root API does not trigger this particular failing case.
			ReactRoblox.createRoot(container):render(React.createElement(ControlledInput, nil))
			act(function()
				return store._profilerStore:startProfiling()
			end)

			-- Sets a value in a way that React doesn't see,
			-- so that a subsequent "change" event will trigger the event handler.
			local setUntrackedValue = Object.getOwnPropertyDescriptor(
				HTMLInputElement.prototype,
				"value"
			).set

			local target = inputRef.current
			setUntrackedValue(target, "bar")
			target:dispatchEvent(
				Event.new("input", { bubbles = true, cancelable = true })
			)
			jestExpect(target.value).toBe("bar")

			act(function()
				return store._profilerStore:stopProfiling()
			end)

			-- Only one commit should have been recorded (in response to the "change" event).
			local root = store:getRoots()[1]
			local data = store._profilerStore:getDataForRoot(root)
			jestExpect(data.commitData).toHaveLength(1)
			jestExpect(data.operations).toHaveLength(1)
		end)
		--\]\]
end) ]]
a4.Children._ed09a9104cf338a339b4b1b33c501c12=bf
local bg

local bh={ClassName="ModuleScript",Children={},Properties={}}
bh.Name="profilingCache.spec"
bh.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/profilingCache-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local xdescribe = JestGlobals.xdescribe
local it = JestGlobals.it
local xit = JestGlobals.xit
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local Bridge = require(script.Parent.Parent.bridge)
type FrontendBridge = Bridge.FrontendBridge

local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store

local ProfilerTypes = require(script.Parent.Parent.devtools.views.Profiler.types)
type ProfilingDataFrontend = ProfilerTypes.ProfilingDataFrontend

local global = _G

-- ROBLOX deviation START: inline simplified PropTypes logic
-- ROBLOX FIXME luau: if not annotated, gets 'Failed ot unify type packs'
local function propTypes(value: any, expectedType): any
	if value == nil then
		return nil
	end
	if type(value) ~= expectedType then
		return Error("expected " .. expectedType)
	end
	return nil
end
local PropTypes = {
	number = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "number")
	end,
	string = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "string")
	end,
}
-- ROBLOX deviation END

xdescribe("ProfilingCache", function()
	local React
	local ReactRoblox
	local Scheduler
	local SchedulerTracing
	local bridge: FrontendBridge
	local store: Store
	local utils
	local act

	beforeEach(function()
		_G.__PROFILE__ = true
		utils = require(script.Parent.utils)
		act = utils.act

		bridge = global.bridge
		store = global.store
		store:setCollapseNodesByDefault(false)
		store:setRecordChangeDescriptions(true)

		--PropTypes = require_("prop-types")
		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		Scheduler = require(Packages.Dev.Scheduler)
		SchedulerTracing = Scheduler.tracing

		utils.beforeEachProfiling()
	end)

	afterEach(function()
		_G.__PROFILE__ = nil
	end)

	it(
		"should collect data for each root (including ones added or mounted after profiling started)",
		function()
			local function Child(props)
				Scheduler.unstable_advanceTime(props.duration)
				return nil
			end

			local MemoizedChild = React.memo(Child)

			local function Parent(props)
				Scheduler.unstable_advanceTime(10)

				local count = props.count
				local children = table.create(count) :: any
				for index = 0, count - 1 do
					children[index + 1] =
						React.createElement(Child, { key = index, duration = index })
				end

				return React.createElement(
					React.Fragment,
					nil,
					children,
					React.createElement(MemoizedChild, { duration = 1 })
				)
			end

			local containerA = ReactRoblox.createRoot(Instance.new("Frame"))
			local containerB = ReactRoblox.createRoot(Instance.new("Frame"))
			local containerC = ReactRoblox.createRoot(Instance.new("Frame"))
			act(function()
				return containerA:render(React.createElement(Parent, { count = 2 }))
			end)

			act(function()
				return containerB:render(React.createElement(Parent, { count = 1 }))
			end)
			act(function()
				return store._profilerStore:startProfiling()
			end)
			act(function()
				return containerA:render(React.createElement(Parent, { count = 3 }))
			end)
			act(function()
				return containerC:render(React.createElement(Parent, { count = 1 }))
			end)
			act(function()
				return containerA:render(React.createElement(Parent, { count = 1 }))
			end)
			act(function()
				return containerB:render(nil)
			end)
			act(function()
				return containerA:render(React.createElement(Parent, { count = 0 }))
			end)
			act(function()
				return store._profilerStore:stopProfiling()
			end)

			local allProfilingDataForRoots = {}
			local function Validator(rootID, previousProfilingDataForRoot)
				local profilingDataForRoot = store._profilerStore:getDataForRoot(rootID)

				if previousProfilingDataForRoot ~= nil then
					jestExpect(profilingDataForRoot).toEqual(previousProfilingDataForRoot)
				else
					jestExpect(profilingDataForRoot).toMatchSnapshot(
						string.format(
							"Data for root %s",
							tostring(profilingDataForRoot.displayName)
						)
					)
				end
				table.insert(allProfilingDataForRoots, profilingDataForRoot)
			end

			local profilingData = store._profilerStore:profilingData()
			local dataForRoots = if profilingData ~= nil
				then profilingData.dataForRoots
				else nil
			jestExpect(dataForRoots).never.toBeNull()

			if dataForRoots ~= nil then
				dataForRoots:forEach(function(dataForRoot)
					Validator(dataForRoot.rootID, nil)
				end)
			end
			jestExpect(#allProfilingDataForRoots).toBe(3)
			utils.exportImportHelper(bridge, store)

			for _, profilingDataForRoot in allProfilingDataForRoots do
				Validator(profilingDataForRoot.rootID, profilingDataForRoot)
			end
		end
	)
	it("should collect data for each commit", function()
		local MemoizedChild, Child
		local function Parent(props)
			Scheduler.unstable_advanceTime(10)

			local count = props.count
			local children = table.create(count) :: any
			for index = 0, count - 1 do
				children[index + 1] =
					React.createElement(Child, { key = index, duration = index })
			end

			return React.createElement(
				React.Fragment,
				nil,
				children,
				React.createElement(MemoizedChild, { duration = 1 })
			)
		end
		function Child(ref)
			local duration = ref.duration
			Scheduler.unstable_advanceTime(duration)
			return nil
		end
		MemoizedChild = React.memo(Child)

		-- ROBLOX deviation START: use Roblox renderer
		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		-- ROBLOX deviation END

		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 2 }))
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 3 }))
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 1 }))
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 0 }))
		end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)
		local allCommitData = {}
		local function Validator(ref)
			local commitIndex, previousCommitDetails, rootID =
				ref.commitIndex, ref.previousCommitDetails, ref.rootID
			local commitData = store._profilerStore:getCommitData(rootID, commitIndex)
			if previousCommitDetails ~= nil then
				jestExpect(commitData).toEqual(previousCommitDetails)
			else
				table.insert(allCommitData, commitData)
				jestExpect(commitData).toMatchSnapshot(
					string.format("CommitDetails commitIndex: %d", commitIndex - 1)
				)
			end
		end
		local rootID = store:getRoots()[1]

		for commitIndex = 1, 4 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = nil,
				rootID = rootID,
			})
		end
		jestExpect(#allCommitData).toBe(4)
		utils.exportImportHelper(bridge, store)

		for commitIndex = 1, 4 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = allCommitData[commitIndex],
				rootID = rootID,
			})
		end
	end)
	it("should record changed props/state/context/hooks", function()
		local LegacyContextConsumer, ModernContextConsumer
		local instance = nil
		local ModernContext = React.createContext(0)

		local LegacyContextProvider = React.Component:extend("LegacyContextProvider")
		LegacyContextProvider.childContextTypes = { count = PropTypes.number }

		function LegacyContextProvider:init()
			self:setState({ count = 0 })
		end
		function LegacyContextProvider:getChildContext()
			return self.state
		end
		function LegacyContextProvider:render()
			return React.createElement(
				ModernContext.Provider,
				{
					value = self.state.count,
				},
				React.createElement(React.Fragment, nil, {
					React.createElement(ModernContextConsumer),
					React.createElement(LegacyContextConsumer),
				})
			)
		end

		local function FunctionComponentWithHooks(ref)
			local count = ref.count
			React.useMemo(function()
				return count
			end, { count })
			return nil
		end
		ModernContextConsumer = React.Component:extend("ModernContextConsumer")
		function ModernContextConsumer:render()
			return React.createElement(
				FunctionComponentWithHooks,
				{ count = self.context }
			)
		end

		LegacyContextConsumer = React.Component:extend("LegacyContextConsumer")
		function LegacyContextConsumer:render()
			instance = self
			return React.createElement(
				FunctionComponentWithHooks,
				{ count = self.context.count }
			)
		end

		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return container:render(React.createElement(LegacyContextProvider, nil))
		end)
		jestExpect(instance).never.toBeNull()
		act(function()
			return (instance :: any):setState({ count = 1 })
		end)
		act(function()
			return container:render(
				React.createElement(LegacyContextProvider, { foo = 123 })
			)
		end)
		act(function()
			return container:render(
				React.createElement(LegacyContextProvider, { bar = "abc" })
			)
		end)
		act(function()
			return container:render(React.createElement(LegacyContextProvider, nil))
		end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)
		local allCommitData = {}
		local function Validator(ref)
			local commitIndex, previousCommitDetails, rootID =
				ref.commitIndex, ref.previousCommitDetails, ref.rootID
			local commitData = store._profilerStore:getCommitData(rootID, commitIndex)
			if previousCommitDetails ~= nil then
				jestExpect(commitData).toEqual(previousCommitDetails)
			else
				table.insert(allCommitData, commitData)
				jestExpect(commitData).toMatchSnapshot(
					string.format("CommitDetails commitIndex: %d", commitIndex - 1)
				)
			end
		end
		local rootID = store:getRoots()[1]
		for commitIndex = 1, 5 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = nil,
				rootID = rootID,
			})
		end
		jestExpect(allCommitData).toHaveLength(5)
		utils.exportImportHelper(bridge, store)
		for commitIndex = 1, 5 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = allCommitData[commitIndex],
				rootID = rootID,
			})
		end
	end)

	-- ROBLOX FIXME: upstream has priorityLevel as "Immediate"
	-- ROBLOX FIXME: upstream has didHooksChange as false in this step. maybe related to the priorityLevel difference below?
	-- ROBLOX Note: These bugs only happen in CommitIndex 1 1
	it("should properly detect changed hooks", function()
		local Context = React.createContext(0)
		local function reducer(state, action)
			if action.type == "invert" then
				return { value = not state.value }
			else
				error(Error.new())
			end
		end
		local dispatch
		local setState
		local function Component(ref)
			local string_ = ref.string
			local _
			-- These hooks may change and initiate re-renders.
			_, setState = React.useState("abc")
			-- ROBLOX FIXME Luau: without this any cast, Type '{| value: boolean |}' could not be converted into 'string'
			_, dispatch = React.useReducer(reducer :: any, { value = true })

			-- This hook's return value may change between renders,
			-- but the hook itself isn't stateful.
			React.useContext(Context)

			-- These hooks and their dependencies may not change between renders.
			-- We're using them to ensure that they don't trigger false positives.
			React.useCallback(function()
				return function() end
			end, { string_ })
			React.useMemo(function()
				return string_
			end, { string_ })

			-- These hooks never "change".
			React.useEffect(function() end, { string_ })
			React.useLayoutEffect(function() end, { string_ })

			return nil
		end

		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return container:render(
				React.createElement(
					Context.Provider,
					{ value = true },
					React.createElement(Component, { count = 1 })
				)
			)
		end)

		-- Second render has no changed hooks, only changed props.
		act(function()
			return container:render(
				React.createElement(
					Context.Provider,
					{ value = true },
					React.createElement(Component, { count = 2 })
				)
			)
		end)

		-- Third render has a changed reducer hook
		act(function()
			return dispatch({ type = "invert" })
		end)

		-- Fourth render has a changed state hook
		act(function()
			return setState("def")
		end)

		-- Fifth render has a changed context value, but no changed hook.
		-- Technically, DevTools will miss this "context" change since it only tracks legacy context.
		act(function()
			return container:render(
				React.createElement(
					Context.Provider,
					{ value = false },
					React.createElement(Component, { count = 2 })
				)
			)
		end)

		act(function()
			return store._profilerStore:stopProfiling()
		end)

		local allCommitData = {}

		local function Validator(ref)
			local commitIndex, previousCommitDetails, rootID =
				ref.commitIndex, ref.previousCommitDetails, ref.rootID
			local commitData = store._profilerStore:getCommitData(rootID, commitIndex)
			if previousCommitDetails ~= nil then
				jestExpect(commitData).toEqual(previousCommitDetails)
			else
				table.insert(allCommitData, commitData)
				jestExpect(commitData).toMatchSnapshot(
					string.format(
						"CommitDetails commitIndex: %s",
						tostring(commitIndex - 1)
					)
				)
			end
			return nil
		end
		local rootID = store:getRoots()[1]
		for commitIndex = 1, 5 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = nil,
				rootID = rootID,
			})
		end

		jestExpect(allCommitData).toHaveLength(5)

		-- Export and re-import profile data and make sure it is retained.
		utils.exportImportHelper(bridge, store)

		for commitIndex = 1, 5 do
			Validator({
				commitIndex = commitIndex,
				previousCommitDetails = allCommitData[commitIndex],
				rootID = rootID,
			})
		end
	end)
	it(
		"should calculate a self duration based on actual children (not filtered children)",
		function()
			local Parent, Child
			store:setComponentFilters({ utils.createDisplayNameFilter("^Parent$") })
			local function Grandparent()
				Scheduler.unstable_advanceTime(10)
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Parent, { key = "one" }),
					React.createElement(Parent, { key = "two" })
				)
			end
			function Parent()
				Scheduler.unstable_advanceTime(2)
				return React.createElement(Child, nil)
			end
			function Child()
				Scheduler.unstable_advanceTime(1)
				return nil
			end
			act(function()
				return store._profilerStore:startProfiling()
			end)
			act(function()
				return ReactRoblox.createRoot(Instance.new("Frame"))
					:render(React.createElement(Grandparent, nil))
			end)
			act(function()
				return store._profilerStore:stopProfiling()
			end)
			local commitData = nil
			local function Validator(ref)
				local commitIndex, rootID = ref.commitIndex, ref.rootID
				commitData = store._profilerStore:getCommitData(rootID, commitIndex)
				jestExpect(commitData).toMatchSnapshot(
					"CommitDetails with filtered self durations"
				)
			end
			local rootID = store:getRoots()[1]
			Validator({ commitIndex = 1, rootID = rootID })
			jestExpect(commitData).never.toBeNull()
		end
	)
	--[=[
		xit("should calculate self duration correctly for suspended views", function(done)
			local Fallback, Async
			return Promise.resolve():andThen(function()
				local data
				local function getData()
					if data then
						return data
					else
						error(Promise.new(function(resolve)
							data = "abc"
							resolve(data)
						end))
					end
				end
				local function Parent()
					Scheduler.unstable_advanceTime(10)
					return React.createElement(
						React.Suspense,
						{ fallback = React.createElement(Fallback, nil) },
						React.createElement(Async, nil)
					)
				end
				function Fallback()
					Scheduler.unstable_advanceTime(2)
					return "Fallback..."
				end
				function Async()
					Scheduler.unstable_advanceTime(3)
					return getData()
				end
				act(function()
					return store._profilerStore:startProfiling()
				end)
				utils
					:actAsync(function()
						return ReactDOM:render(
							React.createElement(Parent, nil),
							document:createElement("div")
						)
					end)
					:jestExpect()
				act(function()
					return store._profilerStore:stopProfiling()
				end)
				local allCommitData = {}
				local function Validator(ref)
					local commitIndex, rootID = ref.commitIndex, ref.rootID
					local commitData = store._profilerStore:getCommitData(
						rootID,
						commitIndex
					)
					table.insert(allCommitData, commitData) --\[\[ ROBLOX CHECK: check if 'allCommitData' is an Array \]\]
					jestExpect(commitData).toMatchSnapshot(
						"CommitDetails with filtered self durations"
					)
					return nil
				end
				local rootID = store.roots[
					1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
				]
				do
					local function _loop(commitIndex)
						act(function()
							TestRenderer:create(
								React.createElement(
									Validator,
									{ commitIndex = commitIndex, rootID = rootID }
								)
							)
						end)
					end
					local commitIndex = 0
					while
						commitIndex
						< 2 --\[\[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number \]\]
					do
						_loop(commitIndex)
						commitIndex += 1
					end
				end
				jestExpect(allCommitData).toHaveLength(2)
				done()
			end)
		end)
		--]=]
	it("should collect data for each rendered fiber", function()
		local MemoizedChild, Child
		local function Parent(props)
			Scheduler.unstable_advanceTime(10)

			local count = props.count
			local children = table.create(count) :: any
			for index = 0, count - 1 do
				children[index + 1] =
					React.createElement(Child, { key = index, duration = index })
			end

			return React.createElement(
				React.Fragment,
				nil,
				children,
				React.createElement(MemoizedChild, { duration = 1 })
			)
		end
		function Child(ref)
			local duration = ref.duration
			Scheduler.unstable_advanceTime(duration)
			return nil
		end
		MemoizedChild = React.memo(Child)

		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 1 }))
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 2 }))
		end)
		act(function()
			return container:render(React.createElement(Parent, { count = 3 }))
		end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)

		local allFiberCommits = {}
		local function Validator(ref)
			local fiberID, previousFiberCommits, rootID =
				ref.fiberID, ref.previousFiberCommits, ref.rootID
			local fiberCommits = store._profilerStore:profilingCache():getFiberCommits({
				fiberID = fiberID,
				rootID = rootID,
			})
			if previousFiberCommits ~= nil then
				jestExpect(fiberCommits).toEqual(previousFiberCommits)
			else
				table.insert(allFiberCommits, fiberCommits)
				jestExpect(fiberCommits).toMatchSnapshot(
					string.format("FiberCommits: element %d", fiberID)
				)
			end
		end
		local rootID = store:getRoots()[1]

		for index = 0, store:getNumElements() - 1 do
			local fiberID = store:getElementIDAtIndex(index)
			if fiberID == nil then
				error(
					string.format(
						"Unexpected null ID for element at index %s",
						tostring(index)
					)
				)
			end

			Validator({
				fiberID = fiberID,
				previousFiberCommits = nil,
				rootID = rootID,
			})
		end

		jestExpect(allFiberCommits).toHaveLength(store:getNumElements())
		utils.exportImportHelper(bridge, store)

		--[=[ ROBLOX FIXME: 0-based indexing gets ruined by deserializing
			for index = 0, store:getNumElements() - 1 do
				local fiberID = store:getElementIDAtIndex(index)
				if fiberID == nil then
					error(
						string.format(
							"Unexpected null ID for element at index %s",
							tostring(index)
						)
					)
				end

				Validator({
					fiberID = fiberID,
					previousFiberCommits = allFiberCommits[index],
					rootID = rootID,
				})
			end
			--]=]
	end)
	it("should report every traced interaction", function()
		local MemoizedChild, Child
		local function Parent(props)
			Scheduler.unstable_advanceTime(10)

			local count = props.count
			local children = table.create(count) :: any
			for index = 0, count - 1 do
				children[index + 1] =
					React.createElement(Child, { key = index, duration = index })
			end

			return React.createElement(
				React.Fragment,
				nil,
				children,
				React.createElement(MemoizedChild, { duration = 1 })
			)
		end
		function Child(ref)
			local duration = ref.duration
			Scheduler.unstable_advanceTime(duration)
			return nil
		end
		MemoizedChild = React.memo(Child)

		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return SchedulerTracing.unstable_trace(
				"mount: one child",
				Scheduler.unstable_now(),
				function()
					return container:render(React.createElement(Parent, { count = 1 }))
				end
			)
		end)
		act(function()
			return SchedulerTracing.unstable_trace(
				"update: two children",
				Scheduler.unstable_now(),
				function()
					return container:render(React.createElement(Parent, { count = 2 }))
				end
			)
		end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)
		local interactions = nil
		local function Validator(ref)
			local previousInteractions, rootID = ref.previousInteractions, ref.rootID
			interactions =
				store._profilerStore:profilingCache():getInteractionsChartData({
					rootID = rootID,
				}).interactions
			-- ROBLOX FIXME: interactions[0] supposed to have __count=1, but it's 0 once it gets to the ProfilerStore. it's correct in WorkLoop and Tracing.
			if previousInteractions ~= nil then
				jestExpect(interactions).toEqual(previousInteractions)
			else
				jestExpect(interactions).toMatchSnapshot("Interactions")
			end
			return nil
		end
		local rootID = store:getRoots()[1]
		Validator({ previousInteractions = nil, rootID = rootID })

		jestExpect(interactions).never.toBeNull()
		utils.exportImportHelper(bridge, store)

		Validator({ previousInteractions = interactions, rootID = rootID })
	end)
	it("should handle unexpectedly shallow suspense trees", function()
		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return store._profilerStore:startProfiling()
		end)
		act(function()
			return container:render(React.createElement(React.Suspense, nil))
		end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)

		local rootID = store:getRoots()[1]
		local profilingDataForRoot = store._profilerStore:getDataForRoot(rootID)
		jestExpect(profilingDataForRoot).toMatchSnapshot("Empty Suspense node")
	end)

	-- ROBLOX TODO: needs a textContent helper for ReactRoblox renderers
	-- See https://github.com/facebook/react/issues/18831
	xit("should not crash during route transitions with Suspense", function()
		local Router, Switch, Route, About, Home, Link
		local RouterContext = React.createContext(nil)
		local function App()
			return React.createElement(
				Router,
				nil,
				React.createElement(
					Switch,
					nil,
					React.createElement(
						Route,
						{ path = "/" },
						React.createElement(Home, nil)
					),
					React.createElement(
						Route,
						{ path = "/about" },
						React.createElement(About, nil)
					)
				)
			)
		end
		function Home()
			return React.createElement(
				React.Suspense,
				nil,
				React.createElement(
					Link,
					{ path = "/about" },
					React.createElement("TextLabel", { Text = "Home" })
				)
			)
		end
		function About()
			return React.createElement("TextLabel", { Text = "About" })
		end

		-- Mimics https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Router.js
		function Router(ref)
			local children = ref.children
			local path, setPath = React.useState("/")
			return React.createElement(
				RouterContext.Provider,
				{ value = { path = path, setPath = setPath } },
				children
			)
		end

		-- Mimics https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Switch.js
		function Switch(ref)
			local children = ref.children
			return React.createElement(RouterContext.Consumer, nil, function(context)
				local element = nil
				React.Children.forEach(children, function(child: any)
					if context.path == child.props.path then
						element = child.props.children
					end
				end)
				return if element then React.cloneElement(element) else nil
			end)
		end

		-- Mimics https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js
		function Route(ref)
			return nil
		end
		local linkRef = React.createRef()

		-- Mimics https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Link.js
		function Link(ref)
			local children, path = ref.children, ref.path
			return React.createElement(RouterContext.Consumer, nil, function(context)
				return React.createElement("TextButton", {
					ref = linkRef,
					[ReactRoblox.Event.Activated] = function()
						return context:setPath(path)
					end,
				}, children)
			end)
		end
		-- ROBLOX TODO: emulate this and uncomment the expect
		-- local Simulate = require_("react-dom/test-utils").Simulate
		local container = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return container:render(React.createElement(App))
		end)
		jestExpect(container.textContent).toBe("Home")
		act(function()
			return store._profilerStore:startProfiling()
		end)
		-- act(function()
		-- 	return Simulate:click(linkRef.current)
		-- end)
		act(function()
			return store._profilerStore:stopProfiling()
		end)
		jestExpect(container.textContent).toBe("About")
	end)
end) ]]
a4.Children._71ee1171e8962a8460d190eef51b6523=bh
local bi

local bj={ClassName="ModuleScript",Children={},Properties={}}
bj.Name="profilingCharts.spec"
bj.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/profilingCharts-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local xdescribe = JestGlobals.xdescribe
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local jestExpect = JestGlobals.expect

local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store

xdescribe("profiling charts", function()
	local React
	local ReactRoblox
	local Scheduler
	local SchedulerTracing
	-- local TestRenderer
	local store: Store
	local utils
	beforeEach(function()
		_G.__PROFILE__ = true
		utils = require(script.Parent.utils)
		utils.beforeEachProfiling()

		store = _G.store
		store:setCollapseNodesByDefault(false)
		store:setRecordChangeDescriptions(true)
		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		Scheduler = require(Packages.Dev.Scheduler)
		SchedulerTracing = Scheduler.tracing
	end)
	afterEach(function()
		_G.__PROFILE__ = nil
	end)
	describe("flamegraph chart", function()
		it("should contain valid data", function()
			local Child
			local function Parent(_: {})
				Scheduler.unstable_advanceTime(10)
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Child, { key = "first", duration = 3 }),
					React.createElement(Child, { key = "second", duration = 2 }),
					React.createElement(Child, { key = "third", duration = 0 })
				)
			end

			-- Memoize children to verify that chart doesn't include in the update.
			function Child(ref)
				local duration = ref.duration
				Scheduler.unstable_advanceTime(duration)
				return nil
			end
			-- ROBLOX FIXME Luau: greediness means first type assignment wins, needs DCR
			Child = React.memo(Child) :: any

			local container = ReactRoblox.createRoot(Instance.new("Frame"))
			utils.act(function()
				return store._profilerStore:startProfiling()
			end)
			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"mount",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)
			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"update",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)
			utils.act(function()
				return store._profilerStore:stopProfiling()
			end)
			local renderFinished = false
			local function Validator(ref)
				local commitIndex, rootID = ref.commitIndex, ref.rootID
				local commitTree = store._profilerStore:profilingCache():getCommitTree({
					commitIndex = commitIndex,
					rootID = rootID,
				})
				local chartData =
					store._profilerStore:profilingCache():getFlamegraphChartData({
						commitIndex = commitIndex,
						commitTree = commitTree,
						rootID = rootID,
					})
				jestExpect(commitTree).toMatchSnapshot(
					("%s: CommitTree"):format(tostring(commitIndex - 1))
				)
				jestExpect(chartData).toMatchSnapshot(
					("%s: FlamegraphChartData"):format(tostring(commitIndex - 1))
				)
				renderFinished = true
				return nil
			end
			local rootID = store:getRoots()[1]

			for commitIndex = 1, 2 do
				renderFinished = false
				Validator({
					commitIndex = commitIndex,
					rootID = rootID,
				})
			end
			jestExpect(renderFinished).toBe(true)
		end)
	end)

	xdescribe("ranked chart", function()
		-- ROBLOX FIXME: the "type" of the children in our snap is 5, but in upstream it's 8, every matches except...
		it("should contain valid data", function()
			local Child
			local function Parent(_: {})
				Scheduler.unstable_advanceTime(10)
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Child, { key = "first", duration = 3 }),
					React.createElement(Child, { key = "second", duration = 2 }),
					React.createElement(Child, { key = "third", duration = 0 })
				)
			end

			-- Memoize children to verify that chart doesn't include in the update.
			function Child(ref)
				local duration = ref.duration
				Scheduler.unstable_advanceTime(duration)
				return nil
			end
			-- ROBLOX FIXME Luau: greediness means first type assignment wins, needs DCR
			Child = React.memo(Child) :: any
			local container = ReactRoblox.createRoot(Instance.new("Frame"))
			utils.act(function()
				return store._profilerStore:startProfiling()
			end)

			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"mount",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)

			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"update",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)

			utils.act(function()
				return store._profilerStore:stopProfiling()
			end)
			local renderFinished = false
			local function Validator(ref)
				local commitIndex, rootID = ref.commitIndex, ref.rootID
				local commitTree = store._profilerStore:profilingCache():getCommitTree({
					commitIndex = commitIndex,
					rootID = rootID,
				})
				local chartData =
					store._profilerStore:profilingCache():getRankedChartData({
						commitIndex = commitIndex,
						commitTree = commitTree,
						rootID = rootID,
					})
				jestExpect(commitTree).toMatchSnapshot(
					("%s: CommitTree"):format(tostring(commitIndex - 1))
				)
				jestExpect(chartData).toMatchSnapshot(
					("%s: RankedChartData"):format(tostring(commitIndex - 1))
				)
				renderFinished = true
				return nil
			end
			local rootID = store:getRoots()[1]

			for commitIndex = 1, 2 do
				renderFinished = false
				Validator({
					commitIndex = commitIndex,
					rootID = rootID,
				})
				jestExpect(renderFinished).toBe(true)
			end
			jestExpect(renderFinished).toBe(true)
		end)
	end)
	xdescribe("interactions", function()
		it("should contain valid data", function()
			local Child
			local function Parent(_: {})
				Scheduler.unstable_advanceTime(10)
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Child, { key = "first", duration = 3 }),
					React.createElement(Child, { key = "second", duration = 2 }),
					React.createElement(Child, { key = "third", duration = 0 })
				)
			end

			-- Memoize children to verify that chart doesn't include in the update.
			function Child(ref)
				local duration = ref.duration
				Scheduler.unstable_advanceTime(duration)
				return nil
			end
			-- ROBLOX FIXME Luau: greediness means first type assignment wins, needs DCR
			Child = React.memo(Child) :: any
			local container = ReactRoblox.createRoot(Instance.new("Frame"))
			utils.act(function()
				return store._profilerStore:startProfiling()
			end)
			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"mount",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)

			utils.act(function()
				return SchedulerTracing.unstable_trace(
					"update",
					Scheduler.unstable_now(),
					function()
						return container:render(React.createElement(Parent))
					end
				)
			end)
			utils.act(function()
				return store._profilerStore:stopProfiling()
			end)
			local renderFinished = false
			local function Validator(ref)
				local _commitIndex, rootID = ref.commitIndex, ref.rootID
				local chartData =
					store._profilerStore:profilingCache():getInteractionsChartData({
						rootID = rootID,
					})
				jestExpect(chartData).toMatchSnapshot("Interactions")
				renderFinished = true
				return nil
			end
			local rootID = store:getRoots()[1]
			for commitIndex = 1, 2 do
				renderFinished = false
				Validator({
					commitIndex = commitIndex,
					rootID = rootID,
				})
				jestExpect(renderFinished).toBe(true)
			end
			jestExpect(renderFinished).toBe(true)
		end)
	end)
end) ]]
a4.Children._9dde680e77332b384300416e6373ae9a=bj
local bk

local bl={ClassName="ModuleScript",Children={},Properties={}}
bl.Name="profilingCommitTreeBuilder.spec"
bl.Properties.Source=[[ --!nonstrict
-- ROBLOX FIXME: Type '({| count: number |}) -> {ReactElement<{ key: number }, a>}' could not be converted into '((React_ElementProps<any>?, any) -> (Array<(Array<*CYCLE*> | React_Element<any> | boolean | number | string | t1)?> | React_Element<any> | boolean | number | string | t1)?) | LazyComponent<a, React_ElementProps<any>?> | ReactContext<any> | ReactProviderType<any> | React_ComponentType<React_ElementProps<any>?> | string where t1 = {| [string]: (boolean | number | string | t1 | {(*CYCLE* | boolean | number | string | t1 | {| key: (number | string)?, props: {| __source: {| fileName: string, lineNumber: number |}?, children: any?, key: (number | string)?, ref: (((any?) -> ()) | {| current: any? |})? |}?, ref: any, type: any |})?}... *TRUNCATED*'; none of the union options are compatible
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/profilingCOmmitTreeBuilder-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local xdescribe = JestGlobals.xdescribe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jestExpect = JestGlobals.expect

local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store

local global = _G

xdescribe("commit tree", function()
	local React
	local ReactRoblox
	local Scheduler
	local store: Store
	local utils
	local act

	beforeEach(function()
		utils = require(script.Parent.utils)
		act = utils.act
		utils.beforeEachProfiling()

		store = global.store
		store:setCollapseNodesByDefault(false)
		store:setRecordChangeDescriptions(true)

		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		Scheduler = require(Packages.Dev.Scheduler)
	end)
	it("should be able to rebuild the store tree for each commit", function()
		local function Child()
			Scheduler.unstable_advanceTime(2)
			return nil
		end
		local ChildMemo = React.memo(Child)

		local function Parent(props: { count: number })
			local count = props.count
			Scheduler.unstable_advanceTime(10)

			local Children = table.create(count)
			for i = 1, count do
				Children[i] = React.createElement(ChildMemo, { key = i - 1 })
			end

			return Children
		end

		local root = ReactRoblox.createRoot(Instance.new("Frame"))

		act(function()
			store._profilerStore:startProfiling()
		end)
		act(function()
			root:render(React.createElement(Parent, { count = 1 }))
		end)
		act(function()
			root:render(React.createElement(Parent, { count = 3 }))
		end)
		act(function()
			root:render(React.createElement(Parent, { count = 2 }))
		end)
		act(function()
			root:render(React.createElement(Parent, { count = 0 }))
		end)
		act(function()
			store._profilerStore:stopProfiling()
		end)

		local rootID = store:getRoots()[1]
		for commitIndex = 1, 4 do
			local profilingCache = store._profilerStore:profilingCache()
			local commitTree = profilingCache:getCommitTree({
				commitIndex = commitIndex,
				rootID = rootID,
			})

			jestExpect(commitTree).toMatchSnapshot(
				string.format("%d: CommitTree", commitIndex - 1)
			)
		end
	end)
end) ]]
a4.Children._0f675261aae583c162d55699fcfc4d85=bl
local bm

local bn={ClassName="ModuleScript",Children={},Properties={}}
bn.Name="profilingUtils.spec"
bn.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/profilingUtils-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach

describe("profiling utils", function()
	local utils
	beforeEach(function()
		utils = require(script.Parent.Parent.devtools.views.Profiler.utils)
	end)
	it("should throw if importing older/unsupported data", function()
		jestExpect(function()
			return utils.prepareProfilingDataFrontendFromExport({
				version = 0,
				dataForRoots = {},
			})
		end).toThrow('Unsupported profiler export version "0"')
	end)
end) ]]
a4.Children._b2a7fc2c51ed0fc3b38b0e48effd74fc=bn
local bo

local bp={ClassName="ModuleScript",Children={},Properties={}}
bp.Name="setupTests"
bp.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/setupTests.js
--\[\[**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 *
 * LICENSE file in the root directory of this source tree.
 * @flow
 *\]\]
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local beforeAll = JestGlobals.beforeAll
local jest = require(Packages.Dev.JestGlobals).jest
local afterEach = JestGlobals.afterEach

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array

local global = _G

type Array<T> = { [number]: T }

beforeAll(function()
	jestExpect.extend({
		toErrorDev = require(Packages.Parent.jest.matchers.toErrorDev),
		toWarnDev = require(Packages.Parent.jest.matchers.toWarnDev),
	})
end)

beforeEach(function()
	-- Fake timers let us flush Bridge operations between setup and assertions.
	jest.useFakeTimers()

	-- These files should be required (and re-required) before each test,
	-- rather than imported at the head of the module.
	-- That's because we reset modules between tests,
	-- which disconnects the DevTool's cache from the current dispatcher ref.
	local Agent = require(script.Parent.Parent.backend.agent)
	local initBackend = require(script.Parent.Parent.backend).initBackend
	local Bridge = require(script.Parent.Parent.bridge)
	local Store = require(script.Parent.Parent.devtools.store)
	local installHook = require(script.Parent.Parent.hook).installHook
	local utils = require(script.Parent.Parent.utils)
	local getDefaultComponentFilters = utils.getDefaultComponentFilters
	local saveComponentFilters = utils.saveComponentFilters

	-- Initialize filters to a known good state.
	saveComponentFilters(getDefaultComponentFilters())
	global.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = getDefaultComponentFilters()

	installHook(global)

	local bridgeListeners = {}
	local bridge = Bridge.new({
		listen = function(callback)
			table.insert(bridgeListeners, callback)
			return function()
				local index = Array.indexOf(bridgeListeners, callback)
				if index >= 0 then
					Array.splice(bridgeListeners, index, 1)
				end
			end
		end,
		send = function(event: string, payload: any, transferable: Array<any>?)
			for _, callback in bridgeListeners do
				callback({ event = event, payload = payload })
			end
		end,
	})

	local agent = Agent.new(bridge)
	local hook = global.__REACT_DEVTOOLS_GLOBAL_HOOK__

	initBackend(hook, agent, global)

	local store = Store.new(bridge)

	global.agent = agent
	global.bridge = bridge
	global.store = store

	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = true
end)

afterEach(function()
	global.__REACT_DEVTOOLS_GLOBAL_HOOK__ = nil

	-- It's important to reset modules between test runs;
	-- Without this, ReactDOM won't re-inject itself into the new hook.
	-- It's also important to reset after tests, rather than before,
	-- so that we don't disconnect the ReactCurrentDispatcher ref.
	jest.resetModules()
end) ]]
a4.Children._b379964cdec039269cdecfc6381383aa=bp
local bq

local br={ClassName="ModuleScript",Children={},Properties={}}
br.Name="store.spec"
br.Properties.Source=[[ --!nonstrict
-- ROBLOX FIXME: TypeError: Type '({+ count: number +}) -> Array<ReactElement<{ key: number }, a>>' could not be converted into '((React_ElementProps<any>?, any) -> (Array<(Array<*CYCLE*> | React_Element<any> | boolean | number | string | t1)?> | React_Element<any> | boolean | number | string | t1)?) | LazyComponent<a, React_ElementProps<any>?> | ReactContext<any> | ReactProviderType<any> | React_ComponentType<React_ElementProps<any>?> | string where t1 = {| [string]: (boolean | number | string | t1 | {(*CYCLE* | boolean | number | string | t1 | {| key: (number | string)?, props: {| __source: {| fileName: string, lineNumber: number |}?, children: any?, key: (number | string)?, ref: (((any?) -> ()) | {| current: any? |})? |}?, ref: any, type: any |})?}... *TRUNCATED*'; none of the union options are compatible
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/store-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local fill = function(count, value)
	local output = {}
	for i = 1, count do
		output[i] = value
	end
	return output
end

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit
local beforeEach = JestGlobals.beforeEach

local Promise = require(Packages.Dev.Promise)
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object

local global = _G
type Array<T> = { [number]: T }

local ReactRoblox
local React
-- ROBLOX deviation: bring in the Agent type
local Agent = require(script.Parent.Parent.backend.agent)
type Agent = Agent.Agent

describe("Store", function()
	local agent: Agent
	local act
	local getRendererID
	local store
	local devtoolsUtils
	local constants

	beforeEach(function(context)
		agent = global.agent
		store = global.store

		React = require(Packages.React)
		jest.resetModules()
		ReactRoblox = require(Packages.ReactRoblox)
		devtoolsUtils = require(script.Parent.Parent.devtools.utils)
		constants = require(script.Parent.Parent.constants)

		jest.useFakeTimers()

		local utils = require(script.Parent.utils)
		act = utils.act
		getRendererID = utils.getRendererID
	end)

	it("should not allow a root node to be collapsed", function()
		local function Component()
			return React.createElement("TextLabel", { Text = "Hi" })
		end

		-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			root:render(React.createElement(Component, {
				count = 4,
			}))
		end)

		jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[
[root]
    <Component>\]\])
		jestExpect(store:getRoots()).toHaveLength(1)

		local rootID = store:getRoots()[1]

		jestExpect(function()
			return store:toggleIsCollapsed(rootID, true)
		end).toThrow("Root nodes cannot be collapsed")
	end)
	it("should properly handle a root with no visible nodes", function()
		local function Root(props)
			return props.children
		end
		-- ROBLOX deviation: use root:render instead of ReactDOM.render
		local root = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			root:render(React.createElement(Root, nil, {}))
		end)

		jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[
[root]
    <Root>\]\])
		act(function()
			root:render(React.createElement("Frame"))
		end)
		jestExpect(devtoolsUtils.printStore(store)).toBe("[root]")
	end)
	describe("collapseNodesByDefault:false", function()
		beforeEach(function()
			store:setCollapseNodesByDefault(false)
		end)
		it("should support mount and update operations", function()
			constants.__DEBUG__ = true
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Grandparent(props)
				local count = props.count
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Parent, { count = count }),
					React.createElement(Parent, { count = count })
				)
			end

			-- ROBLOX deviation: Use Frame instance rather than DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			act(function()
				return root:render(React.createElement(Grandparent, { count = 4 }))
			end)
			-- ROBLOX deviation: we must key children implicitly due to the Roblox DOM being unordered
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
        <Child key="3">
        <Child key="4">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">
        <Child key="3">
        <Child key="4">\]\])
			act(function()
				return root:render(React.createElement(Grandparent, { count = 2 }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">\]\])
			act(function()
				return root:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("")
		end)
		it("should support mount and update operations for multiple roots", function()
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end

			local rootA = ReactRoblox.createBlockingRoot(Instance.new("Frame"))
			local rootB = ReactRoblox.createBlockingRoot(Instance.new("Frame"))

			act(function()
				rootA:render(React.createElement(Parent, {
					key = "A",
					count = 3,
				}))
				rootB:render(React.createElement(Parent, {
					key = "B",
					count = 2,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Parent key="A">
      <Child key="1">
      <Child key="2">
      <Child key="3">
[root]
  ▾ <Parent key="B">
      <Child key="1">
      <Child key="2">\]\])
			act(function()
				rootA:render(React.createElement(Parent, {
					key = "A",
					count = 4,
				}))
				rootB:render(React.createElement(Parent, {
					key = "B",
					count = 1,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Parent key="A">
      <Child key="1">
      <Child key="2">
      <Child key="3">
      <Child key="4">
[root]
  ▾ <Parent key="B">
      <Child key="1">\]\])
			act(function()
				return rootB:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Parent key="A">
      <Child key="1">
      <Child key="2">
      <Child key="3">
      <Child key="4">\]\])
			act(function()
				return rootA:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("")
		end)
		it("should filter DOM nodes from the store tree", function()
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent()
				return React.createElement("Frame", nil, React.createElement(Child))
			end
			local function Grandparent()
				return React.createElement(
					"Frame",
					nil,
					React.createElement("Frame", nil, React.createElement(Parent)),
					React.createElement(Parent)
				)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Grandparent, { count = 4 }))
			end)
			-- ROBLOX deviation: we must key children implicitly due to the Roblox DOM being unordered
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent>
        <Child>
    ▾ <Parent key="2">
        <Child>\]\])
		end)
		-- ROBLOX FIXME: Unskip when unhideInstance is implemented in react-roblox renderer
		xit("should display Suspense nodes properly in various states", function()
			local function Loading()
				return React.createElement("TextLabel", { Text = "Loading..." })
			end
			local function SuspendingComponent()
				error(Promise.new(function() end))
			end
			local function Component()
				return React.createElement("TextLabel", { Text = "Hello" })
			end
			local function Wrapper(props)
				local shouldSuspense = props.shouldSuspense

				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						key = "Outside",
					}),
					React.createElement(
						React.Suspense,
						{
							fallback = React.createElement(Loading),
						},
						(function()
							if shouldSuspense then
								return React.createElement(SuspendingComponent)
							end

							return React.createElement(Component, {
								key = "Inside",
							})
						end)()
					)
				)
			end
			-- ROBLOX deviation: Use Frame instance rather than DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			act(function()
				return root:render(
					React.createElement(Wrapper, { shouldSuspense = true })
				)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Loading>\]\])
			act(function()
				-- ROBLOX FIXME: unsupported unhideInstance is triggered by this line
				root:render(React.createElement(Wrapper, { shouldSuspense = false }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Inside">\]\])
		end)
		-- ROBLOX FIXME: store:886: Cannot remove node nil because no matching node was found in the Store.
		xit("should support nested Suspense nodes", function()
			local function Component()
				return nil
			end
			local function Loading()
				return React.createElement("TextLabel", { Text = "Loading..." })
			end
			local Never = function()
				error(Promise.new(function() end))
			end
			local function Wrapper(props)
				local suspendFirst = props.suspendFirst or false
				local suspendSecond = props.suspendSecond or false
				local suspendParent = props.suspendParent or false

				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						key = "Outside",
					}),
					React.createElement(
						React.Suspense,
						{
							fallback = React.createElement(Loading, {
								key = "Parent Fallback",
							}),
						},
						React.createElement(Component, {
							key = "Unrelated at Start",
						}),
						React.createElement(
							React.Suspense,
							{
								fallback = React.createElement(Loading, {
									key = "Suspense 1 Fallback",
								}),
							},
							(function()
								if suspendFirst then
									return React.createElement(Never)
								end

								return React.createElement(Component, {
									key = "Suspense 1 Content",
								})
							end)()
						),
						React.createElement(
							React.Suspense,
							{
								fallback = React.createElement(Loading, {
									key = "Suspense 2 Fallback",
								}),
							},
							(function()
								if suspendSecond then
									return React.createElement(Never)
								end

								return React.createElement(Component, {
									key = "Suspense 2 Content",
								})
							end)()
						),
						React.createElement(React.Suspense, {
							fallback = React.createElement(Loading, {
								key = "Suspense 3 Fallback",
							}),
						}, React.createElement(Never)),
						(function()
							if suspendParent then
								return React.createElement(Never)
							end
							return nil
						end)(),
						React.createElement(Component, {
							key = "Unrelated at End",
						})
					)
				)
			end
			-- ROBLOX deviation: Use createRoot instead of DOM
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = false,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Component key="Suspense 1 Content">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			-- ROBLOX FIXME: error triggered in this act: store:886: Cannot remove node nil because no matching node was found in the Store.
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = true,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = false,
					suspendSecond = true,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Component key="Suspense 1 Content">
      ▾ <Suspense>
          <Loading key="Suspense 2 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = true,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = true,
					suspendFirst = true,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Loading key="Parent Fallback">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = true,
					suspendSecond = true,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 2 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = false,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Component key="Suspense 1 Content">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])

			local rendererID = getRendererID()

			act(function()
				return agent:overrideSuspense({
					id = store:getElementIDAtIndex(4),
					rendererID = rendererID,
					forceFallback = true,
				})
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return agent:overrideSuspense({
					id = store:getElementIDAtIndex(2),
					rendererID = rendererID,
					forceFallback = true,
				})
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Loading key="Parent Fallback">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = true,
					suspendSecond = true,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Loading key="Parent Fallback">\]\])
			act(function()
				return agent:overrideSuspense({
					id = store:getElementIDAtIndex(2),
					rendererID = rendererID,
					forceFallback = false,
				})
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 2 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return agent:overrideSuspense({
					id = store:getElementIDAtIndex(4),
					rendererID = rendererID,
					forceFallback = false,
				})
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Loading key="Suspense 1 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 2 Fallback">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
			act(function()
				return root:render(React.createElement(Wrapper, {
					suspendParent = false,
					suspendFirst = false,
					suspendSecond = false,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense>
        <Component key="Unrelated at Start">
      ▾ <Suspense>
          <Component key="Suspense 1 Content">
      ▾ <Suspense>
          <Component key="Suspense 2 Content">
      ▾ <Suspense>
          <Loading key="Suspense 3 Fallback">
        <Component key="Unrelated at End">\]\])
		end)
		-- ROBLOX TODO: re-enable when unstable_SuspenseList is implemented
		xit("should display a partially rendered SuspenseList", function()
			local function Loading()
				return React.createElement("TextLabel", { Text = "Loading..." })
			end
			local function SuspendingComponent()
				error(Promise.new(function() end))
			end
			local function Component()
				return React.createElement("TextLabel", { Text = "Hello" })
			end
			local function Wrapper(_ref7)
				local shouldSuspense = _ref7.shouldSuspense

				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(
						React.unstable_SuspenseList,
						{
							revealOrder = "forwards",
							tail = "collapsed",
						},
						React.createElement(Component, {
							key = "A",
						}),
						React.createElement(
							React.Suspense,
							{
								fallback = React.createElement(Loading),
							},
							(function()
								if shouldSuspense then
									return React.createElement(SuspendingComponent)
								end

								return React.createElement(Component, {
									key = "B",
								})
							end)()
						),
						React.createElement(Component, {
							key = "C",
						})
					)
				)
			end
			-- ROBLOX deviation: Use Frame instance rather than DOM element
			local container = Instance.new("Frame")
			local root = ReactRoblox.unstable_createRoot(container)

			act(function()
				root:render(React.createElement(Wrapper, { shouldSuspense = true }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("1: loading")
			act(function()
				root:render(React.createElement(Wrapper, { shouldSuspense = false }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("2: resolved")
		end)
		it("should support collapsing parts of the tree", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end
			local function Grandparent(props)
				local count = props.count

				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Parent, { count = count }),
					React.createElement(Parent, { count = count })
				)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Grandparent, { count = 2 }))
			end)
			-- ROBLOX deviation: we must key children implicitly due to the Roblox DOM being unordered
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">\]\])

			local grandparentID = store:getElementIDAtIndex(0)
			local parentOneID = store:getElementIDAtIndex(1)
			local parentTwoID = store:getElementIDAtIndex(4)

			act(function()
				return store:toggleIsCollapsed(parentOneID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent key="1">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(parentTwoID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent key="1">
    ▸ <Parent key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(parentOneID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▸ <Parent key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(grandparentID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Grandparent>\]\])
			act(function()
				return store:toggleIsCollapsed(grandparentID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▸ <Parent key="2">\]\])
		end)
		it("should support reordering of children", function()
			local function Root(props)
				return props.children
			end
			local function Component()
				return nil
			end
			local function Foo()
				return {
					React.createElement(Component, {
						key = "0",
					}),
				}
			end
			local function Bar()
				return {
					React.createElement(Component, {
						key = "0",
					}),
					React.createElement(Component, {
						key = "1",
					}),
				}
			end
			local foo = React.createElement(Foo, {
				key = "foo",
			})
			local bar = React.createElement(Bar, {
				key = "bar",
			})
			-- ROBLOX deviation: Use createRoot instead of DOM
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Root, nil, { foo, bar }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Root>
    ▾ <Foo key="foo">
        <Component key="0">
    ▾ <Bar key="bar">
        <Component key="0">
        <Component key="1">\]\])
			act(function()
				return root:render(React.createElement(Root, nil, { bar, foo }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Root>
    ▾ <Bar key="bar">
        <Component key="0">
        <Component key="1">
    ▾ <Foo key="foo">
        <Component key="0">\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Root>\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Root>
    ▾ <Bar key="bar">
        <Component key="0">
        <Component key="1">
    ▾ <Foo key="foo">
        <Component key="0">\]\])
		end)
	end)
	describe("collapseNodesByDefault:true", function()
		beforeEach(function()
			store:setCollapseNodesByDefault(true)
		end)
		it("should support mount and update operations", function()
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end
			-- ROBLOX deviation: Use Frame instance rather than DOM element
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Parent, { count = 1 }),
						React.createElement(Parent, { count = 3 })
					)
				)
			end)
			-- ROBLOX deviation: we must key children implicitly due to the Roblox DOM being unordered
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Parent key="1">
  ▸ <Parent key="2">\]\])
			act(function()
				return root:render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Parent, { count = 2 }),
						React.createElement(Parent, { count = 1 })
					)
				)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Parent key="1">
  ▸ <Parent key="2">\]\])
			act(function()
				return root:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("")
		end)
		-- ROBLOX TODO: Tests using multiple roots don't currently work, because rootA and rootB
		-- do not use the SyncLane which is checked in ReactFiberWorkLoop:680 upstream which proceeds
		-- to call handleCommitFiberRoot in devtools renderer.lua for the two separate roots.
		--  The upstream tests use a blocking root, which has a different path through the React
		-- codebase. Using concurrent roots, rootB is placed in lane 512 (rather than 1)
		-- Using blocking roots, rootB is placed in lane 2 (rather than 1) so is not registered.
		it("should support mount and update operations for multiple roots", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end
			local rootA = ReactRoblox.createRoot(Instance.new("Frame"))
			local rootB = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				rootA:render(React.createElement(Parent, {
					key = "A",
					count = 3,
				}))
				rootB:render(React.createElement(Parent, {
					key = "B",
					count = 2,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Parent key="A">
[root]
  ▸ <Parent key="B">\]\])
			act(function()
				rootA:render(React.createElement(Parent, {
					key = "A",
					count = 4,
				}))
				rootB:render(React.createElement(Parent, {
					key = "B",
					count = 1,
				}))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Parent key="A">
[root]
  ▸ <Parent key="B">\]\])
			act(function()
				return rootB:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Parent key="A">\]\])
			act(function()
				return rootA:render(nil)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe("")
		end)
		it("should filter DOM nodes from the store tree", function()
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent()
				return React.createElement("Frame", nil, React.createElement(Child))
			end
			local function Grandparent()
				return React.createElement(
					"Frame",
					nil,
					React.createElement("Frame", nil, React.createElement(Parent)),
					React.createElement(Parent)
				)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Grandparent, { count = 4 }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Grandparent>\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), false)
			end)
			-- ROBLOX deviation: we must key children implicitly due to the Roblox DOM being unordered
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent>
    ▸ <Parent key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(1), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent>
        <Child>
    ▸ <Parent key="2">\]\])
		end)
		-- ROBLOX FIXME: unhideInstance is unimplemented
		xit("should display Suspense nodes properly in various states", function()
			local function Loading()
				return React.createElement("TextLabel", { Text = "Loading..." })
			end
			local function SuspendingComponent()
				error(Promise.new(function() end))
			end
			local function Component()
				return React.createElement("TextLabel", { Text = "Hello" })
			end
			local function Wrapper(props)
				local shouldSuspense = props.shouldSuspense

				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						key = "Outside",
					}),
					React.createElement(
						React.Suspense,
						{
							fallback = React.createElement(Loading),
						},
						(function()
							if shouldSuspense then
								return React.createElement(SuspendingComponent)
							end

							return React.createElement(Component, {
								key = "Inside",
							})
						end)()
					)
				)
			end
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(
					React.createElement(Wrapper, { shouldSuspense = true })
				)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Wrapper>\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), false)
			end)
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(2), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense key="2">
        <Loading>\]\])
			act(function()
				root:render(React.createElement(Wrapper, { shouldSuspense = false }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
      <Component key="Outside">
    ▾ <Suspense key="2">
        <Component key="Inside">\]\])
		end)
		it("should support expanding parts of the tree", function()
			local function Child()
				return React.createElement("TextLabel", { Text = "Hi!" })
			end
			local function Parent(props)
				local count = props.count
				return Array.map(fill(count, true), function(_, index)
					return React.createElement(Child, { key = index })
				end)
			end
			local function Grandparent(props)
				local count = props.count
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Parent, { count = count }),
					React.createElement(Parent, { count = count })
				)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Grandparent, { count = 2 }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Grandparent>\]\])

			local grandparentID = store:getElementIDAtIndex(0)

			act(function()
				return store:toggleIsCollapsed(grandparentID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent key="1">
    ▸ <Parent key="2">\]\])

			local parentOneID = store:getElementIDAtIndex(1)
			local parentTwoID = store:getElementIDAtIndex(2)

			act(function()
				return store:toggleIsCollapsed(parentOneID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▸ <Parent key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(parentTwoID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▾ <Parent key="1">
        <Child key="1">
        <Child key="2">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(parentOneID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent key="1">
    ▾ <Parent key="2">
        <Child key="1">
        <Child key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(parentTwoID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Grandparent>
    ▸ <Parent key="1">
    ▸ <Parent key="2">\]\])
			act(function()
				return store:toggleIsCollapsed(grandparentID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Grandparent>\]\])
		end)
		-- ROBLOX TODO: Support both ReactTestRenderer and ReactRoblox renderer as both renderers are needed
		-- in this test to getIDForNode to return correctly, as findFiberByHostInstance is only implemented
		-- in the ReactRoblox renderer. The next step to do this is implement ReactRoblox.act and uncomment
		-- actDOM in __tests__/utils.lua
		xit("should support expanding deep parts of the tree", function()
			local function Nested(props)
				local depth, forwardedRef = props.depth, props.forwardedRef

				return (function()
					if depth > 0 then
						return React.createElement(Nested, {
							depth = depth - 1,
							forwardedRef = forwardedRef,
						})
					end

					return React.createElement("Frame", { ref = forwardedRef })
				end)()
			end
			local function Wrapper(props)
				local forwardedRef = props.forwardedRef

				return React.createElement(Nested, {
					depth = 3,
					forwardedRef = forwardedRef,
				})
			end
			local ref = React.createRef()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Wrapper, { forwardedRef = ref }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Wrapper>\]\])

			local deepestedNodeID = agent:getIDForNode(ref.current)

			-- ROBLOX FIXME: next line fails with: store:432: invalid argument #2 to 'format' (string expected, got nil)
			act(function()
				return store:toggleIsCollapsed(deepestedNodeID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
    ▾ <Nested>
      ▾ <Nested>
        ▾ <Nested>
            <Nested>\]\])

			local rootID = store:getElementIDAtIndex(0)

			act(function()
				return store:toggleIsCollapsed(rootID, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Wrapper>\]\])
			act(function()
				return store:toggleIsCollapsed(rootID, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
    ▾ <Nested>
      ▾ <Nested>
        ▾ <Nested>
            <Nested>\]\])

			local id = store:getElementIDAtIndex(1)

			act(function()
				return store:toggleIsCollapsed(id, true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
    ▸ <Nested>\]\])
			act(function()
				return store:toggleIsCollapsed(id, false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Wrapper>
    ▾ <Nested>
      ▾ <Nested>
        ▾ <Nested>
            <Nested>\]\])
		end)
		it("should support reordering of children", function()
			local function Root(props)
				return props.children
			end
			local function Component()
				return nil
			end
			local function Foo()
				return {
					React.createElement(Component, {
						key = "0",
					}),
				}
			end
			local function Bar()
				return {
					React.createElement(Component, {
						key = "0",
					}),
					React.createElement(Component, {
						key = "1",
					}),
				}
			end
			local foo = React.createElement(Foo, {
				key = "foo",
			})
			local bar = React.createElement(Bar, {
				key = "bar",
			})
			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Root, nil, { foo, bar }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Root>\]\])
			act(function()
				return root:render(React.createElement(Root, nil, { bar, foo }))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Root>\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Root>
    ▸ <Bar key="bar">
    ▸ <Foo key="foo">\]\])
			act(function()
				store:toggleIsCollapsed(store:getElementIDAtIndex(2), false)
				store:toggleIsCollapsed(store:getElementIDAtIndex(1), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <Root>
    ▾ <Bar key="bar">
        <Component key="0">
        <Component key="1">
    ▾ <Foo key="foo">
        <Component key="0">\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), true)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <Root>\]\])
		end)
		-- ROBLOX FIXME: fails with Parent instead of Fallback, possibly bug in agent:overrideSuspense
		xit("should not add new nodes when suspense is toggled", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Fallback()
				return nil
			end
			local function Child()
				return nil
			end
			local function Parent()
				return React.createElement(Child)
			end
			local function SuspenseTree()
				return React.createElement(React.Suspense, {
					fallback = React.createElement(Fallback, nil, "Loading outer"),
				}, React.createElement(Parent))
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(SuspenseTree))
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▸ <SuspenseTree>\]\])
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(0), false)
			end)
			act(function()
				return store:toggleIsCollapsed(store:getElementIDAtIndex(1), false)
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <SuspenseTree>
    ▾ <Suspense>
      ▸ <Parent>\]\])

			local rendererID = getRendererID()
			local suspenseID = store:getElementIDAtIndex(1)

			act(function()
				return agent:overrideSuspense({
					id = suspenseID,
					rendererID = rendererID,
					forceFallback = true,
				})
			end)
			-- ROBLOX FIXME: fails on the next line, gets Parent instead of Fallback
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <SuspenseTree>
    ▾ <Suspense>
        <Fallback>\]\])
			act(function()
				return agent:overrideSuspense({
					id = suspenseID,
					rendererID = rendererID,
					forceFallback = false,
				})
			end)
			jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
  ▾ <SuspenseTree>
    ▾ <Suspense>
      ▸ <Parent>\]\])
		end)
	end)
	describe("getIndexOfElementID", function()
		beforeEach(function()
			store:setCollapseNodesByDefault(false)
		end)
		it("should support a single root with a single child", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return nil
			end
			local function Parent()
				return React.createElement(Child)
			end
			local function Grandparent()
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(Parent),
					React.createElement(Parent)
				)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(React.createElement(Grandparent))
			end)

			for i = 0, store:getNumElements() - 1 do
				jestExpect(store:getIndexOfElementID(store:getElementIDAtIndex(i))).toBe(
					i
				)
			end
		end)
		it("should support multiple roots with one children each", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return nil
			end
			local function Parent()
				return React.createElement(Child)
			end
			local function Grandparent()
				return React.createElement(Parent)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				root:render(React.createElement(Grandparent))
			end)

			for i = 0, store:getNumElements() - 1 do
				jestExpect(store:getIndexOfElementID(store:getElementIDAtIndex(i))).toBe(
					i
				)
			end
		end)
		it("should support a single root with multiple top level children", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return nil
			end
			local function Parent()
				return React.createElement(Child)
			end
			local function Grandparent()
				return React.createElement(Parent)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				return root:render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Grandparent),
						React.createElement(Grandparent)
					)
				)
			end)

			for i = 0, store:getNumElements() - 1 do
				jestExpect(store:getIndexOfElementID(store:getElementIDAtIndex(i))).toBe(
					i
				)
			end
		end)
		it("should support multiple roots with multiple top level children", function()
			-- ROBLOX deviation: switched ordering for variable definition order
			local function Child()
				return nil
			end
			local function Parent()
				return React.createElement(Child)
			end
			local function Grandparent()
				return React.createElement(Parent)
			end

			local root = ReactRoblox.createRoot(Instance.new("Frame"))

			act(function()
				root:render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Grandparent),
						React.createElement(Grandparent)
					)
				)
			end)

			for i = 0, store:getNumElements() - 1 do
				jestExpect(store:getIndexOfElementID(store:getElementIDAtIndex(i))).toBe(
					i
				)
			end
		end)
	end)
	-- ROBLOX deviation: Not necessary as we will always support profiling
	-- it('detects and updates profiling support based on the attached roots', function()
	-- 	local function Component()
	-- 		return nil
	-- 	end

	-- 	local rootB = Instance.new("Frame")

	-- 	jestExpect(store:getSupportsProfiling()).toBe(false)
	-- 	act(function()
	-- 		return root:render(React.createElement(Component), containerA)
	-- 	end)
	-- 	jestExpect(store:getSupportsProfiling()).toBe(true)
	-- 	act(function()
	-- 		return root:render(React.createElement(Component), containerB)
	-- 	end)
	-- 	act(function()
	-- 		return ReactRoblox.unmountComponentAtNode(containerA)
	-- 	end)
	-- 	jestExpect(store:getSupportsProfiling()).toBe(true)
	-- 	act(function()
	-- 		return ReactRoblox.unmountComponentAtNode(containerB)
	-- 	end)
	-- 	jestExpect(store:getSupportsProfiling()).toBe(false)
	-- end)
	it("should properly serialize non-string key values", function()
		local function Child()
			return nil
		end
		local fauxElement = Object.assign({}, React.createElement(Child), { key = 123 })

		local root = ReactRoblox.createRoot(Instance.new("Frame"))
		act(function()
			return root:render({ fauxElement })
		end)
		jestExpect(devtoolsUtils.printStore(store)).toBe(\[\[[root]
    <Child key="123">\]\])
	end)
	-- ROBLOX FIXME: displayName can't be assigned to a function component in lua
	xit("should show the right display names for special component types", function()
		local fakeImport = function(result)
			return Promise.resolve({ default = result })
		end
		local function MyComponent(props, ref)
			return nil
		end
		local ForwardRefComponent = React.forwardRef(MyComponent)
		local function MyComponent2(props, ref)
			return nil
		end
		local ForwardRefComponentWithAnonymousFunction = React.forwardRef(function()
			return React.createElement(MyComponent2)
		end)
		local function MyComponent3(props, ref)
			return nil
		end
		local ForwardRefComponentWithCustomDisplayName = React.forwardRef(MyComponent3)

		ForwardRefComponentWithCustomDisplayName.displayName = "Custom"

		local function MyComponent4(props, ref)
			return nil
		end
		local MemoComponent = React.memo(MyComponent4)
		local MemoForwardRefComponent = React.memo(ForwardRefComponent)
		local function MyComponent5(props, ref)
			return nil
		end
		local LazyComponent = React.lazy(function()
			return fakeImport(MyComponent5)
		end)
		local function FakeHigherOrderComponent()
			return nil
		end

		-- ROBLOX deviation: Lua can't set fields on functions, and this component *must* be a function component to be memoized
		-- FakeHigherOrderComponent.displayName = 'withFoo(withBar(Baz))'

		local MemoizedFakeHigherOrderComponent = React.memo(FakeHigherOrderComponent)
		local ForwardRefFakeHigherOrderComponent =
			React.forwardRef(FakeHigherOrderComponent)
		local function App()
			return React.createElement(
				React.Fragment,
				nil,
				React.createElement(MyComponent),
				React.createElement(ForwardRefComponent),
				React.createElement(ForwardRefComponentWithAnonymousFunction),
				React.createElement(ForwardRefComponentWithCustomDisplayName),
				React.createElement(MemoComponent),
				React.createElement(MemoForwardRefComponent),
				React.createElement(React.Suspense, {
					fallback = "Loading...",
				}, React.createElement(LazyComponent)),
				React.createElement(FakeHigherOrderComponent),
				React.createElement(MemoizedFakeHigherOrderComponent),
				React.createElement(ForwardRefFakeHigherOrderComponent)
			)
		end
		local root = ReactRoblox.createRoot(Instance.new("Frame"))

		-- Render once to start fetching the lazy component
		act(function()
			return root:render(React.createElement(App))
		end)

		-- ROBLOX deviation: equivalent of await Promise.resolve()
		Promise.delay(0):await()

		-- Render again after it resolves
		act(function()
			return root:render(React.createElement(App))
		end)
		-- ROBLOX TODO: Work out how to customize component display names to correctly parse hook names e.g. withFoo(withBar(Baz))
		-- ROBLOX TODO: Work out why MyComponent is anonymous when wrapped by forwardRef & Memo
		jestExpect(devtoolsUtils.printStore(store)).toBe([==\[\[root]
  ▾ <App>
      <MyComponent>
      <MyComponent> [ForwardRef]
    ▾ <Anonymous> [ForwardRef]
        <MyComponent2>
      <Custom> [ForwardRef]
      <MyComponent4> [Memo]
    ▾ <MyComponent> [Memo]
        <MyComponent> [ForwardRef]
    ▾ <Suspense>
        <MyComponent5>
      <Baz> [withFoo][withBar]
      <Baz> [Memo][withFoo][withBar]
      <Baz> [ForwardRef][withFoo][withBar\]\]==])
	end)
end) ]]
a4.Children._367d842cb43f73512381b772fc9a0001=br
local bs

local bt={ClassName="ModuleScript",Children={},Properties={}}
bt.Name="storeComponentFilters.spec"
bt.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/storeComponentFilters-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

type Function = (...any) -> ...any
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect

local global = _G

local bridgeModule = require(script.Parent.Parent.bridge)
type FrontendBridge = bridgeModule.FrontendBridge
local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store

describe("Store component filters", function()
	local React
	local ReactRoblox
	local Types
	local bridge: FrontendBridge
	local store: Store
	local devtoolsUtils
	local utils

	local act = function(callback: Function)
		ReactRoblox.act(function()
			callback()
			-- ROBLOX FIXME: flush should be happening when all timers are run
			bridge:_flush()
		end)
		jest.runAllTimers() -- Flush Bridge operations
	end

	beforeEach(function()
		bridge = global.bridge
		store = global.store
		store:setCollapseNodesByDefault(false)
		store:setComponentFilters({})
		store:setRecordChangeDescriptions(true)

		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = true

		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		Types = require(script.Parent.Parent.types)
		utils = require(script.Parent.utils)
		devtoolsUtils = require(script.Parent.Parent.devtools.utils)
	end)

	it("should throw if filters are updated while profiling", function()
		act(function()
			return store:getProfilerStore():startProfiling()
		end)
		jestExpect(function()
			store:setComponentFilters({})
			return store:getComponentFilters()
		end).toThrow("Cannot modify filter preferences while profiling")
	end)

	it("should support filtering by element type", function()
		local Root = React.Component:extend("Root")
		function Root:render()
			return React.createElement("Frame", nil, self.props.children)
		end
		local function Component()
			return React.createElement("TextLabel", { Text = "Hi" })
		end
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			return root:render(
				React.createElement(Root, {}, React.createElement(Component))
			)
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
		act(function()
			store:setComponentFilters({
				utils.createElementTypeFilter(Types.ElementTypeHostComponent),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: still shows the Frame and TextLabel, upstream only has [root] ▾ <Root> <Component>
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"2: hide host components"
		)
		act(function()
			store:setComponentFilters({
				utils.createElementTypeFilter(Types.ElementTypeClass),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: supposed to hide Root, but doesn't
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"3: hide class components"
		)
		act(function()
			store:setComponentFilters({
				utils.createElementTypeFilter(Types.ElementTypeClass),
				utils.createElementTypeFilter(Types.ElementTypeFunction),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: should only show Frame and TextLabel
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"4: hide class and function components"
		)
		act(function()
			store:setComponentFilters({
				utils.createElementTypeFilter(Types.ElementTypeClass, false),
				utils.createElementTypeFilter(Types.ElementTypeFunction, false),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"5: disable all filters"
		)
	end)
	it("should ignore invalid ElementTypeRoot filter", function()
		local function Root(props)
			return React.createElement("TextLabel", { Text = "Hi" }, props.children)
		end
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			root:render(React.createElement(Root))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
		act(function()
			store:setComponentFilters({
				utils.createElementTypeFilter(Types.ElementTypeRoot),
			})
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"2: add invalid filter"
		)
	end)
	it("should filter by display name", function()
		local function Text(props)
			-- Roblox deviation: Text is a noop so we don't clutter our tree with TextLabels
			-- return React.createElement("TextLabel", { Text = props.label })
			return nil
		end
		local function Foo()
			return React.createElement(Text, { label = "foo" })
		end
		local function Bar()
			return React.createElement(Text, { label = "bar" })
		end
		local function Baz()
			return React.createElement(Text, { label = "baz" })
		end
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			return root:render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Foo),
					React.createElement(Bar),
					React.createElement(Baz)
				)
			)
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
		act(function()
			store:setComponentFilters({ utils.createDisplayNameFilter("Foo") })
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: doens't filter FOo
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot('2: filter "Foo"')
		act(function()
			store:setComponentFilters({ utils.createDisplayNameFilter("Ba") })
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot('3: filter "Ba"')
		act(function()
			store:setComponentFilters({ utils.createDisplayNameFilter("B.z") })
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot('4: filter "B.z"')
	end)
	it("should filter by path", function()
		local function Component()
			return React.createElement("TextLabel", { Text = "Hi" })
		end
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			root:render(React.createElement(Component))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
		act(function()
			store:setComponentFilters({
				--	utils.createLocationFilter(__filename:replace(__dirname, "")),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: upstream only has `[root]`, we still show the whole tree
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"2: hide all components declared within this test filed"
		)
		act(function()
			store:setComponentFilters({
				utils.createLocationFilter("this:is:a:made:up:path"),
			})
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"3: hide components in a made up fake path"
		)
	end)
	it("should filter HOCs", function()
		local function Component()
			return React.createElement("TextLabel", { Text = "Hi" })
		end

		local Foo = React.Component:extend("Foo(Component)")
		function Foo:render()
			return React.createElement(Component)
		end
		local Bar = React.Component:extend("Bar(Foo(Component))")
		function Bar:render()
			return React.createElement(Foo)
		end

		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			return root:render(React.createElement(Bar))
		end)

		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
		act(function()
			store:setComponentFilters({ utils.createHOCFilter(true) })
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		-- ROBLOX FIXME: still shows all components
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("2: hide all HOCs")
		act(function()
			store:setComponentFilters({ utils.createHOCFilter(false) })
			return store:getComponentFilters()
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"3: disable HOC filter"
		)
	end)
	it(
		"should not send a bridge update if the set of enabled filters has not changed",
		function()
			act(function()
				store:setComponentFilters({ utils.createHOCFilter(true) })
				return store:getComponentFilters()
			end)
			bridge:addListener("updateComponentFilters", function(componentFilters)
				error("Unexpected component update")
			end)
			act(function()
				store:setComponentFilters({
					utils.createHOCFilter(false),
					utils.createHOCFilter(true),
				})
				return store:getComponentFilters()
			end)
			act(function()
				store:setComponentFilters({
					utils.createHOCFilter(true),
					utils.createLocationFilter("abc", false),
				})
				return store:getComponentFilters()
			end)
			act(function()
				store:setComponentFilters({
					utils.createHOCFilter(true),
					utils.createElementTypeFilter(Types.ElementTypeHostComponent, false),
				})
				return store:getComponentFilters()
			end)
		end
	)
end) ]]
a4.Children._509c4cefba6f967c7294d81eb9463732=bt
local bu

local bv={ClassName="ModuleScript",Children={},Properties={}}
bv.Name="storeOwners.spec"
bv.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/storeOwners-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach

local global = _G
local ReactRoblox

-- ROBLOX Deviation: Skip test in nonDev mode
local describeIfDev = _G.DEV and describe or describe.skip :: any
describeIfDev("Store owners list", function()
	local React
	local LuauPolyfill
	local Boolean
	local act
	local store
	local devtoolsUtils
	local printOwnersList

	beforeEach(function()
		store = global.store
		store:setCollapseNodesByDefault(false)

		LuauPolyfill = require(Packages.LuauPolyfill)
		Boolean = LuauPolyfill.Boolean
		React = require(Packages.React)
		ReactRoblox = require(Packages.ReactRoblox)
		devtoolsUtils = require(script.Parent.Parent.devtools.utils)
		printOwnersList = devtoolsUtils.printOwnersList

		local utils = require(script.Parent.utils)
		act = utils.act
	end)

	it("should drill through intermediate components", function()
		local Wrapper, Intermediate, Leaf
		local function Root()
			return React.createElement(
				Intermediate,
				nil,
				React.createElement("Frame", nil, React.createElement(Leaf, nil))
			)
		end
		function Wrapper(ref)
			local children = ref.children
			return children
		end
		function Leaf()
			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Name = "Leaf" })
			)
		end
		function Intermediate(ref)
			local children = ref.children
			return React.createElement(Wrapper, nil, children)
		end

		-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			return root:render(React.createElement(Root, nil))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")

		local rootID = store:getElementIDAtIndex(0)
		jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
			"2: components owned by <Root>"
		)

		local intermediateID = store:getElementIDAtIndex(1)
		jestExpect(printOwnersList(store:getOwnersListForElement(intermediateID))).toMatchSnapshot(
			"3: components owned by <Intermediate>"
		)
	end)

	it("should drill through interleaved intermediate components", function()
		-- ROBLOX FIXME Luau: needs deferred constraint resolution to eliminate any cast
		local Wrapper, Intermediate: any, Leaf
		-- ROBLOX FIXME Luau: this cast couldn't be needed: Type '() -> {ReactElement<any, a>}' could not be converted into '((React_ElementProps<any>?, any) -> (Array<(Array<<CYCLE>> | React_Element<any> | boolean | number | string | t1)?> | React_Element<any> | boolean | number | string | t1)?) | LazyComponent<a, React_ElementProps<any>?> | ReactContext<any> | ReactProviderType<any> | React_ComponentType<React_ElementProps<any>?> | string where t1 = {| [string]: (boolean | number | string | t1 | {(<CYCLE> | boolean | number | string | t1 | {| key: (number | string)?, props: {| __source: {| fileName: string, lineNumber: number |}?, children: any?, key: (number | string)?, ref: (((any?) -> ()) | {| current: any? |})? |}?, ref: any, type: any |})?}... <TRUNCATED>'; none of the union options are compatible
		local function Root(): any
			return {
				React.createElement(
					Intermediate,
					{ key = "intermediate" },
					React.createElement(Leaf)
				),
				React.createElement(Leaf, { key = "leaf" }),
			}
		end
		function Wrapper(ref)
			local children = ref.children
			return children
		end
		function Leaf()
			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Name = "Leaf" })
			)
		end
		function Intermediate(ref)
			local children = ref.children
			return {
				React.createElement(Leaf, { key = "leaf" }),
				-- ROBLOX FIXME Luau: without this any cast,  Type '{ key: string }' could not be converted into '{ key: string }?'
				React.createElement(Wrapper, { key = "wrapper" } :: any, children),
			}
		end

		-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
		act(function()
			local root = ReactRoblox.createRoot(Instance.new("Frame"))
			return root:render(React.createElement(Root))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")

		local rootID = store:getElementIDAtIndex(0)
		jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
			"2: components owned by <Root>"
		)
		local intermediateID = store:getElementIDAtIndex(1)
		jestExpect(printOwnersList(store:getOwnersListForElement(intermediateID))).toMatchSnapshot(
			"3: components owned by <Intermediate>"
		)
	end)

	-- ROBLOX Test Noise: This test alone prints numerous 'No element
	-- found with id' errors that upstream does not
	it(
		"should show the proper owners list order and contents after insertions and deletions",
		function()
			local Wrapper, Leaf, Intermediate
			local function Root(ref)
				local includeDirect, includeIndirect =
					ref.includeDirect, ref.includeIndirect
				return React.createElement(
					"Frame",
					nil,
					if Boolean.toJSBoolean(includeDirect)
						then React.createElement(Leaf, nil)
						else nil,
					if Boolean.toJSBoolean(includeIndirect)
						then React.createElement(
							Intermediate,
							nil,
							React.createElement(Leaf, nil)
						)
						else nil
				)
			end
			function Wrapper(ref)
				local children = ref.children
				return children
			end
			function Leaf()
				return React.createElement(
					"Frame",
					nil,
					React.createElement("TextLabel", { Name = "Leaf" })
				)
			end
			function Intermediate(ref)
				local children = ref.children
				return React.createElement(Wrapper, nil, children)
			end

			local container = Instance.new("Frame")
			-- ROBLOX deviation: Create a root for rendering instead of using ReactDOM
			local root = ReactRoblox.createRoot(container)

			-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
			act(function()
				return root:render(
					React.createElement(
						Root,
						{ includeDirect = false, includeIndirect = true }
					)
				)
			end)
			-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
			jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot("1: mount")
			local rootID = store:getElementIDAtIndex(0)
			jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
				"2: components owned by <Root>"
			)

			-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
			act(function()
				return root:render(
					React.createElement(
						Root,
						{ includeDirect = true, includeIndirect = true }
					)
				)
			end)
			-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
			jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
				"3: update to add direct"
			)
			jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
				"4: components owned by <Root>"
			)

			-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
			act(function()
				return root:render(
					React.createElement(
						Root,
						{ includeDirect = true, includeIndirect = false }
					)
				)
			end)
			-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
			jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
				"5: update to remove indirect"
			)
			jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
				"6: components owned by <Root>"
			)

			-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
			act(function()
				return root:render(
					React.createElement(
						Root,
						{ includeDirect = false, includeIndirect = false }
					)
				)
			end)
			-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
			jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
				"7: update to remove both"
			)
			jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
				"8: components owned by <Root>"
			)
		end
	)

	it("should show the proper owners list ordering after reordered children", function()
		local Leaf
		-- ROBLOX FIXME Luau: shouldn't need this any cast
		local function Root(ref): any
			local ascending = ref.ascending
			return if Boolean.toJSBoolean(ascending)
				then {
					React.createElement(Leaf, { key = "A" }),
					React.createElement(Leaf, { key = "B" }),
					React.createElement(Leaf, { key = "C" }),
				}
				else {
					React.createElement(Leaf, { key = "C" }),
					React.createElement(Leaf, { key = "B" }),
					React.createElement(Leaf, { key = "A" }),
				}
		end
		function Leaf()
			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Name = "Leaf" })
			)
		end

		local container = Instance.new("Frame")
		-- ROBLOX deviation: Create a root for rendering instead of using ReactDOM
		local root = ReactRoblox.createRoot(container)

		-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
		act(function()
			return root:render(React.createElement(Root, { ascending = true }))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"1: mount (ascending)"
		)
		local rootID = store:getElementIDAtIndex(0)
		jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
			"2: components owned by <Root>"
		)

		-- ROBLOX deviation: use root:render to render instead of ReactDOM.render
		act(function()
			return root:render(React.createElement(Root, { ascending = false }))
		end)
		-- ROBLOX deviation: we use devtoolsUtils.printStore, upstream uses a jest serializer (storeSerializer) instead
		jestExpect(devtoolsUtils.printStore(store)).toMatchSnapshot(
			"3: update (descending)"
		)
		jestExpect(printOwnersList(store:getOwnersListForElement(rootID))).toMatchSnapshot(
			"4: components owned by <Root>"
		)
	end)
end) ]]
a4.Children._585e517b20bf0dceec5ed027d6ed6742=bv
local bw

local bx={ClassName="ModuleScript",Children={},Properties={}}
bx.Name="utils"
bx.Properties.Source=[[ --!nonstrict
local HttpService = game:GetService("HttpService")
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/utils.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Number = LuauPolyfill.Number
local Object = LuauPolyfill.Object
type Function = (...any) -> any?
local global = _G
local exports = {}

local Bridge = require(script.Parent.Parent.bridge)
type FrontendBridge = Bridge.FrontendBridge
local devtoolsTypes = require(script.Parent.Parent.devtools.types)
type Store = devtoolsTypes.Store
local ProfilerTypes = require(script.Parent.Parent.devtools.views.Profiler.types)
type ProfilingDataFrontend = ProfilerTypes.ProfilingDataFrontend
local Types = require(script.Parent.Parent.types)
type ElementType = Types.ElementType

exports.act = function(callback: () -> ()): ()
	-- ROBLOX deviation: TestRenderer and RobloxRenderer do not play nice with
	-- one another right now. All of the ported tests in this package are
	-- using only the ReactRoblox renderer, so we only wrap with it directly

	-- local actTestRenderer = require(Packages.Dev.ReactTestRenderer).act

	local actDOM = require(Packages.ReactRoblox).act

	actDOM(function()
		-- actTestRenderer(function()
		callback()
		-- end)
	end)

	while jest.getTimerCount() > 0 do
		actDOM(function()
			-- actTestRenderer(function()
			jest.runAllTimers()
			-- end)
		end)
	end
end

exports.actAsync = function(cb: () -> any, recursivelyFlush: boolean?)
	if recursivelyFlush == nil then
		recursivelyFlush = true
	end

	-- ROBLOX deviation: TestRenderer and RobloxRenderer do not play nice with
	-- one another right now. All of the ported tests in this package are
	-- using only the ReactRoblox renderer, so we only wrap with it directly
	-- local actTestRenderer = require(Packages.Dev.ReactTestRenderer).act

	local actDOM = require(Packages.ReactRoblox).act

	if recursivelyFlush then
		while jest.getTimerCount() > 0 do
			-- $FlowFixMe Flow doesn't know about "await act()" yet
			actDOM(function()
				-- return actTestRenderer(function()
				jest.runAllTimers()
				-- end):await()
			end)
		end
	else
		-- $FlowFixMe Flow doesn't know about "await act()" yet
		actDOM(function()
			-- return actTestRenderer(function()
			jest.runOnlyPendingTimers()
			-- end):await()
		end)
	end
end

exports.beforeEachProfiling = function(): ()
	-- ROBLOX deviation BEGIN: we handle this differently until jest-roblox 27.5 is available
	-- Mock React's timing information so that test runs are predictable.
	jest.mock(Packages.Dev.Scheduler, function()
		return require(Packages.Parent.Scheduler.Scheduler.unstable_mock)
	end)
	-- DevTools itself uses performance.now() to offset commit times
	-- so they appear relative to when profiling was started in the UI.
	-- ROBLOX deviation: os.clock not performance
	-- ROBLOX TODO: Can you actually spy on os.clock?
	-- ROBLOX deviation BEGIN: We need to do slightly more targeted mocking until
	local Scheduler = require(Packages.Dev.Scheduler)
	jest.mockOsClock(Scheduler.unstable_now)
	-- jest.spyOn(os, "clock").mockImplementation(
	-- 	jest.requireActual("scheduler/unstable_mock").unstable_now
	-- )
	-- ROBLOX deviation END
end

exports.createDisplayNameFilter = function(source: string, isEnabled: boolean?)
	if isEnabled == nil then
		isEnabled = true
	end
	-- ROBLOX deviation: Cannot sanitize source as a RegExp so assume valid
	local isValid = true

	return {
		type = Types.ComponentFilterDisplayName,
		isEnabled = isEnabled,
		isValid = isValid,
		value = source,
	}
end

exports.createHOCFilter = function(isEnabled: boolean?)
	if isEnabled == nil then
		isEnabled = true
	end

	return {
		type = Types.ComponentFilterHOC,
		isEnabled = isEnabled,
		isValid = true,
	}
end

exports.createElementTypeFilter = function(elementType: ElementType, isEnabled: boolean?)
	if isEnabled == nil then
		isEnabled = true
	end

	return {
		type = Types.ComponentFilterElementType,
		isEnabled = isEnabled,
		value = elementType,
	}
end

exports.createLocationFilter = function(source: string, isEnabled: boolean?)
	if isEnabled == nil then
		isEnabled = true
	end
	local isValid = true

	return {
		type = Types.ComponentFilterLocation,
		isEnabled = isEnabled,
		isValid = isValid,
		value = source,
	}
end

exports.getRendererID = function(): number
	if global.agent == nil then
		error("Agent unavailable.")
	end

	local ids = Object.keys(global.agent._rendererInterfaces)
	local id = Array.find(ids, function(innerID)
		-- ROBLOX deviation: Let's return all renderers
		-- local rendererInterface = global.agent._rendererInterfaces[innerID]
		-- return rendererInterface.renderer.rendererPackageName == 'react-dom'
		return true
	end)

	if ids == nil then
		error("Could not find renderer.")
	end

	-- ROBLOX FIXME: create Number.parseInt() in luau-polyfill
	-- ROBLOX FIXME Luau: if-expression boolean doesn't narrow id correctly
	return if id then tonumber(id) :: number else Number.NaN
end
exports.requireTestRenderer = function(): any
	-- Hide the hook before requiring TestRenderer, so we don't end up with a loop.
	local hook = global.__REACT_DEVTOOLS_GLOBAL_HOOK__
	global.__REACT_DEVTOOLS_GLOBAL_HOOK__ = nil

	local success, module = pcall(function()
		return require(Packages.Dev.ReactTestRenderer)
	end)

	global.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook

	if not success then
		warn("Failed to require TestRenderer", module)
		return nil
	else
		return module
	end
end

exports.exportImportHelper = function(bridge: FrontendBridge, store: Store): ()
	local utils = require(script.Parent.Parent.devtools.views.Profiler.utils)
	local prepareProfilingDataExport = utils.prepareProfilingDataExport
	local prepareProfilingDataFrontendFromExport =
		utils.prepareProfilingDataFrontendFromExport
	local profilerStore = store._profilerStore

	local profilingDataFrontendInitial = profilerStore:profilingData()
	jestExpect(profilingDataFrontendInitial).never.toBeNull()
	-- ROBLOX deviation: luau needs the assert since .never.toBeNull() doesn't have narrowing side-effects right now
	assert(profilingDataFrontendInitial, "profilingDataFrontendInitial was nil")

	jestExpect(profilingDataFrontendInitial.imported).toBe(false)

	local profilingDataExport = prepareProfilingDataExport(profilingDataFrontendInitial)

	-- Simulate writing/reading to disk.
	local serializedProfilingDataExport = HttpService:JSONEncode(profilingDataExport)
	local parsedProfilingDataExport =
		HttpService:JSONDecode(serializedProfilingDataExport)

	local profilingDataFrontend =
		prepareProfilingDataFrontendFromExport(parsedProfilingDataExport)
	jestExpect(profilingDataFrontend.imported).toBe(true)

	-- Sanity check that profiling snapshots are serialized correctly.
	jestExpect(profilingDataFrontendInitial.dataForRoots).toEqual(
		profilingDataFrontend.dataForRoots
	)

	-- Snapshot the JSON-parsed object, rather than the raw string, because Jest formats the diff nicer.
	jestExpect(parsedProfilingDataExport).toMatchSnapshot("imported data")

	exports.act(function()
		-- Apply the new exported-then-imported data so tests can re-run assertions.
		profilerStore:profilingData(profilingDataFrontend)
	end)
end

return exports ]]
a4.Children._0212effe534455b8a00529dad55474c4=bx
local by

local bz={ClassName="ModuleScript",Children={},Properties={}}
bz.Name="utils.spec"
bz.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/__tests__/events-test.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit
local beforeEach = JestGlobals.beforeEach
local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol

local utils = require(script.Parent.Parent.utils)
local getDisplayName = utils.getDisplayName
local getDisplayNameForReactElement = utils.getDisplayNameForReactElement
local SuspenseList, StrictMode
local createElement

beforeEach(function()
	local ReactSymbols = require(Packages.Shared).ReactSymbols
	SuspenseList = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
	StrictMode = ReactSymbols.REACT_STRICT_MODE_TYPE
	local React = require(Packages.React)
	createElement = React.createElement
end)

describe("utils", function()
	describe("getDisplayName", function()
		it("should return a function name", function()
			local function FauxComponent() end

			jestExpect(getDisplayName(FauxComponent)).toEqual("FauxComponent")
		end)

		it("should return a displayName name if specified", function()
			local FauxComponent = {}

			FauxComponent.__componentName = "OverrideDisplayName"

			jestExpect(getDisplayName(FauxComponent)).toEqual("OverrideDisplayName")
		end)

		it("should return the fallback for anonymous functions", function()
			jestExpect(getDisplayName(function() end, "Fallback")).toEqual("Fallback")
		end)

		it(
			"should return Anonymous for anonymous functions without a fallback",
			function()
				jestExpect(getDisplayName(function() end)).toEqual("Anonymous")
			end
		)

		-- Simulate a reported bug:
		-- https://github.com/facebook/react/issues/16685
		it("should return a fallback when the name prop is not a string", function()
			local FauxComponent = { name = {} }
			jestExpect(getDisplayName(FauxComponent, "Fallback")).toEqual("Fallback")
		end)
	end)
	describe("getDisplayNameForReactElement", function()
		-- ROBLOX deviation: Lua can't put fields on functions
		xit(
			"should return correct display name for an element with function type",
			function()
				local function FauxComponent() end

				-- FauxComponent.displayName = 'OverrideDisplayName'

				local element = createElement(FauxComponent)

				jestExpect(getDisplayNameForReactElement(element)).toEqual(
					"OverrideDisplayName"
				)
			end
		)

		it(
			"should return correct display name for an element with a type of StrictMode",
			function()
				local element = createElement(StrictMode)

				jestExpect(getDisplayNameForReactElement(element)).toEqual("StrictMode")
			end
		)

		it(
			"should return correct display name for an element with a type of SuspenseList",
			function()
				local element
				-- ROBLOX Test Noise: This warning shouldn't be triggered
				jestExpect(function()
					element = createElement(SuspenseList)
				end).toErrorDev("type is invalid", { withoutStack = true })

				jestExpect(getDisplayNameForReactElement(element)).toEqual("SuspenseList")
			end
		)

		it(
			"should return NotImplementedInDevtools for an element with invalid symbol type",
			function()
				local element
				-- ROBLOX Test Noise: This warning isn't captured in
				-- upstream, so it may rely on test setup to suppress it
				jestExpect(function()
					element = (createElement :: any)(Symbol("foo"))
				end).toErrorDev("type is invalid", { withoutStack = true })

				jestExpect(getDisplayNameForReactElement(element)).toEqual(
					"NotImplementedInDevtools"
				)
			end
		)

		it(
			"should return NotImplementedInDevtools for an element with invalid type",
			function()
				local element
				-- ROBLOX Test Noise: This warning isn't captured in
				-- upstream, so it may rely on test setup to suppress it
				jestExpect(function()
					element = (createElement :: any)(true)
				end).toErrorDev("type is invalid", { withoutStack = true })

				jestExpect(getDisplayNameForReactElement(element)).toEqual(
					"NotImplementedInDevtools"
				)
			end
		)

		it("should return Element for null type", function()
			local element
			-- ROBLOX Test Noise: This warning isn't captured in
			-- upstream, so it may rely on test setup to suppress it
			jestExpect(function()
				element = (createElement :: any)()
			end).toErrorDev("type is invalid", { withoutStack = true })

			jestExpect(getDisplayNameForReactElement(element)).toEqual("Element")
		end)
	end)
end) ]]
a4.Children._3110857fb15b605f6177aa5793728519=bz
local bA

local bB={ClassName="ModuleScript",Children={},Properties={}}
bB.Name="backend"
bB.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array

local Agent = require(script.agent)
type Agent = Agent.Agent

local types = require(script.types)
export type DevToolsHook = types.DevToolsHook
export type ReactRenderer = types.ReactRenderer
export type RendererInterface = types.RendererInterface

type Object = { [string]: any }

local function initBackend(hook: DevToolsHook, agent: Agent, global: Object): () -> ()
	if hook == nil then
		-- DevTools didn't get injected into this page (maybe b'c of the contentType).
		return function() end
	end
	local subs = {
		hook.sub("renderer-attached", function(args: {
			id: number,
			renderer: ReactRenderer,
			rendererInterface: RendererInterface,
		})
			local id = args.id
			local rendererInterface = args.rendererInterface

			agent:setRendererInterface(id, rendererInterface)

			-- Now that the Store and the renderer interface are connected,
			-- it's time to flush the pending operation codes to the frontend.
			rendererInterface.flushInitialOperations()
		end),
		hook.sub("unsupported-renderer-version", function(id: number)
			agent:onUnsupportedRenderer(id)
		end),

		hook.sub("operations", function(...)
			agent:onHookOperations(...)
		end),
		hook.sub("traceUpdates", function(...)
			agent:onTraceUpdates(...)
		end),

		-- TODO Add additional subscriptions required for profiling mode
	}

	local attachRenderer = function(id: number, renderer: ReactRenderer)
		-- ROBLOX deviation: require attach lazily to avoid the require of renderer causing Roact to initialize prematurely.
		local attach = require(script.renderer).attach

		local rendererInterface = hook.rendererInterfaces:get(id)

		-- Inject any not-yet-injected renderers (if we didn't reload-and-profile)
		if rendererInterface == nil then
			if type(renderer.findFiberByHostInstance) == "function" then
				-- react-reconciler v16+
				rendererInterface = attach(hook, id, renderer, global)
			elseif renderer.ComponentTree then
				-- react-dom v15
				-- ROBLOX deviation: Not needed
				-- rendererInterface = attachLegacy(hook, id, renderer, global)
			else
				-- Older react-dom or other unsupported renderer version
			end
			if rendererInterface ~= nil then
				hook.rendererInterfaces:set(id, rendererInterface)
			end
		end

		-- Notify the DevTools frontend about new renderers.
		-- This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).
		if rendererInterface ~= nil then
			hook.emit("renderer-attached", {
				id = id,
				renderer = renderer,
				rendererInterface = rendererInterface,
			})
		else
			hook.emit("unsupported-renderer-version", id)
		end
	end

	-- Connect renderers that have already injected themselves.
	hook.renderers:forEach(function(renderer, id)
		attachRenderer(id, renderer)
	end)

	-- Connect any new renderers that injected themselves.
	table.insert(
		subs,
		hook.sub("renderer", function(args: { id: number, renderer: ReactRenderer })
			local id = args.id
			local renderer = args.renderer
			attachRenderer(id, renderer)
		end)
	)

	hook.emit("react-devtools", agent)
	hook.reactDevtoolsAgent = agent
	local function onAgentShutdown()
		Array.forEach(subs, function(fn)
			fn()
		end)
		hook.rendererInterfaces:forEach(function(rendererInterface)
			rendererInterface.cleanup()
		end)
		hook.reactDevtoolsAgent = nil
	end
	agent:addListener("shutdown", onAgentShutdown)
	table.insert(subs, function()
		agent:removeListener("shutdown", onAgentShutdown)
	end)

	return function()
		for _, fn in subs do
			fn()
		end
	end
end

return {
	initBackend = initBackend,
	agent = require(script.agent),
	NativeStyleEditor = {
		types = require(script.NativeStyleEditor.types),
	},
} ]]
a2.Children._6d9c1a11ac02ae3fb25d3ab755472be7=bB
local bC
local bD={ClassName="Folder",Children={},Properties={}}
bD.Name="NativeStyleEditor"
bC.Children._604153e036ace5016a97426b4d994849=bD
local bE
local bF={ClassName="ModuleScript",Children={},Properties={}}
bF.Name="types"
bF.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/NativeStyleEditor/types.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */
type Object = { [string]: any }

export type BoxStyle = { bottom: number, left: number, right: number, top: number }

export type Layout = {
	x: number,
	y: number,
	width: number,
	height: number,
	left: number,
	top: number,
	margin: BoxStyle,
	padding: BoxStyle,
}

export type Style = Object

export type StyleAndLayout = { id: number, style: Style | nil, layout: Layout | nil }

return {} ]]
bE.Children._c9a50c59573ba32d2f4d21c9d6e73773=bF
local bG

local bH={ClassName="ModuleScript",Children={},Properties={}}
bH.Name="ReactSymbols"
bH.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/ReactSymbols.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local exports = {}
exports.CONCURRENT_MODE_NUMBER = 0xeacf
exports.CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)"

exports.CONTEXT_NUMBER = 0xeace
exports.CONTEXT_SYMBOL_STRING = "Symbol(react.context)"

exports.DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)"

exports.ELEMENT_NUMBER = 0xeac7
exports.ELEMENT_SYMBOL_STRING = "Symbol(react.element)"

exports.DEBUG_TRACING_MODE_NUMBER = 0xeae1
exports.DEBUG_TRACING_MODE_SYMBOL_STRING = "Symbol(react.debug_trace_mode)"

exports.FORWARD_REF_NUMBER = 0xead0
exports.FORWARD_REF_SYMBOL_STRING = "Symbol(react.forward_ref)"

exports.FRAGMENT_NUMBER = 0xeacb
exports.FRAGMENT_SYMBOL_STRING = "Symbol(react.fragment)"

exports.LAZY_NUMBER = 0xead4
exports.LAZY_SYMBOL_STRING = "Symbol(react.lazy)"

exports.MEMO_NUMBER = 0xead3
exports.MEMO_SYMBOL_STRING = "Symbol(react.memo)"

exports.OPAQUE_ID_NUMBER = 0xeae0
exports.OPAQUE_ID_SYMBOL_STRING = "Symbol(react.opaque.id)"

exports.PORTAL_NUMBER = 0xeaca
exports.PORTAL_SYMBOL_STRING = "Symbol(react.portal)"

exports.PROFILER_NUMBER = 0xead2
exports.PROFILER_SYMBOL_STRING = "Symbol(react.profiler)"

exports.PROVIDER_NUMBER = 0xeacd
exports.PROVIDER_SYMBOL_STRING = "Symbol(react.provider)"

exports.SCOPE_NUMBER = 0xead7
exports.SCOPE_SYMBOL_STRING = "Symbol(react.scope)"

exports.STRICT_MODE_NUMBER = 0xeacc
exports.STRICT_MODE_SYMBOL_STRING = "Symbol(react.strict_mode)"

exports.SUSPENSE_NUMBER = 0xead1
exports.SUSPENSE_SYMBOL_STRING = "Symbol(react.suspense)"

exports.SUSPENSE_LIST_NUMBER = 0xead8
exports.SUSPENSE_LIST_SYMBOL_STRING = "Symbol(react.suspense_list)"

return exports ]]
bC.Children._108ce5bbb91436cb90ae459e5cfcc930=bH
local bI

local bJ={ClassName="ModuleScript",Children={},Properties={}}
bJ.Name="agent"
bJ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/agent.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Set<T> = LuauPolyfill.Set<T>
local console = LuauPolyfill.console
local JSON = game:GetService("HttpService")
local global = _G
type Function = (...any) -> ...any
type Array<T> = { [number]: T }
type Object = { [string]: any }

local EventEmitter = require(script.Parent.Parent.events)
type EventEmitter<Events> = EventEmitter.EventEmitter<Events>
-- ROBLOX FIXME: need to implement lodash.throttle, pass through for now
-- import throttle from 'lodash.throttle';
local throttle = function(fn: Function, _limit: number): Function
	return fn
end
local constants = require(script.Parent.Parent.constants)
local SESSION_STORAGE_LAST_SELECTION_KEY = constants.SESSION_STORAGE_LAST_SELECTION_KEY
local SESSION_STORAGE_RELOAD_AND_PROFILE_KEY =
	constants.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY
local SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY =
	constants.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY
local __DEBUG__ = constants.__DEBUG__
local storage = require(script.Parent.Parent.storage)
local sessionStorageGetItem = storage.sessionStorageGetItem
local sessionStorageRemoveItem = storage.sessionStorageRemoveItem
local sessionStorageSetItem = storage.sessionStorageSetItem
-- local Highlighter = require(script.Parent.views.Highlighter)
-- local setupHighlighter = Highlighter.default
-- ROBLOX TODO: stub for now
local setupHighlighter = function(bridge, agent) end
-- local TraceUpdates = require(script.Parent.views.TraceUpdates)
-- local setupTraceUpdates = TraceUpdates.initialize
-- local setTraceUpdatesEnabled = TraceUpdates.toggleEnabled
-- ROBLOX TODO: stub these for now
local setupTraceUpdates = function(agent) end
local setTraceUpdatesEnabled = function(enabled: boolean) end

-- local console = require(script.Parent.console)
-- local patchConsole = console.patch
-- local unpatchConsole = console.unpatch
-- ROBLOX TODO: stub these for now. they're used to force the debugger to break immediately when console.error is called
local patchConsole = function(obj) end
local unpatchConsole = function() end

local Bridge = require(script.Parent.Parent.bridge)
type BackendBridge = Bridge.BackendBridge

local BackendTypes = require(script.Parent.types)
type InstanceAndStyle = BackendTypes.InstanceAndStyle
type NativeType = BackendTypes.NativeType
type OwnersList = BackendTypes.OwnersList
type PathFrame = BackendTypes.PathFrame
type PathMatch = BackendTypes.PathMatch
type RendererID = BackendTypes.RendererID
type RendererInterface = BackendTypes.RendererInterface

local SharedTypes = require(script.Parent.Parent.types)
type ComponentFilter = SharedTypes.ComponentFilter

local debug_ = function(methodName, ...)
	if __DEBUG__ then
		-- ROBLOX deviation: simpler print
		print(methodName, ...)
	end
end

type ElementAndRendererID = { id: number, rendererID: number }

type StoreAsGlobalParams = {
	count: number,
	id: number,
	path: Array<string | number>,
	rendererID: number,
}

type CopyElementParams = {
	id: number,
	path: Array<string | number>,
	rendererID: number,
}

type InspectElementParams = {
	id: number,
	path: Array<string | number>?,
	rendererID: number,
}

type OverrideHookParams = {
	id: number,
	hookID: number,
	path: Array<string | number>,
	rendererID: number,
	wasForwarded: boolean?,
	value: any,
}

type SetInParams = {
	id: number,
	path: Array<string | number>,
	rendererID: number,
	wasForwarded: boolean?,
	value: any,
}

-- ROBLOX deviation: Luau can't do literal enumerations: 'props' | 'hooks' | 'state' | 'context';
type PathType = string

type DeletePathParams = {
	type: PathType,
	hookID: number?,
	id: number,
	path: Array<string | number>,
	rendererID: number,
}

type RenamePathParams = {
	type: PathType,
	hookID: number?,
	id: number,
	oldPath: Array<string | number>,
	newPath: Array<string | number>,
	rendererID: number,
}

type OverrideValueAtPathParams = {
	type: PathType,
	hookID: number?,
	id: number,
	path: Array<string | number>,
	rendererID: number,
	value: any,
}

type OverrideSuspenseParams = { id: number, rendererID: number, forceFallback: boolean }

type PersistedSelection = { rendererID: number, path: Array<PathFrame> }

export type Agent = EventEmitter<{
	hideNativeHighlight: Array<any>,
	showNativeHighlight: Array<NativeType>,
	shutdown: any,
	traceUpdates: Set<NativeType>,
}> & {
	_bridge: BackendBridge,
	_isProfiling: boolean,
	_recordChangeDescriptions: boolean,
	_rendererInterfaces: { [RendererID]: RendererInterface },
	_persistedSelection: PersistedSelection | nil,
	_persistedSelectionMatch: PathMatch | nil,
	_traceUpdatesEnabled: boolean,

	getRendererInterfaces: (self: Agent) -> { [RendererID]: RendererInterface },
	copyElementPath: (self: Agent, copyElementParams: CopyElementParams) -> (),
	deletePath: (self: Agent, deletePathParams: DeletePathParams) -> (),
	getInstanceAndStyle: (
		self: Agent,
		elementAndRendererId: ElementAndRendererID
	) -> InstanceAndStyle | nil,
	getIDForNode: (self: Agent, node: Object) -> number | nil,
	getProfilingData: (self: Agent, rendererIdObject: { rendererID: RendererID }) -> (),
	getProfilingStatus: (self: Agent) -> (),
	getOwnersList: (self: Agent, elementAndRendererID: ElementAndRendererID) -> (),
	inspectElement: (self: Agent, inspectElementParams: InspectElementParams) -> (),
	logElementToConsole: (self: Agent, elementAndRendererID: ElementAndRendererID) -> (),
	overrideSuspense: (self: Agent, overrideSuspenseParams: OverrideSuspenseParams) -> (),
	overrideValueAtPath: (
		self: Agent,
		overrideValueAtPathParams: OverrideValueAtPathParams
	) -> (),
	overrideContext: (self: Agent, setInParams: SetInParams) -> (),
	overrideHookState: (self: Agent, overrideHookParams: OverrideHookParams) -> (),
	overrideProps: (self: Agent, setInParams: SetInParams) -> (),
	overrideState: (self: Agent, setInParams: SetInParams) -> (),
	reloadAndProfile: (self: Agent, recordChangeDescriptions: boolean) -> (),
	renamePath: (self: Agent, renamePathParams: RenamePathParams) -> (),
	selectNode: (self: Agent, target: Object) -> (),
	setRendererInterface: (
		self: Agent,
		rendererID: number,
		rendererInterface: RendererInterface
	) -> (),
	setTraceUpdatesEnabled: (self: Agent, traceUpdatesEnabled: boolean) -> (),
	syncSelectionFromNativeElementsPanel: (self: Agent) -> (),
	shutdown: (self: Agent) -> (),
	startProfiling: (self: Agent, recordChangeDescriptions: boolean) -> (),
	stopProfiling: (self: Agent) -> (),
	storeAsGlobal: (self: Agent, storeAsGlobalParams: StoreAsGlobalParams) -> (),
	updateConsolePatchSettings: (
		self: Agent,
		_ref16: { appendComponentStack: boolean, breakOnConsoleErrors: boolean }
	) -> (),
	updateComponentFilters: (self: Agent, componentFilters: Array<ComponentFilter>) -> (),
	viewAttributeSource: (self: Agent, copyElementParams: CopyElementParams) -> (),
	viewElementSource: (self: Agent, elementAndRendererID: ElementAndRendererID) -> (),
	onTraceUpdates: (self: Agent, nodes: Set<NativeType>) -> (),
	onHookOperations: (self: Agent, operations: Array<number>) -> (),
	onUnsupportedRenderer: (self: Agent, rendererID: number) -> (),

	_throttledPersistSelection: (self: Agent, rendererID: number, id: number) -> (),
}

type Agent_Statics = {
	new: (bridge: BackendBridge) -> Agent,
}

local Agent: Agent & Agent_Statics = setmetatable({}, { __index = EventEmitter }) :: any

local AgentMetatable = { __index = Agent }
-- ROBLOX deviation: equivalent of sub-class

function Agent.new(bridge: BackendBridge)
	local self = setmetatable(EventEmitter.new() :: any, AgentMetatable)

	-- ROBLOX deviation: define fields in constructor
	self._bridge = bridge
	self._isProfiling = false
	self._recordChangeDescriptions = false
	self._rendererInterfaces = {}
	self._persistedSelection = nil
	self._persistedSelectionMatch = nil
	self._traceUpdatesEnabled = false

	if sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) == "true" then
		self._recordChangeDescriptions = sessionStorageGetItem(
			SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY
		) == "true"
		self._isProfiling = true

		sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY)
		sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY)
	end

	local persistedSelectionString =
		sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY)

	if persistedSelectionString ~= nil then
		self._persistedSelection = JSON.JSONDecode(persistedSelectionString)
	end

	local function wrapSelf(method: Function)
		return function(...)
			method(self, ...)
		end
	end

	bridge:addListener("copyElementPath", wrapSelf(self.copyElementPath))
	bridge:addListener("deletePath", wrapSelf(self.deletePath))
	bridge:addListener("getProfilingData", wrapSelf(self.getProfilingData))
	bridge:addListener("getProfilingStatus", wrapSelf(self.getProfilingStatus))
	bridge:addListener("getOwnersList", wrapSelf(self.getOwnersList))
	bridge:addListener("inspectElement", wrapSelf(self.inspectElement))
	bridge:addListener("logElementToConsole", wrapSelf(self.logElementToConsole))
	bridge:addListener("overrideSuspense", wrapSelf(self.overrideSuspense))
	bridge:addListener("overrideValueAtPath", wrapSelf(self.overrideValueAtPath))
	bridge:addListener("reloadAndProfile", wrapSelf(self.reloadAndProfile))
	bridge:addListener("renamePath", wrapSelf(self.renamePath))
	bridge:addListener("setTraceUpdatesEnabled", wrapSelf(self.setTraceUpdatesEnabled))
	bridge:addListener("startProfiling", wrapSelf(self.startProfiling))
	bridge:addListener("stopProfiling", wrapSelf(self.stopProfiling))
	bridge:addListener("storeAsGlobal", wrapSelf(self.storeAsGlobal))
	bridge:addListener(
		"syncSelectionFromNativeElementsPanel",
		wrapSelf(self.syncSelectionFromNativeElementsPanel)
	)
	bridge:addListener("shutdown", wrapSelf(self.shutdown))
	bridge:addListener(
		"updateConsolePatchSettings",
		wrapSelf(self.updateConsolePatchSettings)
	)
	bridge:addListener("updateComponentFilters", wrapSelf(self.updateComponentFilters))
	bridge:addListener("viewAttributeSource", wrapSelf(self.viewAttributeSource))
	bridge:addListener("viewElementSource", wrapSelf(self.viewElementSource))

	-- Temporarily support older standalone front-ends sending commands to newer embedded backends.
	-- We do this because React Native embeds the React DevTools backend,
	-- but cannot control which version of the frontend users use.
	bridge:addListener("overrideContext", wrapSelf(self.overrideContext))
	bridge:addListener("overrideHookState", wrapSelf(self.overrideHookState))
	bridge:addListener("overrideProps", wrapSelf(self.overrideProps))
	bridge:addListener("overrideState", wrapSelf(self.overrideState))

	if self._isProfiling then
		bridge:send("profilingStatus", true)
	end

	-- Notify the frontend if the backend supports the Storage API (e.g. localStorage).
	-- If not, features like reload-and-profile will not work correctly and must be disabled.
	-- ROBLOX deviation: Storage is supported, but we don't use localStorage per se
	local isBackendStorageAPISupported = true

	bridge:send("isBackendStorageAPISupported", isBackendStorageAPISupported)
	-- ROBLOX TODO: implement Highlighter stub
	setupHighlighter(bridge, self)
	setupTraceUpdates(self)

	return self
end

-- ROBLOX FIXME: this needs to be a property getter via an __index override
function Agent:getRendererInterfaces()
	return self._rendererInterfaces
end

function Agent:copyElementPath(copyElementParams: CopyElementParams): ()
	local id, path, rendererID =
		copyElementParams.id, copyElementParams.path, copyElementParams.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).copyElementPath(id, path)
	end
end
function Agent:deletePath(deletePathParams: DeletePathParams): ()
	local hookID, id, path, rendererID, type_ =
		deletePathParams.hookID,
		deletePathParams.id,
		deletePathParams.path,
		deletePathParams.rendererID,
		deletePathParams.type
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).deletePath(type_, id, hookID, path)
	end
end
function Agent:getInstanceAndStyle(
	elementAndRendererId: ElementAndRendererID
): InstanceAndStyle | nil
	local id, rendererID = elementAndRendererId.id, elementAndRendererId.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(string.format('Invalid renderer id "%d"', rendererID))
		return nil
	end

	return (renderer :: RendererInterface).getInstanceAndStyle(id)
end

function Agent:getIDForNode(node: Object): number | nil
	for _rendererID, renderer in self._rendererInterfaces do
		local ok, result = pcall(renderer.getFiberIDForNative, node, true)
		if ok and result ~= nil then
			return result
		end
		-- Some old React versions might throw if they can't find a match.
		-- If so we should ignore it...
	end
	return nil
end
function Agent:getProfilingData(rendererIdObject: { rendererID: RendererID }): ()
	local rendererID = rendererIdObject.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(string.format('Invalid renderer id "%d"', rendererID))
	end

	self._bridge:send("profilingData", (renderer :: RendererInterface).getProfilingData())
end
function Agent:getProfilingStatus()
	self._bridge:send("profilingStatus", self._isProfiling)
end
function Agent:getOwnersList(elementAndRendererID: ElementAndRendererID)
	local id, rendererID = elementAndRendererID.id, elementAndRendererID.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		local owners = (renderer :: RendererInterface).getOwnersList(id)

		self._bridge:send("ownersList", {
			id = id,
			owners = owners,
		})
	end
end
function Agent:inspectElement(inspectElementParams: InspectElementParams)
	local id, path, rendererID =
		inspectElementParams.id,
		inspectElementParams.path,
		inspectElementParams.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		self._bridge:send(
			"inspectedElement",
			(renderer :: RendererInterface).inspectElement(id, path)
		)

		-- When user selects an element, stop trying to restore the selection,
		-- and instead remember the current selection for the next reload.
		if
			(self._persistedSelectionMatch :: PathMatch?) == nil
			or (self._persistedSelectionMatch :: PathMatch).id ~= id
		then
			self._persistedSelection = nil
			self._persistedSelectionMatch = nil;

			(renderer :: RendererInterface).setTrackedPath(nil)
			self:_throttledPersistSelection(rendererID, id)
		end

		-- TODO: If there was a way to change the selected DOM element
		-- in native Elements tab without forcing a switch to it, we'd do it here.
		-- For now, it doesn't seem like there is a way to do that:
		-- https://github.com/bvaughn/react-devtools-experimental/issues/102
		-- (Setting $0 doesn't work, and calling inspect() switches the tab.)
	end
end
function Agent:logElementToConsole(elementAndRendererID: ElementAndRendererID)
	local id, rendererID = elementAndRendererID.id, elementAndRendererID.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).logElementToConsole(id)
	end
end
function Agent:overrideSuspense(overrideSuspenseParams: OverrideSuspenseParams)
	local id, rendererID, forceFallback =
		overrideSuspenseParams.id,
		overrideSuspenseParams.rendererID,
		overrideSuspenseParams.forceFallback
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).overrideSuspense(id, forceFallback)
	end
end
function Agent:overrideValueAtPath(overrideValueAtPathParams: OverrideValueAtPathParams)
	local hookID, id, path, rendererID, type_, value =
		overrideValueAtPathParams.hookID,
		overrideValueAtPathParams.id,
		overrideValueAtPathParams.path,
		overrideValueAtPathParams.rendererID,
		overrideValueAtPathParams.type,
		overrideValueAtPathParams.value
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).overrideValueAtPath(
			type_,
			id,
			hookID,
			path,
			value
		)
	end
end

-- Temporarily support older standalone front-ends by forwarding the older message types
-- to the new "overrideValueAtPath" command the backend is now listening to.
function Agent:overrideContext(setInParams: SetInParams)
	local id, path, rendererID, wasForwarded, value =
		setInParams.id,
		setInParams.path,
		setInParams.rendererID,
		setInParams.wasForwarded,
		setInParams.value

	-- Don't forward a message that's already been forwarded by the front-end Bridge.
	-- We only need to process the override command once!
	if not wasForwarded then
		self:overrideValueAtPath({
			id = id,
			path = path,
			rendererID = rendererID,
			type = "context",
			value = value,
		})
	end
end

-- Temporarily support older standalone front-ends by forwarding the older message types
-- to the new "overrideValueAtPath" command the backend is now listening to.
function Agent:overrideHookState(overrideHookParams: OverrideHookParams)
	local id, _hookID, path, rendererID, wasForwarded, value =
		overrideHookParams.id,
		overrideHookParams.hookID,
		overrideHookParams.path,
		overrideHookParams.rendererID,
		overrideHookParams.wasForwarded,
		overrideHookParams.value

	-- Don't forward a message that's already been forwarded by the front-end Bridge.
	-- We only need to process the override command once!
	if not wasForwarded then
		self:overrideValueAtPath({
			id = id,
			path = path,
			rendererID = rendererID,
			type = "hooks",
			value = value,
		})
	end
end

-- Temporarily support older standalone front-ends by forwarding the older message types
-- to the new "overrideValueAtPath" command the backend is now listening to.
function Agent:overrideProps(setInParams: SetInParams)
	local id, path, rendererID, wasForwarded, value =
		setInParams.id,
		setInParams.path,
		setInParams.rendererID,
		setInParams.wasForwarded,
		setInParams.value

	-- Don't forward a message that's already been forwarded by the front-end Bridge.
	-- We only need to process the override command once!
	if not wasForwarded then
		self:overrideValueAtPath({
			id = id,
			path = path,
			rendererID = rendererID,
			type = "props",
			value = value,
		})
	end
end

-- Temporarily support older standalone front-ends by forwarding the older message types
-- to the new "overrideValueAtPath" command the backend is now listening to.
function Agent:overrideState(setInParams: SetInParams)
	local id, path, rendererID, wasForwarded, value =
		setInParams.id,
		setInParams.path,
		setInParams.rendererID,
		setInParams.wasForwarded,
		setInParams.value

	-- Don't forward a message that's already been forwarded by the front-end Bridge.
	-- We only need to process the override command once!
	if not wasForwarded then
		self:overrideValueAtPath({
			id = id,
			path = path,
			rendererID = rendererID,
			type = "state",
			value = value,
		})
	end
end
function Agent:reloadAndProfile(recordChangeDescriptions: boolean)
	sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, "true")
	sessionStorageSetItem(
		SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY,
		(function()
			if recordChangeDescriptions then
				return "true"
			end

			return "false"
		end)()
	)

	-- This code path should only be hit if the shell has explicitly told the Store that it supports profiling.
	-- In that case, the shell must also listen for this specific message to know when it needs to reload the app.
	-- The agent can't do this in a way that is renderer agnostic.
	self._bridge:send("reloadAppForProfiling")
end
function Agent:renamePath(renamePathParams: RenamePathParams)
	local hookID, id, newPath, oldPath, rendererID, type_ =
		renamePathParams.hookID,
		renamePathParams.id,
		renamePathParams.newPath,
		renamePathParams.oldPath,
		renamePathParams.rendererID,
		renamePathParams.type
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).renamePath(type_, id, hookID, oldPath, newPath)
	end
end
function Agent:selectNode(target: Object): ()
	local id = self:getIDForNode(target)

	if id ~= nil then
		self._bridge:send("selectFiber", id)
	end
end
function Agent:setRendererInterface(
	rendererID: number,
	rendererInterface: RendererInterface
)
	self._rendererInterfaces[rendererID] = rendererInterface

	if self._isProfiling then
		rendererInterface.startProfiling(self._recordChangeDescriptions)
	end

	rendererInterface.setTraceUpdatesEnabled(self._traceUpdatesEnabled)

	-- When the renderer is attached, we need to tell it whether
	-- we remember the previous selection that we'd like to restore.
	-- It'll start tracking mounts for matches to the last selection path.
	local selection: PersistedSelection? = self._persistedSelection

	if
		selection ~= nil
		and (selection :: PersistedSelection).rendererID == rendererID
	then
		rendererInterface.setTrackedPath((selection :: PersistedSelection).path)
	end
end
function Agent:setTraceUpdatesEnabled(traceUpdatesEnabled: boolean)
	self._traceUpdatesEnabled = traceUpdatesEnabled

	setTraceUpdatesEnabled(traceUpdatesEnabled)

	for _rendererID, renderer in self._rendererInterfaces do
		renderer.setTraceUpdatesEnabled(traceUpdatesEnabled)
	end
end
function Agent:syncSelectionFromNativeElementsPanel()
	local target = global.__REACT_DEVTOOLS_GLOBAL_HOOK__["$0"]

	if target == nil then
		return
	end

	self:selectNode(target)
end
function Agent:shutdown()
	-- Clean up the overlay if visible, and associated events.
	self:emit("shutdown")
end
function Agent:startProfiling(recordChangeDescriptions: boolean)
	self._recordChangeDescriptions = recordChangeDescriptions
	self._isProfiling = true

	for _rendererID, renderer in self._rendererInterfaces do
		renderer.startProfiling(recordChangeDescriptions)
	end

	self._bridge:send("profilingStatus", self._isProfiling)
end
function Agent:stopProfiling()
	self._isProfiling = false
	self._recordChangeDescriptions = false

	for _rendererID, renderer in self._rendererInterfaces do
		renderer.stopProfiling()
	end

	self._bridge:send("profilingStatus", self._isProfiling)
end

function Agent:storeAsGlobal(storeAsGlobalParams: StoreAsGlobalParams)
	local count, id, path, rendererID =
		storeAsGlobalParams.count,
		storeAsGlobalParams.id,
		storeAsGlobalParams.path,
		storeAsGlobalParams.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).storeAsGlobal(id, path, count)
	end
end

function Agent:updateConsolePatchSettings(_ref16: {
	appendComponentStack: boolean,
	breakOnConsoleErrors: boolean,
})
	local appendComponentStack, breakOnConsoleErrors =
		_ref16.appendComponentStack, _ref16.breakOnConsoleErrors

	-- If the frontend preference has change,
	-- or in the case of React Native- if the backend is just finding out the preference-
	-- then install or uninstall the console overrides.
	-- It's safe to call these methods multiple times, so we don't need to worry about that.
	if appendComponentStack or breakOnConsoleErrors then
		patchConsole({
			appendComponentStack = appendComponentStack,
			breakOnConsoleErrors = breakOnConsoleErrors,
		})
	else
		unpatchConsole()
	end
end
function Agent:updateComponentFilters(componentFilters: Array<ComponentFilter>)
	for _rendererID, renderer in self._rendererInterfaces do
		renderer.updateComponentFilters(componentFilters)
	end
end
function Agent:viewAttributeSource(copyElementParams: CopyElementParams)
	local id, path, rendererID =
		copyElementParams.id, copyElementParams.path, copyElementParams.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).prepareViewAttributeSource(id, path)
	end
end
function Agent:viewElementSource(elementAndRendererID: ElementAndRendererID)
	local id, rendererID = elementAndRendererID.id, elementAndRendererID.rendererID
	local renderer = self._rendererInterfaces[rendererID]

	if renderer == nil then
		console.warn(
			string.format('Invalid renderer id "%d" for element "%d"', rendererID, id)
		)
	else
		(renderer :: RendererInterface).prepareViewElementSource(id)
	end
end
function Agent:onTraceUpdates(nodes: Set<NativeType>)
	self:emit("traceUpdates", nodes)
end
function Agent:onHookOperations(operations: Array<number>)
	if global.__DEBUG__ then
		debug_("onHookOperations", operations)
	end

	-- TODO:
	-- The chrome.runtime does not currently support transferables; it forces JSON serialization.
	-- See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134
	--
	-- Regarding transferables, the postMessage doc states:
	-- If the ownership of an object is transferred, it becomes unusable (neutered)
	-- in the context it was sent from and becomes available only to the worker it was sent to.
	--
	-- Even though Chrome is eventually JSON serializing the array buffer,
	-- using the transferable approach also sometimes causes it to throw:
	--   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.
	--
	-- See bug https://github.com/bvaughn/react-devtools-experimental/issues/25
	--
	-- The Store has a fallback in place that parses the message as JSON if the type isn't an array.
	-- For now the simplest fix seems to be to not transfer the array.
	-- This will negatively impact performance on Firefox so it's unfortunate,
	-- but until we're able to fix the Chrome error mentioned above, it seems necessary.
	--
	self._bridge:send("operations", operations)

	if self._persistedSelection ~= nil then
		local rendererID = operations[1]

		if (self._persistedSelection :: PersistedSelection).rendererID == rendererID then
			-- Check if we can select a deeper match for the persisted selection.
			local renderer = self._rendererInterfaces[rendererID]

			if renderer == nil then
				console.warn(string.format('Invalid renderer id "%d"', rendererID))
			else
				local prevMatch = self._persistedSelectionMatch
				local nextMatch = (renderer :: RendererInterface).getBestMatchForTrackedPath()

				self._persistedSelectionMatch = nextMatch

				local prevMatchID = if prevMatch ~= nil then prevMatch.id else nil
				local nextMatchID = if nextMatch ~= nil then nextMatch.id else nil

				if prevMatchID ~= nextMatchID then
					if nextMatchID ~= nil then
						-- We moved forward, unlocking a deeper node.
						self._bridge:send("selectFiber", nextMatchID)
					end
				end
				if nextMatch ~= nil and (nextMatch :: PathMatch).isFullMatch then
					-- We've just unlocked the innermost selected node.
					-- There's no point tracking it further.
					self._persistedSelection = nil
					self._persistedSelectionMatch = nil;

					(renderer :: RendererInterface).setTrackedPath(nil)
				end
			end
		end
	end
end

function Agent:onUnsupportedRenderer(rendererID: number)
	self._bridge:send("unsupportedRendererVersion", rendererID)
end

Agent._throttledPersistSelection = throttle(function(self, rendererID: number, id: number)
	-- This is throttled, so both renderer and selected ID
	-- might not be available by the time we read them.
	-- This is why we need the defensive checks here.
	local renderer = self._rendererInterfaces[rendererID]
	local path = (function()
		if renderer ~= nil then
			return (renderer :: RendererInterface).getPathForElement(id)
		end

		return nil
	end)()

	if path ~= nil then
		sessionStorageSetItem(
			SESSION_STORAGE_LAST_SELECTION_KEY,
			JSON:JSONEncode({
				rendererID = rendererID,
				path = path,
			})
		)
	else
		sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY)
	end
end, 1000)

return Agent ]]
bC.Children._857bd571625c556c8cd51c97441dca0c=bJ
local bK

local bL={ClassName="ModuleScript",Children={},Properties={}}
bL.Name="console"
bL.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/console.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Types = require(script.Parent.types)
type ReactRenderer = Types.ReactRenderer

local exports = {}

-- ROBLOX FIXME: Stub for now
function exports.patch(_object: {
	appendComponentStack: boolean,
	breakOnConsoleErrors: boolean,
}): () end

function exports.unpatch(): () end

function exports.error(...)
	error(...)
end

function exports.warn(...)
	warn(...)
end

function exports.log(...)
	print(...)
end

function exports.registerRenderer(_renderer: ReactRenderer): () end

return exports ]]
bC.Children._449464d528a4b375c119dbbc3b8a1f93=bL
local bM

local bN={ClassName="ModuleScript",Children={},Properties={}}
bN.Name="renderer"
bN.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/renderer.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Shared = require(Packages.Shared)
local console = Shared.console
local Map = LuauPolyfill.Map
local Set = LuauPolyfill.Set
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
local Number = LuauPolyfill.Number
local String = LuauPolyfill.String
type Symbol = any

type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Set<T> = LuauPolyfill.Set<T>
type Object = LuauPolyfill.Object

-- ROBLOX deviation: Use _G as a catch all for global for now
-- ROBLOX TODO: Work out a better capability-based solution
local window = _G
local exports = {}

local invariant = require(Packages.Shared).invariant

-- ROBLOX deviation: we don't currently need semver, as we only support one version of React
-- local semver = require(semver)
-- local gte = semver.gte
local types = require(script.Parent.Parent.types)
local ComponentFilterDisplayName = types.ComponentFilterDisplayName
local ComponentFilterElementType = types.ComponentFilterElementType
local ComponentFilterHOC = types.ComponentFilterHOC
local ComponentFilterLocation = types.ComponentFilterLocation
local ElementTypeClass = types.ElementTypeClass
local ElementTypeContext = types.ElementTypeContext
local ElementTypeFunction = types.ElementTypeFunction
local ElementTypeForwardRef = types.ElementTypeForwardRef
local ElementTypeHostComponent = types.ElementTypeHostComponent
local ElementTypeMemo = types.ElementTypeMemo
local ElementTypeOtherOrUnknown = types.ElementTypeOtherOrUnknown
local ElementTypeProfiler = types.ElementTypeProfiler
local ElementTypeRoot = types.ElementTypeRoot
local ElementTypeSuspense = types.ElementTypeSuspense
local ElementTypeSuspenseList = types.ElementTypeSuspenseList
local utils = require(script.Parent.Parent.utils)
local deletePathInObject = utils.deletePathInObject
local getDisplayName = utils.getDisplayName
local getDefaultComponentFilters = utils.getDefaultComponentFilters
local getInObject = utils.getInObject
local getUID = utils.getUID
local renamePathInObject = utils.renamePathInObject
local setInObject = utils.setInObject
-- ROBLOX deviation: Don't encode strings
-- local utfEncodeString = utils.utfEncodeString
local storage = require(script.Parent.Parent.storage)
local sessionStorageGetItem = storage.sessionStorageGetItem
local backendUtils = require(script.Parent.utils)
local cleanForBridge = backendUtils.cleanForBridge
local copyToClipboard = backendUtils.copyToClipboard
local copyWithDelete = backendUtils.copyWithDelete
local copyWithRename = backendUtils.copyWithRename
local copyWithSet = backendUtils.copyWithSet
local constants = require(script.Parent.Parent.constants)
local __DEBUG__ = constants.__DEBUG__
local SESSION_STORAGE_RELOAD_AND_PROFILE_KEY =
	constants.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY
local SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY =
	constants.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY
local TREE_OPERATION_ADD = constants.TREE_OPERATION_ADD
local TREE_OPERATION_REMOVE = constants.TREE_OPERATION_REMOVE
local TREE_OPERATION_REORDER_CHILDREN = constants.TREE_OPERATION_REORDER_CHILDREN
local TREE_OPERATION_UPDATE_TREE_BASE_DURATION =
	constants.TREE_OPERATION_UPDATE_TREE_BASE_DURATION
local ReactDebugTools = require(Packages.ReactDebugTools)
local inspectHooksOfFiber = ReactDebugTools.inspectHooksOfFiber
local Console = require(script.Parent.console)
local patchConsole = Console.patch
local registerRendererWithConsole = Console.registerRenderer
local ReactSymbols = require(script.Parent.ReactSymbols)
local CONCURRENT_MODE_NUMBER = ReactSymbols.CONCURRENT_MODE_NUMBER
local CONCURRENT_MODE_SYMBOL_STRING = ReactSymbols.CONCURRENT_MODE_SYMBOL_STRING
local DEPRECATED_ASYNC_MODE_SYMBOL_STRING =
	ReactSymbols.DEPRECATED_ASYNC_MODE_SYMBOL_STRING
local PROVIDER_NUMBER = ReactSymbols.PROVIDER_NUMBER
local PROVIDER_SYMBOL_STRING = ReactSymbols.PROVIDER_SYMBOL_STRING
local CONTEXT_NUMBER = ReactSymbols.CONTEXT_NUMBER
local CONTEXT_SYMBOL_STRING = ReactSymbols.CONTEXT_SYMBOL_STRING
local STRICT_MODE_NUMBER = ReactSymbols.STRICT_MODE_NUMBER
local STRICT_MODE_SYMBOL_STRING = ReactSymbols.STRICT_MODE_SYMBOL_STRING
local PROFILER_NUMBER = ReactSymbols.PROFILER_NUMBER
local PROFILER_SYMBOL_STRING = ReactSymbols.PROFILER_SYMBOL_STRING
local SCOPE_NUMBER = ReactSymbols.SCOPE_NUMBER
local SCOPE_SYMBOL_STRING = ReactSymbols.SCOPE_SYMBOL_STRING
local FORWARD_REF_NUMBER = ReactSymbols.FORWARD_REF_NUMBER
local FORWARD_REF_SYMBOL_STRING = ReactSymbols.FORWARD_REF_SYMBOL_STRING
local MEMO_NUMBER = ReactSymbols.MEMO_NUMBER
local MEMO_SYMBOL_STRING = ReactSymbols.MEMO_SYMBOL_STRING
local is = Shared.objectIs
-- ROBLOX FIXME: pass in a real host config, or make this able to use basic enums without initializing
local ReactReconciler = require(Packages.ReactReconciler)({})

-- ROBLOX deviation: Require shared functionality rather than copying and pasting it inline
local getNearestMountedFiber = ReactReconciler.getNearestMountedFiber

-- ROBLOX deviation: ReactInternalTypes is re-exported from top-level reconciler to respect the module encapsulation boundary
local ReactInternalTypes = require(Packages.ReactReconciler)
type Fiber = ReactInternalTypes.Fiber
local BackendTypes = require(script.Parent.types)
type ChangeDescription = BackendTypes.ChangeDescription
type CommitDataBackend = BackendTypes.CommitDataBackend
type DevToolsHook = BackendTypes.DevToolsHook
type InspectedElement = BackendTypes.InspectedElement
type InspectedElementPayload = BackendTypes.InspectedElementPayload
type InstanceAndStyle = BackendTypes.InstanceAndStyle
type NativeType = BackendTypes.NativeType
type Owner = BackendTypes.Owner
type PathFrame = BackendTypes.PathFrame
type PathMatch = BackendTypes.PathMatch
type ProfilingDataBackend = BackendTypes.ProfilingDataBackend
type ProfilingDataForRootBackend = BackendTypes.ProfilingDataForRootBackend
type ReactRenderer = BackendTypes.ReactRenderer
type RendererInterface = BackendTypes.RendererInterface
type WorkTagMap = BackendTypes.WorkTagMap

local ProfilerTypes = require(script.Parent.Parent.devtools.views.Profiler.types)
type Interaction = ProfilerTypes.Interaction
local TypesModules = require(script.Parent.Parent.types)
type ComponentFilter = TypesModules.ComponentFilter
type ElementType = TypesModules.ElementType

type RegExpComponentFilter = TypesModules.RegExpComponentFilter
type ElementTypeComponentFilter = TypesModules.ElementTypeComponentFilter

type getDisplayNameForFiberType = (fiber: Fiber) -> string | nil
type getTypeSymbolType = (type: any) -> Symbol | number

type ReactPriorityLevelsType = {
	ImmediatePriority: number,
	UserBlockingPriority: number,
	NormalPriority: number,
	LowPriority: number,
	IdlePriority: number,
	NoPriority: number,
}

type ReactTypeOfSideEffectType = {
	NoFlags: number,
	PerformedWork: number,
	Placement: number,
}

local function getFiberFlags(fiber: Fiber): number
	-- The name of this field changed from "effectTag" to "flags"
	if fiber.flags ~= nil then
		return fiber.flags
	else
		return (fiber :: any).effectTag
	end
end

local getCurrentTime = function()
	-- ROBLOX deviation: use os.clock not performance
	return os.clock()
end

exports.getInternalReactConstants = function(version: string): {
	getDisplayNameForFiber: getDisplayNameForFiberType,
	getTypeSymbol: getTypeSymbolType,
	ReactPriorityLevels: ReactPriorityLevelsType,
	ReactTypeOfSideEffect: ReactTypeOfSideEffectType,
	ReactTypeOfWork: WorkTagMap,
}
	local ReactTypeOfSideEffect = {
		NoFlags = 0,
		PerformedWork = 1,
		Placement = 2,
	}

	-- **********************************************************
	-- The section below is copied from files in React repo.
	-- Keep it in sync, and add version guards if it changes.
	--
	-- Technically these priority levels are invalid for versions before 16.9,
	-- but 16.9 is the first version to report priority level to DevTools,
	-- so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.
	local ReactPriorityLevels = {
		ImmediatePriority = 99,
		UserBlockingPriority = 98,
		NormalPriority = 97,
		LowPriority = 96,
		IdlePriority = 95,
		NoPriority = 90,
	}

	-- ROBLOX deviation: we don't need to support older versions
	-- if gte(version, '17.0.0-alpha') then
	local ReactTypeOfWork: WorkTagMap = {
		Block = 22,
		ClassComponent = 1,
		ContextConsumer = 9,
		ContextProvider = 10,
		CoroutineComponent = -1,
		CoroutineHandlerPhase = -1,
		DehydratedSuspenseComponent = 18,
		ForwardRef = 11,
		Fragment = 7,
		FunctionComponent = 0,
		HostComponent = 5,
		HostPortal = 4,
		HostRoot = 3,
		HostText = 6,
		IncompleteClassComponent = 17,
		IndeterminateComponent = 2,
		LazyComponent = 16,
		MemoComponent = 14,
		Mode = 8,
		OffscreenComponent = 23,
		Profiler = 12,
		SimpleMemoComponent = 15,
		SuspenseComponent = 13,
		SuspenseListComponent = 19,
		YieldComponent = -1,
	}
	-- elseif gte(version, '16.6.0-beta.0') then
	--     ReactTypeOfWork = {
	--         Block = 22,
	--         ClassComponent = 1,
	--         ContextConsumer = 9,
	--         ContextProvider = 10,
	--         CoroutineComponent = -1,
	--         CoroutineHandlerPhase = -1,
	--         DehydratedSuspenseComponent = 18,
	--         ForwardRef = 11,
	--         Fragment = 7,
	--         FunctionComponent = 0,
	--         HostComponent = 5,
	--         HostPortal = 4,
	--         HostRoot = 3,
	--         HostText = 6,
	--         IncompleteClassComponent = 17,
	--         IndeterminateComponent = 2,
	--         LazyComponent = 16,
	--         MemoComponent = 14,
	--         Mode = 8,
	--         OffscreenComponent = -1,
	--         Profiler = 12,
	--         SimpleMemoComponent = 15,
	--         SuspenseComponent = 13,
	--         SuspenseListComponent = 19,
	--         YieldComponent = -1,
	--     }
	-- elseif gte(version, '16.4.3-alpha') then
	--     ReactTypeOfWork = {
	--         Block = -1,
	--         ClassComponent = 2,
	--         ContextConsumer = 11,
	--         ContextProvider = 12,
	--         CoroutineComponent = -1,
	--         CoroutineHandlerPhase = -1,
	--         DehydratedSuspenseComponent = -1,
	--         ForwardRef = 13,
	--         Fragment = 9,
	--         FunctionComponent = 0,
	--         HostComponent = 7,
	--         HostPortal = 6,
	--         HostRoot = 5,
	--         HostText = 8,
	--         IncompleteClassComponent = -1,
	--         IndeterminateComponent = 4,
	--         LazyComponent = -1,
	--         MemoComponent = -1,
	--         Mode = 10,
	--         OffscreenComponent = -1,
	--         Profiler = 15,
	--         SimpleMemoComponent = -1,
	--         SuspenseComponent = 16,
	--         SuspenseListComponent = -1,
	--         YieldComponent = -1,
	--     }
	-- else
	--     ReactTypeOfWork = {
	--         Block = -1,
	--         ClassComponent = 2,
	--         ContextConsumer = 12,
	--         ContextProvider = 13,
	--         CoroutineComponent = 7,
	--         CoroutineHandlerPhase = 8,
	--         DehydratedSuspenseComponent = -1,
	--         ForwardRef = 14,
	--         Fragment = 10,
	--         FunctionComponent = 1,
	--         HostComponent = 5,
	--         HostPortal = 4,
	--         HostRoot = 3,
	--         HostText = 6,
	--         IncompleteClassComponent = -1,
	--         IndeterminateComponent = 0,
	--         LazyComponent = -1,
	--         MemoComponent = -1,
	--         Mode = 11,
	--         OffscreenComponent = -1,
	--         Profiler = 15,
	--         SimpleMemoComponent = -1,
	--         SuspenseComponent = 16,
	--         SuspenseListComponent = -1,
	--         YieldComponent = 9,
	--     }
	-- end

	-- 	// **********************************************************
	--    // End of copied code.
	--    // **********************************************************

	local function getTypeSymbol(type_: any): Symbol | number
		local symbolOrNumber = if typeof(type_) == "table"
			then type_["$$typeof"]
			else type_

		-- ROBLOX deviation: symbol is not a native Luau type
		return if typeof(symbolOrNumber) == "table"
			then tostring(symbolOrNumber)
			else symbolOrNumber
	end

	local ClassComponent, IncompleteClassComponent, FunctionComponent, IndeterminateComponent, ForwardRef, HostRoot, HostComponent, HostPortal, HostText, Fragment, MemoComponent, SimpleMemoComponent, SuspenseComponent, SuspenseListComponent =
		ReactTypeOfWork.ClassComponent,
		ReactTypeOfWork.IncompleteClassComponent,
		ReactTypeOfWork.FunctionComponent,
		ReactTypeOfWork.IndeterminateComponent,
		ReactTypeOfWork.ForwardRef,
		ReactTypeOfWork.HostRoot,
		ReactTypeOfWork.HostComponent,
		ReactTypeOfWork.HostPortal,
		ReactTypeOfWork.HostText,
		ReactTypeOfWork.Fragment,
		ReactTypeOfWork.MemoComponent,
		ReactTypeOfWork.SimpleMemoComponent,
		ReactTypeOfWork.SuspenseComponent,
		ReactTypeOfWork.SuspenseListComponent

	local function resolveFiberType(type_: any)
		local typeSymbol = getTypeSymbol(type_)
		if typeSymbol == MEMO_NUMBER or typeSymbol == MEMO_SYMBOL_STRING then
			-- recursively resolving memo type in case of memo(forwardRef(Component))
			return resolveFiberType(type_.type)
		elseif
			typeSymbol == FORWARD_REF_NUMBER
			or typeSymbol == FORWARD_REF_SYMBOL_STRING
		then
			return type_.render
		else
			return type_
		end
	end

	-- NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods
	local function getDisplayNameForFiber(fiber: Fiber): string | nil
		local type_, tag = fiber.type, fiber.tag
		local resolvedType = type_

		if typeof(type_) == "table" and type_ ~= nil then
			resolvedType = resolveFiberType(type_)
		end

		local resolvedContext = nil
		if tag == ClassComponent or tag == IncompleteClassComponent then
			return getDisplayName(resolvedType)
		elseif tag == FunctionComponent or tag == IndeterminateComponent then
			return getDisplayName(resolvedType)
		elseif tag == ForwardRef then
			-- Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37
			return (type_ and type_.displayName)
				or getDisplayName(resolvedType, "Anonymous")
		elseif tag == HostRoot then
			return nil
		elseif tag == HostComponent then
			return type_
		elseif tag == HostPortal or tag == HostText or tag == Fragment then
			return nil
		elseif tag == MemoComponent or tag == SimpleMemoComponent then
			return getDisplayName(resolvedType, "Anonymous")
		elseif tag == SuspenseComponent then
			return "Suspense"
		elseif tag == SuspenseListComponent then
			return "SuspenseList"
		else
			local typeSymbol = getTypeSymbol(type_)
			if
				typeSymbol == CONCURRENT_MODE_NUMBER
				or typeSymbol == CONCURRENT_MODE_SYMBOL_STRING
				or typeSymbol == DEPRECATED_ASYNC_MODE_SYMBOL_STRING
			then
				return nil
			elseif
				typeSymbol == PROVIDER_NUMBER or typeSymbol == PROVIDER_SYMBOL_STRING
			then
				-- 16.3.0 exposed the context object as "context"
				-- PR #12501 changed it to "_context" for 16.3.1+
				-- NOTE Keep in sync with inspectElementRaw()
				resolvedContext = fiber.type._context or fiber.type.context
				return string.format(
					"%s.Provider",
					resolvedContext.displayName or "Context"
				)
			elseif
				typeSymbol == CONTEXT_NUMBER or typeSymbol == CONTEXT_SYMBOL_STRING
			then
				-- 16.3-16.5 read from "type" because the Consumer is the actual context object.
				-- 16.6+ should read from "type._context" because Consumer can be different (in DEV).
				-- NOTE Keep in sync with inspectElementRaw()
				resolvedContext = fiber.type._context or fiber.type

				-- NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'
				-- If you change the name, figure out a more resilient way to detect it.
				return string.format(
					"%s.Consumer",
					resolvedContext.displayName or "Context"
				)
			elseif
				typeSymbol == STRICT_MODE_NUMBER
				or typeSymbol == STRICT_MODE_SYMBOL_STRING
			then
				return nil
			elseif
				typeSymbol == PROFILER_NUMBER or typeSymbol == PROFILER_SYMBOL_STRING
			then
				return string.format("Profiler(%s)", fiber.memoizedProps.id)
			elseif typeSymbol == SCOPE_NUMBER or typeSymbol == SCOPE_SYMBOL_STRING then
				return "Scope"
			else
				-- Unknown element type.
				-- This may mean a new element type that has not yet been added to DevTools.
				return nil
			end
		end
	end

	return {
		getDisplayNameForFiber = getDisplayNameForFiber,
		getTypeSymbol = getTypeSymbol,
		ReactPriorityLevels = ReactPriorityLevels,
		ReactTypeOfWork = ReactTypeOfWork,
		ReactTypeOfSideEffect = ReactTypeOfSideEffect,
	}
end

exports.attach = function(
	hook: DevToolsHook,
	rendererID: number,
	renderer: ReactRenderer,
	global: Object
): RendererInterface
	-- ROBLOX deviation: these definitions have been hoisted to top of function for earlier use
	local fiberToIDMap: Map<Fiber, number> = Map.new() :: Map<Fiber, number>
	local idToFiberMap: Map<number, Fiber> = Map.new() :: Map<number, Fiber>
	local primaryFibers: Set<Fiber> = Set.new() :: Set<Fiber>

	-- When profiling is supported, we store the latest tree base durations for each Fiber.
	-- This is so that we can quickly capture a snapshot of those values if profiling starts.
	-- If we didn't store these values, we'd have to crawl the tree when profiling started,
	-- and use a slow path to find each of the current Fibers.
	local idToTreeBaseDurationMap: Map<number, number> = Map.new() :: Map<number, number>

	-- When profiling is supported, we store the latest tree base durations for each Fiber.
	-- This map enables us to filter these times by root when sending them to the frontend.
	local idToRootMap: Map<number, number> = Map.new() :: Map<number, number>

	-- When a mount or update is in progress, this value tracks the root that is being operated on.
	local currentRootID: number = -1

	local function getFiberID(primaryFiber: Fiber)
		if not fiberToIDMap:has(primaryFiber) then
			local id = getUID()
			fiberToIDMap:set(primaryFiber, id)
			idToFiberMap:set(id, primaryFiber)
		end

		return (fiberToIDMap:get(primaryFiber) :: any) :: number
	end

	local _getInternalReactCons = exports.getInternalReactConstants(renderer.version)
	local getDisplayNameForFiber, getTypeSymbol, ReactPriorityLevels, ReactTypeOfWork, ReactTypeOfSideEffect =
		_getInternalReactCons.getDisplayNameForFiber,
		_getInternalReactCons.getTypeSymbol,
		_getInternalReactCons.ReactPriorityLevels,
		_getInternalReactCons.ReactTypeOfWork,
		_getInternalReactCons.ReactTypeOfSideEffect
	local PerformedWork = ReactTypeOfSideEffect.PerformedWork
	local FunctionComponent, ClassComponent, ContextConsumer, DehydratedSuspenseComponent, Fragment, ForwardRef, HostRoot, HostPortal, HostComponent, HostText, IncompleteClassComponent, IndeterminateComponent, MemoComponent, OffscreenComponent, SimpleMemoComponent, SuspenseComponent, SuspenseListComponent =
		ReactTypeOfWork.FunctionComponent,
		ReactTypeOfWork.ClassComponent,
		ReactTypeOfWork.ContextConsumer,
		ReactTypeOfWork.DehydratedSuspenseComponent,
		ReactTypeOfWork.Fragment,
		ReactTypeOfWork.ForwardRef,
		ReactTypeOfWork.HostRoot,
		ReactTypeOfWork.HostPortal,
		ReactTypeOfWork.HostComponent,
		ReactTypeOfWork.HostText,
		ReactTypeOfWork.IncompleteClassComponent,
		ReactTypeOfWork.IndeterminateComponent,
		ReactTypeOfWork.MemoComponent,
		ReactTypeOfWork.OffscreenComponent,
		ReactTypeOfWork.SimpleMemoComponent,
		ReactTypeOfWork.SuspenseComponent,
		ReactTypeOfWork.SuspenseListComponent
	local ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority =
		ReactPriorityLevels.ImmediatePriority,
		ReactPriorityLevels.UserBlockingPriority,
		ReactPriorityLevels.NormalPriority,
		ReactPriorityLevels.LowPriority,
		ReactPriorityLevels.IdlePriority

	-- ROBLOX deviation: these need binding to self
	local overrideHookState = function(...)
		return renderer.overrideHookState(...)
	end
	local overrideHookStateDeletePath = function(...)
		return renderer.overrideHookStateDeletePath(...)
	end
	local overrideHookStateRenamePath = function(...)
		return renderer.overrideHookStateRenamePath(...)
	end
	local overrideProps = function(...)
		return renderer.overrideProps(...)
	end
	local overridePropsDeletePath = function(...)
		return renderer.overridePropsDeletePath(...)
	end
	local overridePropsRenamePath = function(...)
		return renderer.overridePropsRenamePath(...)
	end
	local setSuspenseHandler = function(...)
		return renderer.setSuspenseHandler(...)
	end
	local scheduleUpdate = function(...)
		return renderer.scheduleUpdate(...)
	end

	local supportsTogglingSuspense = typeof(setSuspenseHandler) == "function"
		and typeof(scheduleUpdate) == "function"

	-- Patching the console enables DevTools to do a few useful things:
	-- * Append component stacks to warnings and error messages
	-- * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
	--
	-- Don't patch in test environments because we don't want to interfere with Jest's own console overrides.
	-- ROBLOX deviation: instead of checking if `process.env.NODE_ENV ~= "production"`
	-- we use the __DEV__ global
	if _G.__DEV__ then
		registerRendererWithConsole(renderer)

		-- The renderer interface can't read these preferences directly,
		-- because it is stored in localStorage within the context of the extension.
		-- It relies on the extension to pass the preference through via the global.
		local appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__
			~= false
		local breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__
			== true

		if appendComponentStack or breakOnConsoleErrors then
			patchConsole({
				appendComponentStack = appendComponentStack,
				breakOnConsoleErrors = breakOnConsoleErrors,
			})
		end
	end

	local debug_ = function(name: string, fiber: Fiber, parentFiber: Fiber?): ()
		if __DEBUG__ then
			-- ROBLOX deviation: Use string nil rather than null as it is Roblox convenion
			local displayName = getDisplayNameForFiber(fiber) or "nil"
			local id = getFiberID(fiber)
			local parentDisplayName = if parentFiber ~= nil
				then getDisplayNameForFiber(parentFiber :: Fiber)
				else "nil"
			local parentID = if parentFiber then getFiberID(parentFiber :: Fiber) else ""
			-- NOTE: calling getFiberID or getPrimaryFiber is unsafe here
			-- because it will put them in the map. For now, we'll omit them.
			-- TODO: better debugging story for this.
			-- ROBLOX deviation: avoid incompatible log formatting
			console.log(
				string.format(
					"[renderer] %s %s (%d) %s",
					name,
					displayName,
					id,
					if parentFiber
						then string.format(
							"%s (%s)",
							tostring(parentDisplayName),
							tostring(parentID)
						)
						else ""
				)
			)
		end
	end

	-- Configurable Components tree filters.
	-- ROBLOX deviation: adjusted to use Lua patterns, but we may actually want original RegExp
	local hideElementsWithDisplayNames: Set<string> = Set.new()
	local hideElementsWithPaths: Set<string> = Set.new()
	local hideElementsWithTypes: Set<ElementType> = Set.new()

	-- ROBLOX deviation: local variables need to be defined above their use in closures
	-- Roots don't have a real persistent identity.
	-- A root's "pseudo key" is "childDisplayName:indexWithThatName".
	-- For example, "App:0" or, in case of similar roots, "Story:0", "Story:1", etc.
	-- We will use this to try to disambiguate roots when restoring selection between reloads.
	local rootPseudoKeys: Map<number, string> = Map.new()
	local rootDisplayNameCounter: Map<string, number> = Map.new()

	-- ROBLOX deviation: definitions hoisted earlier in function
	local currentCommitProfilingMetadata: CommitProfilingData | nil = nil
	local displayNamesByRootID: DisplayNamesByRootID | nil = nil
	local idToContextsMap: Map<number, any> | nil = nil
	local initialTreeBaseDurationsMap: Map<number, number> | nil = nil
	local initialIDToRootMap: Map<number, number> | nil = nil
	local isProfiling: boolean = false
	local profilingStartTime: number = 0
	local recordChangeDescriptions: boolean = false
	local rootToCommitProfilingMetadataMap: CommitProfilingMetadataMap | nil = nil

	local mostRecentlyInspectedElement: InspectedElement | nil = nil
	local hasElementUpdatedSinceLastInspected: boolean = false
	local currentlyInspectedPaths: Object = {}

	local forceFallbackForSuspenseIDs = Set.new()

	-- Highlight updates
	local traceUpdatesEnabled: boolean = false
	local traceUpdatesForNodes: Set<NativeType> = Set.new()

	-- ROBLOX deviation: hoise local variables
	-- Remember if we're trying to restore the selection after reload.
	-- In that case, we'll do some extra checks for matching mounts.
	local trackedPath: Array<PathFrame> | nil = nil
	local trackedPathMatchFiber: Fiber | nil = nil
	local trackedPathMatchDepth = -1
	local mightBeOnTrackedPath = false

	-- ROBLOX deviation: hoist function variables
	local getChangedKeys: (prev: any, next_: any) -> nil | Array<string>
	local mountFiberRecursively: (
		fiber: Fiber,
		parentFiber: Fiber | nil,
		traverseSiblings: boolean,
		traceNearestHostComponentUpdate: boolean
	) -> ()
	local findAllCurrentHostFibers: (id: number) -> Array<Fiber>
	local setTrackedPath: (path: Array<PathFrame> | nil) -> ()
	local getPrimaryFiber, unmountFiberChildrenRecursively, recordUnmount, setRootPseudoKey, removeRootPseudoKey, flushPendingEvents, getElementTypeForFiber, getContextChangedKeys, didHooksChange, getContextsForFiber, getDisplayNameForRoot, recordProfilingDurations, updateTrackedPathStateBeforeMount, updateTrackedPathStateAfterMount, findReorderedChildrenRecursively, findCurrentFiberUsingSlowPathById, isMostRecentlyInspectedElementCurrent, getPathFrame

	local function applyComponentFilters(componentFilters: Array<ComponentFilter>)
		hideElementsWithTypes:clear()
		hideElementsWithDisplayNames:clear()
		hideElementsWithPaths:clear()
		-- ROBLOX TODO: translate to Array.forEach
		for _, componentFilter in componentFilters do
			if not componentFilter.isEnabled then
				continue
			end
			if componentFilter.type == ComponentFilterDisplayName then
				-- ROBLOX deviation: use value directly as pattern rather than creating a RegExp
				hideElementsWithDisplayNames:add(
					(componentFilter :: RegExpComponentFilter).value
				)
			elseif componentFilter.type == ComponentFilterElementType then
				hideElementsWithTypes:add(
					(componentFilter :: ElementTypeComponentFilter).value
				)
			elseif componentFilter.type == ComponentFilterLocation then
				if
					(componentFilter :: RegExpComponentFilter).isValid
					and (componentFilter :: RegExpComponentFilter).value ~= ""
				then
					-- ROBLOX deviation: use value directly as pattern rather than creating a RegExp
					hideElementsWithPaths:add(
						(componentFilter :: RegExpComponentFilter).value
					)
				end
			elseif componentFilter.type == ComponentFilterHOC then
				hideElementsWithDisplayNames:add("%(")
			else
				console.warn(
					string.format(
						'Invalid component filter type "%d"',
						componentFilter.type
					)
				)
			end
		end
	end

	-- The renderer interface can't read saved component filters directly,
	-- because they are stored in localStorage within the context of the extension.
	-- Instead it relies on the extension to pass filters through.
	if window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ ~= nil then
		applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__)
	else
		-- Unfortunately this feature is not expected to work for React Native for now.
		-- It would be annoying for us to spam YellowBox warnings with unactionable stuff,
		-- so for now just skip this message...
		--console.warn('⚛️ DevTools: Could not locate saved component filters');

		-- Fallback to assuming the default filters in this case.
		applyComponentFilters(getDefaultComponentFilters())
	end

	-- If necessary, we can revisit optimizing this operation.
	-- For example, we could add a new recursive unmount tree operation.
	-- The unmount operations are already significantly smaller than mount operations though.
	-- This is something to keep in mind for later.
	local function updateComponentFilters(componentFilters: Array<ComponentFilter>)
		if isProfiling then
			-- Re-mounting a tree while profiling is in progress might break a lot of assumptions.
			-- If necessary, we could support this- but it doesn't seem like a necessary use case.
			error("Cannot modify filter preferences while profiling")
		end

		hook.getFiberRoots(rendererID):forEach(function(root)
			currentRootID = getFiberID(getPrimaryFiber(root.current))
			unmountFiberChildrenRecursively(root.current)
			recordUnmount(root.current, false)
			currentRootID = -1
		end)

		applyComponentFilters(componentFilters)

		-- Reset pseudo counters so that new path selections will be persisted.
		rootDisplayNameCounter:clear()

		-- Recursively re-mount all roots with new filter criteria applied.
		hook.getFiberRoots(rendererID):forEach(function(root)
			currentRootID = getFiberID(getPrimaryFiber(root.current :: Fiber))

			setRootPseudoKey(currentRootID, root.current :: Fiber)
			mountFiberRecursively(root.current :: Fiber, nil, false, false)
			flushPendingEvents(root)

			currentRootID = -1
		end)
	end

	-- NOTICE Keep in sync with get*ForFiber methods
	local function shouldFilterFiber(fiber: Fiber): boolean
		local _debugSource, tag, type_ = fiber._debugSource, fiber.tag, fiber.type

		if tag == DehydratedSuspenseComponent then
			-- TODO: ideally we would show dehydrated Suspense immediately.
			-- However, it has some special behavior (like disconnecting
			-- an alternate and turning into real Suspense) which breaks DevTools.
			-- For now, ignore it, and only show it once it gets hydrated.
			-- https://github.com/bvaughn/react-devtools-experimental/issues/197
			return true
		elseif
			tag == HostPortal
			or tag == HostText
			or tag == Fragment
			or tag == OffscreenComponent
		then
			return true
		elseif tag == HostRoot then
			-- It is never valid to filter the root element.
			return false
		else
			local typeSymbol = getTypeSymbol(type_)
			if
				typeSymbol == CONCURRENT_MODE_NUMBER
				or typeSymbol == CONCURRENT_MODE_SYMBOL_STRING
				or typeSymbol == DEPRECATED_ASYNC_MODE_SYMBOL_STRING
				or typeSymbol == STRICT_MODE_NUMBER
				or typeSymbol == STRICT_MODE_SYMBOL_STRING
			then
				return true
			end
		end

		local elementType = getElementTypeForFiber(fiber)

		if hideElementsWithTypes:has(elementType) then
			return true
		end
		if hideElementsWithDisplayNames.size > 0 then
			local displayName = getDisplayNameForFiber(fiber)
			if displayName ~= nil then
				-- eslint-disable-next-line no-for-of-loops/no-for-of-loops
				for _, displayNameRegExp in hideElementsWithDisplayNames do
					-- ROBLOX deviation: these are patterns not RegExps
					if string.match(displayName :: string, displayNameRegExp) then
						return true
					end
				end
			end
		end
		if _debugSource ~= nil and hideElementsWithPaths.size > 0 then
			local fileName = _debugSource.fileName

			-- eslint-disable-next-line no-for-of-loops/no-for-of-loops
			for _, pathRegExp in hideElementsWithPaths do
				-- ROBLOX deviation: these are patterns not RegExps
				if string.match(fileName, pathRegExp) then
					return true
				end
			end
		end

		return false
	end

	-- NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods
	getElementTypeForFiber = function(fiber: Fiber): ElementType
		local type_, tag = fiber.type, fiber.tag

		if tag == ClassComponent or tag == IncompleteClassComponent then
			return ElementTypeClass
		elseif tag == FunctionComponent or tag == IndeterminateComponent then
			return ElementTypeFunction
		elseif tag == ForwardRef then
			return ElementTypeForwardRef
		elseif tag == HostRoot then
			return ElementTypeRoot
		elseif tag == HostComponent then
			return ElementTypeHostComponent
		elseif tag == HostPortal or tag == HostText or tag == Fragment then
			return ElementTypeOtherOrUnknown
		elseif tag == MemoComponent or tag == SimpleMemoComponent then
			return ElementTypeMemo
		elseif tag == SuspenseComponent then
			return ElementTypeSuspense
		elseif tag == SuspenseListComponent then
			return ElementTypeSuspenseList
		else
			local typeSymbol = getTypeSymbol(type_)
			if
				typeSymbol == CONCURRENT_MODE_NUMBER
				or typeSymbol == CONCURRENT_MODE_SYMBOL_STRING
				or typeSymbol == DEPRECATED_ASYNC_MODE_SYMBOL_STRING
			then
				return ElementTypeContext
			elseif
				typeSymbol == PROVIDER_NUMBER or typeSymbol == PROVIDER_SYMBOL_STRING
			then
				return ElementTypeContext
			elseif
				typeSymbol == CONTEXT_NUMBER or typeSymbol == CONTEXT_SYMBOL_STRING
			then
				return ElementTypeContext
			elseif
				typeSymbol == STRICT_MODE_NUMBER
				or typeSymbol == STRICT_MODE_SYMBOL_STRING
			then
				return ElementTypeOtherOrUnknown
			elseif
				typeSymbol == PROFILER_NUMBER or typeSymbol == PROFILER_SYMBOL_STRING
			then
				return ElementTypeProfiler
			else
				return ElementTypeOtherOrUnknown
			end
		end
	end

	-- This is a slightly annoying indirection.
	-- It is currently necessary because DevTools wants to use unique objects as keys for instances.
	-- However fibers have two versions.
	-- We use this set to remember first encountered fiber for each conceptual instance.
	getPrimaryFiber = function(fiber: Fiber): Fiber
		if primaryFibers:has(fiber) then
			return fiber
		end

		local alternate = fiber.alternate

		if alternate ~= nil and primaryFibers:has(alternate) then
			return alternate :: Fiber
		end

		primaryFibers:add(fiber)

		return fiber
	end

	local function getChangeDescription(
		prevFiber: Fiber | nil,
		nextFiber: Fiber
	): ChangeDescription | nil
		local fiberType = getElementTypeForFiber(nextFiber)
		if
			fiberType == ElementTypeClass
			or fiberType == ElementTypeFunction
			or fiberType == ElementTypeMemo
			or fiberType == ElementTypeForwardRef
			-- ROBLOX deviation: Include host components in the report
			or fiberType == ElementTypeHostComponent
		then
			if prevFiber == nil then
				return {
					context = nil,
					didHooksChange = false,
					isFirstMount = true,
					props = nil,
					state = nil,
				}
			else
				return {
					context = getContextChangedKeys(nextFiber),
					didHooksChange = didHooksChange(
						(prevFiber :: Fiber).memoizedState,
						nextFiber.memoizedState
					),
					isFirstMount = false,
					props = getChangedKeys(
						(prevFiber :: Fiber).memoizedProps,
						nextFiber.memoizedProps
					),
					state = getChangedKeys(
						(prevFiber :: Fiber).memoizedState,
						nextFiber.memoizedState
					),
				}
			end
		else
			return nil
		end
	end

	local function updateContextsForFiber(fiber: Fiber)
		if getElementTypeForFiber(fiber) == ElementTypeClass then
			if idToContextsMap ~= nil then
				local id = getFiberID(getPrimaryFiber(fiber))
				local contexts = getContextsForFiber(fiber)
				if contexts ~= nil then
					idToContextsMap:set(id, contexts)
				end
			end
		end
	end

	-- Differentiates between a null context value and no context.
	local NO_CONTEXT = {}

	-- ROBLOX deviation: Luau can't express return type: [Object, any]
	getContextsForFiber = function(fiber: Fiber): Array<any> | nil
		if getElementTypeForFiber(fiber) == ElementTypeClass then
			local instance = fiber.stateNode
			local legacyContext = NO_CONTEXT
			local modernContext = NO_CONTEXT
			if instance ~= nil then
				if instance.constructor and instance.constructor.contextType ~= nil then
					modernContext = instance.context
				else
					legacyContext = instance.context
					if legacyContext and #Object.keys(legacyContext) == 0 then
						legacyContext = NO_CONTEXT
					end
				end
			end
			return { legacyContext, modernContext }
		end
		return nil
	end

	-- Record all contexts at the time profiling is started.
	-- Fibers only store the current context value,
	-- so we need to track them separately in order to determine changed keys.
	local function crawlToInitializeContextsMap(fiber: Fiber)
		updateContextsForFiber(fiber)
		local current = fiber.child
		while current ~= nil do
			crawlToInitializeContextsMap(current :: Fiber)
			current = (current :: Fiber).sibling
		end
	end

	getContextChangedKeys = function(fiber: Fiber): nil | boolean | Array<string>
		if getElementTypeForFiber(fiber) == ElementTypeClass then
			if idToContextsMap ~= nil then
				local id = getFiberID(getPrimaryFiber(fiber))
				-- ROBLOX TODO? optimize this pattern into just the get
				local prevContexts = if idToContextsMap:has(id)
					then idToContextsMap:get(id)
					else nil
				local nextContexts = getContextsForFiber(fiber)

				if prevContexts == nil or nextContexts == nil then
					return nil
				end

				local prevLegacyContext, prevModernContext =
					prevContexts[1], prevContexts[2]
				local nextLegacyContext, nextModernContext =
					(nextContexts :: Array<any>)[1], (nextContexts :: Array<any>)[2]

				if nextLegacyContext ~= NO_CONTEXT then
					return getChangedKeys(prevLegacyContext, nextLegacyContext)
				elseif nextModernContext ~= NO_CONTEXT then
					return prevModernContext ~= nextModernContext
				end
			end
		end
		return nil
	end
	local function getHighestIndex(array: Array<any>)
		local highestIndex = 0
		for k, v in array do
			highestIndex = if k > highestIndex then k else highestIndex
		end
		return highestIndex
	end
	local function areHookInputsEqual(nextDeps: Array<any>, prevDeps_: Array<any>?)
		if prevDeps_ == nil then
			return false
		end
		local prevDeps = prevDeps_ :: Array<any>

		local prevDepLength = getHighestIndex(prevDeps)
		local nextDepLength = getHighestIndex(nextDeps)

		if prevDepLength ~= nextDepLength then
			return false
		end

		for i = 1, prevDepLength do
			if not is(nextDeps[i], prevDeps[i]) then
				return false
			end
		end
		return true
	end

	local function isEffect(memoizedState)
		return memoizedState ~= nil
			and typeof(memoizedState) == "table"
			and memoizedState.tag ~= nil
			and memoizedState.create ~= nil
			and memoizedState.destroy ~= nil
			and memoizedState.deps ~= nil
			and (memoizedState.deps == nil or Array.isArray(memoizedState.deps))
			and memoizedState.next
	end

	local function didHookChange(prev: any, next: any): boolean
		local prevMemoizedState = prev.memoizedState
		local nextMemoizedState = next.memoizedState

		if isEffect(prevMemoizedState) and isEffect(nextMemoizedState) then
			return prevMemoizedState ~= nextMemoizedState
				and not areHookInputsEqual(nextMemoizedState.deps, prevMemoizedState.deps)
		end
		return nextMemoizedState ~= prevMemoizedState
	end
	didHooksChange = function(prev: any, next_: any): boolean
		if prev == nil or next_ == nil then
			return false
		end
		-- We can't report anything meaningful for hooks changes.
		-- ROBLOX deviation: hasOwnProperty doesn't exist
		if
			next_["baseState"]
			and next_["memoizedState"]
			and next_["next"]
			and next_["queue"]
		then
			while next_ ~= nil do
				-- ROBLOX deviation START: use didHookChange instead of equality check
				if didHookChange(prev, next_) then
					-- ROBLOX deviation END
					return true
				else
					next_ = next_.next
					prev = prev.next
				end
			end
		end

		return false
	end
	getChangedKeys = function(prev: any, next_: any): nil | Array<string>
		if prev == nil or next_ == nil then
			return nil
		end
		-- We can't report anything meaningful for hooks changes.
		-- ROBLOX deviation: hasOwnProperty doesn't exist
		if
			next_["baseState"] ~= nil
			and next_["memoizedState"] ~= nil
			and next_["next"] ~= nil
			and next_["queue"] ~= nil
		then
			return nil
		end

		local keys = Set.new(Array.concat(Object.keys(prev), Object.keys(next_)))
		local changedKeys = {}
		-- -- eslint-disable-next-line no-for-of-loops/no-for-of-loops
		for _, key in keys do
			if prev[key] ~= next_[key] then
				table.insert(changedKeys, key)
			end
		end

		return changedKeys
	end

	-- eslint-disable-next-line no-unused-vars
	local function didFiberRender(prevFiber: Fiber, nextFiber: Fiber): boolean
		local tag = nextFiber.tag
		if
			tag == ClassComponent
			or tag == FunctionComponent
			or tag == ContextConsumer
			or tag == MemoComponent
			or tag == SimpleMemoComponent
		then
			-- For types that execute user code, we check PerformedWork effect.
			-- We don't reflect bailouts (either referential or sCU) in DevTools.
			-- eslint-disable-next-line no-bitwise
			return bit32.band(getFiberFlags(nextFiber), PerformedWork) == PerformedWork
		else
			-- Note: ContextConsumer only gets PerformedWork effect in 16.3.3+
			-- so it won't get highlighted with React 16.3.0 to 16.3.2.
			-- For host components and other types, we compare inputs
			-- to determine whether something is an update.
			return prevFiber.memoizedProps ~= nextFiber.memoizedProps
				or prevFiber.memoizedState ~= nextFiber.memoizedState
				or prevFiber.ref ~= nextFiber.ref
		end
	end

	local pendingOperations: Array<number> = {}
	local pendingRealUnmountedIDs: Array<number> = {}
	local pendingSimulatedUnmountedIDs: Array<number> = {}
	local pendingOperationsQueue: Array<Array<number>> | nil = {}
	local pendingStringTable: Map<string, number> = Map.new()
	local pendingStringTableLength: number = 0
	local pendingUnmountedRootID: number | nil = nil

	local function pushOperation(op: number): ()
		-- ROBLOX deviation: Use global
		if global.__DEV__ then
			if not Number.isInteger(op) then
				console.error(
					"pushOperation() was called but the value is not an integer.",
					op
				)
			end
		end
		table.insert(pendingOperations, op)
	end
	flushPendingEvents = function(root: Object): ()
		if
			#pendingOperations == 0
			and #pendingRealUnmountedIDs == 0
			and #pendingSimulatedUnmountedIDs == 0
			and pendingUnmountedRootID == nil
		then
			-- If we aren't profiling, we can just bail out here.
			-- No use sending an empty update over the bridge.
			--
			-- The Profiler stores metadata for each commit and reconstructs the app tree per commit using:
			-- (1) an initial tree snapshot and
			-- (2) the operations array for each commit
			-- Because of this, it's important that the operations and metadata arrays align,
			-- So it's important not to omit even empty operations while profiling is active.
			if not isProfiling then
				return
			end
		end

		local numUnmountIDs = #pendingRealUnmountedIDs
			+ #pendingSimulatedUnmountedIDs
			+ (if pendingUnmountedRootID == nil then 0 else 1)
		local operations: Array<string | number> = {}
		-- ROBLOX deviation: don't create an array of specified length
		-- Identify which renderer this update is coming from.
		-- 2 -- [rendererID, rootFiberID]
		-- 				-- How big is the string table?
		-- 				+ 1 -- [stringTableLength]
		-- 				-- Then goes the actual string table.
		-- 				+ pendingStringTableLength
		-- 				-- All unmounts are batched in a single message.
		-- 				-- [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
		-- 				+ numUnmountIDs
		-- 			> 0
		-- 		and (2 + numUnmountIDs)
		-- 	or 0
		-- 		-- Regular operations
		-- 		+ #pendingOperations

		-- Identify which renderer this update is coming from.
		-- This enables roots to be mapped to renderers,
		-- Which in turn enables fiber props, states, and hooks to be inspected.
		local i = 1

		-- ROBLOX deviation: instead of i++
		local function POSTFIX_INCREMENT()
			local prevI = i
			i += 1
			return prevI
		end

		operations[POSTFIX_INCREMENT()] = rendererID
		operations[POSTFIX_INCREMENT()] = currentRootID -- Use this ID in case the root was unmounted!

		-- Now fill in the string table.
		-- [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]
		-- ROBLOX deviation: [stringCount, str1, str2, ...]
		operations[POSTFIX_INCREMENT()] = pendingStringTableLength

		-- ROBLOX deviation: insert operations in pendingStringTable value-order
		local stringTableStartIndex = #operations

		pendingStringTable:forEach(function(value, key)
			-- ROBLOX deviation: Don't encode strings
			-- operations[POSTFIX_INCREMENT()] = #key
			-- local encodedKey = utfEncodeString(key)
			-- for j = 1, #encodedKey do
			-- 	operations[i + j] = encodedKey[j]
			-- end
			-- i = i + #key
			operations[stringTableStartIndex + value] = key

			-- ROBLOX deviation: ensure increment is still called
			POSTFIX_INCREMENT()
		end)

		if numUnmountIDs > 0 then
			-- All unmounts except roots are batched in a single message.
			operations[POSTFIX_INCREMENT()] = TREE_OPERATION_REMOVE :: number
			-- The first number is how many unmounted IDs we're gonna send.
			operations[POSTFIX_INCREMENT()] = numUnmountIDs :: number

			-- Fill in the real unmounts in the reverse order.
			-- They were inserted parents-first by React, but we want children-first.
			-- So we traverse our array backwards.
			for j = #pendingRealUnmountedIDs, 1, -1 do
				operations[POSTFIX_INCREMENT()] = pendingRealUnmountedIDs[j] :: number
			end

			-- Fill in the simulated unmounts (hidden Suspense subtrees) in their order.
			-- (We want children to go before parents.)
			-- They go *after* the real unmounts because we know for sure they won't be
			-- children of already pushed "real" IDs. If they were, we wouldn't be able
			-- to discover them during the traversal, as they would have been deleted.
			for j = 1, #pendingSimulatedUnmountedIDs do
				operations[i + j - 1] = pendingSimulatedUnmountedIDs[j] :: number
			end

			i = i + #pendingSimulatedUnmountedIDs

			-- The root ID should always be unmounted last.
			if pendingUnmountedRootID ~= nil then
				operations[i] = pendingUnmountedRootID :: number
				i = i + 1
			end
		end

		-- Fill in the rest of the operations.
		for j = 1, #pendingOperations do
			-- ROBLOX deviation: 1-indexing math
			operations[i + j - 1] = pendingOperations[j] :: number
		end

		i = i + #pendingOperations

		-- Let the frontend know about tree operations.
		-- The first value in this array will identify which root it corresponds to,
		-- so we do no longer need to dispatch a separate root-committed event.
		if pendingOperationsQueue ~= nil then
			-- Until the frontend has been connected, store the tree operations.
			-- This will let us avoid walking the tree later when the frontend connects,
			-- and it enables the Profiler's reload-and-profile functionality to work as well.
			table.insert(pendingOperationsQueue :: Array<any>, operations)
		else
			-- If we've already connected to the frontend, just pass the operations through.
			hook.emit("operations", operations)
		end

		-- ROBLOX deviation: replace table instead of truncating it
		pendingOperations = {}
		pendingRealUnmountedIDs = {}
		pendingSimulatedUnmountedIDs = {}
		pendingUnmountedRootID = nil
		pendingStringTable:clear()
		pendingStringTableLength = 0
	end

	local function getStringID(str: string | nil): number
		if str == nil or str == "" then
			return 0
		end

		-- ROBLOX FIXME Luau: needs type states to not need manual cast
		local existingID = pendingStringTable:get(str :: string)

		if existingID ~= nil then
			return existingID
		end

		local stringID = pendingStringTable.size + 1

		-- ROBLOX FIXME Luau: needs type states to not need cast
		pendingStringTable:set(str :: string, stringID)
		-- The string table total length needs to account
		-- both for the string length, and for the array item
		-- that contains the length itself. Hence + 1.
		-- ROBLOX deviation: Don't encode strings, so just count one for the single string entry
		-- pendingStringTableLength = pendingStringTableLength + (#str + 1)
		pendingStringTableLength += 1
		return stringID
	end

	local function recordMount(fiber: Fiber, parentFiber: Fiber | nil)
		-- ROBLOX deviation: use global
		if global.__DEBUG__ then
			debug_("recordMount()", fiber, parentFiber)
		end

		local isRoot = fiber.tag == HostRoot
		local id = getFiberID(getPrimaryFiber(fiber))
		local hasOwnerMetadata = fiber["_debugOwner"] ~= nil
		local isProfilingSupported = fiber["treeBaseDuration"] ~= nil

		if isRoot then
			pushOperation(TREE_OPERATION_ADD)
			pushOperation(id)
			pushOperation(ElementTypeRoot)
			pushOperation(if isProfilingSupported then 1 else 0)
			pushOperation(if hasOwnerMetadata then 1 else 0)

			if isProfiling then
				if displayNamesByRootID ~= nil then
					(displayNamesByRootID :: Map<number, string>):set(
						id,
						getDisplayNameForRoot(fiber)
					)
				end
			end
		else
			local key = fiber.key
			local displayName = getDisplayNameForFiber(fiber)
			local elementType = getElementTypeForFiber(fiber)
			local _debugOwner = fiber._debugOwner
			local ownerID = if _debugOwner ~= nil
				then getFiberID(getPrimaryFiber(_debugOwner :: Fiber))
				else 0
			local parentID = if Boolean.toJSBoolean(parentFiber)
				then getFiberID(getPrimaryFiber(parentFiber :: Fiber))
				else 0

			local displayNameStringID = getStringID(displayName)

			-- This check is a guard to handle a React element that has been modified
			-- in such a way as to bypass the default stringification of the "key" property.
			local keyString = if key == nil then nil else tostring(key)
			local keyStringID = getStringID(keyString)

			pushOperation(TREE_OPERATION_ADD)
			pushOperation(id)
			pushOperation(elementType)
			pushOperation(parentID)
			pushOperation(ownerID)
			pushOperation(displayNameStringID)
			pushOperation(keyStringID)
		end
		if isProfilingSupported then
			idToRootMap:set(id, currentRootID)
			recordProfilingDurations(fiber)
		end
	end
	recordUnmount = function(fiber: Fiber, isSimulated: boolean)
		-- ROBLOX deviation: use global
		if global.__DEBUG__ then
			debug_("recordUnmount()", fiber)
		end

		if trackedPathMatchFiber ~= nil then
			-- We're in the process of trying to restore previous selection.
			-- If this fiber matched but is being unmounted, there's no use trying.
			-- Reset the state so we don't keep holding onto it.
			if
				fiber == trackedPathMatchFiber
				or fiber == (trackedPathMatchFiber :: Fiber).alternate
			then
				setTrackedPath(nil)
			end
		end

		local isRoot = fiber.tag == HostRoot
		local primaryFiber = getPrimaryFiber(fiber)
		if not fiberToIDMap:has(primaryFiber) then
			-- If we've never seen this Fiber, it might be because
			-- it is inside a non-current Suspense fragment tree,
			-- and so the store is not even aware of it.
			-- In that case we can just ignore it, or otherwise
			-- there will be errors later on.
			primaryFibers:delete(primaryFiber)
			-- TODO: this is fragile and can obscure actual bugs.
			return
		end

		local id = getFiberID(primaryFiber)

		if isRoot then
			-- Roots must be removed only after all children (pending and simulated) have been removed.
			-- So we track it separately.
			pendingUnmountedRootID = id
		elseif not shouldFilterFiber(fiber) then
			-- To maintain child-first ordering,
			-- we'll push it into one of these queues,
			-- and later arrange them in the correct order.
			if isSimulated then
				table.insert(pendingSimulatedUnmountedIDs, id)
			else
				table.insert(pendingRealUnmountedIDs, id)
			end
		end

		fiberToIDMap:delete(primaryFiber)
		idToFiberMap:delete(id)
		primaryFibers:delete(primaryFiber)

		-- ROBLOX deviation: hasOwnProperty doesn't exist
		local isProfilingSupported = fiber["treeBaseDuration"] ~= nil

		if isProfilingSupported then
			idToRootMap:delete(id)
			idToTreeBaseDurationMap:delete(id)
		end
	end
	mountFiberRecursively = function(
		fiber: Fiber,
		parentFiber: Fiber | nil,
		traverseSiblings: boolean,
		traceNearestHostComponentUpdate: boolean
	): ()
		if __DEBUG__ then
			debug_("mountFiberRecursively()", fiber, parentFiber)
		end

		-- If we have the tree selection from previous reload, try to match this Fiber.
		-- Also remember whether to do the same for siblings.
		local mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber)
		local shouldIncludeInTree = not shouldFilterFiber(fiber)

		if shouldIncludeInTree then
			recordMount(fiber, parentFiber)
		end
		if traceUpdatesEnabled then
			if traceNearestHostComponentUpdate then
				local elementType = getElementTypeForFiber(fiber)
				-- If an ancestor updated, we should mark the nearest host nodes for highlighting.
				if elementType == ElementTypeHostComponent then
					traceUpdatesForNodes:add(fiber.stateNode)

					traceNearestHostComponentUpdate = false
				end
			end

			-- We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,
			-- because we don't want to highlight every host node inside of a newly mounted subtree.
		end

		local isSuspense = fiber.tag == ReactTypeOfWork.SuspenseComponent

		if isSuspense then
			local isTimedOut = fiber.memoizedState ~= nil

			if isTimedOut then
				-- Special case: if Suspense mounts in a timed-out state,
				-- get the fallback child from the inner fragment and mount
				-- it as if it was our own child. Updates handle this too.
				local primaryChildFragment = fiber.child
				local fallbackChildFragment = if primaryChildFragment
					then primaryChildFragment.sibling
					else nil
				local fallbackChild = if fallbackChildFragment
					then fallbackChildFragment.child
					else nil

				if fallbackChild ~= nil then
					mountFiberRecursively(
						fallbackChild,
						if shouldIncludeInTree then fiber else parentFiber,
						true,
						traceNearestHostComponentUpdate
					)
				end
			else
				local primaryChild = nil
				local areSuspenseChildrenConditionallyWrapped = OffscreenComponent == -1

				if areSuspenseChildrenConditionallyWrapped then
					primaryChild = fiber.child
				elseif fiber.child ~= nil then
					primaryChild = (fiber.child :: Fiber).child
				end
				if primaryChild ~= nil then
					mountFiberRecursively(
						primaryChild,
						if shouldIncludeInTree then fiber else parentFiber,
						true,
						traceNearestHostComponentUpdate
					)
				end
			end
		else
			if fiber.child ~= nil then
				mountFiberRecursively(
					fiber.child,
					if shouldIncludeInTree then fiber else parentFiber,
					true,
					traceNearestHostComponentUpdate
				)
			end
		end

		-- We're exiting this Fiber now, and entering its siblings.
		-- If we have selection to restore, we might need to re-activate tracking.
		updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath)

		if traverseSiblings and fiber.sibling ~= nil then
			mountFiberRecursively(
				fiber.sibling,
				parentFiber :: Fiber,
				true,
				traceNearestHostComponentUpdate
			)
		end
	end

	-- We use this to simulate unmounting for Suspense trees
	-- when we switch from primary to fallback.
	unmountFiberChildrenRecursively = function(fiber: Fiber)
		-- ROBLOX deviation: use global
		if global.__DEBUG__ then
			debug_("unmountFiberChildrenRecursively()", fiber)
		end

		-- We might meet a nested Suspense on our way.
		local isTimedOutSuspense = fiber.tag == ReactTypeOfWork.SuspenseComponent
			and fiber.memoizedState ~= nil
		local child = fiber.child

		if isTimedOutSuspense then
			-- If it's showing fallback tree, let's traverse it instead.
			local primaryChildFragment = fiber.child
			local fallbackChildFragment = if primaryChildFragment
				then primaryChildFragment.sibling
				else nil

			-- Skip over to the real Fiber child.
			child = if fallbackChildFragment then fallbackChildFragment.child else nil
		end

		while child ~= nil do
			-- Record simulated unmounts children-first.
			-- We skip nodes without return because those are real unmounts.
			if (child :: Fiber).return_ ~= nil then
				unmountFiberChildrenRecursively(child :: Fiber)
				recordUnmount(child :: Fiber, true)
			end

			child = (child :: Fiber).sibling
		end
	end
	recordProfilingDurations = function(fiber: Fiber)
		local id = getFiberID(getPrimaryFiber(fiber))
		local actualDuration, treeBaseDuration =
			fiber.actualDuration, fiber.treeBaseDuration

		idToTreeBaseDurationMap:set(id, treeBaseDuration or 0)

		if isProfiling then
			local alternate = fiber.alternate

			-- It's important to update treeBaseDuration even if the current Fiber did not render,
			-- because it's possible that one of its descendants did.
			if
				alternate == nil
				or treeBaseDuration ~= (alternate :: Fiber).treeBaseDuration
			then
				local convertedTreeBaseDuration =
					math.floor((treeBaseDuration or 0) * 1000)

				pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION)
				pushOperation(id)
				pushOperation(convertedTreeBaseDuration)
			end
			if alternate == nil or didFiberRender(alternate :: Fiber, fiber) then
				if actualDuration ~= nil then
					-- The actual duration reported by React includes time spent working on children.
					-- This is useful information, but it's also useful to be able to exclude child durations.
					-- The frontend can't compute this, since the immediate children may have been filtered out.
					-- So we need to do this on the backend.
					-- Note that this calculated self duration is not the same thing as the base duration.
					-- The two are calculated differently (tree duration does not accumulate).
					local selfDuration = actualDuration :: number
					local child = fiber.child

					while child ~= nil do
						selfDuration = selfDuration
							- ((child :: Fiber).actualDuration or 0)
						child = (child :: Fiber).sibling
					end

					-- If profiling is active, store durations for elements that were rendered during the commit.
					-- Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.
					-- In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)
					-- In other cases (e.g. Memo) actualDuration might be greater than 0 even if we "bailed out".
					local metadata = currentCommitProfilingMetadata :: CommitProfilingData
					table.insert(metadata.durations, id)
					table.insert(metadata.durations, actualDuration :: number)
					table.insert(metadata.durations, selfDuration)
					metadata.maxActualDuration =
						math.max(metadata.maxActualDuration, actualDuration :: number)

					if recordChangeDescriptions then
						local changeDescription = getChangeDescription(alternate, fiber)
						if changeDescription ~= nil then
							if metadata.changeDescriptions ~= nil then
								(
									metadata.changeDescriptions :: Map<
										number,
										ChangeDescription
									>
								):set(id, changeDescription :: ChangeDescription)
							end
						end

						updateContextsForFiber(fiber)
					end
				end
			end
		end
	end
	local function recordResetChildren(fiber: Fiber, childSet: Fiber)
		-- The frontend only really cares about the displayName, key, and children.
		-- The first two don't really change, so we are only concerned with the order of children here.
		-- This is trickier than a simple comparison though, since certain types of fibers are filtered.
		local nextChildren: Array<number> = {}

		-- This is a naive implementation that shallowly recourses children.
		-- We might want to revisit this if it proves to be too inefficient.
		local child: Fiber? = childSet

		while child ~= nil do
			findReorderedChildrenRecursively(child :: Fiber, nextChildren)

			child = (child :: Fiber).sibling
		end

		local numChildren = #nextChildren

		if numChildren < 2 then
			-- No need to reorder.
			return
		end

		pushOperation(TREE_OPERATION_REORDER_CHILDREN)
		pushOperation(getFiberID(getPrimaryFiber(fiber)))
		pushOperation(numChildren)

		for i = 1, #nextChildren do
			pushOperation(nextChildren[i])
		end
	end

	findReorderedChildrenRecursively = function(fiber: Fiber, nextChildren: Array<number>)
		if not shouldFilterFiber(fiber) then
			table.insert(nextChildren, getFiberID(getPrimaryFiber(fiber)))
		else
			local child = fiber.child
			while child ~= nil do
				findReorderedChildrenRecursively(child, nextChildren)
				child = (child :: Fiber).sibling
			end
		end
	end

	-- Returns whether closest unfiltered fiber parent needs to reset its child list.
	local function updateFiberRecursively(
		nextFiber: Fiber,
		prevFiber: Fiber,
		parentFiber: Fiber | nil,
		traceNearestHostComponentUpdate: boolean
	): boolean
		-- ROBLOX deviation: use global
		if global.__DEBUG__ then
			debug_("updateFiberRecursively()", nextFiber, parentFiber)
		end
		if traceUpdatesEnabled then
			local elementType = getElementTypeForFiber(nextFiber)

			if traceNearestHostComponentUpdate then
				-- If an ancestor updated, we should mark the nearest host nodes for highlighting.
				if elementType == ElementTypeHostComponent then
					traceUpdatesForNodes:add(nextFiber.stateNode)

					traceNearestHostComponentUpdate = false
				end
			else
				if
					elementType == ElementTypeFunction
					or elementType == ElementTypeClass
					or elementType == ElementTypeContext
				then
					-- Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).
					traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber)
				end
			end
		end
		if
			mostRecentlyInspectedElement ~= nil
			and (mostRecentlyInspectedElement :: InspectedElement).id == getFiberID(
				getPrimaryFiber(nextFiber)
			)
			and didFiberRender(prevFiber, nextFiber)
		then
			-- If this Fiber has updated, clear cached inspected data.
			-- If it is inspected again, it may need to be re-run to obtain updated hooks values.
			hasElementUpdatedSinceLastInspected = true
		end

		local shouldIncludeInTree = not shouldFilterFiber(nextFiber)
		local isSuspense = nextFiber.tag == SuspenseComponent
		local shouldResetChildren = false
		-- The behavior of timed-out Suspense trees is unique.
		-- Rather than unmount the timed out content (and possibly lose important state),
		-- React re-parents this content within a hidden Fragment while the fallback is showing.
		-- This behavior doesn't need to be observable in the DevTools though.
		-- It might even result in a bad user experience for e.g. node selection in the Elements panel.
		-- The easiest fix is to strip out the intermediate Fragment fibers,
		-- so the Elements panel and Profiler don't need to special case them.
		-- Suspense components only have a non-null memoizedState if they're timed-out.
		local prevDidTimeout = isSuspense and prevFiber.memoizedState ~= nil
		local nextDidTimeOut = isSuspense and nextFiber.memoizedState ~= nil

		-- The logic below is inspired by the code paths in updateSuspenseComponent()
		-- inside ReactFiberBeginWork in the React source code.
		if prevDidTimeout and nextDidTimeOut then
			-- Fallback -> Fallback:
			-- 1. Reconcile fallback set.
			local nextFiberChild = nextFiber.child
			local nextFallbackChildSet = if nextFiberChild
				then nextFiberChild.sibling
				else nil
			-- Note: We can't use nextFiber.child.sibling.alternate
			-- because the set is special and alternate may not exist.
			local prevFiberChild = prevFiber.child
			local prevFallbackChildSet = if prevFiberChild
				then prevFiberChild.sibling
				else nil

			if
				nextFallbackChildSet ~= nil
				and prevFallbackChildSet ~= nil
				and updateFiberRecursively(
					nextFallbackChildSet :: Fiber,
					prevFallbackChildSet :: Fiber,
					nextFiber :: Fiber,
					traceNearestHostComponentUpdate
				)
			then
				shouldResetChildren = true
			end
		elseif prevDidTimeout and not nextDidTimeOut then
			-- Fallback -> Primary:
			-- 1. Unmount fallback set
			-- Note: don't emulate fallback unmount because React actually did it.
			-- 2. Mount primary set
			local nextPrimaryChildSet = nextFiber.child

			if nextPrimaryChildSet ~= nil then
				mountFiberRecursively(
					nextPrimaryChildSet :: Fiber,
					nextFiber :: Fiber,
					true,
					traceNearestHostComponentUpdate
				)
			end

			shouldResetChildren = true
		elseif not prevDidTimeout and nextDidTimeOut then
			-- Primary -> Fallback:
			-- 1. Hide primary set
			-- This is not a real unmount, so it won't get reported by React.
			-- We need to manually walk the previous tree and record unmounts.
			unmountFiberChildrenRecursively(prevFiber)

			-- 2. Mount fallback set
			local nextFiberChild = nextFiber.child
			local nextFallbackChildSet = if nextFiberChild
				then nextFiberChild.sibling
				else nil

			if nextFallbackChildSet ~= nil then
				mountFiberRecursively(
					nextFallbackChildSet,
					nextFiber,
					true,
					traceNearestHostComponentUpdate
				)

				shouldResetChildren = true
			end
		else
			-- Common case: Primary -> Primary.
			-- This is the same code path as for non-Suspense fibers.
			if nextFiber.child ~= prevFiber.child then
				-- If the first child is different, we need to traverse them.
				-- Each next child will be either a new child (mount) or an alternate (update).
				local nextChild: Fiber? = nextFiber.child
				local prevChildAtSameIndex = prevFiber.child

				while nextChild do
					-- We already know children will be referentially different because
					-- they are either new mounts or alternates of previous children.
					-- Schedule updates and mounts depending on whether alternates exist.
					-- We don't track deletions here because they are reported separately.
					if (nextChild :: Fiber).alternate then
						local prevChild = (nextChild :: Fiber).alternate

						if
							updateFiberRecursively(
								nextChild :: Fiber,
								prevChild :: Fiber,
								if shouldIncludeInTree
									then nextFiber
									else parentFiber :: Fiber,
								traceNearestHostComponentUpdate
							)
						then
							-- If a nested tree child order changed but it can't handle its own
							-- child order invalidation (e.g. because it's filtered out like host nodes),
							-- propagate the need to reset child order upwards to this Fiber.
							shouldResetChildren = true
						end
						-- However we also keep track if the order of the children matches
						-- the previous order. They are always different referentially, but
						-- if the instances line up conceptually we'll want to know that.
						if prevChild ~= prevChildAtSameIndex then
							shouldResetChildren = true
						end
					else
						mountFiberRecursively(
							nextChild :: Fiber,
							if shouldIncludeInTree then nextFiber else parentFiber,
							false,
							traceNearestHostComponentUpdate
						)

						shouldResetChildren = true
					end

					-- Try the next child.
					nextChild = nextChild.sibling :: Fiber

					-- Advance the pointer in the previous list so that we can
					-- keep comparing if they line up.
					if not shouldResetChildren and prevChildAtSameIndex ~= nil then
						prevChildAtSameIndex = (prevChildAtSameIndex :: Fiber).sibling
					end
				end

				-- If we have no more children, but used to, they don't line up.
				if prevChildAtSameIndex ~= nil then
					shouldResetChildren = true
				end
			else
				if traceUpdatesEnabled then
					-- If we're tracing updates and we've bailed out before reaching a host node,
					-- we should fall back to recursively marking the nearest host descendants for highlight.
					if traceNearestHostComponentUpdate then
						local hostFibers = findAllCurrentHostFibers(
							getFiberID(getPrimaryFiber(nextFiber))
						)

						for _, hostFiber in hostFibers do
							traceUpdatesForNodes:add(hostFiber.stateNode)
						end
					end
				end
			end
		end
		if shouldIncludeInTree then
			-- ROBLOX deviation: hasOwnProperty doesn't exist
			local isProfilingSupported = nextFiber["treeBaseDuration"] ~= nil

			if isProfilingSupported then
				recordProfilingDurations(nextFiber)
			end
		end
		if shouldResetChildren then
			-- We need to crawl the subtree for closest non-filtered Fibers
			-- so that we can display them in a flat children set.
			if shouldIncludeInTree then
				-- Normally, search for children from the rendered child.
				local nextChildSet = nextFiber.child

				if nextDidTimeOut then
					-- Special case: timed-out Suspense renders the fallback set.
					local nextFiberChild = nextFiber.child

					nextChildSet = if nextFiberChild then nextFiberChild.sibling else nil
				end
				if nextChildSet ~= nil then
					recordResetChildren(nextFiber, nextChildSet :: Fiber)
				end

				-- We've handled the child order change for this Fiber.
				-- Since it's included, there's no need to invalidate parent child order.
				return false
			else
				-- Let the closest unfiltered parent Fiber reset its child order instead.
				return true
			end
		else
			return false
		end
	end
	local function cleanup()
		-- We don't patch any methods so there is no cleanup.
	end

	local function flushInitialOperations()
		local localPendingOperationsQueue = pendingOperationsQueue

		pendingOperationsQueue = nil

		if
			localPendingOperationsQueue ~= nil
			and #(localPendingOperationsQueue :: Array<Array<number>>) > 0
		then
			for _, operations in localPendingOperationsQueue :: Array<Array<number>> do
				hook.emit("operations", operations)
			end
		else
			-- Before the traversals, remember to start tracking
			-- our path in case we have selection to restore.
			if trackedPath ~= nil then
				mightBeOnTrackedPath = true
			end

			-- If we have not been profiling, then we can just walk the tree and build up its current state as-is.
			hook.getFiberRoots(rendererID):forEach(function(root)
				currentRootID = getFiberID(getPrimaryFiber(root.current))
				setRootPseudoKey(currentRootID, root.current)

				-- Checking root.memoizedInteractions handles multi-renderer edge-case-
				-- where some v16 renderers support profiling and others don't.
				if isProfiling and root.memoizedInteractions ~= nil then
					-- If profiling is active, store commit time and duration, and the current interactions.
					-- The frontend may request this information after profiling has stopped.
					local _tmp = Array.from(root.memoizedInteractions)

					currentCommitProfilingMetadata = {
						-- ROBLOX deviation: use bare table instead of Map type
						changeDescriptions = if recordChangeDescriptions
							then Map.new()
							else nil,
						durations = {},
						commitTime = getCurrentTime() - profilingStartTime,
						-- ROBLOX TODO: Work out how to deviate this assignment, it's messy
						interactions = Array.map(
							Array.from(root.memoizedInteractions),
							function(interaction: Interaction)
								local tmp2 = Object.assign({}, interaction, {
									timestamp = interaction.timestamp
										- profilingStartTime,
								})
								return tmp2
							end
						),
						maxActualDuration = 0,
						priorityLevel = nil,
					}
				end

				mountFiberRecursively(root.current, nil, false, false)
				flushPendingEvents(root)
				currentRootID = -1
			end)
		end
	end

	local function handleCommitFiberUnmount(fiber)
		-- This is not recursive.
		-- We can't traverse fibers after unmounting so instead
		-- we rely on React telling us about each unmount.
		recordUnmount(fiber, false)
	end

	local formatPriorityLevel = function(priorityLevel: number?)
		if priorityLevel == nil then
			return "Unknown"
		end
		if priorityLevel == ImmediatePriority then
			return "Immediate"
		elseif priorityLevel == UserBlockingPriority then
			return "User-Blocking"
		elseif priorityLevel == NormalPriority then
			return "Normal"
		elseif priorityLevel == LowPriority then
			return "Low"
		elseif priorityLevel == IdlePriority then
			return "Idle"
			-- ROBLOX deviation: no need to check for NoPriority
		else
			return "Unknown"
		end
	end

	local function handleCommitFiberRoot(root: Object, priorityLevel: number?)
		local current = root.current
		local alternate = current.alternate

		currentRootID = getFiberID(getPrimaryFiber(current))

		-- Before the traversals, remember to start tracking
		-- our path in case we have selection to restore.
		if trackedPath ~= nil then
			mightBeOnTrackedPath = true
		end
		if traceUpdatesEnabled then
			traceUpdatesForNodes:clear()
		end

		-- Checking root.memoizedInteractions handles multi-renderer edge-case-
		-- where some v16 renderers support profiling and others don't.
		local isProfilingSupported = root.memoizedInteractions ~= nil

		if isProfiling and isProfilingSupported then
			local _tmp = Array.from(root.memoizedInteractions)
			-- If profiling is active, store commit time and duration, and the current interactions.
			-- The frontend may request this information after profiling has stopped.
			currentCommitProfilingMetadata = {
				-- ROBLOX deviation: use bare table instead of Map type
				changeDescriptions = if recordChangeDescriptions then Map.new() else nil,
				durations = {},
				commitTime = getCurrentTime() - profilingStartTime,
				interactions = Array.map(
					Array.from(root.memoizedInteractions),
					-- ROBLOX FIXME Luau: shouldn't need this manual annotation
					function(interaction: Interaction)
						local _tmp2 = Object.assign({}, interaction, {
							timestamp = interaction.timestamp - profilingStartTime,
						})
						return _tmp2
					end
				),
				maxActualDuration = 0,
				priorityLevel = if priorityLevel == nil
					then nil
					else formatPriorityLevel(priorityLevel),
			}
		end
		if alternate then
			-- TODO: relying on this seems a bit fishy.
			local wasMounted = (alternate :: Fiber).memoizedState ~= nil
				and (alternate :: Fiber).memoizedState.element ~= nil
			local isMounted = current.memoizedState ~= nil
				and current.memoizedState.element ~= nil

			if not wasMounted and isMounted then
				-- Mount a new root.
				setRootPseudoKey(currentRootID, current)
				mountFiberRecursively(current :: Fiber, nil, false, false)
			elseif wasMounted and isMounted then
				-- Update an existing root.
				updateFiberRecursively(current, alternate, nil, false)
			elseif wasMounted and not isMounted then
				-- Unmount an existing root.
				removeRootPseudoKey(currentRootID)
				recordUnmount(current, false)
			end
		else
			-- Mount a new root.
			setRootPseudoKey(currentRootID, current)
			mountFiberRecursively(current :: Fiber, nil, false, false)
		end
		if isProfiling and isProfilingSupported then
			local commitProfilingMetadata = (
				(rootToCommitProfilingMetadataMap :: any) :: CommitProfilingMetadataMap
			):get(currentRootID)

			if commitProfilingMetadata ~= nil then
				table.insert(
					commitProfilingMetadata,
					(currentCommitProfilingMetadata :: any) :: CommitProfilingData
				)
			else
				((rootToCommitProfilingMetadataMap :: any) :: CommitProfilingMetadataMap):set(
					currentRootID,
					{
						(currentCommitProfilingMetadata :: any) :: CommitProfilingData,
					}
				)
			end
		end

		-- We're done here.
		flushPendingEvents(root)

		if traceUpdatesEnabled then
			hook.emit("traceUpdates", traceUpdatesForNodes)
		end

		currentRootID = -1
	end
	findAllCurrentHostFibers = function(id: number): Array<Fiber>
		local fibers = {}
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if not fiber then
			return fibers
		end

		-- Next we'll drill down this component to find all HostComponent/Text.
		-- ROBLOX FIXME Luau: shouldn't need cast on the RHS here
		local node: Fiber = fiber :: Fiber

		while true do
			if node.tag == HostComponent or node.tag == HostText then
				table.insert(fibers, node)
			elseif node.child then
				-- ROBLOX TODO: What do we use instead of "return"?
				(node.child :: Fiber).return_ = node
				node = node.child :: Fiber
			end
			if node == fiber then
				return fibers
			end

			while not node.sibling do
				if not node.return_ or node.return_ == fiber then
					return fibers
				end

				node = node.return_ :: Fiber
			end

			(node.sibling :: Fiber).return_ = node.return_ :: Fiber
			node = node.sibling :: Fiber
		end

		-- Flow needs the return here, but ESLint complains about it.
		-- eslint-disable-next-line no-unreachable
		return fibers
	end
	local function findNativeNodesForFiberID(id: number)
		-- ROBLOX try
		local ok, result = pcall(function()
			local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)
			if fiber == nil then
				return nil
			end
			-- Special case for a timed-out Suspense.
			local isTimedOutSuspense = (fiber :: Fiber).tag == SuspenseComponent
				and (fiber :: Fiber).memoizedState ~= nil
			if isTimedOutSuspense then
				-- A timed-out Suspense's findDOMNode is useless.
				-- Try our best to find the fallback directly.
				local maybeFallbackFiber = (fiber :: Fiber).child
					and ((fiber :: Fiber).child :: Fiber).sibling
				if maybeFallbackFiber ~= nil then
					fiber = maybeFallbackFiber :: Fiber
				end
			end
			local hostFibers = findAllCurrentHostFibers(id)
			-- ROBLOX deviation: filter for Boolean doesn't make sense
			return Array.map(hostFibers, function(hostFiber: Fiber)
				return hostFiber.stateNode
				-- ROBLOX FIXME Luau: remove this any once deferred constraint resolution replaces greedy algorithms
			end) :: any
		end)
		-- ROBLOX catch
		if not ok then
			-- The fiber might have unmounted by now.
			return nil
		end
		return result
	end

	local function getDisplayNameForFiberID(id)
		local fiber = idToFiberMap:get(id)
		return if fiber ~= nil then getDisplayNameForFiber(fiber) else nil
	end

	local function getFiberIDForNative(
		hostInstance,
		findNearestUnfilteredAncestor: boolean?
	): number?
		findNearestUnfilteredAncestor = findNearestUnfilteredAncestor or false
		local fiber = renderer.findFiberByHostInstance(hostInstance)

		if fiber ~= nil then
			if findNearestUnfilteredAncestor then
				while fiber ~= nil and shouldFilterFiber(fiber :: Fiber) do
					fiber = (fiber :: Fiber).return_
				end
			end
			return getFiberID(getPrimaryFiber(fiber :: Fiber))
		end

		return nil
	end

	-- ROBLOX deviation: The copied code is indeed copied, but from ReactFiberTreeReflection.lua

	-- This function is copied from React and should be kept in sync:
	-- https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberTreeReflection.js
	-- It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).
	-- BEGIN copied code

	-- ROBLOX NOTE: Copied these supporting functions from ReactFiberTreeReflection
	local function assertIsMounted(fiber)
		invariant(
			getNearestMountedFiber(fiber) == fiber,
			"Unable to find node on an unmounted component."
		)
	end

	findCurrentFiberUsingSlowPathById = function(id: number): Fiber | nil
		local fiber: Fiber? = idToFiberMap:get(id)

		if fiber == nil then
			console.warn(string.format('Could not find Fiber with id "%s"', tostring(id)))
			return nil
		end

		-- ROBLOX NOTE: Copied from ReactFiberTreeReflection.lua
		local alternate = (fiber :: Fiber).alternate
		if not alternate then
			-- If there is no alternate, then we only need to check if it is mounted.
			local nearestMounted = getNearestMountedFiber(fiber :: Fiber)
			invariant(
				nearestMounted ~= nil,
				"Unable to find node on an unmounted component."
			)
			if nearestMounted ~= (fiber :: Fiber) then
				return nil
			end
			return fiber :: Fiber
		end
		-- If we have two possible branches, we'll walk backwards up to the root
		-- to see what path the root points to. On the way we may hit one of the
		-- special cases and we'll deal with them.
		local a = fiber :: Fiber
		local b = alternate :: Fiber
		while true do
			local parentA = a.return_
			if parentA == nil then
				-- We're at the root.
				break
			end
			local parentB = (parentA :: Fiber).alternate
			if parentB == nil then
				-- There is no alternate. This is an unusual case. Currently, it only
				-- happens when a Suspense component is hidden. An extra fragment fiber
				-- is inserted in between the Suspense fiber and its children. Skip
				-- over this extra fragment fiber and proceed to the next parent.
				local nextParent = (parentA :: Fiber).return_
				if nextParent ~= nil then
					a = nextParent :: Fiber
					b = nextParent :: Fiber
					continue
				end
				-- If there's no parent, we're at the root.
				break
			end

			-- If both copies of the parent fiber point to the same child, we can
			-- assume that the child is current. This happens when we bailout on low
			-- priority: the bailed out fiber's child reuses the current child.
			if (parentA :: Fiber).child == (parentB :: Fiber).child then
				local child = (parentA :: Fiber).child
				while child do
					if child == a then
						-- We've determined that A is the current branch.
						assertIsMounted(parentA)
						return fiber
					end
					if child == b then
						-- We've determined that B is the current branch.
						assertIsMounted(parentA)
						return alternate
					end
					child = child.sibling :: Fiber
				end
				-- We should never have an alternate for any mounting node. So the only
				-- way this could possibly happen is if this was unmounted, if at all.
				invariant(false, "Unable to find node on an unmounted component.")
			end

			if a.return_ ~= b.return_ then
				-- The return pointer of A and the return pointer of B point to different
				-- fibers. We assume that return pointers never criss-cross, so A must
				-- belong to the child set of A.return_, and B must belong to the child
				-- set of B.return_.
				a = parentA :: Fiber
				b = parentB :: Fiber
			else
				-- The return pointers point to the same fiber. We'll have to use the
				-- default, slow path: scan the child sets of each parent alternate to see
				-- which child belongs to which set.
				--
				-- Search parent A's child set
				local didFindChild = false
				local child = (parentA :: Fiber).child
				while child do
					if child == a then
						didFindChild = true
						a = parentA :: Fiber
						b = parentB :: Fiber
						break
					end
					if child == b then
						didFindChild = true
						b = parentA :: Fiber
						a = parentB :: Fiber
						break
					end
					child = child.sibling :: Fiber
				end
				if not didFindChild then
					-- Search parent B's child set
					child = (parentB :: Fiber).child
					while child do
						if child == a then
							didFindChild = true
							a = parentB :: Fiber
							b = parentA :: Fiber
							break
						end
						if child == b then
							didFindChild = true
							b = parentB :: Fiber
							a = parentA :: Fiber
							break
						end
						child = child.sibling :: Fiber
					end
					invariant(
						didFindChild,
						"Child was not found in either parent set. This indicates a bug "
							.. "in React related to the return pointer. Please file an issue."
					)
				end
			end

			invariant(
				a.alternate == b,
				"Return fibers should always be each others' alternates. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		end
		-- If the root is not a host container, we're in a disconnected tree. I.e.
		-- unmounted.
		invariant(a.tag == HostRoot, "Unable to find node on an unmounted component.")
		if a.stateNode.current == a then
			-- We've determined that A is the current branch.
			return fiber
		end
		-- Otherwise B has to be current branch.
		return alternate
	end
	-- END copied code

	local function prepareViewAttributeSource(
		id: number,
		path: Array<string | number>
	): ()
		local isCurrent = isMostRecentlyInspectedElementCurrent(id)

		if isCurrent then
			window["$attribute"] = getInObject(mostRecentlyInspectedElement :: any, path)
		end
	end
	local function prepareViewElementSource(id: number): ()
		local fiber: Fiber? = idToFiberMap:get(id)

		if fiber == nil then
			console.warn(string.format('Could not find Fiber with id "%s"', tostring(id)))
			return
		end

		local elementType, tag, type_ =
			(fiber :: Fiber).elementType, (fiber :: Fiber).tag, (fiber :: Fiber).type

		if
			tag == ClassComponent
			or tag == FunctionComponent
			or tag == IncompleteClassComponent
			or tag == IndeterminateComponent
		then
			global["$type"] = type_
		elseif tag == ForwardRef then
			global["$type"] = type_.render
		elseif tag == MemoComponent or tag == SimpleMemoComponent then
			global["$type"] = elementType ~= nil
					and elementType.type ~= nil
					and elementType.type
				or type_
		else
			global["$type"] = nil
		end
	end

	local function getOwnersList(id: number): Array<Owner> | nil
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber == nil then
			return nil
		end

		local _debugOwner = (fiber :: Fiber)._debugOwner
		local owners = {
			{
				displayName = getDisplayNameForFiber(fiber :: Fiber) or "Anonymous",
				id = id,
				type = getElementTypeForFiber(fiber :: Fiber),
			},
		}

		if _debugOwner then
			local owner: Fiber? = _debugOwner

			while owner ~= nil do
				Array.unshift(owners, {
					displayName = getDisplayNameForFiber(owner :: Fiber) or "Anonymous",
					id = getFiberID(getPrimaryFiber(owner :: Fiber)),
					type = getElementTypeForFiber(owner :: Fiber),
				})

				owner = (owner :: Fiber)._debugOwner or nil
			end
		end

		return owners
	end

	-- Fast path props lookup for React Native style editor.
	-- Could use inspectElementRaw() but that would require shallow rendering hooks components,
	-- and could also mess with memoization.
	local function getInstanceAndStyle(id: number): InstanceAndStyle
		local instance = nil
		local style = nil
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber ~= nil then
			instance = (fiber :: Fiber).stateNode

			if (fiber :: Fiber).memoizedProps ~= nil then
				style = (fiber :: Fiber).memoizedProps.style
			end
		end

		return {
			instance = instance,
			style = style,
		}
	end

	local function inspectElementRaw(id: number): InspectedElement | nil
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber == nil then
			return nil
		end

		local _debugOwner, _debugSource, stateNode, key, memoizedProps, memoizedState, dependencies, tag, type_ =
			(fiber :: Fiber)._debugOwner,
			(fiber :: Fiber)._debugSource,
			(fiber :: Fiber).stateNode,
			(fiber :: Fiber).key,
			(fiber :: Fiber).memoizedProps,
			(fiber :: Fiber).memoizedState,
			(fiber :: Fiber).dependencies,
			(fiber :: Fiber).tag,
			(fiber :: Fiber).type

		local elementType = getElementTypeForFiber(fiber :: Fiber)

		local usesHooks = (
			tag == FunctionComponent
			or tag == SimpleMemoComponent
			or tag == ForwardRef
		) and (not not memoizedState or not not dependencies)

		local typeSymbol = getTypeSymbol(type_)
		local canViewSource = false
		local context = nil

		if
			tag == ClassComponent
			or tag == FunctionComponent
			or tag == IncompleteClassComponent
			or tag == IndeterminateComponent
			or tag == MemoComponent
			or tag == ForwardRef
			or tag == SimpleMemoComponent
		then
			canViewSource = true

			if stateNode and stateNode.context ~= nil then
				-- Don't show an empty context object for class components that don't use the context API.
				local shouldHideContext = elementType == ElementTypeClass
					and not (type_.contextTypes or type_.contextType)

				if not shouldHideContext then
					context = stateNode.context
				end
			end
		elseif typeSymbol == CONTEXT_NUMBER or typeSymbol == CONTEXT_SYMBOL_STRING then
			-- 16.3-16.5 read from "type" because the Consumer is the actual context object.
			-- 16.6+ should read from "type._context" because Consumer can be different (in DEV).
			-- NOTE Keep in sync with getDisplayNameForFiber()
			local consumerResolvedContext = type_._context or type_

			-- Global context value.
			context = consumerResolvedContext._currentValue or nil

			-- Look for overridden value.
			local current = (fiber :: Fiber).return_

			while current ~= nil do
				local currentType = (current :: Fiber).type
				local currentTypeSymbol = getTypeSymbol(currentType)

				if
					currentTypeSymbol == PROVIDER_NUMBER
					or currentTypeSymbol == PROVIDER_SYMBOL_STRING
				then
					-- 16.3.0 exposed the context object as "context"
					-- PR #12501 changed it to "_context" for 16.3.1+
					-- NOTE Keep in sync with getDisplayNameForFiber()
					local providerResolvedContext = currentType._context
						or currentType.context

					if providerResolvedContext == consumerResolvedContext then
						context = (current :: Fiber).memoizedProps.value

						break
					end
				end

				current = (current :: Fiber).return_
			end
		end

		local hasLegacyContext = false

		if context ~= nil then
			hasLegacyContext = not not type_.contextTypes
			-- To simplify hydration and display logic for context, wrap in a value object.
			-- Otherwise simple values (e.g. strings, booleans) become harder to handle.
			context = { value = context }
		end

		local owners: Array<Owner>? = nil

		if _debugOwner then
			owners = {}
			local owner: Fiber? = _debugOwner
			while owner ~= nil do
				table.insert(owners :: Array<Owner>, {
					displayName = getDisplayNameForFiber(owner :: Fiber) or "Anonymous",
					id = getFiberID(getPrimaryFiber(owner :: Fiber)),
					type = getElementTypeForFiber(owner :: Fiber),
				})
				owner = (owner :: Fiber)._debugOwner or nil
			end
		end

		local isTimedOutSuspense = tag == SuspenseComponent and memoizedState ~= nil
		local hooks = nil

		if usesHooks then
			local originalConsoleMethods = {}

			-- Temporarily disable all console logging before re-running the hook.
			-- ROBLOX TODO: Is iterating over console methods be sensible here?
			for method, _ in console do
				pcall(function()
					originalConsoleMethods[method] = console[method]
					console[method] = function() end
				end)
			end

			pcall(function()
				hooks = inspectHooksOfFiber(fiber :: Fiber, renderer.currentDispatcherRef)
			end)

			-- Restore original console functionality.
			for method, _ in console do
				pcall(function()
					console[method] = originalConsoleMethods[method]
				end)
			end
		end

		local rootType: string? = nil
		local current = fiber :: Fiber

		while current.return_ ~= nil do
			current = current.return_ :: Fiber
		end
		local fiberRoot = current.stateNode
		if fiberRoot ~= nil and fiberRoot._debugRootType ~= nil then
			rootType = fiberRoot._debugRootType
		end

		return {
			id = id,
			-- Does the current renderer support editable hooks and function props?
			canEditHooks = typeof(overrideHookState) == "function",
			canEditFunctionProps = typeof(overrideProps) == "function",
			-- Does the current renderer support advanced editing interface?
			canEditHooksAndDeletePaths = typeof(overrideHookStateDeletePath)
				== "function",
			canEditHooksAndRenamePaths = typeof(overrideHookStateRenamePath)
				== "function",
			canEditFunctionPropsDeletePaths = typeof(overridePropsDeletePath)
				== "function",
			canEditFunctionPropsRenamePaths = typeof(overridePropsRenamePath)
				== "function",
			canToggleSuspense = supportsTogglingSuspense
				-- If it's showing the real content, we can always flip fallback.
				and (
					not isTimedOutSuspense
					-- If it's showing fallback because we previously forced it to,
					-- allow toggling it back to remove the fallback override.
					or forceFallbackForSuspenseIDs[id]
				),

			-- Can view component source location.
			canViewSource = canViewSource,

			-- Does the component have legacy contexted to it.
			hasLegacyContext = hasLegacyContext,
			-- ROBLOX TODO: upstream has a buggy ternary for this
			key = key,
			displayName = getDisplayNameForFiber(fiber :: Fiber),
			type_ = elementType,

			-- Inspectable properties.
			-- TODO Review sanitization approach for the below inspectable values.
			context = context,
			-- ROBLOX deviation: Luau won't coerce HooksTree to Object
			hooks = hooks :: any,
			props = memoizedProps,
			state = if usesHooks then nil else memoizedState,

			-- List of owners
			owners = owners,

			-- Location of component in source code.
			source = _debugSource or nil,

			rootType = rootType,
			rendererPackageName = renderer.rendererPackageName,
			rendererVersion = renderer.version,
		}
	end

	isMostRecentlyInspectedElementCurrent = function(id: number): boolean
		return mostRecentlyInspectedElement ~= nil
			and (mostRecentlyInspectedElement :: InspectedElement).id == id
			and not hasElementUpdatedSinceLastInspected
	end

	-- Track the intersection of currently inspected paths,
	-- so that we can send their data along if the element is re-rendered.
	local function mergeInspectedPaths(path)
		local current = currentlyInspectedPaths

		for _, key in path do
			if not Boolean.toJSBoolean(current[key]) then
				current[key] = {}
			end
			current = current[key]
		end
	end

	local function createIsPathAllowed(
		key: string | nil,
		secondaryCategory: string | nil -- ROBLOX TODO: Luau can't express literal type: 'hooks'
	)
		-- This function helps prevent previously-inspected paths from being dehydrated in updates.
		-- This is important to avoid a bad user experience where expanded toggles collapse on update.
		return function(path): boolean
			if secondaryCategory == "hooks" then
				if #path == 1 then
					-- Never dehydrate the "hooks" object at the top levels.
					return true
				end
				if path[#path] == "subHooks" or path[#path - 1] == "subHooks" then
					-- Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,
					-- so it's easiest for now if we just don't break on this boundary.
					-- We can always dehydrate a level deeper (in the value object).
					return true
				end
			end

			local current = if key == nil
				then currentlyInspectedPaths
				else currentlyInspectedPaths[key]

			if not Boolean.toJSBoolean(current) then
				return false
			end

			for i = 1, #path do
				current = current[path[i\]\]
				if not Boolean.toJSBoolean(current) then
					return false
				end
			end
			return true
		end
	end

	local function updateSelectedElement(inspectedElement: InspectedElement): ()
		local hooks, id, props =
			inspectedElement.hooks, inspectedElement.id, inspectedElement.props
		local fiber: Fiber? = idToFiberMap:get(id)

		if fiber == nil then
			console.warn(string.format('Could not find Fiber with id "%s"', tostring(id)))

			return
		end

		local elementType, stateNode, tag, type_ =
			(fiber :: Fiber).elementType,
			(fiber :: Fiber).stateNode,
			(fiber :: Fiber).tag,
			(fiber :: Fiber).type

		if
			tag == ClassComponent
			or tag == IncompleteClassComponent
			or tag == IndeterminateComponent
		then
			global["$r"] = stateNode
		elseif tag == FunctionComponent then
			global["$r"] = {
				hooks = hooks,
				props = props,
				type = type_,
			}
		elseif tag == ForwardRef then
			global["$r"] = {
				props = props,
				type = type_.render,
			}
		elseif tag == MemoComponent or tag == SimpleMemoComponent then
			global["$r"] = {
				props = props,
				type = elementType ~= nil
						and elementType.type ~= nil
						and elementType.type
					or type_,
			}
		else
			global["$r"] = nil
		end
	end

	local function storeAsGlobal(
		id: number,
		path: Array<string | number>,
		count: number
	): ()
		local isCurrent = isMostRecentlyInspectedElementCurrent(id)

		if isCurrent then
			local value = getInObject(mostRecentlyInspectedElement :: any, path)
			local key = string.format("$reactTemp%s", tostring(count))

			window[key] = value

			console.log(key)
			console.log(value)
		end
	end

	local function copyElementPath(id: number, path: Array<string | number>): ()
		local isCurrent = isMostRecentlyInspectedElementCurrent(id)

		if isCurrent then
			copyToClipboard(getInObject(mostRecentlyInspectedElement :: any, path))
		end
	end

	local function inspectElement(
		id: number,
		path: Array<string | number>?
	): InspectedElementPayload
		local isCurrent = isMostRecentlyInspectedElementCurrent(id)

		if isCurrent then
			if path ~= nil then
				mergeInspectedPaths(path :: Array<string>)

				local secondaryCategory = nil

				if (path :: Array<string>)[1] == "hooks" then
					secondaryCategory = "hooks"
				end

				-- If this element has not been updated since it was last inspected,
				-- we can just return the subset of data in the newly-inspected path.
				return {
					id = id,
					type = "hydrated-path",
					path = path,
					value = cleanForBridge(
						getInObject(mostRecentlyInspectedElement :: any, path),
						createIsPathAllowed(nil, secondaryCategory),
						path
					),
				}
			else
				-- If this element has not been updated since it was last inspected, we don't need to re-run it.
				-- Instead we can just return the ID to indicate that it has not changed.
				return {
					id = id,
					type = "no-change",
				}
			end
		else
			hasElementUpdatedSinceLastInspected = false

			if
				mostRecentlyInspectedElement == nil
				or (mostRecentlyInspectedElement :: InspectedElement).id ~= id
			then
				currentlyInspectedPaths = {}
			end

			mostRecentlyInspectedElement = inspectElementRaw(id)

			if mostRecentlyInspectedElement == nil then
				return {
					id = id,
					type = "not-found",
				}
			end
			if path ~= nil then
				mergeInspectedPaths(path :: Array<string>)
			end

			-- Any time an inspected element has an update,
			-- we should update the selected $r value as wel.
			-- Do this before dehydration (cleanForBridge).
			updateSelectedElement(mostRecentlyInspectedElement :: InspectedElement)

			-- Clone before cleaning so that we preserve the full data.
			-- This will enable us to send patches without re-inspecting if hydrated paths are requested.
			-- (Reducing how often we shallow-render is a better DX for function components that use hooks.)
			local cleanedInspectedElement =
				Object.assign({}, mostRecentlyInspectedElement)

			cleanedInspectedElement.context = cleanForBridge(
				cleanedInspectedElement.context,
				createIsPathAllowed("context", nil)
			)
			cleanedInspectedElement.hooks = cleanForBridge(
				cleanedInspectedElement.hooks,
				createIsPathAllowed("hooks", "hooks")
			)
			cleanedInspectedElement.props = cleanForBridge(
				cleanedInspectedElement.props,
				createIsPathAllowed("props", nil)
			)
			cleanedInspectedElement.state = cleanForBridge(
				cleanedInspectedElement.state,
				createIsPathAllowed("state", nil)
			)

			return {
				id = id,
				type = "full-data",
				value = cleanedInspectedElement,
			}
		end
	end

	local function logElementToConsole(id: number)
		local result: InspectedElement? = if isMostRecentlyInspectedElementCurrent(id)
			then mostRecentlyInspectedElement
			else inspectElementRaw(id)

		if result == nil then
			console.warn(string.format('Could not find Fiber with id "%s"', tostring(id)))
			return
		end

		-- ROBLOX TODO: Do we want to support this? Seems out of scope
		-- local supportsGroup = typeof(console.groupCollapsed) == 'function'

		-- if supportsGroup then
		--     console.groupCollapsed(string.format('[Click to expand] %c<%s />', result.displayName or 'Component'), 'color: var(--dom-tag-name-color); font-weight: normal;')
		-- end
		if (result :: InspectedElement).props ~= nil then
			console.log("Props:", (result :: InspectedElement).props)
		end
		if (result :: InspectedElement).state ~= nil then
			console.log("State:", (result :: InspectedElement).state)
		end
		if (result :: InspectedElement).hooks ~= nil then
			console.log("Hooks:", (result :: InspectedElement).hooks)
		end

		local nativeNodes = findNativeNodesForFiberID(id)

		if nativeNodes ~= nil then
			console.log("Nodes:", nativeNodes)
		end
		if (result :: InspectedElement).source ~= nil then
			console.log("Location:", (result :: InspectedElement).source)
		end

		-- ROBLOX deviation: not needed
		-- if (window.chrome || /firefox/i.test(navigator.userAgent)) {
		-- 	console.log(
		-- 	  'Right-click any value to save it as a global variable for further inspection.',
		-- 	);
		--   }

		-- if supportsGroup then
		-- 	console.groupEnd()
		-- end
	end

	local function deletePath(
		type_: string, -- ROBLOX TODO: Luau can't express literal types: 'context' | 'hooks' | 'props' | 'state',
		id: number,
		hookID: number?,
		path: Array<string | number>
	): ()
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber ~= nil then
			local instance = (fiber :: Fiber).stateNode

			if type_ == "context" then
				-- To simplify hydration and display of primitive context values (e.g. number, string)
				-- the inspectElement() method wraps context in a {value: ...} object.
				-- We need to remove the first part of the path (the "value") before continuing.
				path = Array.slice(path, 1)

				if (fiber :: Fiber).tag == ClassComponent then
					if #path == 0 then
						-- Simple context value (noop)
					else
						deletePathInObject(instance.context, path)
					end
					instance:forceUpdate()
				elseif (fiber :: Fiber).tag == FunctionComponent then
					-- Function components using legacy context are not editable
					-- because there's no instance on which to create a cloned, mutated context.
				end
			elseif type_ == "hooks" then
				if type(overrideHookStateDeletePath) == "function" then
					overrideHookStateDeletePath(fiber :: Fiber, hookID, path)
				end
			elseif type_ == "props" then
				if instance == nil then
					if type(overridePropsDeletePath) == "function" then
						overridePropsDeletePath(fiber :: Fiber, path)
					end
				else
					(fiber :: Fiber).pendingProps = copyWithDelete(instance.props, path)
					instance:forceUpdate()
				end
			elseif type_ == "state" then
				deletePathInObject(instance.state, path)
				instance:forceUpdate()
			end
		end
	end

	local function renamePath(
		type_: string, -- ROBLOX deviation: Luau can't express: 'context' | 'hooks' | 'props' | 'state',
		id: number,
		hookID: number?,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	): ()
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber ~= nil then
			local instance = (fiber :: Fiber).stateNode

			if type_ == "context" then
				-- To simplify hydration and display of primitive context values (e.g. number, string)
				-- the inspectElement() method wraps context in a {value: ...} object.
				-- We need to remove the first part of the path (the "value") before continuing.
				oldPath = Array.slice(oldPath, 1)
				newPath = Array.slice(newPath, 1)

				if (fiber :: Fiber).tag == ClassComponent then
					if #oldPath == 0 then
						-- Simple context value (noop)
					else
						renamePathInObject(instance.context, oldPath, newPath)
					end
					instance:forceUpdate()
				elseif (fiber :: Fiber).tag == FunctionComponent then
					-- Function components using legacy context are not editable
					-- because there's no instance on which to create a cloned, mutated context.
				end
			elseif type_ == "hooks" then
				if type(overrideHookStateRenamePath) == "function" then
					overrideHookStateRenamePath(fiber, hookID, oldPath, newPath)
				end
			elseif type_ == "props" then
				if instance == nil then
					if type(overridePropsRenamePath) == "function" then
						overridePropsRenamePath(fiber, oldPath, newPath)
					end
				else
					(fiber :: Fiber).pendingProps =
						copyWithRename(instance.props, oldPath, newPath)
					instance:forceUpdate()
				end
			elseif type_ == "state" then
				renamePathInObject(instance.state, oldPath, newPath)
				instance:forceUpdate()
			end
		end
	end

	local function overrideValueAtPath(
		type_: string, -- ROBLOX deviation: Luau can't express: 'context' | 'hooks' | 'props' | 'state',
		id: number,
		hookID: number?,
		path: Array<string | number>,
		value: any
	): ()
		local fiber: Fiber? = findCurrentFiberUsingSlowPathById(id)

		if fiber ~= nil then
			local instance = (fiber :: Fiber).stateNode

			if type_ == "context" then
				-- To simplify hydration and display of primitive context values (e.g. number, string)
				-- the inspectElement() method wraps context in a {value: ...} object.
				-- We need to remove the first part of the path (the "value") before continuing.
				path = Array.slice(path, 1)

				if (fiber :: Fiber).tag == ClassComponent then
					if #path == 0 then
						-- Simple context value
						instance.context = value
					else
						setInObject(instance.context, path, value)
					end
					instance:forceUpdate()
				elseif (fiber :: Fiber).tag == FunctionComponent then
					-- Function components using legacy context are not editable
					-- because there's no instance on which to create a cloned, mutated context.
				end
			elseif type_ == "hooks" then
				if type(overrideHookState) == "function" then
					overrideHookState(fiber :: Fiber, hookID, path, value)
				end
			elseif type_ == "props" then
				if instance == nil then
					if type(overrideProps) == "function" then
						overrideProps(fiber :: Fiber, path, value)
					end
				else
					(fiber :: Fiber).pendingProps =
						copyWithSet(instance.props, path, value)
					instance:forceUpdate()
				end
			elseif type_ == "state" then
				setInObject(instance.state, path, value)
				instance:forceUpdate()
			end
		end
	end

	type CommitProfilingData = {
		changeDescriptions: Map<number, ChangeDescription> | nil,
		commitTime: number,
		durations: Array<number>,
		interactions: Array<Interaction>,
		maxActualDuration: number,
		priorityLevel: string | nil,
	}

	type CommitProfilingMetadataMap = Map<number, Array<CommitProfilingData>>
	type DisplayNamesByRootID = Map<number, string>

	local function getProfilingData(): ProfilingDataBackend
		local dataForRoots: Array<ProfilingDataForRootBackend> = {}

		if rootToCommitProfilingMetadataMap == nil then
			error("getProfilingData() called before any profiling data was recorded")
		end

		-- ROBLOX FIXME Luau: need type states to not need this manual cast
		(rootToCommitProfilingMetadataMap :: CommitProfilingMetadataMap):forEach(
			function(commitProfilingMetadata, rootID)
				local commitData: Array<CommitDataBackend> = {}
				local initialTreeBaseDurations: Array<Array<number>> = {}
				local allInteractions: Map<number, Interaction> = Map.new()
				local interactionCommits: Map<number, Array<number>> = Map.new()
				local displayName = displayNamesByRootID ~= nil
						and (displayNamesByRootID :: DisplayNamesByRootID):get(rootID)
					or "Unknown"

				if initialTreeBaseDurationsMap ~= nil then
					initialTreeBaseDurationsMap:forEach(function(treeBaseDuration, id)
						if
							initialIDToRootMap ~= nil
							and (initialIDToRootMap :: Map<number, number>):get(id)
								== rootID
						then
							-- We don't need to convert milliseconds to microseconds in this case,
							-- because the profiling summary is JSON serialized.
							table.insert(
								initialTreeBaseDurations,
								{ id, treeBaseDuration }
							)
						end
					end)
				end

				for commitIndex, commitProfilingData in commitProfilingMetadata do
					local changeDescriptions, durations, interactions, maxActualDuration, priorityLevel, commitTime =
						commitProfilingData.changeDescriptions,
						commitProfilingData.durations,
						commitProfilingData.interactions,
						commitProfilingData.maxActualDuration,
						commitProfilingData.priorityLevel,
						commitProfilingData.commitTime
					local interactionIDs: Array<number> = {}

					for _, interaction in interactions do
						if not allInteractions:has(interaction.id) then
							allInteractions:set(interaction.id, interaction)
						end

						table.insert(interactionIDs, interaction.id)

						local commitIndices = interactionCommits:get(interaction.id)

						if commitIndices ~= nil then
							table.insert(commitIndices, commitIndex)
						else
							interactionCommits:set(interaction.id, { commitIndex })
						end
					end

					local fiberActualDurations: Array<Array<number>> = {}
					local fiberSelfDurations: Array<Array<number>> = {}

					for i = 1, #durations, 3 do
						local fiberID = durations[i]
						table.insert(fiberActualDurations, { fiberID, durations[i + 1] })
						table.insert(fiberSelfDurations, { fiberID, durations[i + 2] })
					end

					table.insert(commitData, {
						changeDescriptions = if changeDescriptions ~= nil
							-- ROBLOX FIXME: types don't flow from entries through Array.from() return value
							then Array.from(changeDescriptions:entries()) :: Array<Array<any>>
							else nil,
						duration = maxActualDuration,
						fiberActualDurations = fiberActualDurations,
						fiberSelfDurations = fiberSelfDurations,
						interactionIDs = interactionIDs,
						priorityLevel = priorityLevel,
						timestamp = commitTime,
					})
				end

				local _tmpCommits = Array.from(interactionCommits:entries())
				local _tmp = Array.from(allInteractions:entries())
				table.insert(dataForRoots, {
					commitData = commitData,
					displayName = displayName,
					initialTreeBaseDurations = initialTreeBaseDurations,
					interactionCommits = Array.from(interactionCommits:entries()),
					interactions = Array.from(allInteractions:entries()),
					rootID = rootID,
				})
			end
		)

		return {
			dataForRoots = dataForRoots,
			rendererID = rendererID,
		}
	end

	local function startProfiling(shouldRecordChangeDescriptions: boolean)
		if isProfiling then
			return
		end

		recordChangeDescriptions = shouldRecordChangeDescriptions

		-- Capture initial values as of the time profiling starts.
		-- It's important we snapshot both the durations and the id-to-root map,
		-- since either of these may change during the profiling session
		-- (e.g. when a fiber is re-rendered or when a fiber gets removed).
		displayNamesByRootID = Map.new()
		initialTreeBaseDurationsMap = Map.new(idToTreeBaseDurationMap)
		initialIDToRootMap = Map.new(idToRootMap)
		idToContextsMap = Map.new()

		hook.getFiberRoots(rendererID):forEach(function(root)
			local rootID = getFiberID(getPrimaryFiber(root.current));
			((displayNamesByRootID :: any) :: DisplayNamesByRootID):set(
				rootID,
				getDisplayNameForRoot(root.current)
			)

			if shouldRecordChangeDescriptions then
				-- Record all contexts at the time profiling is started.
				-- Fibers only store the current context value,
				-- so we need to track them separately in order to determine changed keys.
				crawlToInitializeContextsMap(root.current)
			end
		end)

		isProfiling = true
		profilingStartTime = getCurrentTime()
		rootToCommitProfilingMetadataMap = Map.new()
	end

	local function stopProfiling()
		isProfiling = false
		recordChangeDescriptions = false
	end

	-- Automatically start profiling so that we don't miss timing info from initial "mount".
	if sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) == "true" then
		startProfiling(
			sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY)
				== "true"
		)
	end

	-- React will switch between these implementations depending on whether
	-- we have any manually suspended Fibers or not.
	local function shouldSuspendFiberAlwaysFalse()
		return false
	end

	local function shouldSuspendFiberAccordingToSet(fiber: Fiber)
		local id = getFiberID(getPrimaryFiber(fiber))
		return forceFallbackForSuspenseIDs:has(id)
	end
	-- ROBLOX FIXME Luau: infers this as <a>(number, a) -> (), but it doesn't later normalize to (number, boolean) -> ()
	local function overrideSuspense(id: number, forceFallback: boolean): ()
		if
			typeof(setSuspenseHandler) ~= "function"
			or typeof(scheduleUpdate) ~= "function"
		then
			error(
				"Expected overrideSuspense() to not get called for earlier React versions."
			)
		end
		if forceFallback then
			forceFallbackForSuspenseIDs:add(id)

			if forceFallbackForSuspenseIDs.size == 1 then
				-- First override is added. Switch React to slower path.
				setSuspenseHandler(shouldSuspendFiberAccordingToSet)
			end
		else
			forceFallbackForSuspenseIDs:delete(id)

			if forceFallbackForSuspenseIDs.size == 0 then
				-- Last override is gone. Switch React back to fast path.
				setSuspenseHandler(shouldSuspendFiberAlwaysFalse)
			end
		end

		local fiber: Fiber? = idToFiberMap:get(id)

		if fiber ~= nil then
			scheduleUpdate(fiber :: Fiber)
		end
	end

	setTrackedPath = function(path: Array<PathFrame> | nil): ()
		if path == nil then
			trackedPathMatchFiber = nil
			trackedPathMatchDepth = -1
			mightBeOnTrackedPath = false
		end

		trackedPath = path
	end

	-- We call this before traversing a new mount.
	-- It remembers whether this Fiber is the next best match for tracked path.
	-- The return value signals whether we should keep matching siblings or not.
	updateTrackedPathStateBeforeMount = function(fiber: Fiber): boolean
		if trackedPath == nil or not mightBeOnTrackedPath then
			-- Fast path: there's nothing to track so do nothing and ignore siblings.
			return false
		end

		local returnFiber = fiber.return_
		local returnAlternate = if returnFiber ~= nil then returnFiber.alternate else nil
		-- By now we know there's some selection to restore, and this is a new Fiber.
		-- Is this newly mounted Fiber a direct child of the current best match?
		-- (This will also be true for new roots if we haven't matched anything yet.)
		if
			trackedPathMatchFiber == returnFiber
			or trackedPathMatchFiber == returnAlternate and returnAlternate ~= nil
		then
			-- Is this the next Fiber we should select? Let's compare the frames.
			local actualFrame = getPathFrame(fiber)
			local expectedFrame: PathFrame? = (trackedPath :: Array<PathFrame>)[trackedPathMatchDepth + 1]

			if expectedFrame == nil then
				error("Expected to see a frame at the next depth.")
			end
			if
				actualFrame.index == (expectedFrame :: PathFrame).index
				and actualFrame.key == (expectedFrame :: PathFrame).key
				and actualFrame.displayName
					== (expectedFrame :: PathFrame).displayName
			then
				-- We have our next match.
				trackedPathMatchFiber = fiber
				trackedPathMatchDepth = trackedPathMatchDepth + 1
				-- Are we out of frames to match?
				if trackedPathMatchDepth == #(trackedPath :: Array<PathFrame>) - 1 then
					-- There's nothing that can possibly match afterwards.
					-- Don't check the children.
					mightBeOnTrackedPath = false
				else
					-- Check the children, as they might reveal the next match.
					mightBeOnTrackedPath = true
				end
				-- In either case, since we have a match, we don't need
				-- to check the siblings. They'll never match.
				return false
			end
		end

		-- This Fiber's parent is on the path, but this Fiber itself isn't.
		-- There's no need to check its children--they won't be on the path either.
		mightBeOnTrackedPath = false
		-- However, one of its siblings may be on the path so keep searching.
		return true
	end

	updateTrackedPathStateAfterMount = function(mightSiblingsBeOnTrackedPath)
		-- updateTrackedPathStateBeforeMount() told us whether to match siblings.
		-- Now that we're entering siblings, let's use that information.
		mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath
	end

	-- ROBLOX deviation: rootPseudoKeys and rootDisplayNameCounter defined earlier in the file
	setRootPseudoKey = function(id: number, fiber: Fiber)
		local name = getDisplayNameForRoot(fiber)
		local counter = rootDisplayNameCounter:get(name) or 0
		rootDisplayNameCounter:set(name, counter + 1)
		local pseudoKey = string.format("%s:%d", name, counter)
		rootPseudoKeys:set(id, pseudoKey)
	end
	removeRootPseudoKey = function(id: number)
		local pseudoKey: string? = rootPseudoKeys:get(id)

		if pseudoKey == nil then
			error("Expected root pseudo key to be known.")
		end

		-- Luau FIXME: `pseudoKey == nil` above should narrow pseudoKey from string? to string
		local name = string.sub(
			pseudoKey :: string,
			1,
			String.lastIndexOf(pseudoKey :: string, ":") - 1
		)
		local counter = rootDisplayNameCounter:get(name)

		-- ROBLOX FIXME Luau: needs type states to know past this branch count is non-nil
		if counter == nil then
			error("Expected counter to be known.")
		end
		if counter :: number > 1 then
			rootDisplayNameCounter:set(name, counter :: number - 1)
		else
			rootDisplayNameCounter:delete(name)
		end

		rootPseudoKeys:delete(id)
	end

	getDisplayNameForRoot = function(fiber: Fiber): string
		local preferredDisplayName = nil
		local fallbackDisplayName = nil
		local child = fiber.child
		-- Go at most three levels deep into direct children
		-- while searching for a child that has a displayName.
		for i = 0, 3 - 1 do
			if child == nil then
				break
			end

			local displayName = getDisplayNameForFiber(child :: Fiber)

			if displayName ~= nil then
				-- Prefer display names that we get from user-defined components.
				-- We want to avoid using e.g. 'Suspense' unless we find nothing else.
				if typeof((child :: Fiber).type) == "function" then
					-- There's a few user-defined tags, but we'll prefer the ones
					-- that are usually explicitly named (function or class components).
					preferredDisplayName = displayName
				elseif fallbackDisplayName == nil then
					fallbackDisplayName = displayName
				end
			end
			if preferredDisplayName ~= nil then
				break
			end

			child = (child :: Fiber).child
		end

		return preferredDisplayName or fallbackDisplayName or "Anonymous"
	end

	getPathFrame = function(fiber: Fiber): PathFrame
		local key = fiber.key
		local displayName = getDisplayNameForFiber(fiber)
		local index = fiber.index

		if fiber.tag == HostRoot then
			-- Roots don't have a real displayName, index, or key.
			-- Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).
			local id = getFiberID(getPrimaryFiber(fiber))
			local pseudoKey: string? = rootPseudoKeys:get(id)
			if pseudoKey == nil then
				error("Expected mounted root to have known pseudo key.")
			end
			displayName = pseudoKey :: string
		elseif fiber.tag == HostComponent then
			displayName = fiber.type
		end

		return {
			displayName = displayName,
			key = key,
			index = index,
		}
	end

	-- Produces a serializable representation that does a best effort
	-- of identifying a particular Fiber between page reloads.
	-- The return path will contain Fibers that are "invisible" to the store
	-- because their keys and indexes are important to restoring the selection.
	local function getPathForElement(id: number): Array<PathFrame> | nil
		local fiber: Fiber? = idToFiberMap:get(id)
		if fiber == nil then
			return nil
		end

		local keyPath = {}
		while fiber ~= nil do
			table.insert(keyPath, getPathFrame(fiber :: Fiber))
			fiber = (fiber :: Fiber).return_
		end

		Array.reverse(keyPath)
		return keyPath
	end

	local function getBestMatchForTrackedPath(): PathMatch | nil
		if trackedPath == nil then
			-- Nothing to match.
			return nil
		end
		if trackedPathMatchFiber == nil then
			-- We didn't find anything.
			return nil
		end

		-- Find the closest Fiber store is aware of.
		local fiber: Fiber? = trackedPathMatchFiber
		while fiber ~= nil and shouldFilterFiber(fiber :: Fiber) do
			fiber = (fiber :: Fiber).return_
		end

		if fiber == nil then
			return nil
		end

		return {
			id = getFiberID(getPrimaryFiber(fiber :: Fiber)),
			isFullMatch = trackedPathMatchDepth == #(trackedPath :: Array<PathFrame>),
		}
	end

	local function setTraceUpdatesEnabled(isEnabled: boolean): ()
		traceUpdatesEnabled = isEnabled
	end

	return {
		cleanup = cleanup,
		copyElementPath = copyElementPath,
		deletePath = deletePath,
		findNativeNodesForFiberID = findNativeNodesForFiberID,
		flushInitialOperations = flushInitialOperations,
		getBestMatchForTrackedPath = getBestMatchForTrackedPath,
		getDisplayNameForFiberID = getDisplayNameForFiberID,
		getFiberIDForNative = getFiberIDForNative,
		getInstanceAndStyle = getInstanceAndStyle,
		getOwnersList = getOwnersList,
		getPathForElement = getPathForElement,
		getProfilingData = getProfilingData,
		handleCommitFiberRoot = handleCommitFiberRoot,
		handleCommitFiberUnmount = handleCommitFiberUnmount,
		inspectElement = inspectElement,
		logElementToConsole = logElementToConsole,
		prepareViewAttributeSource = prepareViewAttributeSource,
		prepareViewElementSource = prepareViewElementSource,
		overrideSuspense = overrideSuspense,
		overrideValueAtPath = overrideValueAtPath,
		renamePath = renamePath,
		renderer = renderer,
		setTraceUpdatesEnabled = setTraceUpdatesEnabled,
		setTrackedPath = setTrackedPath,
		startProfiling = startProfiling,
		stopProfiling = stopProfiling,
		storeAsGlobal = storeAsGlobal,
		updateComponentFilters = updateComponentFilters,
		-- ROBLOX deviation: expose extra function for Roblox Studio use
		getDisplayNameForRoot = getDisplayNameForRoot,
	}
end

return exports ]]
bC.Children._a8ae9210f3b7e656f2d610acb3df649d=bN
local bO

local bP={ClassName="ModuleScript",Children={},Properties={}}
bP.Name="types"
bP.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/types.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
type Function = (...any) -> any
type Map<K, V> = LuauPolyfill.Map<K, V>
type Set<T> = LuauPolyfill.Set<T>
type Symbol = Object
local exports = {}

-- ROBLOX deviation: rotriever re-exports types to the top-level export
local ReactShared = require(Packages.Shared)
type ReactContext<T> = ReactShared.ReactContext<T>
type Source = ReactShared.Source
local ReactInternalTypes = require(Packages.ReactReconciler)
type Fiber = ReactInternalTypes.Fiber
local Types = require(script.Parent.Parent.types)
type ComponentFilter = Types.ComponentFilter
type ElementType = Types.ElementType

local DevToolsViewsProfilerTypes =
	require(script.Parent.Parent.devtools.views.Profiler.types)
type Interaction = DevToolsViewsProfilerTypes.Interaction

type ResolveNativeStyle = (any) -> Object?

-- ROBLOX deviation: Luau currently can't express enumerations of literals
--  | 0 -- PROD
--  | 1; -- DEV
type BundleType = number

export type WorkTag = number
export type WorkFlags = number
export type ExpirationTime = number

export type WorkTagMap = {
	Block: WorkTag,
	ClassComponent: WorkTag,
	ContextConsumer: WorkTag,
	ContextProvider: WorkTag,
	CoroutineComponent: WorkTag,
	CoroutineHandlerPhase: WorkTag,
	DehydratedSuspenseComponent: WorkTag,
	ForwardRef: WorkTag,
	Fragment: WorkTag,
	FunctionComponent: WorkTag,
	HostComponent: WorkTag,
	HostPortal: WorkTag,
	HostRoot: WorkTag,
	HostText: WorkTag,
	IncompleteClassComponent: WorkTag,
	IndeterminateComponent: WorkTag,
	LazyComponent: WorkTag,
	MemoComponent: WorkTag,
	Mode: WorkTag,
	OffscreenComponent: WorkTag,
	Profiler: WorkTag,
	SimpleMemoComponent: WorkTag,
	SuspenseComponent: WorkTag,
	SuspenseListComponent: WorkTag,
	YieldComponent: WorkTag,
}

-- TODO: If it's useful for the frontend to know which types of data an Element has
-- (e.g. props, state, context, hooks) then we could add a bitmask field for this
-- to keep the number of attributes small.
export type FiberData = {
	key: string | nil,
	displayName: string | nil,
	type: ElementType,
}

export type NativeType = Object
export type RendererID = number
type Dispatcher = ReactShared.Dispatcher
export type CurrentDispatcherRef = { current: nil | Dispatcher }

export type GetDisplayNameForFiberID = (number, boolean?) -> string | nil

export type GetFiberIDForNative = (NativeType, boolean?) -> number | nil
export type FindNativeNodesForFiberID = (number) -> Array<NativeType>?

export type ReactProviderType<T> = {
	-- ROBLOX TODO: Luau can't express field names that require quoted accessor
	--   $$typeof: Symbol | number,
	[string]: Symbol | number,
	_context: ReactContext<T>,
	--   ...
}

-- ROBLOX deviation: most of the instance methods are nil-able upstream, but we can't typecheck inline when using the colon call operator
export type ReactRenderer = {
	findFiberByHostInstance: (NativeType) -> Fiber?,
	version: string,
	rendererPackageName: string,
	bundleType: BundleType,
	-- 16.9+
	overrideHookState: ((
		self: ReactRenderer,
		Object,
		number,
		Array<string | number>,
		any
	) -> ()),
	-- 17+
	overrideHookStateDeletePath: ((
		self: ReactRenderer,
		Object,
		number,
		Array<string | number>
	) -> ()),
	-- 17+
	overrideHookStateRenamePath: ((
		self: ReactRenderer,
		Object,
		number,
		Array<string | number>,
		Array<string | number>
	) -> ()),
	-- 16.7+
	overrideProps: ((self: ReactRenderer, Object, Array<string | number>, any) -> ()),
	-- 17+
	overridePropsDeletePath: (
		(self: ReactRenderer, Object, Array<string | number>) -> ()
	),
	-- 17+
	overridePropsRenamePath: ((
		self: ReactRenderer,
		Object,
		Array<string | number>,
		Array<string | number>
	) -> ()),
	-- 16.9+
	scheduleUpdate: ((self: ReactRenderer, Object) -> ()),
	setSuspenseHandler: (
		self: ReactRenderer,
		shouldSuspend: (fiber: Object) -> boolean
	) -> (),
	-- Only injected by React v16.8+ in order to support hooks inspection.
	currentDispatcherRef: CurrentDispatcherRef?,
	-- Only injected by React v16.9+ in DEV mode.
	-- Enables DevTools to append owners-only component stack to error messages.
	getCurrentFiber: (() -> Fiber | nil)?,
	-- Uniquely identifies React DOM v15.
	ComponentTree: any?,
	-- Present for React DOM v12 (possibly earlier) through v15.
	Mount: any?,
	--   ...
}

export type ChangeDescription = {
	context: Array<string> | boolean | nil,
	didHooksChange: boolean,
	isFirstMount: boolean,
	props: Array<string> | nil,
	state: Array<string> | nil,
}

export type CommitDataBackend = {
	-- Tuple of fiber ID and change description
	-- ROBLOX TODO: how to express bracket syntax embedded in Array type?
	-- changeDescriptions: Array<[number, ChangeDescription]> | nil,
	changeDescriptions: Array<Array<number | ChangeDescription>> | nil,
	duration: number,
	-- Tuple of fiber ID and actual duration
	fiberActualDurations: Array<Array<number>>,
	-- Tuple of fiber ID and computed "self" duration
	fiberSelfDurations: Array<Array<number>>,
	interactionIDs: Array<number>,
	priorityLevel: string | nil,
	timestamp: number,
}

export type ProfilingDataForRootBackend = {
	commitData: Array<CommitDataBackend>,
	displayName: string,
	-- Tuple of Fiber ID and base duration
	-- ROBLOX TODO: how to express bracket syntax embedded in Array type?

	initialTreeBaseDurations: Array<any>,
	-- Tuple of Interaction ID and commit indices
	interactionCommits: Array<any>,
	interactions: Array<any>,
	rootID: number,
}

-- Profiling data collected by the renderer interface.
-- This information will be passed to the frontend and combined with info it collects.
export type ProfilingDataBackend = {
	dataForRoots: Array<ProfilingDataForRootBackend>,
	rendererID: number,
}

-- ROBLOX deviation: Roact stable keys - slightly widen the type definition of a
-- stable key so that it's likely to work with existing Roact code. Includes
-- numbers for mixed/sparse tables
type RoactStableKey = string | number

export type PathFrame = {
	key: RoactStableKey | nil,
	index: number,
	displayName: string | nil,
}

export type PathMatch = { id: number, isFullMatch: boolean }

export type Owner = { displayName: string | nil, id: number, type: ElementType }

export type OwnersList = { id: number, owners: Array<Owner> | nil }

export type InspectedElement = {
	id: number,

	displayName: string | nil,

	-- Does the current renderer support editable hooks and function props?
	canEditHooks: boolean,
	canEditFunctionProps: boolean,

	-- Does the current renderer support advanced editing interface?
	canEditHooksAndDeletePaths: boolean,
	canEditHooksAndRenamePaths: boolean,
	canEditFunctionPropsDeletePaths: boolean,
	canEditFunctionPropsRenamePaths: boolean,

	-- Is this Suspense, and can its value be overridden now?
	canToggleSuspense: boolean,

	-- Can view component source location.
	canViewSource: boolean,

	-- Does the component have legacy context attached to it.
	hasLegacyContext: boolean,

	-- Inspectable properties.
	context: Object | nil,
	hooks: Object | nil,
	props: Object | nil,
	state: Object | nil,
	key: number | string | nil,

	-- List of owners
	owners: Array<Owner> | nil,

	-- Location of component in source code.
	source: Source | nil,

	type_: ElementType,

	-- Meta information about the root this element belongs to.
	rootType: string | nil,

	-- Meta information about the renderer that created this element.
	rendererPackageName: string | nil,
	rendererVersion: string | nil,
}

exports.InspectElementFullDataType = "full-data"
exports.InspectElementNoChangeType = "no-change"
exports.InspectElementNotFoundType = "not-found"
exports.InspectElementHydratedPathType = "hydrated-path"

type InspectElementFullData = {
	id: number,
	-- ROBLOX TODO: Luau can't express literals
	--   type: 'full-data',
	type: string,
	value: InspectedElement,
}

type InspectElementHydratedPath = {
	id: number,
	-- ROBLOX TODO: Luau can't express literals
	--   type: 'hydrated-path',
	type: string,
	path: Array<string | number>,
	value: any,
}

type InspectElementNoChange = {
	id: number,
	-- ROBLOX TODO: Luau can't express literals
	--   type: 'no-change',
	type: string,
}

type InspectElementNotFound = {
	id: number,
	-- ROBLOX TODO: Luau can't express literals
	--   type: 'not-found',
	type: string,
}

export type InspectedElementPayload =
	InspectElementFullData
	| InspectElementHydratedPath
	| InspectElementNoChange
	| InspectElementNotFound

export type InstanceAndStyle = { instance: Object | nil, style: Object | nil }

-- ROBLOX TODO: Luau can't express literals
--   type Type = 'props' | 'hooks' | 'state' | 'context';
type Type = string

export type RendererInterface = {
	cleanup: () -> (),
	copyElementPath: (number, Array<string | number>) -> (),
	deletePath: (Type, number, number?, Array<string | number>) -> (),
	findNativeNodesForFiberID: FindNativeNodesForFiberID,
	flushInitialOperations: () -> (),
	getBestMatchForTrackedPath: () -> PathMatch | nil,
	getFiberIDForNative: GetFiberIDForNative,
	getDisplayNameForFiberID: GetDisplayNameForFiberID,
	getInstanceAndStyle: (number) -> InstanceAndStyle,
	getProfilingData: () -> ProfilingDataBackend,
	getOwnersList: (number) -> Array<Owner> | nil,
	getPathForElement: (number) -> Array<PathFrame> | nil,
	handleCommitFiberRoot: (Object, number?) -> (),
	handleCommitFiberUnmount: (Object) -> (),
	inspectElement: (number, Array<string | number>?) -> InspectedElementPayload,
	logElementToConsole: (number) -> (),
	overrideSuspense: (number, boolean) -> (),
	overrideValueAtPath: (Type, number, number?, Array<string | number>, any) -> (),
	prepareViewAttributeSource: (number, Array<string | number>) -> (),
	prepareViewElementSource: (number) -> (),
	renamePath: (
		Type,
		number,
		number?,
		Array<string | number>,
		Array<string | number>
	) -> (),
	renderer: ReactRenderer | nil,
	setTraceUpdatesEnabled: (boolean) -> (),
	setTrackedPath: (Array<PathFrame> | nil) -> (),
	startProfiling: (boolean) -> (),
	stopProfiling: () -> (),
	storeAsGlobal: (number, Array<string | number>, number) -> (),
	updateComponentFilters: (Array<ComponentFilter>) -> (),
	-- ROBLOX TODO: once we are back up to 70% coverage, use [string]: any to approximate the ... below
	--   ...
	-- ROBLOX deviation: add specific exports needed so the contract is explcit and explicitly typed
	getDisplayNameForRoot: (fiber: Fiber) -> string,
}

export type Handler = (any) -> ()

-- ROBLOX TODO? move these types into shared so reconciler and devtools don't have circlar dep?
export type DevToolsHook = {
	listeners: {
		[string]: Array<Handler>, --\[\[ ...\]\]
	},
	rendererInterfaces: Map<RendererID, RendererInterface>,
	renderers: Map<RendererID, ReactRenderer>,

	emit: (string, any) -> (),
	getFiberRoots: (RendererID) -> Set<Object>,
	inject: (ReactRenderer) -> number | nil,
	on: (string, Handler) -> (),
	off: (string, Handler) -> (),
	reactDevtoolsAgent: Object?,
	sub: (string, Handler) -> (() -> ()),

	-- Used by react-native-web and Flipper/Inspector
	resolveRNStyle: ResolveNativeStyle?,
	nativeStyleEditorValidAttributes: Array<string>?,

	-- React uses these methods.
	checkDCE: (Function) -> (),
	onCommitFiberUnmount: (RendererID, Object) -> (),
	onCommitFiberRoot: (
		RendererID,
		Object,
		-- Added in v16.9 to support Profiler priority labels
		number?,
		-- Added in v16.9 to support Fast Refresh
		boolean?
	) -> (),
	-- ROBLOX deviation: track specific additions to interface needed instead of catch-all
	supportsFiber: boolean,
	isDisabled: boolean?,
	--   ...
}

return exports ]]
bC.Children._3b3adbe1fff0e776461c1b20cc0a1b4d=bP
local bQ

local bR={ClassName="ModuleScript",Children={},Properties={}}
bR.Name="utils"
bR.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/backend/utils.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local hydration = require(script.Parent.Parent.hydration)
local dehydrate = hydration.dehydrate

local ComponentsTypes = require(script.Parent.Parent.devtools.views.Components.types)
type DehydratedData = ComponentsTypes.DehydratedData

-- ROBLOX deviation: Use HttpService for JSON
local JSON = game:GetService("HttpService")

local exports: any = {}

exports.cleanForBridge = function(
	data: Object | nil,
	isPathAllowed: (path: Array<string | number>) -> boolean,
	path: Array<string | number>?
): DehydratedData | nil
	path = path or {}
	if data ~= nil then
		local cleanedPaths: Array<Array<string | number>> = {}
		local unserializablePaths: Array<Array<string | number>> = {}
		local cleanedData = dehydrate(
			data :: Object,
			cleanedPaths,
			unserializablePaths,
			path :: Array<string | number>,
			isPathAllowed
		)
		return {
			data = cleanedData,
			cleaned = cleanedPaths,
			unserializable = unserializablePaths,
		}
	else
		return nil
	end
end
exports.copyToClipboard = function(value: any): ()
	-- ROBLOX TODO: we will need a different implementation for this
	-- local safeToCopy = serializeToString(value)
	-- local text = (function()
	--     if safeToCopy == nil then
	--         return'undefined'
	--     end

	--     return safeToCopy
	-- end)()
	-- local clipboardCopyText = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.clipboardCopyText

	-- if typeof(clipboardCopyText) == 'function' then
	--     clipboardCopyText(text).catch(function(err) end)
	-- else
	--     copy(text)
	-- end
end

exports.copyWithDelete = function(
	-- ROBLOX FIXME Luau: workaround for Expected type table, got 'Array<any> | Object' instead
	obj: { [any]: any }, --Object | Array<any>,
	path: Array<string | number>,
	index: number
): Object | Array<any>
	-- ROBLOX deviation: 1-indexed
	index = index or 1
	local key = path[index]
	-- ROBLOX deviation START: combine [].slice() and spread into single op, because we can
	local updated = table.clone(obj)
	-- ROBLOX deviation END

	-- ROBLOX deviation: 1-indexed, check for last element
	if index == #path then
		if Array.isArray(updated) then
			Array.splice(updated, key :: number, 1)
		else
			updated[key] = nil
		end
	else
		updated[key] = exports.copyWithDelete(obj[key], path, index + 1)
	end

	return updated
end

-- This function expects paths to be the same except for the final value.
-- e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']
exports.copyWithRename = function(
	-- ROBLOX FIXME Luau: workaround for Expected type table, got 'Array<any> | Object' instead
	obj: { [any]: any }, --Object | Array<any>,
	oldPath: Array<string | number>,
	newPath: Array<string | number>,
	index: number
): Object | Array<any>
	-- ROBLOX deviation: 1-indexed
	index = index or 1
	local oldKey = oldPath[index]
	-- ROBLOX deviation START: combine [].slice() and spread into single op, because we can
	local updated = table.clone(obj)
	-- ROBLOX deviation END

	-- ROBLOX deviation: 1-indexed, check for last element
	if index == #oldPath then
		local newKey = newPath[index]

		updated[newKey] = updated[oldKey]

		if Array.isArray(updated) then
			Array.splice(updated, oldKey :: number, 1)
		else
			updated[oldKey] = nil
		end
	else
		updated[oldKey] = exports.copyWithRename(obj[oldKey], oldPath, newPath, index + 1)
	end

	return updated
end

exports.copyWithSet = function(
	-- ROBLOX FIXME Luau: workaround for Expected type table, got 'Array<any> | Object' instead
	obj: { [any]: any }, --Object | Array<any>,
	path: Array<string | number>,
	value: any,
	index: number
): Object | Array<any>
	-- ROBLOX deviation: 1-indexed
	index = index or 1

	-- ROBLOX deviation: 1-indexed, check for out of bounds
	if index > #path then
		return value
	end

	local key = path[index]
	-- ROBLOX deviation START: combine [].slice() and spread into single op, because we can
	local updated = table.clone(obj)
	-- ROBLOX deviation END

	updated[key] = exports.copyWithSet(obj[key], path, value, index + 1)

	return updated
end

exports.serializeToString = function(data: any): string
	local cache = Set.new()

	return JSON.JSONEncode(data, function(key, value)
		-- ROBLOX deviation: use 'table' not object
		if typeof(value) == "table" and value ~= nil then
			if cache:has(value) then
				return
			end

			cache:add(value)
		end
		-- ROBLOX deviation: not Luau
		-- if typeof(value) == 'bigint' then
		-- 	return tostring(value) + 'n'
		-- end

		return value
	end)
end

return exports ]]
bC.Children._4e27e9330c86991ceb1d65abfa06b763=bR
local bS

local bT={ClassName="ModuleScript",Children={},Properties={}}
bT.Name="bridge"
bT.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/bridge.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = require(Packages.Shared).console
type Array<T> = { [number]: T }
type Function = (...any) -> ...any

local EventEmitter = require(script.Parent.events)
type EventEmitter<T> = EventEmitter.EventEmitter<T>

local Types = require(script.Parent.types)
type ComponentFilter = Types.ComponentFilter
type Wall = Types.Wall
local BackendTypes = require(script.Parent.backend.types)
type InspectedElementPayload = BackendTypes.InspectedElementPayload
type OwnersList = BackendTypes.OwnersList
type ProfilingDataBackend = BackendTypes.ProfilingDataBackend
type RendererID = BackendTypes.RendererID

local BATCH_DURATION = 100

type Message = { event: string, payload: any }

type ElementAndRendererID = { id: number, rendererID: RendererID }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type HighlightElementInDOM = ElementAndRendererID & {
	displayName: string?,
	hideAfterTimeout: boolean,
	openNativeElementsPanel: boolean,
	scrollIntoView: boolean,
}

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type OverrideValue = ElementAndRendererID & {
	path: Array<string | number>,
	wasForwarded: boolean?,
	value: any,
}

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type OverrideHookState = OverrideValue & { hookID: number }

-- ROBLOX deviation: 'props' | 'hooks' | 'state' | 'context';
type PathType = string

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type DeletePath =
	ElementAndRendererID
	& { type: PathType, hookID: number?, path: Array<string | number> }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type RenamePath = ElementAndRendererID & {
	type: PathType,
	hookID: number?,
	oldPath: Array<string | number>,
	newPath: Array<string | number>,
}

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type OverrideValueAtPath = ElementAndRendererID & {
	type: PathType,
	hookID: number?,
	path: Array<string | number>,
	value: any,
}

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type OverrideSuspense = ElementAndRendererID & { forceFallback: boolean }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type CopyElementPathParams = ElementAndRendererID & { path: Array<string | number> }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type ViewAttributeSourceParams = ElementAndRendererID & { path: Array<string | number> }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type InspectElementParams = ElementAndRendererID & { path: Array<string | number>? }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type StoreAsGlobalParams =
	ElementAndRendererID
	& { count: number, path: Array<string | number> }

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type NativeStyleEditor_RenameAttributeParams = ElementAndRendererID & {
	oldName: string,
	newName: string,
	value: string,
}

-- ROBLOX deviation: Luau can't use ...type, use intersection instead
type NativeStyleEditor_SetValueParams =
	ElementAndRendererID
	& { name: string, value: string }

type UpdateConsolePatchSettingsParams = {
	appendComponentStack: boolean,
	breakOnConsoleErrors: boolean,
}

-- ROBLOX deviation: Luau can't define object types in a function type
type IsSupported = { isSupported: boolean, validAttributes: Array<string> }

type BackendEvents = {
	extensionBackendInitialized: () -> (),
	inspectedElement: (InspectedElementPayload) -> (),
	isBackendStorageAPISupported: (boolean) -> (),
	-- ROBLOX deviation: don't binary encode strings
	operations: (Array<number | string>) -> (),
	ownersList: (OwnersList) -> (),
	overrideComponentFilters: (Array<ComponentFilter>) -> (),
	profilingData: (ProfilingDataBackend) -> (),
	profilingStatus: (boolean) -> (),
	reloadAppForProfiling: () -> (),
	selectFiber: (number) -> (),
	shutdown: () -> (),
	stopInspectingNative: (boolean) -> (),
	syncSelectionFromNativeElementsPanel: () -> (),
	syncSelectionToNativeElementsPanel: () -> (),
	unsupportedRendererVersion: (RendererID) -> (),

	-- React Native style editor plug-in.
	isNativeStyleEditorSupported: (IsSupported) -> (),
	-- ROBLOX deviation: StyleAndLayoutPayload type not transliterated
	NativeStyleEditor_styleAndLayout: () -> (),
}

type FrontendEvents = {
	clearNativeElementHighlight: () -> (),
	copyElementPath: (CopyElementPathParams) -> (),
	deletePath: (DeletePath) -> (),
	getOwnersList: (ElementAndRendererID) -> (),
	getProfilingData: ({ rendererID: RendererID }) -> (),
	getProfilingStatus: () -> (),
	highlightNativeElement: (HighlightElementInDOM) -> (),
	inspectElement: (InspectElementParams) -> (),
	logElementToConsole: (ElementAndRendererID) -> (),
	overrideSuspense: (OverrideSuspense) -> (),
	overrideValueAtPath: (OverrideValueAtPath) -> (),
	profilingData: (ProfilingDataBackend) -> (),
	reloadAndProfile: (boolean) -> (),
	renamePath: (RenamePath) -> (),
	selectFiber: (number) -> (),
	setTraceUpdatesEnabled: (boolean) -> (),
	shutdown: () -> (),
	startInspectingNative: () -> (),
	startProfiling: (boolean) -> (),
	stopInspectingNative: (boolean) -> (),
	stopProfiling: () -> (),
	storeAsGlobal: (StoreAsGlobalParams) -> (),
	updateComponentFilters: (Array<ComponentFilter>) -> (),
	updateConsolePatchSettings: (UpdateConsolePatchSettingsParams) -> (),
	viewAttributeSource: (ViewAttributeSourceParams) -> (),
	viewElementSource: (ElementAndRendererID) -> (),

	-- React Native style editor plug-in.
	NativeStyleEditor_measure: (ElementAndRendererID) -> (),
	NativeStyleEditor_renameAttribute: (NativeStyleEditor_RenameAttributeParams) -> (),
	NativeStyleEditor_setValue: (NativeStyleEditor_SetValueParams) -> (),

	-- Temporarily support newer standalone front-ends sending commands to older embedded backends.
	-- We do this because React Native embeds the React DevTools backend,
	-- but cannot control which version of the frontend users use.
	--
	-- Note that nothing in the newer backend actually listens to these events,
	-- but the new frontend still dispatches them (in case older backends are listening to them instead).
	--
	-- Note that this approach does no support the combination of a newer backend with an older frontend.
	-- It would be more work to suppot both approaches (and not run handlers twice)
	-- so I chose to support the more likely/common scenario (and the one more difficult for an end user to "fix").
	overrideContext: (OverrideValue) -> (),
	overrideHookState: (OverrideHookState) -> (),
	overrideProps: (OverrideValue) -> (),
	overrideState: (OverrideValue) -> (),
}

-- ROBLOX deviation: Luau can't spread keys of a type as string
type EventName = string -- $Keys<OutgoingEvents>
-- ROBLOX deviation: Luau can't express
-- type $ElementType<T, K extends keyof T> = T[K];
type ElementType<T, U> = any

export type Bridge<
	OutgoingEvents,
	IncomingEvents -- ROBLOX deviation: Luau can't express	-- > extends EventEmitter<{|	--   ...IncomingEvents,	--   ...OutgoingEvents,	-- |}> {
> = EventEmitter<any> & {
	_isShutdown: boolean,
	_messageQueue: Array<any>,
	_timeoutID: TimeoutID | nil,
	_wall: Wall,
	_wallUnlisten: Function | nil,
	send: (
		self: Bridge<OutgoingEvents, IncomingEvents>,
		eventName: EventName,
		...ElementType<OutgoingEvents, IncomingEvents>
	) -> (),
	shutdown: (self: Bridge<OutgoingEvents, IncomingEvents>) -> (),
	_flush: (self: Bridge<OutgoingEvents, IncomingEvents>) -> (),
	overrideValueAtPath: (
		self: Bridge<OutgoingEvents, IncomingEvents>,
		_ref: OverrideValueAtPath
	) -> (),
}

type Bridge_Statics = {
	new: (wall: Wall) -> Bridge<any, any>,
}

-- ROBLOX deviation: not sure where TimeoutID comes from in upstream
type TimeoutID = any
local Bridge: Bridge<any, any> & Bridge_Statics = setmetatable(
	{},
	{ __index = EventEmitter }
) :: any
local BridgeMetatable = { __index = Bridge }

function Bridge.new(wall: Wall)
	local self = setmetatable(EventEmitter.new() :: any, BridgeMetatable)

	-- ROBLOX deviation: initializers from class declaration
	self._isShutdown = false
	self._messageQueue = {} :: Array<Array<any>>
	self._timeoutID = nil
	-- _wall
	self._wallUnlisten = nil

	self._wall = wall
	self._wallUnlisten = wall.listen(function(message: Message)
		self:emit(message.event, message.payload)
	end) or nil

	-- Temporarily support older standalone front-ends sending commands to newer embedded backends.
	-- We do this because React Native embeds the React DevTools backend,
	-- but cannot control which version of the frontend users use.
	self:addListener("overrideValueAtPath", self.overrideValueAtPath)

	-- ROBLOX deviation: just expose wall as an instance field, instead of read-only property
	self.wall = wall

	return self
end

function Bridge:send(event: EventName, ...: ElementType<any, EventName>)
	local payload = { ... }
	if self._isShutdown then
		console.warn(
			string.format(
				'Cannot send message "%s" through a Bridge that has been shutdown.',
				event
			)
		)
		return
	end

	-- When we receive a message:
	-- - we add it to our queue of messages to be sent
	-- - if there hasn't been a message recently, we set a timer for 0 ms in
	--   the future, allowing all messages created in the same tick to be sent
	--   together
	-- - if there *has* been a message flushed in the last BATCH_DURATION ms
	--   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
	--   be set, and we'll simply add to the queue and wait for that
	table.insert(self._messageQueue, event)
	table.insert(self._messageQueue, payload)

	if not self._timeoutID then
		self._timeoutID = LuauPolyfill.setTimeout(function()
			self:_flush()
		end, 0)
	end
end

function Bridge:shutdown()
	if self._isShutdown then
		console.warn("Bridge was already shutdown.")
		return
	end

	-- Queue the shutdown outgoing message for subscribers.
	self:send("shutdown")

	-- Mark this bridge as destroyed, i.e. disable its public API.
	self._isShutdown = true

	-- Disable the API inherited from EventEmitter that can add more listeners and send more messages.
	-- $FlowFixMe This property is not writable.
	self.addListener = function() end
	-- $FlowFixMe This property is not writable.
	self.emit = function() end
	-- NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.

	-- Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.
	self:removeAllListeners()

	-- Stop accepting and emitting incoming messages from the wall.
	local wallUnlisten = self._wallUnlisten

	if wallUnlisten then
		wallUnlisten()
	end

	-- Synchronously flush all queued outgoing messages.
	-- At this step the subscribers' code may run in this call stack.
	repeat
		self:_flush()
	until #self._messageQueue == 0

	-- Make sure once again that there is no dangling timer.
	if self._timeoutID ~= nil then
		LuauPolyfill.clearTimeout(self._timeoutID)

		self._timeoutID = nil
	end
end

function Bridge:_flush(): ()
	-- This method is used after the bridge is marked as destroyed in shutdown sequence,
	-- so we do not bail out if the bridge marked as destroyed.
	-- It is a private method that the bridge ensures is only called at the right times.

	if self._timeoutID ~= nil then
		LuauPolyfill.clearTimeout(self._timeoutID)

		self._timeoutID = nil
	end
	if #self._messageQueue > 0 then
		-- ROBLOX deviation: Use a while loop instead of for loop to handle new insertions during the loop
		local i = 1
		while i < #self._messageQueue do
			self._wall.send(
				self._messageQueue[i],
				table.unpack(self._messageQueue[i + 1])
			)
			i += 2
		end
		table.clear(self._messageQueue)

		-- Check again for queued messages in BATCH_DURATION ms. This will keep
		-- flushing in a loop as long as messages continue to be added. Once no
		-- more are, the timer expires.
		self._timeoutID = LuauPolyfill.setTimeout(function()
			self:_flush()
		end, BATCH_DURATION)
	end
end

-- Temporarily support older standalone backends by forwarding "overrideValueAtPath" commands
-- to the older message types they may be listening to.
function Bridge:overrideValueAtPath(_ref: OverrideValueAtPath)
	local id, path, rendererID, type_, value =
		_ref.id, _ref.path, _ref.rendererID, _ref.type, _ref.value
	if type_ == "context" then
		self:send("overrideContext", {
			id = id,
			path = path,
			rendererID = rendererID,
			wasForwarded = true,
			value = value,
		})
	elseif type_ == "hooks" then
		self:send("overrideHookState", {
			id = id,
			path = path,
			rendererID = rendererID,
			wasForwarded = true,
			value = value,
		})
	elseif type_ == "props" then
		self:send("overrideProps", {
			id = id,
			path = path,
			rendererID = rendererID,
			wasForwarded = true,
			value = value,
		})
	elseif type_ == "state" then
		self:send("overrideState", {
			id = id,
			path = path,
			rendererID = rendererID,
			wasForwarded = true,
			value = value,
		})
	end
end

export type BackendBridge = Bridge<BackendEvents, FrontendEvents>
export type FrontendBridge = Bridge<FrontendEvents, BackendEvents>

return Bridge ]]
a2.Children._56291a6bc6ba23096cf9a524da5b1123=bT
local bU

local bV={ClassName="ModuleScript",Children={},Properties={}}
bV.Name="clipboardjs.mock"
bV.Properties.Source=[[ -- ROBLOX TODO: stub for clipboardjs, remove when we know how we'll handle its intent in a Roblox way
return {} ]]
a2.Children._a2e42ab986f09234a026bef87daf3673=bV
local bW

local bX={ClassName="ModuleScript",Children={},Properties={}}
bX.Name="constants"
bX.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/constants.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local exports = {}

-- Flip this flag to true to enable verbose console debug logging.
exports.__DEBUG__ = _G.__DEBUG__

exports.TREE_OPERATION_ADD = 1
exports.TREE_OPERATION_REMOVE = 2
exports.TREE_OPERATION_REORDER_CHILDREN = 3
exports.TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4

exports.LOCAL_STORAGE_FILTER_PREFERENCES_KEY = "React::DevTools::componentFilters"

exports.SESSION_STORAGE_LAST_SELECTION_KEY = "React::DevTools::lastSelection"

exports.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY =
	"React::DevTools::recordChangeDescriptions"

exports.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = "React::DevTools::reloadAndProfile"

exports.LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS =
	"React::DevTools::breakOnConsoleErrors"

exports.LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = "React::DevTools::appendComponentStack"

exports.LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = "React::DevTools::traceUpdatesEnabled"

exports.PROFILER_EXPORT_VERSION = 4

exports.CHANGE_LOG_URL =
	"https://github.com/facebook/react/blob/master/packages/react-devtools/CHANGELOG.md"

exports.UNSUPPORTED_VERSION_URL =
	"https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back"

-- HACK
--
-- Extracting during build time avoids a temporarily invalid state for the inline target.
-- Sometimes the inline target is rendered before root styles are applied,
-- which would result in e.g. NaN itemSize being passed to react-window list.
--
local COMFORTABLE_LINE_HEIGHT
local COMPACT_LINE_HEIGHT

-- ROBLOX deviation: we won't use the CSS, and don't have a bundler, so always use the 'fallback'
-- We can't use the Webpack loader syntax in the context of Jest,
-- so tests need some reasonably meaningful fallback value.
COMFORTABLE_LINE_HEIGHT = 15
COMPACT_LINE_HEIGHT = 10

exports.COMFORTABLE_LINE_HEIGHT = COMFORTABLE_LINE_HEIGHT
exports.COMPACT_LINE_HEIGHT = COMPACT_LINE_HEIGHT

return exports ]]
a2.Children._181b8146a5b769ba70c8c5ed9a8fac0d=bX
local bY

local bZ={ClassName="ModuleScript",Children={},Properties={}}
bZ.Name="devtools"
bZ.Properties.Source=[[ return {
	utils = require(script.utils),
	store = require(script.store),
	cache = require(script.cache),
	devtools = {
		Components = {
			views = {
				types = require(script.views.Components.types),
			},
		},
	},
} ]]
a2.Children._843273de1009291191f7d0f13e3d9d0a=bZ
local b_
local b0={ClassName="ModuleScript",Children={},Properties={}}
b0.Name="ProfilerStore"
b0.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map
local Set = LuauPolyfill.Set
local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Object = LuauPolyfill.Object
type Set<K> = LuauPolyfill.Set<K>

local EventEmitter = require(script.Parent.Parent.events)
type EventEmitter<T> = EventEmitter.EventEmitter<T>

local prepareProfilingDataFrontendFromBackendAndStore = require(
	script.Parent.views.Profiler.utils
).prepareProfilingDataFrontendFromBackendAndStore

local devtoolsTypes = require(script.Parent.types)
type ProfilingCache = devtoolsTypes.ProfilingCache
export type ProfilerStore = devtoolsTypes.ProfilerStore
type Store = devtoolsTypes.Store

local Bridge = require(script.Parent.Parent.bridge)
type FrontendBridge = Bridge.FrontendBridge

local backendTypes = require(script.Parent.Parent.backend.types)
type ProfilingDataBackend = backendTypes.ProfilingDataBackend

local profilerTypes = require(script.Parent.views.Profiler.types)
type CommitDataFrontend = profilerTypes.CommitDataFrontend
type ProfilingDataForRootFrontend = profilerTypes.ProfilingDataForRootFrontend
type ProfilingDataFrontend = profilerTypes.ProfilingDataFrontend
type SnapshotNode = profilerTypes.SnapshotNode

type ProfilerStore_statics = {
	new: (
		bridge: FrontendBridge,
		store: Store,
		defaultIsProfiling: boolean
	) -> ProfilerStore,
	__index: {},
}

local ProfilingCache = require(script.Parent.ProfilingCache)

local ProfilerStore: ProfilerStore & ProfilerStore_statics = (
	setmetatable({}, { __index = EventEmitter }) :: any
) :: ProfilerStore & ProfilerStore_statics
ProfilerStore.__index = ProfilerStore

function ProfilerStore.new(
	bridge: FrontendBridge,
	store: Store,
	defaultIsProfiling: boolean
): ProfilerStore
	local profilerStore: ProfilerStore =
		setmetatable(EventEmitter.new() :: any, ProfilerStore)
	profilerStore._dataBackends = {}
	profilerStore._dataFrontend = nil
	profilerStore._initialRendererIDs = Set.new()
	profilerStore._initialSnapshotsByRootID = Map.new()
	profilerStore._inProgressOperationsByRootID = Map.new()
	profilerStore._isProfiling = defaultIsProfiling
	profilerStore._rendererIDsThatReportedProfilingData = Set.new()
	profilerStore._rendererQueue = Set.new()
	profilerStore._bridge = bridge
	profilerStore._store = store

	function profilerStore:_takeProfilingSnapshotRecursive(
		elementID: number,
		profilingSnapshots: Map<number, SnapshotNode>
	)
		local element = self._store:getElementByID(elementID)
		if element ~= nil then
			local snapshotNode: SnapshotNode = {
				id = elementID,
				children = Array.slice(element.children, 0),
				displayName = element.displayName,
				hocDisplayNames = element.hocDisplayNames,
				key = element.key,
				type = element.type,
			}
			profilingSnapshots:set(elementID, snapshotNode)
			Array.forEach(element.children, function(childID)
				return self:_takeProfilingSnapshotRecursive(childID, profilingSnapshots)
			end)
		end
	end
	function profilerStore:onBridgeOperations(operations: Array<number>)
		-- The first two values are always rendererID and rootID
		local rendererID = operations[
			1 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]
		local rootID = operations[
			2 --\[\[ ROBLOX adaptation: added 1 to array index \]\]
		]
		if self._isProfiling then
			local profilingOperations = self._inProgressOperationsByRootID:get(rootID)
			if profilingOperations == nil then
				profilingOperations = { operations }
				-- ROBLOX FIXME Luau: nil-ability always remove due to assignment if nil
				self._inProgressOperationsByRootID:set(
					rootID,
					profilingOperations :: Array<Array<number>>
				)
			else
				table.insert(profilingOperations, operations)
			end

			if not self._initialRendererIDs:has(rendererID) then
				self._initialRendererIDs:add(rendererID)
			end

			if not self._initialSnapshotsByRootID:has(rootID) then
				self._initialSnapshotsByRootID:set(rootID, Map.new())
			end
			self._rendererIDsThatReportedProfilingData:add(rendererID)
		end
	end
	function profilerStore:onBridgeProfilingData(dataBackend: ProfilingDataBackend)
		if self._isProfiling then
			-- This should never happen, but if it does- ignore previous profiling data.
			return
		end
		local rendererID = dataBackend.rendererID
		if not self._rendererQueue:has(rendererID) then
			error(
				string.format(
					'Unexpected profiling data update from renderer "%s"',
					tostring(rendererID)
				)
			)
		end
		table.insert(self._dataBackends, dataBackend)
		self._rendererQueue:delete(rendererID)
		if self._rendererQueue.size == 0 then
			self._dataFrontend = prepareProfilingDataFrontendFromBackendAndStore(
				self._dataBackends,
				self._inProgressOperationsByRootID,
				self._initialSnapshotsByRootID
			)
			Array.splice(self._dataBackends, 0)
			self:emit("isProcessingData")
		end
	end
	function profilerStore:onBridgeShutdown()
		self._bridge:removeListener("operations", self.onBridgeOperations)
		self._bridge:removeListener("profilingData", self.onBridgeProfilingData)
		self._bridge:removeListener("profilingStatus", self.onProfilingStatus)
		self._bridge:removeListener("shutdown", self.onBridgeShutdown)
	end
	function profilerStore:onProfilingStatus(isProfiling: boolean)
		if isProfiling then
			Array.splice(self._dataBackends, 0)
			self._dataFrontend = nil
			self._initialRendererIDs:clear()
			self._initialSnapshotsByRootID:clear()
			self._inProgressOperationsByRootID:clear()
			self._rendererIDsThatReportedProfilingData:clear()
			self._rendererQueue:clear()
			-- Record all renderer IDs initially too (in case of unmount)
			-- eslint-disable-next-line no-for-of-loops/no-for-of-loops
			for _, rendererID in self._store:getRootIDToRendererID() do
				if not self._initialRendererIDs:has(rendererID) then
					self._initialRendererIDs:add(rendererID)
				end
			end
			-- Record snapshot of tree at the time profiling is started.
			-- This info is required to handle cases of e.g. nodes being removed during profiling.
			for _, rootID in self._store:getRoots() do
				local profilingSnapshots = Map.new()
				self._initialSnapshotsByRootID:set(rootID, profilingSnapshots)
				self:_takeProfilingSnapshotRecursive(rootID, profilingSnapshots)
			end
		end
		if self._isProfiling ~= isProfiling then
			self._isProfiling = isProfiling -- Invalidate suspense cache if profiling data is being (re-)recorded.
			-- Note that we clear again, in case any views read from the cache while profiling.
			-- (That would have resolved a now-stale value without any profiling data.)
			self._cache:invalidate()
			self:emit("isProfiling") -- If we've just finished a profiling session, we need to fetch data stored in each renderer interface
			-- and re-assemble it on the front-end into a format (ProfilingDataFrontend) that can power the Profiler UI.
			-- During this time, DevTools UI should probably not be interactive.
			if not isProfiling then
				Array.splice(self._dataBackends, 0)
				self._rendererQueue:clear() -- Only request data from renderers that actually logged it.
				-- This avoids unnecessary bridge requests and also avoids edge case mixed renderer bugs.
				-- (e.g. when v15 and v16 are both present)
				for _, rendererID in self._rendererIDsThatReportedProfilingData do
					if not self._rendererQueue:has(rendererID) then
						self._rendererQueue:add(rendererID)
						self._bridge:send("getProfilingData", {
							rendererID = rendererID,
						})
					end
				end
				self:emit("isProcessingData")
			end
		end
	end

	bridge:addListener("operations", function(...)
		return profilerStore:onBridgeOperations(...)
	end)
	bridge:addListener("profilingData", function(...)
		return profilerStore:onBridgeProfilingData(...)
	end)
	bridge:addListener("profilingStatus", function(...)
		return profilerStore:onProfilingStatus(...)
	end)
	bridge:addListener("shutdown", function(...)
		return profilerStore:onBridgeShutdown(...)
	end)

	-- It's possible that profiling has already started (e.g. "reload and start profiling")
	-- so the frontend needs to ask the backend for its status after mounting.
	bridge:send("getProfilingStatus")
	profilerStore._cache = ProfilingCache.new(profilerStore)

	return profilerStore
end
function ProfilerStore:getCommitData(
	rootID: number,
	commitIndex: number
): CommitDataFrontend
	if self._dataFrontend ~= nil then
		local dataForRoot = self._dataFrontend.dataForRoots:get(rootID)
		if dataForRoot ~= nil then
			local commitDatum = dataForRoot.commitData[commitIndex]
			if commitDatum ~= nil then
				return commitDatum
			end
		end
	end
	error(
		string.format(
			'Could not find commit data for root "%s" and commit %s',
			tostring(rootID),
			tostring(commitIndex)
		)
	)
end
function ProfilerStore:getDataForRoot(rootID: number): ProfilingDataForRootFrontend
	if self._dataFrontend ~= nil then
		local dataForRoot = self._dataFrontend.dataForRoots:get(rootID)
		if dataForRoot ~= nil then
			return dataForRoot
		end
	end
	error(string.format('Could not find commit data for root "%s"', tostring(rootID)))
end
function ProfilerStore:didRecordCommits(): boolean
	return self._dataFrontend ~= nil and self._dataFrontend.dataForRoots.size > 0
end
function ProfilerStore:isProcessingData(): boolean
	return self._rendererQueue.size > 0 or #self._dataBackends > 0
end
function ProfilerStore:isProfiling(): boolean
	return self._isProfiling
end
function ProfilerStore:profilingCache(): ProfilingCache
	return self._cache
end
function ProfilerStore:profilingData(
	value: ProfilingDataFrontend | nil
): (...ProfilingDataFrontend?)
	if value == nil then
		return self._dataFrontend
	end

	if self._isProfiling then
		console.warn("Profiling data cannot be updated while profiling is in progress.")
		return
	end
	Array.splice(self._dataBackends, 0)
	self._dataFrontend = value
	self._initialRendererIDs:clear()
	self._initialSnapshotsByRootID:clear()
	self._inProgressOperationsByRootID:clear()
	self._cache:invalidate()
	self:emit("profilingData")
	return
end
function ProfilerStore:clear(): (...any?)
	Array.splice(self._dataBackends, 0)
	self._dataFrontend = nil
	self._initialRendererIDs:clear()
	self._initialSnapshotsByRootID:clear()
	self._inProgressOperationsByRootID:clear()
	self._rendererQueue:clear() -- Invalidate suspense cache if profiling data is being (re-)recorded.
	-- Note that we clear now because any existing data is "stale".
	self._cache:invalidate()
	self:emit("profilingData")
end
function ProfilerStore:startProfiling(): (...any?)
	self._bridge:send("startProfiling", self._store:getRecordChangeDescriptions()) -- Don't actually update the local profiling boolean yet!
	-- Wait for onProfilingStatus() to confirm the status has changed.
	-- This ensures the frontend and backend are in sync wrt which commits were profiled.
	-- We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.
end
function ProfilerStore:stopProfiling(): (...any?)
	self._bridge:send("stopProfiling") -- Don't actually update the local profiling boolean yet!
	-- Wait for onProfilingStatus() to confirm the status has changed.
	-- This ensures the frontend and backend are in sync wrt which commits were profiled.
	-- We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.
end

return ProfilerStore ]]
b_.Children._188ccab8f5e0b9267a1c6be41aec5aa1=b0
local b1

local b2={ClassName="ModuleScript",Children={},Properties={}}
b2.Name="ProfilingCache"
b2.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<T> = LuauPolyfill.Array<T>

local ProfilerViews = script.Parent.views.Profiler

local CommitTreeBuilderModule = require(ProfilerViews.CommitTreeBuilder)
local getCommitTree = CommitTreeBuilderModule.getCommitTree
local invalidateCommitTrees = CommitTreeBuilderModule.invalidateCommitTrees

local FlamegraphChartBuilderModule = require(ProfilerViews.FlamegraphChartBuilder)
local getFlamegraphChartData = FlamegraphChartBuilderModule.getChartData
local invalidateFlamegraphChartData = FlamegraphChartBuilderModule.invalidateChartData

local InteractionsChartBuilderModule = require(ProfilerViews.InteractionsChartBuilder)
local getInteractionsChartData = InteractionsChartBuilderModule.getChartData
local invalidateInteractionsChartData = InteractionsChartBuilderModule.invalidateChartData

local RankedChartBuilderModule = require(ProfilerViews.RankedChartBuilder)
local getRankedChartData = RankedChartBuilderModule.getChartData
local invalidateRankedChartData = RankedChartBuilderModule.invalidateChartData

local typesModule = require(ProfilerViews.types)
type CommitTree = typesModule.CommitTree

type FlamegraphChartData = FlamegraphChartBuilderModule.ChartData
type InteractionsChartData = InteractionsChartBuilderModule.ChartData
type RankedChartData = RankedChartBuilderModule.ChartData

local devtoolsTypes = require(script.Parent.types)
type ProfilingCache = devtoolsTypes.ProfilingCache
type ProfilerStore = devtoolsTypes.ProfilerStore

type ProfilingCache_statics = { new: (profilerStore: ProfilerStore) -> ProfilingCache }

local ProfilingCache = {} :: ProfilingCache & ProfilingCache_statics;
(ProfilingCache :: any).__index = ProfilingCache

function ProfilingCache.new(profilerStore: ProfilerStore): ProfilingCache
	local profilingCache: ProfilingCache = (
		setmetatable({}, ProfilingCache) :: any
	) :: ProfilingCache
	profilingCache._fiberCommits = Map.new()
	profilingCache._profilerStore = profilerStore

	function profilingCache:getCommitTree(ref: { commitIndex: number, rootID: number })
		local commitIndex, rootID = ref.commitIndex, ref.rootID
		return getCommitTree({
			commitIndex = commitIndex,
			profilerStore = self._profilerStore,
			rootID = rootID,
		})
	end
	function profilingCache:getFiberCommits(
		ref: { fiberID: number, rootID: number }
	): Array<number>
		local fiberID, rootID = ref.fiberID, ref.rootID
		local cachedFiberCommits = self._fiberCommits:get(fiberID)
		if cachedFiberCommits ~= nil then
			return cachedFiberCommits
		end
		local fiberCommits = {} :: Array<number>
		local dataForRoot = self._profilerStore:getDataForRoot(rootID)
		Array.forEach(dataForRoot.commitData, function(commitDatum, commitIndex)
			if commitDatum.fiberActualDurations:has(fiberID) then
				table.insert(fiberCommits, commitIndex)
			end
		end)
		self._fiberCommits:set(fiberID, fiberCommits)
		return fiberCommits
	end
	function profilingCache:getFlamegraphChartData(ref: {
		commitIndex: number,
		commitTree: CommitTree,
		rootID: number,
	}): FlamegraphChartData
		local commitIndex, commitTree, rootID =
			ref.commitIndex, ref.commitTree, ref.rootID
		return getFlamegraphChartData({
			commitIndex = commitIndex,
			commitTree = commitTree,
			profilerStore = self._profilerStore,
			rootID = rootID,
		})
	end
	function profilingCache:getInteractionsChartData(
		ref: { rootID: number }
	): InteractionsChartData
		local rootID = ref.rootID
		return getInteractionsChartData({
			profilerStore = self._profilerStore,
			rootID = rootID,
		})
	end
	function profilingCache:getRankedChartData(ref: {
		commitIndex: number,
		commitTree: CommitTree,
		rootID: number,
	}): RankedChartData
		local commitIndex, commitTree, rootID =
			ref.commitIndex, ref.commitTree, ref.rootID
		return getRankedChartData({
			commitIndex = commitIndex,
			commitTree = commitTree,
			profilerStore = self._profilerStore,
			rootID = rootID,
		})
	end

	return profilingCache
end
function ProfilingCache:invalidate()
	self._fiberCommits:clear()
	invalidateCommitTrees()
	invalidateFlamegraphChartData()
	invalidateInteractionsChartData()
	invalidateRankedChartData()
end

return ProfilingCache ]]
b_.Children._96c3c06ffe6b6ddf2a5433adbbe470d5=b2
local b3

local b4={ClassName="ModuleScript",Children={},Properties={}}
b4.Name="cache"
b4.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/devtools/cache.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
type Map<K, V> = LuauPolyfill.Map<K, V>
local WeakMap = LuauPolyfill.WeakMap
type WeakMap<K, V> = LuauPolyfill.WeakMap<K, V>

local ReactTypes = require(Packages.Shared)
export type Thenable<R> = ReactTypes.Thenable<R>

local React = require(Packages.React)
local createContext = React.createContext

-- Cache implementation was forked from the React repo:
-- https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js
--
-- This cache is simpler than react-cache in that:
-- 1. Individual items don't need to be invalidated.
--    Profiling data is invalidated as a whole.
-- 2. We didn't need the added overhead of an LRU cache.
--    The size of this cache is bounded by how many renders were profiled,
--    and it will be fully reset between profiling sessions.

-- ROBLOX deviation START: Suspender needs a generic param to be type compatible with Thenable
export type Suspender<R = any> = {
	andThen: <U>(
		self: Thenable<R>,
		onFulfill: (R) -> () | U,
		onReject: (error: any) -> () | U
	) -> (),
}
-- ROBLOX deviation END

type PendingResult = {
	status: number, -- ROBLOX TODO: Luau doesn't support literal: 0
	value: Suspender,
}

type ResolvedResult<Value> = {
	status: number, -- ROBLOX TODO: Luau doesn't support literal: 1
	value: Value,
}

type RejectedResult = {
	status: number, -- ROBLOX TODO: Luau doesn't support literal: 2
	value: any,
}

type Result<Value> = PendingResult | ResolvedResult<Value> | RejectedResult

export type Resource<Input, Key, Value> = {
	clear: () -> (),
	invalidate: (Key) -> (),
	read: (Input) -> Value,
	preload: (Input) -> (),
	write: (Key, Value) -> (),
}

local Pending = 0
local Resolved = 1
local Rejected = 2

local ReactCurrentDispatcher =
	React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher

local function readContext(Context, observedBits: boolean?)
	local dispatcher = ReactCurrentDispatcher.current
	if dispatcher == nil then
		error(
			Error.new(
				"react-cache: read and preload may only be called from within a "
					.. "component's render. They are not supported in event handlers or "
					.. "lifecycle methods."
			)
		)
	end
	assert(dispatcher ~= nil, "assert needed until Luau understands if nil then error()")
	return dispatcher.readContext(Context, observedBits)
end

local CacheContext = createContext(nil)

type Config = { useWeakMap: boolean? }

-- ROBLOX deviation START: only use WeakMap
local entries: Map<Resource<any, any, any>, WeakMap<any, any>> = Map.new()
local resourceConfigs: Map<Resource<any, any, any>, Config> = Map.new()

local function getEntriesForResource(resource: any): WeakMap<any, any>
	local entriesForResource = entries:get(resource) :: WeakMap<any, any>
	if entriesForResource == nil then
		-- ROBLOX deviation START: skip the check and just use WeakMap
		-- local config = resourceConfigs:get(resource)
		entriesForResource = WeakMap.new()
		-- ROBLOX deviation END

		entries:set(resource, entriesForResource :: WeakMap<any, any>)
	end

	return entriesForResource :: WeakMap<any, any>
end
-- ROBLOX deviation END

local function accessResult<Input, Key, Value>(
	resource: any,
	fetch: (Input) -> Thenable<Value>,
	input: Input,
	key: Key
): Result<Value>
	local entriesForResource = getEntriesForResource(resource)
	local entry = entriesForResource:get(key)

	if entry == nil then
		local thenable = fetch(input)

		local newResult: PendingResult

		thenable:andThen(function(value)
			if newResult.status == Pending then
				local resolvedResult: ResolvedResult<Value> = newResult :: any

				resolvedResult.status = Resolved
				resolvedResult.value = value
			end
			-- ROBLOX deviation START: explicit return type
			-- end, function(error_)
		end, function(error_): ()
			-- ROBLOX deviation END
			if newResult.status == Pending then
				local rejectedResult: RejectedResult = newResult :: any

				rejectedResult.status = Rejected
				rejectedResult.value = error_
			end
		end)

		newResult = {
			status = Pending,
			-- ROBLOX deviation START: needs cast
			-- value = thenable,
			value = thenable :: any,
			-- ROBLOX deviation END
		}
		entriesForResource:set(key, newResult)
		return newResult
	else
		return entry
	end
end

local exports = {}

exports.createResource = function<Input, Key, Value>(
	fetch: (Input) -> Thenable<Value>,
	hashInput: (Input) -> Key,
	_config: Config?
): Resource<Input, Key, Value>
	local config = _config or {}
	-- ROBLOX deviation: define before reference
	local resource
	resource = {
		clear = function(): ()
			entries[resource] = nil
		end,
		invalidate = function(key: Key): ()
			local entriesForResource = getEntriesForResource(resource)
			entriesForResource[key] = nil
		end,
		read = function(input: Input): Value
			readContext(CacheContext)
			local key = hashInput(input)
			local result: Result<Value> = accessResult(resource, fetch, input, key)
			if result.status == Pending then
				error(result.value)
			elseif result.status == Resolved then
				return result.value
			elseif result.status == Rejected then
				error(result.value)
			else
				-- Should be unreachable
				return nil :: any
			end
		end,
		preload = function(input: Input): ()
			readContext(CacheContext)

			local key = hashInput(input)
			accessResult(resource, fetch, input, key)
		end,
		write = function(key: Key, value: Value): ()
			local entriesForResource = getEntriesForResource(resource)
			local resolvedResult: ResolvedResult<Value> = {
				status = Resolved,
				value = value,
			}

			entriesForResource:set(key, resolvedResult)
		end,
	}

	resourceConfigs:set(resource, config)

	return resource
end

exports.invalidateResources = function(): ()
	entries:clear()
end

return exports ]]
b_.Children._b3b58d7aa804071ec6403518d008c007=b4
local b5

local b6={ClassName="ModuleScript",Children={},Properties={}}
b6.Name="store"
b6.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/devtools/store.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set

type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Object = LuauPolyfill.Object
type Set<K> = LuauPolyfill.Set<K>
local console = require(Packages.Shared).console

local EventEmitter = require(script.Parent.Parent.events)
type EventEmitter<T> = EventEmitter.EventEmitter<T>
local constants = require(script.Parent.Parent.constants)
local TREE_OPERATION_ADD = constants.TREE_OPERATION_ADD
local TREE_OPERATION_REMOVE = constants.TREE_OPERATION_REMOVE
local TREE_OPERATION_REORDER_CHILDREN = constants.TREE_OPERATION_REORDER_CHILDREN
local TREE_OPERATION_UPDATE_TREE_BASE_DURATION =
	constants.TREE_OPERATION_UPDATE_TREE_BASE_DURATION
local types = require(script.Parent.Parent.types)
local ElementTypeRoot = types.ElementTypeRoot
local utils = require(script.Parent.Parent.utils)
local getSavedComponentFilters = utils.getSavedComponentFilters
local saveComponentFilters = utils.saveComponentFilters
local separateDisplayNameAndHOCs = utils.separateDisplayNameAndHOCs
local shallowDiffers = utils.shallowDiffers
-- ROBLOX deviation: don't use string encoding
-- local utfDecodeString = utils.utfDecodeString
local storage = require(script.Parent.Parent.storage)
local localStorageGetItem = storage.localStorageGetItem
local localStorageSetItem = storage.localStorageSetItem
local __DEBUG__ = constants.__DEBUG__

local ProfilerStore = require(script.Parent.ProfilerStore)
type ProfilerStore = ProfilerStore.ProfilerStore

local ComponentsTypes = require(script.Parent.Parent.devtools.views.Components.types)
type Element = ComponentsTypes.Element
local Types = require(script.Parent.Parent.types)
type ComponentFilter = Types.ComponentFilter
type ElementType = Types.ElementType
local Bridge = require(script.Parent.Parent.bridge)
type FrontendBridge = Bridge.FrontendBridge

local devtoolsTypes = require(script.Parent.types)
type Store = devtoolsTypes.Store
type Capabilities = devtoolsTypes.Capabilities

local debug_ = function(methodName, ...)
	if __DEBUG__ then
		print("Store", methodName, ...)
	end
end

local LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY =
	"React::DevTools::collapseNodesByDefault"
local LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY =
	"React::DevTools::recordChangeDescriptions"

type Config = {
	isProfiling: boolean?,
	supportsNativeInspection: boolean?,
	supportsReloadAndProfile: boolean?,
	supportsProfiling: boolean?,
	supportsTraceUpdates: boolean?,
}

-- /**
--  * The store is the single source of truth for updates from the backend.
--  * ContextProviders can subscribe to the Store for specific things they want to provide.
--  */

-- ROBLOX deviation: equivalent of sub-class
type Store_static = {
	new: (bridge: FrontendBridge, config: Config?) -> Store,
}
local Store: Store & Store_static = (
	setmetatable({}, { __index = EventEmitter }) :: any
) :: Store & Store_static
local StoreMetatable = { __index = Store }

function Store.new(bridge: FrontendBridge, config: Config?): Store
	local self = setmetatable(EventEmitter.new() :: any, StoreMetatable) :: any
	config = config or {}

	-- ROBLOX deviation: define fields in constructor
	self._bridge = bridge

	-- Should new nodes be collapsed by default when added to the tree?
	self._collapseNodesByDefault = true

	self._componentFilters = {}

	-- At least one of the injected renderers contains (DEV only) owner metadata.
	self._hasOwnerMetadata = false

	-- Map of ID to (mutable) Element.
	-- Elements are mutated to avoid excessive cloning during tree updates.
	-- The InspectedElementContext also relies on this mutability for its WeakMap usage.
	self._idToElement = Map.new() :: Map<number, Element>

	-- Should the React Native style editor panel be shown?
	self._isNativeStyleEditorSupported = false

	-- Can the backend use the Storage API (e.g. localStorage)?
	-- If not, features like reload-and-profile will not work correctly and must be disabled.
	self._isBackendStorageAPISupported = false

	self._nativeStyleEditorValidAttributes = nil

	-- Map of element (id) to the set of elements (ids) it owns.
	-- This map enables getOwnersListForElement() to avoid traversing the entire tree.
	self._ownersMap = Map.new() :: Map<number, Set<number>>

	self._recordChangeDescriptions = false

	-- Incremented each time the store is mutated.
	-- This enables a passive effect to detect a mutation between render and commit phase.
	self._revision = 0

	-- This Array must be treated as immutable!
	-- Passive effects will check it for changes between render and mount.
	self._roots = {} :: Array<number>

	self._rootIDToCapabilities = Map.new() :: Map<number, Capabilities>

	-- Renderer ID is needed to support inspection fiber props, state, and hooks.
	self._rootIDToRendererID = Map.new() :: Map<number, number>

	-- These options may be initially set by a confiugraiton option when constructing the Store.
	-- In the case of "supportsProfiling", the option may be updated based on the injected renderers.
	self._supportsNativeInspection = true
	self._supportsProfiling = false
	self._supportsReloadAndProfile = false
	self._supportsTraceUpdates = false

	self._unsupportedRendererVersionDetected = false

	-- Total number of visible elements (within all roots).
	-- Used for windowing purposes.
	self._weightAcrossRoots = 0

	if __DEBUG__ then
		debug_("constructor", "subscribing to Bridge")
	end

	self._collapseNodesByDefault = localStorageGetItem(
		LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY
	) == "true"

	self._recordChangeDescriptions = localStorageGetItem(
		LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY
	) == "true"

	self._componentFilters = getSavedComponentFilters()

	local isProfiling = false
	if config ~= nil then
		isProfiling = (config :: Config).isProfiling == true

		local supportsNativeInspection = (config :: Config).supportsNativeInspection
		local supportsProfiling = (config :: Config).supportsProfiling
		local supportsReloadAndProfile = (config :: Config).supportsReloadAndProfile
		local supportsTraceUpdates = (config :: Config).supportsTraceUpdates

		self._supportsNativeInspection = supportsNativeInspection ~= false
		if supportsProfiling then
			self._supportsProfiling = true
		end
		if supportsReloadAndProfile then
			self._supportsReloadAndProfile = true
		end
		if supportsTraceUpdates then
			self._supportsTraceUpdates = true
		end
	end

	self._profilerStore = ProfilerStore.new(bridge, self, isProfiling)

	-- ROBLOX deviation: bind methods which don't pass self to this instance
	self._onBridgeOperations = self.onBridgeOperations
	self.onBridgeOperations = function(...)
		self:_onBridgeOperations(...)
	end
	self._onBridgeOverrideComponentFilters = self.onBridgeOverrideComponentFilters
	self.onBridgeOverrideComponentFilters = function(...)
		self:_onBridgeOverrideComponentFilters(...)
	end
	self._onBridgeShutdown = self.onBridgeShutdown
	self.onBridgeShutdown = function(...)
		self:_onBridgeShutdown(...)
	end
	self._onBridgeStorageSupported = self.onBridgeStorageSupported
	self.onBridgeStorageSupported = function(...)
		self:_onBridgeStorageSupported(...)
	end
	self._onBridgeNativeStyleEditorSupported = self.onBridgeNativeStyleEditorSupported
	self.onBridgeNativeStyleEditorSupported = function(...)
		self:_onBridgeNativeStyleEditorSupported(...)
	end
	self._onBridgeUnsupportedRendererVersion = self.onBridgeUnsupportedRendererVersion
	self.onBridgeUnsupportedRendererVersion = function(...)
		self:_onBridgeUnsupportedRendererVersion(...)
	end

	bridge:addListener("operations", self.onBridgeOperations)
	bridge:addListener("overrideComponentFilters", self.onBridgeOverrideComponentFilters)
	bridge:addListener("shutdown", self.onBridgeShutdown)
	bridge:addListener("isBackendStorageAPISupported", self.onBridgeStorageSupported)
	bridge:addListener(
		"isNativeStyleEditorSupported",
		self.onBridgeNativeStyleEditorSupported
	)
	bridge:addListener(
		"unsupportedRendererVersion",
		self.onBridgeUnsupportedRendererVersion
	)

	return self
end

-- This is only used in tests to avoid memory leaks.
function Store:assertExpectedRootMapSizes()
	if #self._roots == 0 then
		-- The only safe time to assert these maps are empty is when the store is empty.
		self:assertMapSizeMatchesRootCount(self._idToElement, "_idToElement")
		self:assertMapSizeMatchesRootCount(self._ownersMap, "_ownersMap")
	end

	-- These maps should always be the same size as the number of roots
	self:assertMapSizeMatchesRootCount(
		self._rootIDToCapabilities,
		"_rootIDToCapabilities"
	)
	self:assertMapSizeMatchesRootCount(self._rootIDToRendererID, "_rootIDToRendererID")
end

-- This is only used in tests to avoid memory leaks.
function Store:assertMapSizeMatchesRootCount(map: Map<any, any>, mapName: string)
	local expectedSize = #self._roots
	if map.size ~= expectedSize then
		error(
			Error.new(
				string.format(
					"Expected %s to contain %s items, but it contains %s items\n\n%s",
					mapName,
					tostring(expectedSize),
					tostring(map.size),
					inspect(map, { depth = 20 })
				)
			)
		)
	end
end

-- ROBLOX deviation: get / setters not supported in luau
function Store:getCollapseNodesByDefault(): boolean
	return self._collapseNodesByDefault
end

function Store:setCollapseNodesByDefault(value: boolean)
	self._collapseNodesByDefault = value

	localStorageSetItem(
		LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY,
		if value then "true" else "false"
	)
	self:emit("collapseNodesByDefault")
end
function Store:getComponentFilters(): Array<ComponentFilter>
	return self._componentFilters
end

function Store:setComponentFilters(value: Array<ComponentFilter>): ()
	if self._profilerStore:isProfiling() then
		-- Re-mounting a tree while profiling is in progress might break a lot of assumptions.
		-- If necessary, we could support this- but it doesn't seem like a necessary use case.
		error("Cannot modify filter preferences while profiling")
	end

	-- Filter updates are expensive to apply (since they impact the entire tree).
	-- Let's determine if they've changed and avoid doing this work if they haven't.
	local prevEnabledComponentFilters = Array.filter(
		self._componentFilters,
		function(filter)
			return filter.isEnabled
		end
	)
	local nextEnabledComponentFilters = Array.filter(value, function(filter)
		return filter.isEnabled
	end)
	local haveEnabledFiltersChanged = #prevEnabledComponentFilters
		~= #nextEnabledComponentFilters

	if not haveEnabledFiltersChanged then
		-- ROBLOX deviation: 1-indexing use 1 not 0
		for i = 1, #nextEnabledComponentFilters do
			local prevFilter = prevEnabledComponentFilters[i]
			local nextFilter = nextEnabledComponentFilters[i]

			if shallowDiffers(prevFilter, nextFilter) then
				haveEnabledFiltersChanged = true
				break
			end
		end
	end

	self._componentFilters = value

	-- Update persisted filter preferences stored in localStorage.
	saveComponentFilters(value)

	-- Notify the renderer that filter prefernces have changed.
	-- This is an expensive opreation; it unmounts and remounts the entire tree,
	-- so only do it if the set of enabled component filters has changed.
	if haveEnabledFiltersChanged then
		self._bridge:send("updateComponentFilters", value)
	end

	self:emit("componentFilters")
end
function Store:getHasOwnerMetadata(): boolean
	return self._hasOwnerMetadata
end
function Store:getNativeStyleEditorValidAttributes(): Array<string> | nil
	return self._nativeStyleEditorValidAttributes
end
function Store:getNumElements(): number
	return self._weightAcrossRoots
end
function Store:getProfilerStore(): ProfilerStore
	return self._profilerStore
end
function Store:getRecordChangeDescriptions(): boolean
	return self._recordChangeDescriptions
end
function Store:setRecordChangeDescriptions(value: boolean): ()
	self._recordChangeDescriptions = value

	localStorageSetItem(
		LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY,
		if value then "true" else "false"
	)
	self:emit("recordChangeDescriptions")
end
function Store:getRevision(): number
	return self._revision
end
function Store:getRootIDToRendererID(): Map<number, number>
	return self._rootIDToRendererID
end
function Store:getRoots(): Array<number>
	return self._roots
end
function Store:getSupportsNativeInspection(): boolean
	return self._supportsNativeInspection
end
function Store:getSupportsNativeStyleEditor(): boolean
	return self._isNativeStyleEditorSupported
end
function Store:getSupportsProfiling(): boolean
	return self._supportsProfiling
end
function Store:getSupportsReloadAndProfile(): boolean
	return self._supportsReloadAndProfile and self._isBackendStorageAPISupported
end
function Store:getSupportsTraceUpdates(): boolean
	return self._supportsTraceUpdates
end
function Store:getUnsupportedRendererVersionDetected(): boolean
	return self._unsupportedRendererVersionDetected
end
function Store:containsElement(id: number): boolean
	return self._idToElement:get(id) ~= nil
end
function Store:getElementAtIndex(index: number): Element?
	if index < 0 or index >= self:getNumElements() then
		console.warn(
			string.format(
				"Invalid index %d specified; store contains %d items.",
				index,
				self:getNumElements()
			)
		)
		return nil
	end

	-- Find which root this element is in...
	local rootID
	local root
	local rootWeight = 0

	-- ROBLOX deviation: 1-indexing use 1 not 0
	for i = 1, #self._roots do
		rootID = self._roots[i]
		root = (self._idToElement:get(rootID) :: any) :: Element
		if #root.children == 0 then
			continue
		elseif rootWeight + root.weight > index then
			break
		else
			rootWeight += root.weight
		end
	end

	-- Find the element in the tree using the weight of each node...
	-- Skip over the root itself, because roots aren't visible in the Elements tree.
	local currentElement = (root :: any) :: Element
	local currentWeight = rootWeight - 1

	while index ~= currentWeight do
		local numChildren = #currentElement.children

		for i = 1, numChildren do
			local childID = currentElement.children[i]
			local child = (self._idToElement:get(childID) :: any) :: Element
			local childWeight = if child.isCollapsed then 1 else child.weight

			if index <= currentWeight + childWeight then
				currentWeight += 1
				currentElement = child
				break
			else
				currentWeight += childWeight
			end
		end
	end
	return currentElement or nil
end

function Store:getElementIDAtIndex(index: number): number | nil
	local element: Element? = self:getElementAtIndex(index)

	return (function(): number?
		if element == nil then
			return nil
		end
		return (element :: Element).id
	end)()
end
function Store:getElementByID(id: number): Element | nil
	local element = self._idToElement:get(id)

	if element == nil then
		console.warn(string.format('No element found with id "%s"', tostring(id)))
		return nil
	end

	return element
end
function Store:getIndexOfElementID(id: number): number | nil
	local element: Element? = self:getElementByID(id)

	if element == nil or (element :: Element).parentID == 0 then
		return nil
	end

	-- Walk up the tree to the root.
	-- Increment the index by one for each node we encounter,
	-- and by the weight of all nodes to the left of the current one.
	-- This should be a relatively fast way of determining the index of a node within the tree.
	local previousID = id
	local currentID = (element :: Element).parentID
	local index = 0

	while true do
		local current = (self._idToElement:get(currentID) :: any) :: Element
		local children = current.children

		for i = 1, #children do
			local childID = children[i]
			if childID == previousID then
				break
			end

			local child = (self._idToElement:get(childID) :: any) :: Element
			index += if child.isCollapsed then 1 else child.weight
		end

		-- We found the root; stop crawling.
		if current.parentID == 0 then
			break
		end

		index += 1
		previousID = current.id
		currentID = current.parentID
	end

	-- At this point, the current ID is a root (from the previous loop).
	-- We also need to offset the index by previous root weights.
	for i = 1, #self._roots do
		local rootID = self._roots[i]
		if rootID == currentID then
			break
		end
		local root = (self._idToElement:get(rootID) :: any) :: Element
		index += root.weight
	end

	return index
end

function Store:getOwnersListForElement(ownerID: number): Array<Element>
	local list = {}
	local element = self._idToElement:get(ownerID)
	if element ~= nil then
		table.insert(list, Object.assign({}, element, { depth = 0 }))

		local unsortedIDs = self._ownersMap:get(ownerID)

		-- ROBLOX FIXME Luau: without manual annotation: Types Set and nil cannot be compared with ~= because they do not have the same metatable
		if unsortedIDs ~= nil then
			local depthMap: Map<number, number> = Map.new({ { ownerID, 0 } })

			-- Items in a set are ordered based on insertion.
			-- This does not correlate with their order in the tree.
			-- So first we need to order them.
			-- I wish we could avoid this sorting operation; we could sort at insertion time,
			-- but then we'd have to pay sorting costs even if the owners list was never used.
			-- Seems better to defer the cost, since the set of ids is probably pretty small.
			local sortedIDs = Array.sort(
				Array.from(unsortedIDs),
				-- ROBLOX FIXME Luau: shouldn't need this annotation?
				function(idA: number, idB: number)
					return (self:getIndexOfElementID(idA) or 0)
						- (self:getIndexOfElementID(idB) or 0)
				end
			)

			-- Next we need to determine the appropriate depth for each element in the list.
			-- The depth in the list may not correspond to the depth in the tree,
			-- because the list has been filtered to remove intermediate components.
			-- Perhaps the easiest way to do this is to walk up the tree until we reach either:
			-- (1) another node that's already in the tree, or (2) the root (owner)
			-- at which point, our depth is just the depth of that node plus one.
			for _, id in sortedIDs do
				local innerElement = self._idToElement:get(id)

				if innerElement ~= nil then
					local parentID = innerElement.parentID
					local depth = 0

					while parentID > 0 do
						if parentID == ownerID or unsortedIDs:has(parentID) then
							depth = depthMap:get(parentID) :: number + 1
							depthMap:set(id, depth)
							break
						end
						local parent = self._idToElement:get(parentID)
						if parent == nil then
							break
						end
						-- ROBLOX FIXME Luau: need type states to understand parent isn't nil due to break
						parentID = (parent :: Element).parentID
					end

					if depth == 0 then
						error("Invalid owners list")
					end

					table.insert(list, Object.assign({}, innerElement, { depth = depth }))
				end
			end
		end
	end

	return list
end

function Store:getRendererIDForElement(id: number): number | nil
	local current = self._idToElement:get(id)

	while current ~= nil do
		if current.parentID == 0 then
			local rendererID = self._rootIDToRendererID:get(current.id)
			if rendererID == nil then
				return nil
			end
			return rendererID
		else
			current = self._idToElement:get(current.parentID)
		end
	end

	return nil
end

function Store:getRootIDForElement(id: number): number | nil
	local current = self._idToElement:get(id)
	while current ~= nil do
		if current.parentID == 0 then
			return current.id
		else
			current = self._idToElement:get(current.parentID)
		end
	end
	return nil
end

function Store:isInsideCollapsedSubTree(id: number): boolean
	local current = self._idToElement:get(id)
	while current ~= nil do
		if (current :: Element).parentID == 0 then
			return false
		else
			current = self._idToElement:get(current.parentID)
			if current ~= nil and (current :: Element).isCollapsed then
				return true
			end
		end
	end
	return false
end

-- TODO Maybe split this into two methods: expand() and collapse()
function Store:toggleIsCollapsed(id: number, isCollapsed: boolean): ()
	local didMutate = false
	local element: Element? = self:getElementByID(id)

	if element ~= nil then
		if isCollapsed then
			if (element :: Element).type == ElementTypeRoot then
				error("Root nodes cannot be collapsed")
			end
			if not (element :: Element).isCollapsed then
				didMutate = true;
				(element :: Element).isCollapsed = true

				local weightDelta = 1 - (element :: Element).weight
				-- ROBLOX FIXME Luau: shouldn't need this annoatation, should infer correctly
				local parentElement: Element? = (
					self._idToElement:get(element.parentID) :: any
				) :: Element
				while parentElement ~= nil do
					-- We don't need to break on a collapsed parent in the same way as the expand case below.
					-- That's because collapsing a node doesn't "bubble" and affect its parents.
					parentElement.weight += weightDelta
					parentElement = self._idToElement:get(parentElement.parentID)
				end
			end
		else
			-- ROBLOX FIXME Luau: shouldn't need this annoatation, should infer correctly
			local currentElement: Element? = element

			while currentElement ~= nil do
				local oldWeight = if (currentElement :: Element).isCollapsed
					then 1
					else currentElement.weight

				if (currentElement :: Element).isCollapsed then
					didMutate = true;
					(currentElement :: Element).isCollapsed = false

					local newWeight = if (currentElement :: Element).isCollapsed
						then 1
						else (currentElement :: Element).weight
					local weightDelta = newWeight - oldWeight
					-- ROBLOX FIXME Luau: shouldn't need this annoatation, should infer correctly
					local parentElement: Element? = (
						self._idToElement:get(currentElement.parentID) :: any
					) :: Element

					while parentElement ~= nil do
						parentElement.weight += weightDelta

						if (parentElement :: Element).isCollapsed then
							-- It's important to break on a collapsed parent when expanding nodes.
							-- That's because expanding a node "bubbles" up and expands all parents as well.
							-- Breaking in this case prevents us from over-incrementing the expanded weights.
							break
						end
						parentElement = self._idToElement:get(parentElement.parentID)
					end
				end

				currentElement = if (currentElement :: Element).parentID ~= 0
					then self:getElementByID((currentElement :: Element).parentID)
					else nil
			end
		end

		-- Only re-calculate weights and emit an "update" event if the store was mutated.
		if didMutate then
			local weightAcrossRoots = 0
			for _i, rootID in self._roots do
				local elementById: Element? = self:getElementByID(rootID)
				local weight = (elementById :: Element).weight
				weightAcrossRoots = weightAcrossRoots + weight
			end
			self._weightAcrossRoots = weightAcrossRoots

			-- The Tree context's search reducer expects an explicit list of ids for nodes that were added or removed.
			-- In this  case, we can pass it empty arrays since nodes in a collapsed tree are still there (just hidden).
			-- Updating the selected search index later may require auto-expanding a collapsed subtree though.
			self:emit("mutated", {
				{},
				{},
			})
		end
	end
end

function Store:_adjustParentTreeWeight(parentElement: Element | nil, weightDelta: number)
	local isInsideCollapsedSubTree = false

	while parentElement ~= nil do
		(parentElement :: Element).weight += weightDelta

		-- Additions and deletions within a collapsed subtree should not bubble beyond the collapsed parent.
		-- Their weight will bubble up when the parent is expanded.
		if (parentElement :: Element).isCollapsed then
			isInsideCollapsedSubTree = true
			break
		end

		parentElement = (self._idToElement:get(parentElement.parentID) :: any) :: Element
	end

	-- Additions and deletions within a collapsed subtree should not affect the overall number of elements.
	if not isInsideCollapsedSubTree then
		self._weightAcrossRoots += weightDelta
	end
end

function Store:onBridgeNativeStyleEditorSupported(options: {
	isSupported: boolean,
	validAttributes: Array<string>,
})
	local isSupported, validAttributes = options.isSupported, options.validAttributes

	self._isNativeStyleEditorSupported = isSupported
	self._nativeStyleEditorValidAttributes = validAttributes or nil

	self:emit("supportsNativeStyleEditor")
end

function Store:onBridgeOperations(operations: Array<number>): ()
	if __DEBUG__ then
		console.groupCollapsed("onBridgeOperations")
		debug_("onBridgeOperations", table.concat(operations, ","))
	end

	local haveRootsChanged = false

	-- The first two values are always rendererID and rootID
	local rendererID = operations[1]
	local addedElementIDs = {}
	-- This is a mapping of removed ID -> parent ID:
	local removedElementIDs = {}
	-- We'll use the parent ID to adjust selection if it gets deleted.
	-- ROBLOX deviation: 1-indexed means this is 3, not 2
	local i = 3
	local stringTable: Array<any> = {
		-- ROBLOX deviation: element 1 corresponds to empty string
		"", -- ID = 0 corresponds to the null string.
	}

	-- ROBLOX deviation: use postfix as a function
	local function POSTFIX_INCREMENT()
		local prevI = i
		i += 1
		return prevI
	end

	local stringTableSize = operations[POSTFIX_INCREMENT()]
	local stringTableEnd = i + stringTableSize

	while i < stringTableEnd do
		-- ROBLOX deviation: don't binary encode strings, so store string directly rather than length
		-- local nextLength = operations[POSTFIX_INCREMENT()]
		-- local nextString = utfDecodeString(Array.slice(operations, i, i + nextLength))
		local nextString = operations[POSTFIX_INCREMENT()]

		table.insert(stringTable, nextString)
		-- ROBLOX deviation: don't binary encode strings, so no need to move pointer
		-- i = i + nextLength
	end

	-- ROBLOX deviation: 1-indexing, use <= not <
	while i <= #operations do
		local operation = operations[i]
		if operation == TREE_OPERATION_ADD then
			local id = operations[i + 1]
			local type_ = operations[i + 2]

			i += 3

			if self._idToElement:has(id) then
				error(
					Error.new(
						("Cannot add node %s because a node with that id is already in the Store."):format(
							tostring(id)
						)
					)
				)
			end

			local ownerID: number = 0
			local parentID: number = (nil :: any) :: number

			if type_ == ElementTypeRoot then
				if __DEBUG__ then
					debug_("Add", string.format("new root node %s", tostring(id)))
				end

				local supportsProfiling = operations[i] > 0
				i += 1

				local hasOwnerMetadata = operations[i] > 0

				i += 1
				self._roots = Array.concat(self._roots, id)

				self._rootIDToRendererID:set(id, rendererID)
				self._rootIDToCapabilities:set(id, {
					hasOwnerMetadata = hasOwnerMetadata,
					supportsProfiling = supportsProfiling,
				})

				self._idToElement:set(id, {
					children = {},
					depth = -1,
					displayName = nil,
					hocDisplayNames = nil,
					id = id,
					isCollapsed = false, -- Never collapse roots; it would hide the entire tree.
					key = nil,
					ownerID = 0,
					parentID = 0,
					type = type_,
					weight = 0,
				})
				haveRootsChanged = true
			else
				parentID = (operations[i] :: any) :: number
				i += 1
				ownerID = (operations[i] :: any) :: number
				i += 1

				local displayNameStringID = operations[i]
				-- ROBLOX deviation: 1-indexed
				local displayName = stringTable[displayNameStringID + 1]

				i += 1

				local keyStringID = operations[i]
				-- ROBLOX deviation: 1-indexed
				local key = stringTable[keyStringID + 1]

				i += 1

				if __DEBUG__ then
					debug_(
						"Add",
						string.format(
							"node %s (%s) as child of %s",
							tostring(id),
							displayName or "null",
							tostring(parentID)
						)
					)
				end
				if not self._idToElement:has(parentID) then
					error(
						Error.new(
							("Cannot add child %s to parent %s because parent node was not found in the Store."):format(
								tostring(id),
								tostring(parentID)
							)
						)
					)
				end

				local parentElement = (self._idToElement:get(parentID) :: any) :: Element

				table.insert(parentElement.children, id)

				local displayNameWithoutHOCs, hocDisplayNames =
					separateDisplayNameAndHOCs(displayName, type_)

				local element = {
					children = {},
					depth = parentElement.depth + 1,
					displayName = displayNameWithoutHOCs,
					hocDisplayNames = hocDisplayNames,
					id = id,
					isCollapsed = self._collapseNodesByDefault,
					key = key,
					ownerID = ownerID,
					parentID = parentElement.id,
					type = type_,
					weight = 1,
				}

				self._idToElement:set(id, element)
				table.insert(addedElementIDs, id)
				self:_adjustParentTreeWeight(parentElement, 1)

				if ownerID > 0 then
					local set = self._ownersMap:get(ownerID)

					-- ROBLOX FIXME Luau: needs type states to eliminate the manual cast
					if set == nil then
						set = Set.new()
						self._ownersMap:set(ownerID, set :: Set<number>)
					end

					(set :: Set<number>):add(id)
				end
			end
		elseif operation == TREE_OPERATION_REMOVE then
			local removeLength = operations[i + 1]
			i += 2

			-- ROBLOX deviation: 1-indexing use 1 not 0
			for removeIndex = 1, removeLength do
				local id = (operations[i] :: any) :: number

				if not self._idToElement:has(id) then
					error(
						Error.new(
							("Cannot remove node %s because no matching node was found in the Store."):format(
								tostring(id)
							)
						)
					)
				end
				i += 1

				local element = (self._idToElement:get(id) :: any) :: Element
				local children, ownerID, parentID, weight =
					element.children, element.ownerID, element.parentID, element.weight

				if #children > 0 then
					error(
						Error.new(
							string.format(
								"Node %s was removed before its children.",
								tostring(id)
							)
						)
					)
				end

				self._idToElement:delete(id)

				local parentElement: Element? = nil

				if parentID == 0 then
					if __DEBUG__ then
						debug_("Remove", string.format("node %s root", tostring(id)))
					end

					self._roots = Array.filter(self._roots, function(rootID)
						return rootID ~= id
					end)

					self._rootIDToRendererID:delete(id)
					self._rootIDToCapabilities:delete(id)

					haveRootsChanged = true
				else
					if __DEBUG__ then
						debug_(
							"Remove",
							string.format(
								"node %s from parent %s",
								tostring(id),
								tostring(parentID)
							)
						)
					end

					parentElement = (self._idToElement:get(parentID) :: any) :: Element

					if parentElement == nil then
						error(
							("Cannot remove node %s from parent %s because no matching node was found in the Store."):format(
								tostring(id),
								tostring(parentID)
							)
						)
					end

					local index = Array.indexOf((parentElement :: Element).children, id)
					Array.splice((parentElement :: Element).children, index, 1)
				end

				self:_adjustParentTreeWeight(parentElement, -weight)
				removedElementIDs[id] = parentID
				self._ownersMap:delete(id)

				if ownerID > 0 then
					local set = self._ownersMap:get(ownerID)
					-- ROBLOX FIXME Luau: without any cast below, we get: Types Set and nil cannot be compared with ~= because they do not have the same metatable
					if set :: any ~= nil then
						(set :: Set<number>):delete(id)
					end
				end
			end
		elseif operation == TREE_OPERATION_REORDER_CHILDREN then
			local id = (operations[i + 1] :: any) :: number
			local numChildren = (operations[i + 2] :: any) :: number

			i += 3

			if not self._idToElement:has(id) then
				error(
					Error.new(
						("Cannot reorder children for node %s because no matching node was found in the Store."):format(
							tostring(id)
						)
					)
				)
			end

			local element = (self._idToElement:get(id) :: any) :: Element
			local children = element.children

			if #children ~= numChildren then
				error("Children cannot be added or removed during a reorder operation.")
			end

			-- ROBLOX deviation: 1-indexing use 1 not 0
			for j = 1, numChildren do
				local childID = operations[i + j - 1]

				children[j] = childID

				if _G.__DEV__ then
					local childElement: Element? = self._idToElement:get(childID)

					if
						childElement == nil
						or (childElement :: Element).parentID ~= id
					then
						console.error(
							"Children cannot be added or removed during a reorder operation."
						)
					end
				end
			end

			i = i + numChildren

			if _G.__DEBUG__ then
				debug_(
					"Re-order",
					string.format(
						"Node %s children %s",
						tostring(id),
						Array.join(children, ",")
					)
				)
			end
		elseif operation == TREE_OPERATION_UPDATE_TREE_BASE_DURATION then
			-- Base duration updates are only sent while profiling is in progress.
			-- We can ignore them at this point.
			-- The profiler UI uses them lazily in order to generate the tree.
			i += 3
		else
			error("Unsupported Bridge operation " .. tostring(operation))
		end
	end

	self._revision += 1

	if haveRootsChanged then
		local prevSupportsProfiling = self._supportsProfiling

		self._hasOwnerMetadata = false
		self._supportsProfiling = false

		for _, capabilities in self._rootIDToCapabilities do
			local hasOwnerMetadata, supportsProfiling =
				capabilities.hasOwnerMetadata, capabilities.supportsProfiling

			if hasOwnerMetadata then
				self._hasOwnerMetadata = true
			end
			if supportsProfiling then
				self._supportsProfiling = true
			end
		end
		self:emit("roots")

		if self._supportsProfiling ~= prevSupportsProfiling then
			self:emit("supportsProfiling")
		end
	end
	if __DEBUG__ then
		-- ROBLOX deviation: inline require here to work around circular dependency
		local devtoolsUtils = require(script.Parent.utils) :: any
		local printStore = devtoolsUtils.printStore
		console.log(printStore(self, true))
		console.groupEnd()
	end

	self:emit("mutated", { addedElementIDs, removedElementIDs })
end

function Store:onBridgeOverrideComponentFilters(
	componentFilters: Array<ComponentFilter>
): ()
	self._componentFilters = componentFilters

	saveComponentFilters(componentFilters)
end

function Store:onBridgeShutdown(): ()
	if __DEBUG__ then
		debug_("onBridgeShutdown", "unsubscribing from Bridge")
	end

	self._bridge:removeListener("operations", self.onBridgeOperations)
	self._bridge:removeListener("shutdown", self.onBridgeShutdown)
	self._bridge:removeListener(
		"isBackendStorageAPISupported",
		self.onBridgeStorageSupported
	)
end

function Store:onBridgeStorageSupported(isBackendStorageAPISupported: boolean): ()
	self._isBackendStorageAPISupported = isBackendStorageAPISupported
	self:emit("supportsReloadAndProfile")
end

function Store:onBridgeUnsupportedRendererVersion(): ()
	self._unsupportedRendererVersionDetected = true
	self:emit("unsupportedRendererVersionDetected")
end

return Store ]]
b_.Children._2e256b7a7ed1d244df18c57840ac299c=b6
local b7

local b8={ClassName="ModuleScript",Children={},Properties={}}
b8.Name="types"
b8.Properties.Source=[[ --!strict
local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Object = LuauPolyfill.Object
type Set<K> = LuauPolyfill.Set<K>

local ComponentsTypes = require(script.Parent.Parent.devtools.views.Components.types)
type Element = ComponentsTypes.Element

local Types = require(script.Parent.Parent.types)
type ComponentFilter = Types.ComponentFilter
type ElementType = Types.ElementType

local EventEmitter = require(script.Parent.Parent.events)
type EventEmitter<T> = EventEmitter.EventEmitter<T>

local Bridge = require(script.Parent.Parent.bridge)
type FrontendBridge = Bridge.FrontendBridge

local backendTypes = require(script.Parent.Parent.backend.types)
type ProfilingDataBackend = backendTypes.ProfilingDataBackend

local profilerTypes = require(script.Parent.views.Profiler.types)
type CommitDataFrontend = profilerTypes.CommitDataFrontend
type ProfilingDataForRootFrontend = profilerTypes.ProfilingDataForRootFrontend
type ProfilingDataFrontend = profilerTypes.ProfilingDataFrontend
type SnapshotNode = profilerTypes.SnapshotNode

export type Capabilities = { hasOwnerMetadata: boolean, supportsProfiling: boolean }

export type Store = EventEmitter<{
	collapseNodesByDefault: Array<any>,
	componentFilters: Array<any>,
	mutated: Array<any>, -- ROBLOX deviation: can't express jagged array types in Luau
	recordChangeDescriptions: Array<any>,
	roots: Array<any>,
	supportsNativeStyleEditor: Array<any>,
	supportsProfiling: Array<any>,
	supportsReloadAndProfile: Array<any>,
	unsupportedRendererVersionDetected: Array<any>,
}> & {
	_bridge: FrontendBridge,

	-- Should new nodes be collapsed by default when added to the tree?
	_collapseNodesByDefault: boolean,

	_componentFilters: Array<ComponentFilter>,

	-- At least one of the injected renderers contains (DEV only) owner metadata.
	_hasOwnerMetadata: boolean,

	-- Map of ID to (mutable) Element.
	-- Elements are mutated to avoid excessive cloning during tree updates.
	-- The InspectedElementContext also relies on this mutability for its WeakMap usage.
	_idToElement: Map<number, Element>,

	-- Should the React Native style editor panel be shown?
	_isNativeStyleEditorSupported: boolean,

	-- Can the backend use the Storage API (e.g. localStorage)?
	-- If not, features like reload-and-profile will not work correctly and must be disabled.
	_isBackendStorageAPISupported: boolean,

	_nativeStyleEditorValidAttributes: Array<string> | nil,

	-- Map of element (id) to the set of elements (ids) it owns.
	-- This map enables getOwnersListForElement() to avoid traversing the entire tree.
	_ownersMap: Map<number, Set<number>>,

	_profilerStore: ProfilerStore,

	_recordChangeDescriptions: boolean,

	-- Incremented each time the store is mutated.
	-- This enables a passive effect to detect a mutation between render and commit phase.
	_revision: number,

	-- This Array must be treated as immutable!
	-- Passive effects will check it for changes between render and mount.
	_roots: Array<number>,

	_rootIDToCapabilities: Map<number, Capabilities>,

	-- Renderer ID is needed to support inspection fiber props, state, and hooks.
	_rootIDToRendererID: Map<number, number>,

	-- These options may be initially set by a confiugraiton option when constructing the Store.
	-- In the case of "supportsProfiling", the option may be updated based on the injected renderers.
	_supportsNativeInspection: boolean,
	_supportsProfiling: boolean,
	_supportsReloadAndProfile: boolean,
	_supportsTraceUpdates: boolean,

	_unsupportedRendererVersionDetected: boolean,

	-- Total number of visible elements (within all roots).
	-- Used for windowing purposes.
	_weightAcrossRoots: number,
	assertExpectedRootMapSizes: (self: Store) -> (),
	assertMapSizeMatchesRootCount: (
		self: Store,
		map: Map<any, any>,
		mapName: string
	) -> (),
	getCollapseNodesByDefault: (self: Store) -> boolean,
	setCollapseNodesByDefault: (self: Store, boolean) -> (),
	getComponentFilters: (self: Store) -> Array<ComponentFilter>,
	setComponentFilters: (self: Store, Array<ComponentFilter>) -> (),
	getHasOwnerMetadata: (self: Store) -> boolean,
	getNativeStyleEditorValidAttributes: (self: Store) -> Array<string> | nil,
	getNumElements: (self: Store) -> number,
	getProfilerStore: (self: Store) -> ProfilerStore,
	getRecordChangeDescriptions: (self: Store) -> boolean,
	setRecordChangeDescriptions: (self: Store, value: boolean) -> (),
	getRevision: (self: Store) -> number,
	getRootIDToRendererID: (self: Store) -> Map<number, number>,
	getRoots: (self: Store) -> Array<number>,
	getSupportsNativeInspection: (self: Store) -> boolean,
	getSupportsNativeStyleEditor: (self: Store) -> boolean,
	getSupportsProfiling: (self: Store) -> boolean,
	getSupportsReloadAndProfile: (self: Store) -> boolean,
	getSupportsTraceUpdates: (self: Store) -> boolean,
	getUnsupportedRendererVersionDetected: (self: Store) -> boolean,
	containsElement: (self: Store, id: number) -> boolean,
	getElementAtIndex: (self: Store, index: number) -> Element | nil,
	getElementIDAtIndex: (self: Store, index: number) -> number | nil,
	getElementByID: (self: Store, id: number) -> Element | nil,
	getIndexOfElementID: (self: Store, id: number) -> number | nil,
	getOwnersListForElement: (self: Store, ownerID: number) -> Array<Element>,
	getRendererIDForElement: (self: Store, id: number) -> number | nil,
	getRootIDForElement: (self: Store, id: number) -> number | nil,
	isInsideCollapsedSubTree: (self: Store, id: number) -> boolean,
	toggleIsCollapsed: (self: Store, id: number, isCollapsed: boolean) -> (),
	_adjustParentTreeWeight: (
		self: Store,
		parentElement: Element | nil,
		weightDelta: number
	) -> (),
	onBridgeNativeStyleEditorSupported: (
		self: Store,
		options: {
			isSupported: boolean,
			validAttributes: Array<string>,
		}
	) -> (),
	onBridgeOperations: (self: Store, operations: Array<number>) -> (),
	onBridgeOverrideComponentFilters: (
		self: Store,
		componentFilters: Array<ComponentFilter>
	) -> (),
	onBridgeShutdown: (self: Store) -> (),
	onBridgeStorageSupported: (self: Store, isBackendStorageAPISupported: boolean) -> (),
	onBridgeUnsupportedRendererVersion: (self: Store) -> (),
}

export type ProfilingCache = {
	_fiberCommits: Map<number, Array<number>>,
	_profilerStore: ProfilerStore,
	getCommitTree: any,
	getFiberCommits: any,
	getFlamegraphChartData: any,
	getInteractionsChartData: any,
	getRankedChartData: any,
	invalidate: (self: ProfilingCache) -> (),
}

export type ProfilerStore = EventEmitter<{
	isProcessingData: any, --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [] \]\]
	isProfiling: any, --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [] \]\]
	profilingData: any, --\[\[ ROBLOX TODO: Unhandled node for type: TupleTypeAnnotation \]\] --\[\[ [] \]\]
}> & {
	_bridge: FrontendBridge, -- Suspense cache for lazily calculating derived profiling data.
	_cache: ProfilingCache, -- Temporary store of profiling data from the backend renderer(s).
	-- This data will be converted to the ProfilingDataFrontend format after being collected from all renderers.
	_dataBackends: Array<ProfilingDataBackend>, -- Data from the most recently completed profiling session,
	-- or data that has been imported from a previously exported session.
	-- This object contains all necessary data to drive the Profiler UI interface,
	-- even though some of it is lazily parsed/derived via the ProfilingCache.
	_dataFrontend: ProfilingDataFrontend | nil, -- Snapshot of all attached renderer IDs.
	-- Once profiling is finished, this snapshot will be used to query renderers for profiling data.
	--
	-- This map is initialized when profiling starts and updated when a new root is added while profiling;
	-- Upon completion, it is converted into the exportable ProfilingDataFrontend format.
	_initialRendererIDs: Set<number>, -- Snapshot of the state of the main Store (including all roots) when profiling started.
	-- Once profiling is finished, this snapshot can be used along with "operations" messages emitted during profiling,
	-- to reconstruct the state of each root for each commit.
	-- It's okay to use a single root to store this information because node IDs are unique across all roots.
	--
	-- This map is initialized when profiling starts and updated when a new root is added while profiling;
	-- Upon completion, it is converted into the exportable ProfilingDataFrontend format.
	_initialSnapshotsByRootID: Map<number, Map<number, SnapshotNode>>, -- Map of root (id) to a list of tree mutation that occur during profiling.
	-- Once profiling is finished, these mutations can be used, along with the initial tree snapshots,
	-- to reconstruct the state of each root for each commit.
	--
	-- This map is only updated while profiling is in progress;
	-- Upon completion, it is converted into the exportable ProfilingDataFrontend format.
	_inProgressOperationsByRootID: Map<number, Array<Array<number>>>, -- The backend is currently profiling.
	-- When profiling is in progress, operations are stored so that we can later reconstruct past commit trees.
	_isProfiling: boolean, -- Tracks whether a specific renderer logged any profiling data during the most recent session.
	_rendererIDsThatReportedProfilingData: Set<number>, -- After profiling, data is requested from each attached renderer using this queue.
	-- So long as this queue is not empty, the store is retrieving and processing profiling data from the backend.
	_rendererQueue: Set<number>,
	_store: Store,
	getCommitData: (
		self: ProfilerStore,
		rootID: number,
		commitIndex: number
	) -> CommitDataFrontend,
	getDataForRoot: (self: ProfilerStore, rootID: number) -> ProfilingDataForRootFrontend, -- Profiling data has been recorded for at least one root.
	didRecordCommits: (self: ProfilerStore) -> boolean,
	isProcessingData: (self: ProfilerStore) -> boolean,
	isProfiling: (self: ProfilerStore) -> boolean,
	profilingCache: (self: ProfilerStore) -> ProfilingCache,
	profilingData: (
		self: ProfilerStore,
		value: ProfilingDataFrontend?
	) -> (...ProfilingDataFrontend?),
	clear: (self: ProfilerStore) -> (),
	startProfiling: (self: ProfilerStore) -> (),
	stopProfiling: (self: ProfilerStore) -> (),
	_takeProfilingSnapshotRecursive: any,
	onBridgeOperations: (self: ProfilerStore, operations: Array<number>) -> (),
	onBridgeProfilingData: (self: ProfilerStore, dataBackend: ProfilingDataBackend) -> (),
	onBridgeShutdown: (self: ProfilerStore) -> (),
	onProfilingStatus: (self: ProfilerStore, isProfiling: boolean) -> (),
}

return true ]]
b_.Children._dd512e17e9cb81e5eb54790a716c2bf1=b8
local b9

local ca={ClassName="ModuleScript",Children={},Properties={}}
ca.Name="utils"
ca.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/devtools/utils.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX deviation: Use HttpService for JSON
local JSON = game:GetService("HttpService")

local exports = {}

local ViewsComponentsTypes = require(script.Parent.views.Components.types)
type Element = ViewsComponentsTypes.Element
local devtoolsTypes = require(script.Parent.types)
type Store = devtoolsTypes.Store

exports.printElement = function(element: Element, includeWeight: boolean?)
	includeWeight = includeWeight or false
	local prefix = " "

	if #element.children > 0 then
		prefix = if element.isCollapsed then "▸" else "▾"
	end

	local key = ""

	if element.key ~= nil and element.key ~= "" then
		key = string.format(' key="%s"', tostring(element.key))
	end

	local hocDisplayNames = nil

	if element.hocDisplayNames ~= nil then
		hocDisplayNames = table.clone(element.hocDisplayNames)
	end

	local hocs = if hocDisplayNames == nil
		then ""
		else string.format(" [%s]", table.concat(hocDisplayNames, "]["))
	local suffix = ""

	if includeWeight then
		suffix = string.format(
			" (%s)",
			if element.isCollapsed then "1" else tostring(element.weight)
		)
	end
	return string.format(
		"%s%s <%s%s>%s%s",
		("  "):rep(element.depth + 1),
		prefix,
		element.displayName or "null",
		key,
		hocs,
		suffix
	)
end

exports.printOwnersList = function(elements: Array<Element>, includeWeight: boolean)
	includeWeight = includeWeight or false
	return table.concat(
		Array.map(elements, function(element)
			return exports.printElement(element, includeWeight)
		end),
		"\n"
	)
end

exports.printStore = function(store: Store, includeWeight: boolean?)
	includeWeight = includeWeight or false
	local snapshotLines: Array<string> = {}
	local rootWeight = 0

	Array.forEach(store:getRoots(), function(rootID)
		local weight = ((store:getElementByID(rootID) :: any) :: Element).weight

		table.insert(
			snapshotLines,
			"[root]" .. (if includeWeight then string.format(" (%d)", weight) else "")
		)
		for i = rootWeight, rootWeight + weight - 1 do
			local element: Element? = store:getElementAtIndex(i)

			if element == nil then
				error(string.format("Could not find element at index %d", i))
			end

			table.insert(
				snapshotLines,
				exports.printElement(element :: Element, includeWeight :: boolean)
			)
		end
		rootWeight += weight
	end)

	-- Make sure the pretty-printed test align with the Store's reported number of total rows.
	if rootWeight ~= store:getNumElements() then
		error(
			("Inconsistent Store state. Individual root weights (%s) do not match total weight (%s)"):format(
				tostring(rootWeight),
				tostring(store:getNumElements())
			)
		)
	end

	-- If roots have been unmounted, verify that they've been removed from maps.
	-- This helps ensure the Store doesn't leak memory.
	store:assertExpectedRootMapSizes()

	return table.concat(snapshotLines, "\n")
end

-- We use JSON.parse to parse string values
-- e.g. 'foo' is not valid JSON but it is a valid string
-- so this method replaces e.g. 'foo' with "foo"
exports.sanitizeForParse = function(value)
	if typeof(value) == "string" then
		if
			#value >= 2
			and string.sub(value, 1, 1) == "'"
			and string.sub(value, #value) == "'"
		then
			return '"' .. string.sub(value, 1, #value - 2) .. '"'
		end
	end
	return value
end

exports.smartParse = function(value): number?
	if value == "Infinity" then
		return math.huge
	elseif value == "NaN" then
		-- ROBLOX deviation: no NaN
		return 0
	elseif value == "undefined" then
		return nil
	else
		return JSON:JSONDecode(exports.sanitizeForParse(value))
	end
end

exports.smartStringify = function(value)
	if typeof(value) == "number" then
		-- ROBLOX deviation: these numbers don't exist
		-- if Number.isNaN(value) then
		-- 	return'NaN'
		-- elseif not Number.isFinite(value) then
		-- 	return'Infinity'
		-- end
	elseif value == nil then
		return "undefined"
	end

	return JSON:JSONEncode(value)
end

return exports ]]
b_.Children._eee0bdd1e56c216aec5b856d6718866d=ca
local cb

local cc={ClassName="Folder",Children={},Properties={}}
cc.Name="views"
b_.Children._7020d19e0f70ce3822ebc6fb0eb23d15=cc
local cd
local ce={ClassName="Folder",Children={},Properties={}}
ce.Name="Components"
cd.Children._8b7c26d04f1aff99f9c8ba32efb12d3b=ce
local cf
local cg={ClassName="ModuleScript",Children={},Properties={}}
cg.Name="types"
cg.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/devtools/views/Components/types.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local ReactShared = require(Packages.Shared)
type Source = ReactShared.Source
local Hydration = require(script.Parent.Parent.Parent.Parent.hydration)
type Dehydrated = Hydration.Dehydrated
type Unserializable = Hydration.Unserializable

local ReactDevtoolsSharedTypes = require(script.Parent.Parent.Parent.Parent.types)
type ElementType = ReactDevtoolsSharedTypes.ElementType

-- Each element on the frontend corresponds to a Fiber on the backend.
-- Some of its information (e.g. id, type, displayName) come from the backend.
-- Other bits (e.g. weight and depth) are computed on the frontend for windowing and display purposes.
-- Elements are updated on a push basis– meaning the backend pushes updates to the frontend when needed.
export type Element = {
	id: number,
	parentID: number,
	children: Array<number>,
	type: ElementType,
	displayName: string | nil,
	key: number | string | nil,

	hocDisplayNames: nil | Array<string>,

	-- Should the elements children be visible in the tree?
	isCollapsed: boolean,

	-- Owner (if available)
	ownerID: number,

	-- How many levels deep within the tree is this element?
	-- This determines how much indentation (left padding) should be used in the Elements tree.
	depth: number,

	-- How many nodes (including itself) are below this Element within the tree.
	-- This property is used to quickly determine the total number of Elements,
	-- and the Element at any given index (for windowing purposes).
	weight: number,
}

export type Owner = {
	displayName: string | nil,
	id: number,
	hocDisplayNames: Array<string> | nil,
	type: ElementType,
}

export type OwnersList = { id: number, owners: Array<Owner> | nil }

export type InspectedElement = {
	id: number,

	-- Does the current renderer support editable hooks and function props?
	canEditHooks: boolean,
	canEditFunctionProps: boolean,

	-- Does the current renderer support advanced editing interface?
	canEditHooksAndDeletePaths: boolean,
	canEditHooksAndRenamePaths: boolean,
	canEditFunctionPropsDeletePaths: boolean,
	canEditFunctionPropsRenamePaths: boolean,

	-- Is this Suspense, and can its value be overridden now?
	canToggleSuspense: boolean,

	-- Can view component source location.
	canViewSource: boolean,

	-- Does the component have legacy context attached to it.
	hasLegacyContext: boolean,

	-- Inspectable properties.
	context: Object | nil,
	hooks: Object | nil,
	props: Object | nil,
	state: Object | nil,
	key: number | string | nil,

	-- List of owners
	owners: Array<Owner> | nil,

	-- Location of component in source code.
	source: Source | nil,

	type: ElementType,

	-- Meta information about the root this element belongs to.
	rootType: string | nil,

	-- Meta information about the renderer that created this element.
	rendererPackageName: string | nil,
	rendererVersion: string | nil,
}

-- TODO: Add profiling type

export type DehydratedData = {
	cleaned: Array<Array<string | number>>,
	data: string
		| Dehydrated
		| Unserializable
		| Array<Dehydrated>
		| Array<Unserializable>
		| { [string]: string | Dehydrated | Unserializable },
	unserializable: Array<Array<string | number>>,
}

return {} ]]
cf.Children._e2902e0ca0104a1114044971735b701c=cg
local ch

local ci={ClassName="Folder",Children={},Properties={}}
ci.Name="Profiler"
cd.Children._ebbcc0a80a8a69f7bd5ede273b0e3a7d=ci
local cj
local ck={ClassName="ModuleScript",Children={},Properties={}}
ck.Name="CommitTreeBuilder"
ck.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map
local console = LuauPolyfill.console

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>

local exports = {}
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local constantsModule = require(script.Parent.Parent.Parent.Parent.constants)
local __DEBUG__ = constantsModule.__DEBUG__
local TREE_OPERATION_ADD = constantsModule.TREE_OPERATION_ADD
local TREE_OPERATION_REMOVE = constantsModule.TREE_OPERATION_REMOVE
local TREE_OPERATION_REORDER_CHILDREN = constantsModule.TREE_OPERATION_REORDER_CHILDREN
local TREE_OPERATION_UPDATE_TREE_BASE_DURATION =
	constantsModule.TREE_OPERATION_UPDATE_TREE_BASE_DURATION

local devtoolsTypes = require(script.Parent.Parent.Parent.types)
type ProfilerStore = devtoolsTypes.ProfilerStore

local ElementTypeRoot = require(script.Parent.Parent.Parent.Parent.types).ElementTypeRoot
local typesModule = require(script.Parent.Parent.Parent.Parent.types)
type ElementType = typesModule.ElementType

local Profiler_typesModule = require(script.Parent.types)
type CommitTree = Profiler_typesModule.CommitTree
type CommitTreeNode = Profiler_typesModule.CommitTreeNode
type ProfilingDataForRootFrontend = Profiler_typesModule.ProfilingDataForRootFrontend
type ProfilingDataFrontend = Profiler_typesModule.ProfilingDataFrontend

local function debug_(methodName, ...: any)
	if __DEBUG__ then
		print("[CommitTreeBuilder]", methodName, ...)
	end
end

local function __printTree(commitTree: CommitTree)
	if __DEBUG__ then
		local nodes, rootID = commitTree.nodes, commitTree.rootID
		console.group("__printTree()")
		local queue = { rootID, 0 }
		-- ROBLOX TODO Luau? if length check > 0, remove() nil-ability could be removed
		while #queue > 0 do
			local id = table.remove(queue, 1) :: number
			local depth = table.remove(queue, 1) :: number
			local node = nodes:get(id)
			-- ROBLOX FIXME Luau: need to understand error() narrows node nil-ability
			if node == nil then
				error(
					string.format(
						'Could not find node with id "%s" in commit tree',
						tostring(id)
					)
				)
			end
			console.log(
				string.format(
					"%s%s:%s %s (%s)",
					string.rep("\u{2022}", depth),
					tostring((node :: CommitTreeNode).id),
					tostring((node :: CommitTreeNode).displayName or ""),
					if (node :: CommitTreeNode).key
						then string.format(
							'key:"%s"',
							tostring((node :: CommitTreeNode).key)
						)
						else "",
					tostring((node :: CommitTreeNode).treeBaseDuration)
				)
			)
			Array.forEach((node :: CommitTreeNode).children, function(childID)
				Array.concat(queue, { childID, depth + 1 })
			end)
		end
		console.groupEnd()
	end
end

local function updateTree(commitTree: CommitTree, operations: Array<number>): CommitTree
	-- Clone the original tree so edits don't affect it.
	local nodes = Map.new(commitTree.nodes)

	-- Clone nodes before mutating them so edits don't affect the original.
	local function getClonedNode(id: number): CommitTreeNode
		local clonedNode = table.clone((nodes:get(id) :: any) :: CommitTreeNode)
		nodes:set(id, clonedNode)
		return clonedNode
	end

	local i = 3 -- Skip rendererID and currentRootID
	local function POSTFIX_INCREMENT()
		local x = i
		i += 1
		return x
	end

	local id: number = (nil :: any) :: number -- Reassemble the string table.
	local stringTable: Array<any> = {
		-- ROBLOX deviation: element 1 corresponds to empty string, this is why key is "" instead of nil in snapshots
		"", -- ID = 0 corresponds to the null string.
	}

	local stringTableSize = operations[POSTFIX_INCREMENT()]
	local stringTableEnd = i + stringTableSize

	while i < stringTableEnd do
		-- ROBLOX deviation: don't binary encode strings, so store string directly rather than length
		-- local nextLength = operations[POSTFIX_INCREMENT()]
		-- local nextString = utfDecodeString(Array.slice(operations, i, i + nextLength))
		local nextString = operations[POSTFIX_INCREMENT()]

		table.insert(stringTable, nextString)
		-- ROBLOX deviation: don't binary encode strings, so no need to move pointer
		-- i = i + nextLength
	end

	while i <= #operations do
		local operation = operations[POSTFIX_INCREMENT()]

		if operation == TREE_OPERATION_ADD then
			id = operations[POSTFIX_INCREMENT()]
			local type_ = (operations[POSTFIX_INCREMENT()] :: any) :: ElementType
			if nodes:has(id) then
				error(
					"Commit tree already contains fiber "
						.. tostring(id)
						.. ". This is a bug in React DevTools."
				)
			end
			if type_ == ElementTypeRoot then
				i += 2 -- supportsProfiling flag and hasOwnerMetadata flag
				if __DEBUG__ then
					debug_("Add", ("new root fiber %s"):format(tostring(id)))
				end
				local node: CommitTreeNode = {
					children = {},
					displayName = nil,
					hocDisplayNames = nil,
					id = id,
					key = nil,
					parentID = 0,
					treeBaseDuration = 0, -- This will be updated by a subsequent operation
					type = type_,
				}
				nodes:set(id, node)
			else
				local parentID = operations[POSTFIX_INCREMENT()]
				i += 1 -- skip ownerID
				local displayNameStringID = operations[POSTFIX_INCREMENT()]
				local displayName = stringTable[displayNameStringID + 1]

				local keyStringID = operations[POSTFIX_INCREMENT()]
				local key = stringTable[keyStringID + 1] -- 1 indexed stringtable

				if __DEBUG__ then
					debug_(
						"Add",
						("fiber %s (%s) as child of %s"):format(
							tostring(id),
							tostring(displayName or "null"),
							tostring(parentID)
						)
					)
				end
				local parentNode = getClonedNode(parentID)
				parentNode.children = Array.concat(parentNode.children, id)
				local node: CommitTreeNode = {
					children = {},
					displayName = displayName,
					hocDisplayNames = nil,
					id = id,
					key = key,
					parentID = parentID,
					treeBaseDuration = 0, -- This will be updated by a subsequent operation
					type = type_,
				}
				nodes:set(id, node)
			end
		elseif operation == TREE_OPERATION_REMOVE then
			local removeLength = operations[POSTFIX_INCREMENT()]
			for _ = 1, removeLength do
				id = operations[POSTFIX_INCREMENT()]
				if not nodes:has(id) then
					error(
						"Commit tree does not contain fiber "
							.. tostring(id)
							.. ". This is a bug in React DevTools."
					)
				end
				local node = getClonedNode(id)
				local parentID = node.parentID
				nodes:delete(id)
				if not nodes:has(parentID) then
					-- No-op
				else
					local parentNode = getClonedNode(parentID)
					if __DEBUG__ then
						debug_(
							"Remove",
							("fiber %s from parent %s"):format(
								tostring(id),
								tostring(parentID)
							)
						)
					end
					parentNode.children = Array.filter(
						parentNode.children,
						function(childID)
							return childID ~= id
						end
					)
				end
			end
		elseif operation == TREE_OPERATION_REORDER_CHILDREN then
			id = operations[POSTFIX_INCREMENT()]
			local numChildren = operations[POSTFIX_INCREMENT()]
			local children = (
				Array.slice(operations, i, i + numChildren) :: any
			) :: Array<number>
			i += numChildren
			if __DEBUG__ then
				debug_(
					"Re-order",
					("fiber %s children %s"):format(
						tostring(id),
						tostring(Array.join(children, ","))
					)
				)
			end
			local node = getClonedNode(id)
			-- ROBLOX FIXME Luau: this cast shouldn't be necessary
			node.children = Array.from(children) :: Array<number>
		elseif operation == TREE_OPERATION_UPDATE_TREE_BASE_DURATION then
			id = operations[POSTFIX_INCREMENT()]
			local node = getClonedNode(id)
			node.treeBaseDuration = operations[POSTFIX_INCREMENT()] / 1000 -- Convert microseconds back to milliseconds;
			if __DEBUG__ then
				debug_(
					"Update",
					("fiber %s treeBaseDuration to %s"):format(
						tostring(id),
						tostring(node.treeBaseDuration)
					)
				)
			end
		else
			error(
				string.format(
					"Unsupported Bridge operation %s at operation index %d",
					tostring(operation),
					i
				)
			)
		end
	end
	return { nodes = nodes, rootID = commitTree.rootID }
end

local function recursivelyInitializeTree(
	id: number,
	parentID: number,
	nodes: Map<number, CommitTreeNode>,
	dataForRoot: ProfilingDataForRootFrontend
): ()
	local node = dataForRoot.snapshots:get(id)
	if node ~= nil then
		nodes:set(id, {
			id = id,
			children = node.children,
			displayName = node.displayName,
			hocDisplayNames = node.hocDisplayNames,
			key = node.key,
			parentID = parentID,
			treeBaseDuration = (
					dataForRoot.initialTreeBaseDurations:get(id) :: any
				) :: number,
			type = node.type,
		})
		for _, childID in node.children do
			recursivelyInitializeTree(childID, id, nodes, dataForRoot)
		end
	end
end

local rootToCommitTreeMap: Map<number, Array<CommitTree>> = Map.new()
local function getCommitTree(ref: {
	commitIndex: number,
	profilerStore: ProfilerStore,
	rootID: number,
}): CommitTree
	local commitIndex, profilerStore, rootID =
		ref.commitIndex, ref.profilerStore, ref.rootID
	if not rootToCommitTreeMap:has(rootID) then
		rootToCommitTreeMap:set(rootID, {})
	end
	local commitTrees = (rootToCommitTreeMap:get(rootID) :: any) :: Array<CommitTree>
	if commitIndex <= #commitTrees then
		return commitTrees[commitIndex]
	end
	local profilingData = profilerStore:profilingData()
	-- ROBLOX FIXME Luau: need to understand error() means profilingData gets nil-ability stripped. needs type states.
	if profilingData == nil then
		error("No profiling data available")
	end
	local dataForRoot = (profilingData :: ProfilingDataFrontend).dataForRoots:get(rootID)
	-- ROBLOX FIXME Luau: need to understand error() means profilingData gets nil-ability stripped. needs type states.
	if dataForRoot == nil then
		error(
			string.format('Could not find profiling data for root "%s"', tostring(rootID))
		)
	end
	local operations = (dataForRoot :: ProfilingDataForRootFrontend).operations -- Commits are generated sequentially and cached.
	-- If this is the very first commit, start with the cached snapshot and apply the first mutation.
	-- Otherwise load (or generate) the previous commit and append a mutation to it.
	if commitIndex == 1 then
		local nodes = Map.new() -- Construct the initial tree.
		recursivelyInitializeTree(
			rootID,
			0,
			nodes,
			dataForRoot :: ProfilingDataForRootFrontend
		) -- Mutate the tree
		if operations ~= nil and commitIndex <= #operations then
			local commitTree =
				updateTree({ nodes = nodes, rootID = rootID }, operations[commitIndex])
			if __DEBUG__ then
				__printTree(commitTree)
			end
			table.insert(commitTrees, commitTree)
			return commitTree
		end
	else
		local previousCommitTree = getCommitTree({
			commitIndex = commitIndex - 1,
			profilerStore = profilerStore,
			rootID = rootID,
		})
		if operations ~= nil and commitIndex <= #operations then
			local commitTree = updateTree(previousCommitTree, operations[commitIndex])
			if __DEBUG__ then
				__printTree(commitTree)
			end
			table.insert(commitTrees, commitTree)
			return commitTree
		end
	end
	error(
		string.format(
			'getCommitTree(): Unable to reconstruct tree for root "%s" and commit %s',
			tostring(rootID),
			tostring(commitIndex)
		)
	)
end
exports.getCommitTree = getCommitTree

local function invalidateCommitTrees(): any?
	return rootToCommitTreeMap:clear()
end
exports.invalidateCommitTrees = invalidateCommitTrees -- DEBUG

return exports ]]
cj.Children._f492b2b7c138024e60d56b3e949fcf26=ck
local cl

local cm={ClassName="ModuleScript",Children={},Properties={}}
cm.Name="FlamegraphChartBuilder"
cm.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
local Map = LuauPolyfill.Map
local Set = LuauPolyfill.Set

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>
type Set<T> = LuauPolyfill.Set<T>

local exports = {}

local devtoolsTypes = require(script.Parent.Parent.Parent.types)
type ProfilerStore = devtoolsTypes.ProfilerStore

local formatDuration = require(script.Parent.utils).formatDuration
local typesModule = require(script.Parent.types)
type CommitTree = typesModule.CommitTree
type CommitTreeNode = typesModule.CommitTreeNode

export type ChartNode = {
	actualDuration: number,
	didRender: boolean,
	id: number,
	label: string,
	name: string,
	offset: number,
	selfDuration: number,
	treeBaseDuration: number,
}
export type ChartData = {
	baseDuration: number,
	depth: number,
	idToDepthMap: Map<number, number>,
	maxSelfDuration: number,
	renderPathNodes: Set<number>,
	rows: Array<Array<ChartNode>>,
}
local cachedChartData: Map<string, ChartData> = Map.new()
local function getChartData(ref: {
	commitIndex: number,
	commitTree: CommitTree,
	profilerStore: ProfilerStore,
	rootID: number,
}): ChartData
	local commitIndex, commitTree, profilerStore, rootID =
		ref.commitIndex, ref.commitTree, ref.profilerStore, ref.rootID
	local commitDatum = profilerStore:getCommitData(rootID, commitIndex)
	local fiberActualDurations, fiberSelfDurations =
		commitDatum.fiberActualDurations, commitDatum.fiberSelfDurations
	local nodes = commitTree.nodes
	local chartDataKey = ("%s-%s"):format(tostring(rootID), tostring(commitIndex))
	if cachedChartData:has(chartDataKey) then
		return (cachedChartData:get(chartDataKey) :: any) :: ChartData
	end
	local idToDepthMap: Map<number, number> = Map.new()
	local renderPathNodes: Set<number> = Set.new()
	local rows: Array<Array<ChartNode>> = {}
	local maxDepth = 0
	local maxSelfDuration = 0

	-- Generate flame graph structure using tree base durations.
	local function walkTree(id: number, rightOffset: number, currentDepth: number)
		idToDepthMap:set(id, currentDepth)

		local node = nodes:get(id)
		if node == nil then
			error(
				string.format(
					'Could not find node with id "%s" in commit tree',
					tostring(id)
				)
			)
		end
		-- ROBLOX FIXME Luau: Luau doesn't understand error() narrows, needs type states
		local children, displayName, hocDisplayNames, key, treeBaseDuration =
			(node :: CommitTreeNode).children,
			(node :: CommitTreeNode).displayName,
			(node :: CommitTreeNode).hocDisplayNames,
			(node :: CommitTreeNode).key,
			(node :: CommitTreeNode).treeBaseDuration

		local actualDuration = fiberActualDurations:get(id) or 0
		local selfDuration = fiberSelfDurations:get(id) or 0
		local didRender = fiberActualDurations:has(id)

		local name = displayName or "Anonymous"
		local maybeKey = if Boolean.toJSBoolean(key)
			then (' key="%s"'):format(tostring(key))
			else ""

		local maybeBadge = ""
		if hocDisplayNames ~= nil and #hocDisplayNames > 0 then
			maybeBadge = string.format(" (%s)", tostring(hocDisplayNames[1]))
		end

		local label = string.format(
			"%s%s%s%s",
			tostring(name),
			tostring(maybeBadge),
			tostring(maybeKey),
			if didRender
				then string.format(
					" (%sms of %sms)",
					tostring(formatDuration(selfDuration)),
					tostring(formatDuration(actualDuration))
				)
				else ""
		)

		maxDepth = math.max(maxDepth, currentDepth)
		maxSelfDuration = math.max(maxSelfDuration, selfDuration)
		local chartNode: ChartNode = {
			actualDuration = actualDuration,
			didRender = didRender,
			id = id,
			label = label,
			name = name,
			offset = rightOffset - treeBaseDuration,
			selfDuration = selfDuration,
			treeBaseDuration = treeBaseDuration,
		}
		if currentDepth > #rows then
			table.insert(rows, { chartNode })
		else
			table.insert(rows[currentDepth - 1], chartNode)
		end
		do
			local i = #children
			while i >= 1 do
				local childID = children[i]
				local childChartNode = walkTree(childID, rightOffset, currentDepth)
				rightOffset -= childChartNode.treeBaseDuration
				i -= 1
			end
		end
		return chartNode
	end
	local baseDuration = 0 -- Special case to handle unmounted roots.
	if nodes.size > 0 then
		-- Skip over the root; we don't want to show it in the flamegraph.
		local root = nodes:get(rootID)
		if root == nil then
			error(
				string.format(
					'Could not find root node with id "%s" in commit tree',
					tostring(rootID)
				)
			)
		end
		-- Don't assume a single root.
		-- Component filters or Fragments might lead to multiple "roots" in a flame graph.
		do
			-- ROBLOX FIXME Luau: Luau doesn't understand error() narrows, needs type states
			local i = #(root :: CommitTreeNode).children
			while i >= 1 do
				local id = (root :: CommitTreeNode).children[i]
				local node = nodes:get(id)
				if node == nil then
					error(
						string.format(
							'Could not find node with id "%s" in commit tree',
							tostring(id)
						)
					)
				end
				-- ROBLOX FIXME Luau: Luau doesn't understand error() narrows, needs type states
				baseDuration += (node :: CommitTreeNode).treeBaseDuration
				-- ROBLOX deviation START: walkTree does table.insert(tbl, currentDepth - 1), so the parameter here needs to be a valid index with after substracting 1 at the start
				walkTree(id, baseDuration, 2)
				-- ROBLOX deviation END
				i -= 1
			end
		end
		for id, duration in fiberActualDurations do
			local node = nodes:get(id)
			if node ~= nil then
				local currentID = node.parentID
				while currentID ~= 0 do
					if renderPathNodes:has(currentID) then
						-- We've already walked this path; we can skip it.
						break
					else
						renderPathNodes:add(currentID)
					end
					node = nodes:get(currentID)
					currentID = if node ~= nil then node.parentID else 0
				end
			end
		end
	end
	local chartData = {
		baseDuration = baseDuration,
		depth = maxDepth,
		idToDepthMap = idToDepthMap,
		maxSelfDuration = maxSelfDuration,
		renderPathNodes = renderPathNodes,
		rows = rows,
	}
	cachedChartData:set(chartDataKey, chartData)
	return chartData
end
exports.getChartData = getChartData
local function invalidateChartData(): any
	return cachedChartData:clear()
end
exports.invalidateChartData = invalidateChartData
return exports ]]
cj.Children._037d5e8644df77270de12b5f29f46be9=cm
local cn

local co={ClassName="ModuleScript",Children={},Properties={}}
co.Name="InteractionsChartBuilder"
co.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>

local exports = {}

local devtoolsTypes = require(script.Parent.Parent.Parent.types)
type ProfilerStore = devtoolsTypes.ProfilerStore
local typesModule = require(script.Parent.types)
type Interaction = typesModule.Interaction
export type ChartData = {
	interactions: Array<Interaction>,
	lastInteractionTime: number,
	maxCommitDuration: number,
}
local cachedChartData: Map<number, ChartData> = Map.new()
local function getChartData(
	ref: { profilerStore: ProfilerStore, rootID: number }
): ChartData
	local profilerStore, rootID = ref.profilerStore, ref.rootID
	if cachedChartData:has(rootID) then
		return (cachedChartData:get(rootID) :: any) :: ChartData
	end
	local dataForRoot = profilerStore:getDataForRoot(rootID)
	if dataForRoot == nil then
		error(
			string.format('Could not find profiling data for root "%s"', tostring(rootID))
		)
	end
	-- ROBLOX FIXME Luau: any cast necessary to work around: Property 'interactions' is not compatible. Type 'Array<Interaction> | Array<a> | Array<string>' could not be converted into 'Array<Interaction>'
	local commitData, interactions: any = dataForRoot.commitData, dataForRoot.interactions
	local lastInteractionTime = if #commitData > 0
		then commitData[#commitData].timestamp
		else 0
	local maxCommitDuration = 0
	Array.forEach(commitData, function(commitDatum)
		maxCommitDuration = math.max(maxCommitDuration, commitDatum.duration)
	end)
	local chartData = {
		interactions = Array.from(interactions:values()) :: Array<Interaction>,
		lastInteractionTime = lastInteractionTime,
		maxCommitDuration = maxCommitDuration,
	}
	cachedChartData:set(rootID, chartData)
	return chartData
end
exports.getChartData = getChartData
local function invalidateChartData(): any?
	return cachedChartData:clear()
end
exports.invalidateChartData = invalidateChartData
return exports ]]
cj.Children._0807f41962c8cc8b629e7ca7817a9d37=co
local cp

local cq={ClassName="ModuleScript",Children={},Properties={}}
cq.Name="RankedChartBuilder"
cq.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Map = LuauPolyfill.Map

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>
type Set<T> = LuauPolyfill.Set<T>

local exports = {}

local devtoolsTypes = require(script.Parent.Parent.Parent.types)
type ProfilerStore = devtoolsTypes.ProfilerStore

local typesModule = require(script.Parent.Parent.Parent.Parent.types)
local ElementTypeForwardRef = typesModule.ElementTypeForwardRef
local ElementTypeMemo = typesModule.ElementTypeMemo
local formatDuration = require(script.Parent.utils).formatDuration
local Profiler_typesModule = require(script.Parent.types)
type CommitTree = Profiler_typesModule.CommitTree
type CommitTreeNode = Profiler_typesModule.CommitTreeNode

export type ChartNode = { id: number, label: string, name: string, value: number }
export type ChartData = { maxValue: number, nodes: Array<ChartNode> }
local cachedChartData: Map<string, ChartData> = Map.new()
local function getChartData(ref: {
	commitIndex: number,
	commitTree: CommitTree,
	profilerStore: ProfilerStore,
	rootID: number,
}): ChartData
	local commitIndex, commitTree, profilerStore, rootID =
		ref.commitIndex, ref.commitTree, ref.profilerStore, ref.rootID
	local commitDatum = profilerStore:getCommitData(rootID, commitIndex)
	local fiberActualDurations: Map<number, number>, fiberSelfDurations: Map<number, number> =
		commitDatum.fiberActualDurations, commitDatum.fiberSelfDurations
	local nodes = commitTree.nodes
	local chartDataKey = ("%s-%s"):format(tostring(rootID), tostring(commitIndex))
	if cachedChartData:has(chartDataKey) then
		return (cachedChartData:get(chartDataKey) :: any) :: ChartData
	end
	local maxSelfDuration = 0
	local chartNodes: Array<ChartNode> = {}
	-- ROBLOX deviation? this is a simple Map, but could .forEach() always be generalized into genealized for-in if the loop is 'simple'?
	for id, actualDuration in fiberActualDurations do
		local node = nodes:get(id)
		if node == nil then
			error(
				string.format(
					'Could not find node with id "%s" in commit tree',
					tostring(id)
				)
			)
		end
		-- ROBLOX FIXME Luau: need to understand that error() means `node` has nil-ability stripped
		local displayName, key, parentID, type_ =
			(node :: CommitTreeNode).displayName,
			(node :: CommitTreeNode).key,
			(node :: CommitTreeNode).parentID,
			(node :: CommitTreeNode).type -- Don't show the root node in this chart.
		if parentID == 0 then
			continue
		end
		local selfDuration = fiberSelfDurations:get(id) or 0
		maxSelfDuration = math.max(maxSelfDuration, selfDuration)
		local name = displayName or "Anonymous"
		local maybeKey = if Boolean.toJSBoolean(key)
			then (' key="%s"'):format(tostring(key))
			else ""
		local maybeBadge = ""
		if type_ == ElementTypeForwardRef then
			maybeBadge = " (ForwardRef)"
		elseif type_ == ElementTypeMemo then
			maybeBadge = " (Memo)"
		end
		local label = ("%s%s%s (%sms)"):format(
			tostring(name),
			tostring(maybeBadge),
			tostring(maybeKey),
			tostring(formatDuration(selfDuration))
		)
		table.insert(
			chartNodes,
			{ id = id, label = label, name = name, value = selfDuration }
		)
	end
	local chartData = {
		maxValue = maxSelfDuration,
		nodes = Array.sort(chartNodes, function(a, b)
			return b.value - a.value
		end),
	}
	cachedChartData:set(chartDataKey, chartData)
	return chartData
end
exports.getChartData = getChartData
local function invalidateChartData(): any?
	return cachedChartData:clear()
end
exports.invalidateChartData = invalidateChartData
return exports ]]
cj.Children._c82da4c8d71e9755c4d4879dab788c24=cq
local cr

local cs={ClassName="ModuleScript",Children={},Properties={}}
cs.Name="types"
cs.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/devtools/views/Profiler/types.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>
local exports = {}

local ReactDevtoolsSharedTypes = require(script.Parent.Parent.Parent.Parent.types)

type ElementType = ReactDevtoolsSharedTypes.ElementType

export type CommitTreeNode = {
	id: number,
	children: Array<number>,
	displayName: string | nil,
	hocDisplayNames: Array<string> | nil,
	key: number | string | nil,
	parentID: number,
	treeBaseDuration: number,
	type: ElementType,
}

export type CommitTree = { nodes: Map<number, CommitTreeNode>, rootID: number }

export type Interaction = { id: number, name: string, timestamp: number }

export type SnapshotNode = {
	id: number,
	children: Array<number>,
	displayName: string | nil,
	hocDisplayNames: Array<string> | nil,
	key: number | string | nil,
	type: ElementType,
}

export type ChangeDescription = {
	context: Array<string> | boolean | nil,
	didHooksChange: boolean,
	isFirstMount: boolean,
	props: Array<string> | nil,
	state: Array<string> | nil,
}

export type CommitDataFrontend = {
	-- Map of Fiber (ID) to a description of what changed in this commit.
	changeDescriptions: Map<number, ChangeDescription> | nil,

	-- How long was this commit?
	duration: number,

	-- Map of Fiber (ID) to actual duration for this commit;
	-- Fibers that did not render will not have entries in this Map.
	fiberActualDurations: Map<number, number>,

	-- Map of Fiber (ID) to "self duration" for this commit;
	-- Fibers that did not render will not have entries in this Map.
	fiberSelfDurations: Map<number, number>,

	-- Which interactions (IDs) were associated with this commit.
	interactionIDs: Array<number>,

	-- Priority level of the commit (if React provided this info)
	priorityLevel: string | nil,

	-- When did this commit occur (relative to the start of profiling)
	timestamp: number,
}

export type ProfilingDataForRootFrontend = {
	-- Timing, duration, and other metadata about each commit.
	commitData: Array<CommitDataFrontend>,

	-- Display name of the nearest descendant component (ideally a function or class component).
	-- This value is used by the root selector UI.
	displayName: string,

	-- Map of fiber id to (initial) tree base duration when Profiling session was started.
	-- This info can be used along with commitOperations to reconstruct the tree for any commit.
	initialTreeBaseDurations: Map<number, number>,

	-- All interactions recorded (for this root) during the current session.
	interactionCommits: Map<number, Array<number>>,

	-- All interactions recorded (for this root) during the current session.
	interactions: Map<number, Interaction>,

	-- List of tree mutation that occur during profiling.
	-- These mutations can be used along with initial snapshots to reconstruct the tree for any commit.
	operations: Array<Array<number>>,

	-- Identifies the root this profiler data corresponds to.
	rootID: number,

	-- Map of fiber id to node when the Profiling session was started.
	-- This info can be used along with commitOperations to reconstruct the tree for any commit.
	snapshots: Map<number, SnapshotNode>,
}

-- Combination of profiling data collected by the renderer interface (backend) and Store (frontend).
export type ProfilingDataFrontend = {
	-- Profiling data per root.
	dataForRoots: Map<number, ProfilingDataForRootFrontend>,
	imported: boolean,
}

export type CommitDataExport = {
	-- ROBLOX TODO: how to express bracket syntax embedded in Array type?
	--   changeDescriptions: Array<[number, ChangeDescription]> | nil,
	changeDescriptions: Array<Array<number | ChangeDescription>> | nil,
	duration: number,
	-- Tuple of fiber ID and actual duration
	fiberActualDurations: Array<Array<number>>,
	-- Tuple of fiber ID and computed "self" duration
	fiberSelfDurations: Array<Array<number>>,
	interactionIDs: Array<number>,
	priorityLevel: string | nil,
	timestamp: number,
}

export type ProfilingDataForRootExport = {
	commitData: Array<CommitDataExport>,
	displayName: string,
	-- Tuple of Fiber ID and base duration
	initialTreeBaseDurations: Array<Array<number>>,
	-- Tuple of Interaction ID and commit indices
	interactionCommits: Array<Array<number | Array<number>>>,
	interactions: Array<Array<number | Interaction>>,
	operations: Array<Array<number>>,
	rootID: number,
	snapshots: Array<Array<number | SnapshotNode>>,
}

-- Serializable version of ProfilingDataFrontend data.
export type ProfilingDataExport = {
	-- ROBLOX TODO: Luau can't express literals/enums
	--   version: 4,
	version: number,
	dataForRoots: Array<ProfilingDataForRootExport>,
}

return exports ]]
cj.Children._5956511115308cf9385c11b142f0100d=cs
local ct

local cu={ClassName="ModuleScript",Children={},Properties={}}
cu.Name="utils"
cu.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Map = LuauPolyfill.Map
local Number = LuauPolyfill.Number

type Map<K, V> = LuauPolyfill.Map<K, V>
type Array<K> = LuauPolyfill.Array<K>

local exports = {}

local PROFILER_EXPORT_VERSION =
	require(script.Parent.Parent.Parent.Parent.constants).PROFILER_EXPORT_VERSION
local backendTypes = require(script.Parent.Parent.Parent.Parent.backend.types)
type ProfilingDataBackend = backendTypes.ProfilingDataBackend
local profilerTypes = require(script.Parent.types)
type ProfilingDataExport = profilerTypes.ProfilingDataExport
type ProfilingDataForRootExport = profilerTypes.ProfilingDataForRootExport
type ProfilingDataForRootFrontend = profilerTypes.ProfilingDataForRootFrontend
type ProfilingDataFrontend = profilerTypes.ProfilingDataFrontend
type SnapshotNode = profilerTypes.SnapshotNode

local commitGradient = {
	"var(--color-commit-gradient-0)",
	"var(--color-commit-gradient-1)",
	"var(--color-commit-gradient-2)",
	"var(--color-commit-gradient-3)",
	"var(--color-commit-gradient-4)",
	"var(--color-commit-gradient-5)",
	"var(--color-commit-gradient-6)",
	"var(--color-commit-gradient-7)",
	"var(--color-commit-gradient-8)",
	"var(--color-commit-gradient-9)",
} -- Combines info from the Store (frontend) and renderer interfaces (backend) into the format required by the Profiler UI.
-- This format can then be quickly exported (and re-imported).
local function prepareProfilingDataFrontendFromBackendAndStore(
	dataBackends: Array<
		ProfilingDataBackend
	>,
	operationsByRootID: Map<
		number,
		Array<Array<number>>
	>,
	snapshotsByRootID: Map<
		number,
		Map<number, SnapshotNode>
	>
): ProfilingDataFrontend
	local dataForRoots: Map<number, ProfilingDataForRootFrontend> = Map.new()
	for _, dataBackend in dataBackends do
		for _, ref in dataBackend.dataForRoots do
			local commitData, displayName, initialTreeBaseDurations, interactionCommits, interactions, rootID =
				ref.commitData,
				ref.displayName,
				ref.initialTreeBaseDurations,
				ref.interactionCommits,
				ref.interactions,
				ref.rootID
			local operations = operationsByRootID:get(rootID)
			if operations == nil then
				error(
					Error.new(
						string.format(
							"Could not find profiling operations for root %s",
							tostring(rootID)
						)
					)
				)
			end
			local snapshots = snapshotsByRootID:get(rootID)
			if snapshots == nil then
				error(
					Error.new(
						string.format(
							"Could not find profiling snapshots for root %s",
							tostring(rootID)
						)
					)
				)
			end

			-- Do not filter empty commits from the profiler data!
			-- We used to do this, but it was error prone (see #18798).
			-- A commit may appear to be empty (no actual durations) because of component filters,
			-- but filtering these empty commits causes interaction commit indices to be off by N.
			-- This not only corrupts the resulting data, but also potentially causes runtime errors.
			--
			-- For that matter, hiding "empty" commits might cause confusion too.
			-- A commit *did happen* even if none of the components the Profiler is showing were involved.
			local convertedCommitData = Array.map(
				commitData,
				function(commitDataBackend, commitIndex)
					return {
						changeDescriptions = if commitDataBackend.changeDescriptions
								~= nil
							then Map.new(commitDataBackend.changeDescriptions)
							else nil,
						duration = commitDataBackend.duration,
						fiberActualDurations = Map.new(
							commitDataBackend.fiberActualDurations
						),
						fiberSelfDurations = Map.new(
							commitDataBackend.fiberSelfDurations
						),
						interactionIDs = commitDataBackend.interactionIDs,
						priorityLevel = commitDataBackend.priorityLevel,
						timestamp = commitDataBackend.timestamp,
					}
				end
			)
			dataForRoots:set(rootID, {
				commitData = convertedCommitData,
				displayName = displayName,
				initialTreeBaseDurations = Map.new(initialTreeBaseDurations),
				interactionCommits = Map.new(interactionCommits),
				interactions = Map.new(interactions),
				-- ROBLOX FIXME Luau: need type states to not need manual annotation
				operations = operations :: Array<Array<number>>,
				rootID = rootID,
				-- ROBLOX FIXME Luau: need type states to not need manual annotation
				snapshots = snapshots :: Map<number, SnapshotNode>,
			})
		end
	end
	return {
		dataForRoots = dataForRoots,
		imported = false,
	}
end

-- Converts a Profiling data export into the format required by the Store.
exports.prepareProfilingDataFrontendFromBackendAndStore =
	prepareProfilingDataFrontendFromBackendAndStore
local function prepareProfilingDataFrontendFromExport(
	profilingDataExport: ProfilingDataExport
): ProfilingDataFrontend
	local version_ = profilingDataExport.version
	if version_ ~= PROFILER_EXPORT_VERSION then
		error(
			string.format('Unsupported profiler export version "%s"', tostring(version_))
		)
	end
	local dataForRoots: Map<number, ProfilingDataForRootFrontend> = Map.new()
	Array.forEach(profilingDataExport.dataForRoots, function(ref)
		local commitData, displayName, initialTreeBaseDurations, interactionCommits, interactions, operations, rootID, snapshots =
			ref.commitData,
			ref.displayName,
			ref.initialTreeBaseDurations,
			ref.interactionCommits,
			ref.interactions,
			ref.operations,
			ref.rootID,
			ref.snapshots
		dataForRoots:set(rootID, {
			commitData = Array.map(commitData, function(ref)
				local changeDescriptions, duration, fiberActualDurations, fiberSelfDurations, interactionIDs, priorityLevel, timestamp =
					ref.changeDescriptions,
					ref.duration,
					ref.fiberActualDurations,
					ref.fiberSelfDurations,
					ref.interactionIDs,
					ref.priorityLevel,
					ref.timestamp
				return {
					changeDescriptions = if changeDescriptions ~= nil
						then Map.new(changeDescriptions)
						else nil,
					duration = duration,
					fiberActualDurations = Map.new(fiberActualDurations),
					fiberSelfDurations = Map.new(fiberSelfDurations),
					interactionIDs = interactionIDs,
					priorityLevel = priorityLevel,
					timestamp = timestamp,
				}
			end),
			displayName = displayName,
			initialTreeBaseDurations = Map.new(initialTreeBaseDurations),
			interactionCommits = Map.new(interactionCommits),
			interactions = Map.new(interactions),
			operations = operations,
			rootID = rootID,
			snapshots = Map.new(snapshots),
		})
	end)
	return { dataForRoots = dataForRoots, imported = true }
end
exports.prepareProfilingDataFrontendFromExport = prepareProfilingDataFrontendFromExport -- Converts a Store Profiling data into a format that can be safely (JSON) serialized for export.
local function prepareProfilingDataExport(
	profilingDataFrontend: ProfilingDataFrontend
): ProfilingDataExport
	local dataForRoots: Array<ProfilingDataForRootExport> = {}
	profilingDataFrontend.dataForRoots:forEach(function(ref)
		local commitData, displayName, initialTreeBaseDurations, interactionCommits, interactions, operations, rootID, snapshots =
			ref.commitData,
			ref.displayName,
			ref.initialTreeBaseDurations,
			ref.interactionCommits,
			ref.interactions,
			ref.operations,
			ref.rootID,
			ref.snapshots
		table.insert(dataForRoots, {
			commitData = Array.map(commitData, function(ref)
				local changeDescriptions, duration, fiberActualDurations, fiberSelfDurations, interactionIDs, priorityLevel, timestamp =
					ref.changeDescriptions,
					ref.duration,
					ref.fiberActualDurations,
					ref.fiberSelfDurations,
					ref.interactionIDs,
					ref.priorityLevel,
					ref.timestamp
				return {
					changeDescriptions = if changeDescriptions ~= nil
						-- ROBLOX FIXME: types aren't flowing from entries through to return value of Array.from
						then Array.from(changeDescriptions:entries()) :: Array<Array<any>>
						else nil,
					duration = duration,
					fiberActualDurations = Array.from(fiberActualDurations:entries()) :: Array<Array<number>>,
					fiberSelfDurations = Array.from(fiberSelfDurations:entries()) :: Array<Array<number>>,
					interactionIDs = interactionIDs,
					priorityLevel = priorityLevel,
					timestamp = timestamp,
				}
			end),
			displayName = displayName,
			-- ROBLOX FIXME: types aren't flowing from entries through to return value of Array.from
			initialTreeBaseDurations = Array.from(initialTreeBaseDurations:entries()) :: Array<Array<number>>,
			interactionCommits = Array.from(interactionCommits:entries()) :: Array<Array<Array<number> | number>>,
			interactions = Array.from(interactions:entries()) :: Array<Array<any>>,
			operations = operations,
			rootID = rootID,
			snapshots = Array.from(snapshots:entries()) :: Array<Array<any>>,
		})
	end)
	return { version = PROFILER_EXPORT_VERSION, dataForRoots = dataForRoots }
end
exports.prepareProfilingDataExport = prepareProfilingDataExport
local function getGradientColor(value: number)
	local maxIndex = #commitGradient
	local index
	if Number.isNaN(value) then
		index = 0
	elseif not Number.isFinite(value) then
		index = maxIndex
	else
		index = math.max(0, math.min(maxIndex, value)) * maxIndex
	end
	return commitGradient[math.round(index)]
end
exports.getGradientColor = getGradientColor
local function formatDuration(duration: number)
	local ref = math.round(duration * 10) / 10
	return if Boolean.toJSBoolean(ref) then ref else "<0.1"
end
exports.formatDuration = formatDuration
local function formatPercentage(percentage: number)
	return math.round(percentage * 100)
end
exports.formatPercentage = formatPercentage
local function formatTime(timestamp: number)
	return math.round(math.round(timestamp) / 100) / 10
end
exports.formatTime = formatTime
local function scale(
	minValue: number,
	maxValue: number,
	minRange: number,
	maxRange: number
)
	return function(value: number, fallbackValue: number)
		return if maxValue - minValue == 0
			then fallbackValue
			else (value - minValue) / (maxValue - minValue) * (maxRange - minRange)
	end
end
exports.scale = scale
return exports ]]
cj.Children._4eb5426c3ed914a4286d869df6b907b6=cu
local cv

local cw={ClassName="ModuleScript",Children={},Properties={}}
cw.Name="events"
cw.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/events.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Function = (...any) -> ...any
type ElementType<T, U> = any
type EventListener = (...ElementType<any, string>) -> ...any

export type EventEmitter<Events> = {
	listenersMap: Map<string, Array<Function>>,
	-- ROBLOX TODO: function generics <Event: $Keys<Events>>(
	addListener: (
		self: EventEmitter<Events>,
		event: string,
		listener: EventListener
	) -> (),
	-- ROBLOX TODO: function generics <Event: $Keys<Events>>(
	emit: (EventEmitter<Events>, string, ...ElementType<Events, string>) -> (),
	removeAllListeners: (EventEmitter<Events>) -> (),
	-- ROBLOX deviation: Luau doesn't support $Keys<Events> for first non-self param
	removeListener: (self: EventEmitter<Events>, event: string, listener: Function) -> (),
}
type EventEmitter_statics = {
	new: () -> EventEmitter<any>,
}
local EventEmitter: EventEmitter<any> & EventEmitter_statics = (
	{} :: any
) :: EventEmitter<any> & EventEmitter_statics
local EventEmitterMetatable = { __index = EventEmitter }

function EventEmitter.new(): EventEmitter<any>
	local self = {}
	self.listenersMap = Map.new()

	return (setmetatable(self, EventEmitterMetatable) :: any) :: EventEmitter<any>
end

function EventEmitter:addListener(event: string, listener: EventListener): ()
	local listeners = self.listenersMap:get(event)
	if listeners == nil then
		self.listenersMap:set(event, { listener })
	else
		local index = Array.indexOf(listeners :: Array<EventListener>, listener)
		if index < 1 then
			table.insert(listeners, listener)
		end
	end
end

-- ROBLOX deviation: Luau doesn't support $Keys<Events> for first non-self param
function EventEmitter:emit(event: string, ...: ElementType<string, string>): ()
	local listeners = self.listenersMap:get(event)
	if listeners ~= nil then
		if #listeners == 1 then
			-- No need to clone or try/catch
			local listener = listeners[1]
			listener(...)
		else
			local didThrow = false
			local caughtError = nil
			local clonedListeners = table.clone(listeners)
			for _, listener in clonedListeners do
				local ok, error_ = pcall(function(...)
					listener(...)
					return nil
				end, ...)
				if not ok then
					didThrow = true
					caughtError = error_
				end
			end
			if didThrow then
				-- ROBLOX note: stringify error to avoid "nil output from lua" error
				error(tostring(caughtError))
			end
		end
	end
end

function EventEmitter:removeAllListeners(): ()
	self.listenersMap:clear()
end

-- ROBLOX deviation: Luau doesn't support $Keys<Events> for first non-self param
function EventEmitter:removeListener(event: string, listener: Function): ()
	local listeners = self.listenersMap:get(event)

	if listeners ~= nil then
		local index = Array.indexOf(listeners, listener)

		if index >= 1 then
			Array.splice(listeners, index, 1)
		end
	end
end

return EventEmitter ]]
a2.Children._86a35a78a8b087befb5dbb1fb0eb41f2=cw
local cx

local cy={ClassName="ModuleScript",Children={},Properties={}}
cy.Name="hook"
cy.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://raw.githubusercontent.com/facebook/react/v17.0.1/packages/react-devtools-shared/src/hook.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]
local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Map = LuauPolyfill.Map
local Set = LuauPolyfill.Set
type Set<T> = LuauPolyfill.Set<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Function = (...any) -> any
local exports = {}

local console = require(script.Parent.backend.console)
local patchConsole = console.patch
local registerRendererWithConsole = console.registerRenderer

local BackendTypes = require(script.Parent.backend.types)
type DevToolsHook = BackendTypes.DevToolsHook

local window = _G

exports.installHook = function(target: any): DevToolsHook | nil
	if target["__REACT_DEVTOOLS_GLOBAL_HOOK__"] then
		return nil
	end

	-- ROBLOX deviation: hoist decls to top
	local hook: DevToolsHook
	-- ROBLOX deviation: always false, only relevant in context of optimizing bundler
	local hasDetectedBadDCE = false
	-- TODO: More meaningful names for "rendererInterfaces" and "renderers".
	local fiberRoots = {}
	local rendererInterfaces = Map.new()
	local listeners = {}
	local renderers = Map.new()

	local function detectReactBuildType(renderer)
		-- ROBLOX TODO? do we need to distinguish between prod and dev bundles?
		return "production"
	end
	local function checkDCE(fn: Function)
		-- ROBLOX deviation: not needed in the absence of optimizing bundler
	end

	-- ROBLOX deviation: start at 1
	local uidCounter = 1
	local function PREFIX_INCREMENT()
		uidCounter += 1
		return uidCounter
	end

	local function inject(renderer)
		local id = PREFIX_INCREMENT()

		renderers:set(id, renderer)

		local reactBuildType = if hasDetectedBadDCE
			then "deadcode"
			else detectReactBuildType(renderer)

		-- ROBLOX deviation: instead of checking if `process.env.NODE_ENV ~= "production"`
		-- we use the __DEV__ global
		if _G.__DEV__ then
			pcall(function()
				local appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__
					~= false
				local breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__
					== true

				-- The installHook() function is injected by being stringified in the browser,
				-- so imports outside of this function do not get included.
				--
				-- Normally we could check "type patchConsole === 'function'",
				-- but Webpack wraps imports with an object (e.g. _backend_console__WEBPACK_IMPORTED_MODULE_0__)
				-- and the object itself will be undefined as well for the reasons mentioned above,
				-- so we use try/catch instead.
				if appendComponentStack or breakOnConsoleErrors then
					registerRendererWithConsole(renderer)
					patchConsole({
						appendComponentStack = appendComponentStack,
						breakOnConsoleErrors = breakOnConsoleErrors,
					})
				end
			end)
		end

		local attach = target.__REACT_DEVTOOLS_ATTACH__

		if type(attach) == "function" then
			local rendererInterface = attach(hook, id, renderer, target)
			hook.rendererInterfaces:set(id, rendererInterface)
		end

		hook.emit("renderer", {
			id = id,
			renderer = renderer,
			reactBuildType = reactBuildType,
		})
		return id
	end

	local function sub(event: string, fn: (any) -> ())
		hook.on(event, fn)
		return function()
			return hook.off(event, fn)
		end
	end
	local function on(event, fn)
		if not listeners[event] then
			listeners[event] = {}
		end
		table.insert(listeners[event], fn)
	end
	local function off(event, fn)
		if not listeners[event] then
			return
		end

		local index = Array.indexOf(listeners[event], fn)

		if index ~= -1 then
			Array.splice(listeners[event], index, 1)
		end
		if #listeners[event] == 0 then
			listeners[event] = nil
		end
	end
	local function emit(event, data)
		if listeners[event] then
			for _, fn in listeners[event] do
				fn(data)
			end
		end
	end
	local function getFiberRoots(rendererID)
		local roots = fiberRoots

		if not roots[rendererID] then
			roots[rendererID] = Set.new()
		end

		return roots[rendererID]
	end
	local function onCommitFiberUnmount(rendererID, fiber)
		local rendererInterface = rendererInterfaces:get(rendererID)

		if rendererInterface ~= nil then
			rendererInterface.handleCommitFiberUnmount(fiber)
		end
	end
	local function onCommitFiberRoot(rendererID, root, priorityLevel)
		local mountedRoots = hook.getFiberRoots(rendererID)
		local current = root.current
		local isKnownRoot = mountedRoots[root] ~= nil
		local isUnmounting = current.memoizedState == nil
			or current.memoizedState.element == nil

		if not isKnownRoot and not isUnmounting then
			mountedRoots[root] = true
		elseif isKnownRoot and isUnmounting then
			mountedRoots[root] = nil
		end

		local rendererInterface = rendererInterfaces:get(rendererID)

		if rendererInterface ~= nil then
			rendererInterface.handleCommitFiberRoot(root, priorityLevel)
		end
	end

	hook = {
		rendererInterfaces = rendererInterfaces,
		listeners = listeners,
		-- Fast Refresh for web relies on this.
		renderers = renderers,

		emit = emit,
		getFiberRoots = getFiberRoots,
		inject = inject,
		on = on,
		off = off,
		sub = sub,

		-- This is a legacy flag.
		-- React v16 checks the hook for this to ensure DevTools is new enough.
		supportsFiber = true,

		-- React calls these methods.
		checkDCE = checkDCE,
		onCommitFiberUnmount = onCommitFiberUnmount,
		onCommitFiberRoot = onCommitFiberRoot,
	}

	target["__REACT_DEVTOOLS_GLOBAL_HOOK__"] = hook
	return hook
end

return exports ]]
a2.Children._de7451381e2271e5f262a1aaf8e62042=cy
local cz

local cA={ClassName="ModuleScript",Children={},Properties={}}
cA.Name="hydration"
cA.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/hydration.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol
type Array<T> = { [number]: T }
type Object = { [string]: any }

-- ROBLOX FIXME: !!! THIS FILE IS A STUB WITH BAREBONES FOR UTILS TEST
local function unimplemented(functionName: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!! " .. functionName .. " was called, but is stubbed! ")
end

local exports = {}

--ROBLOX TODO: circular dependency, inline for now and submit PR to fix upstream
--local ComponentsTypes = require(script.Parent.devtools.views.Components.types)
export type DehydratedData = {
	cleaned: Array<Array<string | number>>,
	data: string
		| Dehydrated
		| Unserializable
		| Array<Dehydrated>
		| Array<Unserializable>
		| { [string]: string | Dehydrated | Unserializable },
	unserializable: Array<Array<string | number>>,
}

exports.meta = {
	inspectable = Symbol("inspectable"),
	inspected = Symbol("inspected"),
	name = Symbol("name"),
	preview_long = Symbol("preview_long"),
	preview_short = Symbol("preview_short"),
	readonly = Symbol("readonly"),
	size = Symbol("size"),
	type = Symbol("type"),
	unserializable = Symbol("unserializable"),
}

export type Dehydrated = {
	inspectable: boolean,
	name: string | nil,
	preview_long: string | nil,
	preview_short: string | nil,
	readonly: boolean?,
	size: number?,
	type: string,
}

-- Typed arrays and other complex iteratable objects (e.g. Map, Set, ImmutableJS) need special handling.
-- These objects can't be serialized without losing type information,
-- so a "Unserializable" type wrapper is used (with meta-data keys) to send nested values-
-- while preserving the original type and name.
export type Unserializable = {
	name: string | nil,
	preview_long: string | nil,
	preview_short: string | nil,
	readonly: boolean?,
	size: number?,
	type: string,
	unserializable: boolean,
	-- ...
}

-- This threshold determines the depth at which the bridge "dehydrates" nested data.
-- Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
-- unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
--
-- Reducing this threshold will improve the speed of initial component inspection,
-- but may decrease the responsiveness of expanding objects/arrays to inspect further.
local _LEVEL_THRESHOLD = 2

-- /**
--  * Generate the dehydrated metadata for complex object instances
--  */
exports.createDehydrated = function(
	type: string,
	inspectable: boolean,
	data: Object,
	cleaned: Array<Array<string | number>>,
	path: Array<string | number>
): Dehydrated
	unimplemented("createDehydrated")
	error("unimplemented createDehydrated")
end

-- /**
--  * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
--  * The paths of the stripped out objects are appended to the `cleaned` list.
--  * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
--  * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
--  *
--  * Input: {"some": {"attr": fn()}, "other": AnInstance}
--  * Output: {
--  *   "some": {
--  *     "attr": {"name": the fn.name, type: "function"}
--  *   },
--  *   "other": {
--  *     "name": "AnInstance",
--  *     "type": "object",
--  *   },
--  * }
--  * and cleaned = \[\["some", "attr"], ["other"\]\]
--  */
exports.dehydrate = function(
	data: Object,
	cleaned: Array<Array<string | number>>,
	unserializable: Array<Array<string | number>>,
	path: Array<string | number>,
	isPathAllowed: (Array<string | number>) -> boolean,
	level: number?
): string | Dehydrated | Unserializable | Array<Dehydrated> | Array<Unserializable> | {
	[string]: string | Dehydrated | Unserializable, --\[\[...\]\]
}
	if level == nil then
		level = 0
	end

	-- ROBLOX TODO: port this properly, for now just do the default case
	-- let isPathAllowedCheck;

	-- switch (type) {
	--   case 'html_element':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data.tagName,
	-- 	  type,
	-- 	};

	--   case 'function':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name:
	-- 		typeof data.name === 'function' || !data.name
	-- 		  ? 'function'
	-- 		  : data.name,
	-- 	  type,
	-- 	};

	--   case 'string':
	-- 	isPathAllowedCheck = isPathAllowed(path);
	-- 	if (isPathAllowedCheck) {
	-- 	  return data;
	-- 	} else {
	-- 	  return data.length <= 500 ? data : data.slice(0, 500) + '...';
	-- 	}

	--   case 'bigint':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data.toString(),
	-- 	  type,
	-- 	};

	--   case 'symbol':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data.toString(),
	-- 	  type,
	-- 	};

	--   // React Elements aren't very inspector-friendly,
	--   // and often contain private fields or circular references.
	--   case 'react_element':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: getDisplayNameForReactElement(data) || 'Unknown',
	-- 	  type,
	-- 	};

	--   // ArrayBuffers error if you try to inspect them.
	--   case 'array_buffer':
	--   case 'data_view':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
	-- 	  size: data.byteLength,
	-- 	  type,
	-- 	};

	--   case 'array':
	-- 	isPathAllowedCheck = isPathAllowed(path);
	-- 	if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
	-- 	  return createDehydrated(type, true, data, cleaned, path);
	-- 	}
	-- 	return data.map((item, i) =>
	-- 	  dehydrate(
	-- 		item,
	-- 		cleaned,
	-- 		unserializable,
	-- 		path.concat([i]),
	-- 		isPathAllowed,
	-- 		isPathAllowedCheck ? 1 : level + 1,
	-- 	  ),
	-- 	);

	--   case 'html_all_collection':
	--   case 'typed_array':
	--   case 'iterator':
	-- 	isPathAllowedCheck = isPathAllowed(path);
	-- 	if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
	-- 	  return createDehydrated(type, true, data, cleaned, path);
	-- 	} else {
	-- 	  const unserializableValue: Unserializable = {
	-- 		unserializable: true,
	-- 		type: type,
	-- 		readonly: true,
	-- 		size: type === 'typed_array' ? data.length : undefined,
	-- 		preview_short: formatDataForPreview(data, false),
	-- 		preview_long: formatDataForPreview(data, true),
	-- 		name:
	-- 		  !data.constructor || data.constructor.name === 'Object'
	-- 			? ''
	-- 			: data.constructor.name,
	-- 	  };

	-- 	  // TRICKY
	-- 	  // Don't use [...spread] syntax for this purpose.
	-- 	  // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
	-- 	  // Other types (e.g. typed arrays, Sets) will not spread correctly.
	-- 	  Array.from(data).forEach(
	-- 		(item, i) =>
	-- 		  (unserializableValue[i] = dehydrate(
	-- 			item,
	-- 			cleaned,
	-- 			unserializable,
	-- 			path.concat([i]),
	-- 			isPathAllowed,
	-- 			isPathAllowedCheck ? 1 : level + 1,
	-- 		  )),
	-- 	  );

	-- 	  unserializable.push(path);

	-- 	  return unserializableValue;
	-- 	}

	--   case 'opaque_iterator':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data[Symbol.toStringTag],
	-- 	  type,
	-- 	};

	--   case 'date':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data.toString(),
	-- 	  type,
	-- 	};

	--   case 'regexp':
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  inspectable: false,
	-- 	  preview_short: formatDataForPreview(data, false),
	-- 	  preview_long: formatDataForPreview(data, true),
	-- 	  name: data.toString(),
	-- 	  type,
	-- 	};

	--   case 'object':
	-- 	isPathAllowedCheck = isPathAllowed(path);
	-- 	if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
	-- 	  return createDehydrated(type, true, data, cleaned, path);
	-- 	} else {
	-- 	  const object = {};
	-- 	  getAllEnumerableKeys(data).forEach(key => {
	-- 		const name = key.toString();
	-- 		object[name] = dehydrate(
	-- 		  data[key],
	-- 		  cleaned,
	-- 		  unserializable,
	-- 		  path.concat([name]),
	-- 		  isPathAllowed,
	-- 		  isPathAllowedCheck ? 1 : level + 1,
	-- 		);
	-- 	  });
	-- 	  return object;
	-- 	}

	--   case 'infinity':
	--   case 'nan':
	--   case 'undefined':
	-- 	// Some values are lossy when sent through a WebSocket.
	-- 	// We dehydrate+rehydrate them to preserve their type.
	-- 	cleaned.push(path);
	-- 	return {
	-- 	  type,
	-- 	};

	--   default:
	return data
end

exports.fillInPath = function(
	object: Object,
	data: DehydratedData,
	path: Array<string | number>,
	value: any
): ()
	unimplemented("fillInPath")
end

exports.hydrate = function(
	object: any,
	cleaned: Array<Array<string | number>>,
	unserializable: Array<Array<string | number>>
): Object
	-- ROBLOX TODO: port this properly later, for now return the default
	-- 	const length = path.length;
	--     const last = path[length - 1];
	--     const parent = getInObject(object, path.slice(0, length - 1));
	--     if (!parent || !parent.hasOwnProperty(last)) {
	--       return;
	--     }

	--     const value = parent[last];

	--     if (value.type === 'infinity') {
	--       parent[last] = Infinity;
	--     } else if (value.type === 'nan') {
	--       parent[last] = NaN;
	--     } else if (value.type === 'undefined') {
	--       parent[last] = undefined;
	--     } else {
	--       // Replace the string keys with Symbols so they're non-enumerable.
	--       const replaced: {[key: Symbol]: boolean | string, ...} = {};
	--       replaced[meta.inspectable] = !!value.inspectable;
	--       replaced[meta.inspected] = false;
	--       replaced[meta.name] = value.name;
	--       replaced[meta.preview_long] = value.preview_long;
	--       replaced[meta.preview_short] = value.preview_short;
	--       replaced[meta.size] = value.size;
	--       replaced[meta.readonly] = !!value.readonly;
	--       replaced[meta.type] = value.type;

	--       parent[last] = replaced;
	--     }
	--   });
	--   unserializable.forEach((path: Array<string | number>) => {
	--     const length = path.length;
	--     const last = path[length - 1];
	--     const parent = getInObject(object, path.slice(0, length - 1));
	--     if (!parent || !parent.hasOwnProperty(last)) {
	--       return;
	--     }

	--     const node = parent[last];

	--     const replacement = {
	--       ...node,
	--     };

	--     upgradeUnserializable(replacement, node);

	--     parent[last] = replacement;
	--   });

	return object
end

return exports ]]
a2.Children._07cece602a78471295499119bae562f6=cA
local cB

local cC={ClassName="ModuleScript",Children={},Properties={}}
cC.Name="jest.config"
cC.Properties.Source=[[ return {
	setupFilesAfterEnv = { script.Parent.__tests__.setupTests },
	testMatch = { "**/*.(spec|test)" },
} ]]
a2.Children._6199ed4211350cc4c2b38b49e30b2ae4=cC
local cD

local cE={ClassName="ModuleScript",Children={},Properties={}}
cE.Name="storage"
cE.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/storage.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  */

local exports = {}
if _G.__LOCALSTORAGE__ == nil then
	_G.__LOCALSTORAGE__ = {}
end

if _G.__SESSIONSTORAGE__ == nil then
	_G.__SESSIONSTORAGE__ = {}
end

-- ROBLOX FIXME: what's a high-performance storage that for temporal (current DM lifetime) and permanent (beyond current DM lifetime)
local localStorage = _G.__LOCALSTORAGE__
local sessionStorage = _G.__SESSIONSTORAGE__

exports.localStorageGetItem = function(key: string): any
	return localStorage[key]
end
exports.localStorageRemoveItem = function(key: string): ()
	localStorage[key] = nil
end
exports.localStorageSetItem = function(key: string, value: any): ()
	localStorage[key] = value
end
exports.sessionStorageGetItem = function(key: string): any
	return sessionStorage[key]
end
exports.sessionStorageRemoveItem = function(key: string): ()
	sessionStorage[key] = nil
end
exports.sessionStorageSetItem = function(key: string, value: any): ()
	sessionStorage[key] = value
end

return exports ]]
a2.Children._9866d67c5b97053915159c86654bf80c=cE
local cF

local cG={ClassName="ModuleScript",Children={},Properties={}}
cG.Name="types"
cG.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/types.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  */

type Array<T> = { [number]: T }
type Function = (...any) -> ...any
local exports = {}

-- WARNING
-- The values below are referenced by ComponentFilters (which are saved via localStorage).
-- Do not change them or it will break previously saved user customizations.
--
-- If new element types are added, use new numbers rather than re-ordering existing ones.
-- Changing these types is also a backwards breaking change for the standalone shell,
-- since the frontend and backend must share the same values-
-- and the backend is embedded in certain environments (like React Native).

export type Wall = {
	listen: (Function) -> Function,
	send: (string, any, Array<any>) -> (),
}

exports.ElementTypeClass = 1
exports.ElementTypeContext = 2
exports.ElementTypeFunction = 5
exports.ElementTypeForwardRef = 6
exports.ElementTypeHostComponent = 7
exports.ElementTypeMemo = 8
exports.ElementTypeOtherOrUnknown = 9
exports.ElementTypeProfiler = 10
exports.ElementTypeRoot = 11
exports.ElementTypeSuspense = 12
exports.ElementTypeSuspenseList = 13

-- Different types of elements displayed in the Elements tree.
-- These types may be used to visually distinguish types,
-- or to enable/disable certain functionality.
-- ROBLOX deviation: Luau doesn't support literals as types: 1 | 2 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
export type ElementType = number

-- WARNING
-- The values below are referenced by ComponentFilters (which are saved via localStorage).
-- Do not change them or it will break previously saved user customizations.
-- If new filter types are added, use new numbers rather than re-ordering existing ones.
exports.ComponentFilterElementType = 1
exports.ComponentFilterDisplayName = 2
exports.ComponentFilterLocation = 3
exports.ComponentFilterHOC = 4

-- ROBLOX deviation: Luau doesn't support literals as types: 1 | 2 | 3 | 4
export type ComponentFilterType = number

-- Hide all elements of types in this Set.
-- We hide host components only by default.
export type ElementTypeComponentFilter = {
	isEnabled: boolean,
	-- ROBLOX deviation: Luau doesn't support literals as types: 1
	type: number,
	value: ElementType,
}

-- Hide all elements with displayNames or paths matching one or more of the RegExps in this Set.
-- Path filters are only used when elements include debug source location.
export type RegExpComponentFilter = {
	isEnabled: boolean,
	isValid: boolean,
	-- ROBLOX deviation: Luau doesn't support literals as types: 2 | 3
	type: number,
	value: string,
}

export type BooleanComponentFilter = {
	isEnabled: boolean,
	isValid: boolean,
	-- ROBLOX deviation: Luau doesn't support literals as types: 4
	type: number,
}

export type ComponentFilter =
	BooleanComponentFilter
	| ElementTypeComponentFilter
	| RegExpComponentFilter

return exports ]]
a2.Children._f29ad8e921690ca207d5fab38fc17378=cG
local cH

local cI={ClassName="ModuleScript",Children={},Properties={}}
cI.Name="utils"
cI.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.1/packages/react-devtools-shared/src/utils.js
-- /*
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  */
--  * LICENSE file in the root directory of this source tree.

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local WeakMap = LuauPolyfill.WeakMap
local Number = LuauPolyfill.Number
local Object = LuauPolyfill.Object
type WeakMap<K, V> = LuauPolyfill.WeakMap<K, V>
type Function = (...any) -> ...any
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
local JSON = game:GetService("HttpService")

local exports = {}

-- ROBLOX TODO: pull in smarter cache when there's a performance reason to do so
-- local LRU = require()
-- ROBLOX deviation: pull in getComponentName for Lua-specific logic to extract component names
local Shared = require(Packages.Shared)
local getComponentName = Shared.getComponentName

local ReactIs = require(Packages.ReactIs)
local isElement = ReactIs.isElement
local typeOf = ReactIs.typeOf
local ContextConsumer = ReactIs.ContextConsumer
local ContextProvider = ReactIs.ContextProvider
local ForwardRef = ReactIs.ForwardRef
local Fragment = ReactIs.Fragment
local Lazy = ReactIs.Lazy
local Memo = ReactIs.Memo
local Portal = ReactIs.Portal
local Profiler = ReactIs.Profiler
local StrictMode = ReactIs.StrictMode
local Suspense = ReactIs.Suspense
local ReactSymbols = require(Packages.Shared).ReactSymbols
local SuspenseList = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local constants = require(script.Parent.constants)
local TREE_OPERATION_ADD = constants.TREE_OPERATION_ADD
local TREE_OPERATION_REMOVE = constants.TREE_OPERATION_REMOVE
local TREE_OPERATION_REORDER_CHILDREN = constants.TREE_OPERATION_REORDER_CHILDREN
local TREE_OPERATION_UPDATE_TREE_BASE_DURATION =
	constants.TREE_OPERATION_UPDATE_TREE_BASE_DURATION
local types = require(script.Parent.types)
local ElementTypeRoot = types.ElementTypeRoot
local LOCAL_STORAGE_FILTER_PREFERENCES_KEY =
	constants.LOCAL_STORAGE_FILTER_PREFERENCES_KEY
local LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS =
	constants.LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS
local LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY =
	constants.LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY
local ComponentFilterElementType = types.ComponentFilterElementType
local ElementTypeHostComponent = types.ElementTypeHostComponent
local ElementTypeClass = types.ElementTypeClass
local ElementTypeForwardRef = types.ElementTypeForwardRef
local ElementTypeFunction = types.ElementTypeFunction
local ElementTypeMemo = types.ElementTypeMemo
local storage = require(script.Parent.storage)
local localStorageGetItem = storage.localStorageGetItem
local localStorageSetItem = storage.localStorageSetItem
local hydration = require(script.Parent.hydration)
local meta = hydration.meta
type ComponentFilter = types.ComponentFilter
type ElementType = types.ElementType

local cachedDisplayNames: WeakMap<Function, string> = WeakMap.new()

-- On large trees, encoding takes significant time.
-- Try to reuse the already encoded strings.
-- ROBLOX TODO: implement this when there's a performance issue in Studio tools driving it
-- local encodedStringCache = LRU({max = 1000})

exports.alphaSortKeys = function(
	a: string | number, -- ROBLOX deviation: | Symbol,
	b: string | number -- ROBLOX deviation: | Symbol,
): boolean
	-- ROBLOX deviation: passed to table.sort(), which returns a bool
	return tostring(a) > tostring(b)
end

exports.getAllEnumerableKeys = function(obj: Object): Array<string | number> -- | Symbol>
	-- ROBLOX TODO: we probably need to enumerate inheritance chain metatables
	return Object.keys(obj)
end

exports.getDisplayName = function(type_: any, fallbackName: string?): string
	fallbackName = fallbackName or "Anonymous"
	local nameFromCache = cachedDisplayNames:get(type_)

	if nameFromCache ~= nil then
		return nameFromCache :: string
	end

	-- ROBLOX FIXME: Luau type narrowing doesn't understand the or "anonymous" above
	local displayName: string = fallbackName :: string

	-- The displayName property is not guaranteed to be a string.
	-- It's only safe to use for our purposes if it's a string.
	-- github.com/facebook/react-devtools/issues/803
	-- ROBLOX deviation START: Luau datatypes don't have a displayName property, so we use .__componentName
	if typeof(type_) == "table" and typeof(type_.__componentName) == "string" then
		displayName = type_.__componentName
		-- ROBLOX deviation END
	elseif
		typeof(type_) == "table"
		and typeof(type_.name) == "string"
		and type_.name ~= ""
	then
		displayName = type_.name
		-- ROBLOX deviation: use the Lua logic in getComponentName to extract names of function components
	elseif typeof(type_) == "function" then
		displayName = getComponentName(type_) or displayName
	end

	cachedDisplayNames:set(type_, displayName)

	return displayName
end

local uidCounter: number = 0

exports.getUID = function(): number
	uidCounter += 1
	return uidCounter
end

-- ROBLOX deviation: string encoding not required
-- exports.utfDecodeString = function(str): string
-- end
-- exports.utfEncodeString = function(str): string
-- end

-- ROBLOX deviation: don't binary encode strings, so operations Array can include strings
exports.printOperationsArray = function(operations: Array<number | string>)
	-- The first two values are always rendererID and rootID
	local rendererID = operations[1] :: number
	local rootID = operations[2] :: number
	local logs = {
		string.format(
			"operations for renderer:%s and root:%s",
			tostring(rendererID),
			tostring(rootID)
		),
	}

	-- ROBLOX deviation: 1-indexing so start at 3
	local i = 3

	-- ROBLOX deviation: use POSTFIX_INCREMENT instead of return i++
	local function POSTFIX_INCREMENT()
		local tmp = i
		i += 1
		return tmp
	end

	-- Reassemble the string table.
	local stringTable: Array<string> = {
		-- ROBLOX deviation: Use the empty string
		"", -- ID = 0 corresponds to the empty string.
	}
	local stringTableSize = operations[POSTFIX_INCREMENT()] :: number
	local stringTableEnd = i + stringTableSize

	-- ROBLOX deviation: adjust bounds due to 1-based indexing
	while i < stringTableEnd do
		-- ROBLOX deviation: don't binary encode strings, so store string directly rather than length
		-- local nextLength = operations[POSTFIX_INCREMENT()]
		-- local nextString = exports.utfDecodeString(Array.slice(operations, i, i + nextLength)
		local nextString = operations[POSTFIX_INCREMENT()] :: string
		table.insert(stringTable, nextString)
	end

	while i < #operations do
		local operation = operations[i] :: number

		if operation == TREE_OPERATION_ADD then
			local id = operations[i + 1] :: number
			local type_ = operations[i + 2] :: ElementType

			i += 3

			if type_ == ElementTypeRoot then
				table.insert(logs, string.format("Add new root node %d", id))

				i += 1 -- supportsProfiling
				i += 1 -- hasOwnerMetadata
			else
				local parentID = operations[i] :: number
				i += 1

				i += 1 -- ownerID

				local displayNameStringID = operations[i] :: number
				local displayName = stringTable[displayNameStringID + 1]
				i += 1

				i += 1 -- key

				table.insert(
					logs,
					string.format(
						"Add node %d (%s) as child of %d",
						id,
						displayName or "null",
						parentID
					)
				)
			end
		elseif operation == TREE_OPERATION_REMOVE then
			local removeLength = operations[i + 1] :: number
			i += 2

			for removeIndex = 1, removeLength do
				local id = operations[i] :: number
				i += 1

				table.insert(logs, string.format("Remove node %d", id))
			end
		elseif operation == TREE_OPERATION_REORDER_CHILDREN then
			local id = operations[i + 1] :: number
			local numChildren = operations[i + 2] :: number
			i += 3
			local children = Array.slice(operations, i, i + numChildren)
			i += numChildren

			table.insert(
				logs,
				string.format(
					"Re-order node %d children %s",
					id,
					Array.join(children, ",")
				)
			)
		elseif operation == TREE_OPERATION_UPDATE_TREE_BASE_DURATION then
			-- Base duration updates are only sent while profiling is in progress.
			-- We can ignore them at this point.
			-- The profiler UI uses them lazily in order to generate the tree.
			i += 3
		else
			error(string.format("Unsupported Bridge operation %d", operation))
		end
	end

	print(table.concat(logs, "\n  "))
end

exports.getDefaultComponentFilters = function(): Array<ComponentFilter>
	return {
		{
			type = ComponentFilterElementType,
			value = ElementTypeHostComponent,
			isEnabled = true,
		},
	}
end
exports.getSavedComponentFilters = function(): Array<ComponentFilter>
	local ok, result = pcall(function()
		local raw = localStorageGetItem(LOCAL_STORAGE_FILTER_PREFERENCES_KEY)
		if raw ~= nil then
			return JSON:JSONDecode(raw)
		end
		return nil
	end)
	if not ok then
		return exports.getDefaultComponentFilters()
	end

	return result
end
exports.saveComponentFilters = function(componentFilters: Array<ComponentFilter>): ()
	localStorageSetItem(
		LOCAL_STORAGE_FILTER_PREFERENCES_KEY,
		JSON:JSONEncode(componentFilters)
	)
end
exports.getAppendComponentStack = function(): boolean
	local ok, result = pcall(function()
		local raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY)
		if raw ~= nil then
			return JSON:JSONDecode(raw)
		end
		return nil
	end)
	if not ok then
		return true
	end

	return result
end
exports.setAppendComponentStack = function(value: boolean): ()
	localStorageSetItem(LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY, JSON:JSONEncode(value))
end
exports.getBreakOnConsoleErrors = function(): boolean
	local ok, result = pcall(function()
		local raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS)
		if raw ~= nil then
			return JSON:JSONDecode(raw)
		end
		return nil
	end)
	if ok then
		return result
	end
	return false
end

exports.setBreakOnConsoleErrors = function(value: boolean): ()
	localStorageSetItem(
		LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS,
		JSON:JSONEncode(value)
	)
end
exports.separateDisplayNameAndHOCs = function(
	displayName: string | nil,
	type_: ElementType
): (string | nil, Array<string> | nil)
	if displayName == nil then
		return nil, nil
	end

	local hocDisplayNames: Array<string>? = nil

	if
		type_ == ElementTypeClass
		or type_ == ElementTypeForwardRef
		or type_ == ElementTypeFunction
		or type_ == ElementTypeMemo
	then
		-- ROBLOX deviation START: use find instead of indexOf and gmatch instead of /[^()]+/g
		if string.find(displayName :: string, "(", 1, true) then
			local hocTable: Array<string> = {}
			for match in string.gmatch(displayName :: string, "[^()]+") do
				table.insert(hocTable, match)
			end

			-- ROBLOX note: Pull the last one out as the displayName
			local count = #hocTable
			local lastMatch = hocTable[count]
			hocTable[count] = nil

			displayName = lastMatch
			hocDisplayNames = hocTable
		end
		-- ROBLOX Deviation END
	end

	if type_ == ElementTypeMemo then
		if hocDisplayNames == nil then
			hocDisplayNames = { "Memo" }
		else
			Array.unshift(hocDisplayNames :: Array<string>, "Memo")
		end
	elseif type_ == ElementTypeForwardRef then
		if hocDisplayNames == nil then
			hocDisplayNames = { "ForwardRef" }
		else
			Array.unshift(hocDisplayNames :: Array<string>, "ForwardRef")
		end
	end
	return displayName, hocDisplayNames
end

-- Pulled from preact-compat
-- https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349
exports.shallowDiffers = function(prev: Object, next_: Object): boolean
	for key, value in prev do
		if next_[key] ~= value then
			return true
		end
	end
	return false
end

exports.getInObject = function(object: Object, path: Array<string | number>): any
	return Array.reduce(path, function(reduced: Object, attr: any): any
		if reduced then
			if reduced[attr] ~= nil then
				return reduced[attr]
			end
			-- ROBLOX deviation: no iterators in Symbol polyfill
			-- if typeof(reduced[Symbol.iterator]) == "function" then
			-- 	return Array.from(reduced)[attr]
			-- end
		end

		return nil
	end, object)
end
exports.deletePathInObject = function(object: Object?, path: Array<string | number>)
	local length = #path
	local last = path[length] :: number

	if object ~= nil then
		local parent = exports.getInObject(object :: Object, Array.slice(path, 0, length))

		if parent then
			if Array.isArray(parent) then
				Array.splice(parent, last, 1)
			else
				parent[last] = nil
			end
		end
	end
end
exports.renamePathInObject = function(
	object: Object?,
	oldPath: Array<string | number>,
	newPath: Array<string | number>
)
	local length = #oldPath

	if object ~= nil then
		local parent =
			exports.getInObject(object :: Object, Array.slice(oldPath, 1, length))

		if parent then
			local lastOld = oldPath[length] :: number
			local lastNew = newPath[length] :: number

			parent[lastNew] = parent[lastOld]

			if Array.isArray(parent) then
				Array.splice(parent, lastOld, 1)
			else
				parent[lastOld] = nil
			end
		end
	end
end
exports.setInObject = function(object: Object?, path: Array<string | number>, value)
	local length = #path
	local last = path[length]

	if object ~= nil then
		local parent = exports.getInObject(object :: Object, Array.slice(path, 1, length))

		if parent then
			parent[last] = value
		end
	end
end

-- ROBLOX deviation: Luau can't express enumeration of literals
-- export type DataType =
--   | 'array'
--   | 'array_buffer'
--   | 'bigint'
--   | 'boolean'
--   | 'data_view'
--   | 'date'
--   | 'function'
--   | 'html_all_collection'
--   | 'html_element'
--   | 'infinity'
--   | 'iterator'
--   | 'opaque_iterator'
--   | 'nan'
--   | 'null'
--   | 'number'
--   | 'object'
--   | 'react_element'
--   | 'regexp'
--   | 'string'
--   | 'symbol'
--   | 'typed_array'
--   | 'undefined'
--   | 'unknown';
export type DataType = string

-- /**
--  * Get a enhanced/artificial type string based on the object instance
--  */
exports.getDataType = function(data: Object?): DataType
	if data == nil then
		return "null"
		-- ROBLOX deviation: no undefined in Lua
		-- elseif data == nil then
		--     return'undefined'
	end

	if isElement(data) then
		return "react_element"
	end

	-- ROBLOX deviation: only applies to web
	-- if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
	--     return 'html_element';
	--   }

	local type_ = typeof(data)
	if type_ == "bigint" then
		return "bigint"
	elseif type_ == "boolean" then
		return "boolean"
	elseif type_ == "function" then
		return "function"
	elseif type_ == "number" then
		if Number.isNaN(data) then
			return "nan"
		elseif not Number.isFinite(data) then
			return "infinity"
		else
			return "number"
		end
	elseif type_ == "object" then
		if Array.isArray(data) then
			return "array"

			-- ROBLOX deviation: only applies to web
			-- elseif ArrayBuffer.isView(data) then
			-- return Object.hasOwnProperty(data.constructor, 'BYTES_PER_ELEMENT')
			-- and 'typed_array'
			-- or 'data_view'
			-- elseif data.constructor and data.constructor.name == 'ArrayBuffer' then
			-- HACK This ArrayBuffer check is gross is there a better way?
			-- We could try to create a new DataView with the value.
			-- If it doesn't error, we know it's an ArrayBuffer,
			-- but this seems kind of awkward and expensive.
			-- return 'array_buffer'
			-- elseif typeof(data[Symbol.iterator]) == 'function' then
			-- return data[Symbol.iterator]() == data
			--   ? 'opaque_iterator'
			--   : 'iterator'
			-- elseif (data.constructor and data.constructor.name == 'RegExp'then
			-- return 'regexp'
			-- else
			-- const toStringValue = Object.prototype.toString.call(data)
			-- if (toStringValue == '[object Date]'then
			--   return 'date'
			-- elseif (toStringValue == '[object HTMLAllCollection]'then
			--   return 'html_all_collection'
			-- }
			--   }
		else
			return "object"
		end
	elseif type_ == "string" then
		return "string"
		-- ROBLOX TODO? detect our Symbol polyfill here?
		-- elseif type_ == 'symbol' then
		--   return 'symbol'
	elseif type_ == "nil" then
		-- ROBLOX deviation: skip web-specific stuff
		--   if (
		-- Object.prototype.toString.call(data) == '[object HTMLAllCollection]'
		--   then
		-- return 'html_all_collection'
		--   }
		return "nil"
	else
		return "unknown"
	end
end

exports.getDisplayNameForReactElement = function(element): string | nil
	local elementType = typeOf(element)
	if elementType == ContextConsumer then
		return "ContextConsumer"
	elseif elementType == ContextProvider then
		return "ContextProvider"
	elseif elementType == ForwardRef then
		return "ForwardRef"
	elseif elementType == Fragment then
		return "Fragment"
	elseif elementType == Lazy then
		return "Lazy"
	elseif elementType == Memo then
		return "Memo"
	elseif elementType == Portal then
		return "Portal"
	elseif elementType == Profiler then
		return "Profiler"
	elseif elementType == StrictMode then
		return "StrictMode"
	elseif elementType == Suspense then
		return "Suspense"
	elseif elementType == SuspenseList then
		return "SuspenseList"
	else
		local type_ = if element then element.type else nil
		if typeof(type_) == "string" then
			return type_
		elseif typeof(type_) == "function" then
			return exports.getDisplayName(type_, "Anonymous")
		elseif type_ ~= nil then
			return "NotImplementedInDevtools"
		else
			return "Element"
		end
	end
end

local MAX_PREVIEW_STRING_LENGTH = 50

local function truncateForDisplay(string_: string, length: number?)
	length = length or MAX_PREVIEW_STRING_LENGTH

	if string.len(string_) > (length :: number) then
		return string.sub(string_, 1, (length :: number) + 1) .. "…"
	else
		return string_
	end
end

-- Attempts to mimic Chrome's inline preview for values.
-- For example, the following value...
--   {
--      foo: 123,
--      bar: "abc",
--      baz: [true, false],
--      qux: { ab: 1, cd: 2 }
--   };
--
-- Would show a preview of...
--   {foo: 123, bar: "abc", baz: Array(2), qux: {…}}
--
-- And the following value...
--   [
--     123,
--     "abc",
--     [true, false],
--     { foo: 123, bar: "abc" }
--   ];
--
-- Would show a preview of...
--   [123, "abc", Array(2), {…}]

function exports.formatDataForPreview(data: Object, showFormattedValue: boolean): string
	if data[meta.type] ~= nil then
		return (function()
			if showFormattedValue then
				return data[meta.preview_long]
			end
			return data[meta.preview_short]
		end)()
	end

	local type_ = exports.getDataType(data)

	if type_ == "html_element" then
		return string.format("<%s />", truncateForDisplay(string.lower(data.tagName)))
	elseif type_ == "function" then
		return truncateForDisplay(string.format(
			"ƒ %s() {}",
			(function()
				if typeof(data.name) == "function" then
					return ""
				end
				return data.name
			end)()
		))
	elseif type_ == "string" then
		return string.format('"%s"', tostring(data))
		-- ROBLOX TODO? should we support our RegExp and Symbol polyfills here?
		-- elseif type_ == 'bigint' then
		-- elseif type_ == 'regexp' then
		-- elseif type_ == 'symbol' then
	elseif type_ == "react_element" then
		return string.format(
			"<%s />",
			truncateForDisplay(exports.getDisplayNameForReactElement(data) or "Unknown")
		)
		-- elseif type_ == 'array_buffer' then
		-- elseif type_ == 'data_view' then
	elseif type_ == "array" then
		local array: Array<any> = data :: any
		if showFormattedValue then
			local formatted = ""
			for i = 1, #array do
				if i > 1 then
					formatted ..= ", "
				end
				formatted = formatted .. exports.formatDataForPreview(array[i], false)
				if string.len(formatted) > MAX_PREVIEW_STRING_LENGTH then
					-- Prevent doing a lot of unnecessary iteration...
					break
				end
			end
			return string.format("[%s]", truncateForDisplay(formatted))
		else
			local length = (function()
				if array[#meta] ~= nil then
					return array[#meta]
				end
				return #array
			end)()
			return string.format("Array(%s)", length)
		end
		-- ROBLOX deviation: don't implement web-specifics
		-- elseif type_ == 'typed_array' then
		-- elseif type_ == 'iterator' then
		-- elseif type_ == 'opaque_iterator' then
		-- ROBLOX TODO? should we support Luau's datetime object?
		-- elseif type_ == 'date' then
	elseif type_ == "object" then
		if showFormattedValue then
			local keys = exports.getAllEnumerableKeys(data)
			table.sort(keys, exports.alphaSortKeys)

			local formatted = ""
			for i = 1, #keys do
				local key = keys[i] :: string
				if i > 1 then
					formatted = formatted .. ", "
				end
				formatted = formatted
					.. string.format(
						"%s: %s",
						tostring(key),
						exports.formatDataForPreview(data[key], false)
					)
				if string.len(formatted) > MAX_PREVIEW_STRING_LENGTH then
					-- Prevent doing a lot of unnecessary iteration...
					break
				end
			end
			return string.format("{%s}", truncateForDisplay(formatted))
		else
			return "{…}"
		end
	elseif
		type_ == "boolean"
		or type_ == "number"
		or type_ == "infinity"
		or type_ == "nan"
		or type_ == "null"
		or type_ == "undefined"
	then
		return tostring(data)
	else
		local ok, result = pcall(truncateForDisplay, "" .. tostring(data))
		return if ok then result else "unserializable"
	end
end

return exports ]]
a2.Children._fc3467a75354eeecb2f8320f4ba78bbf=cI
local cJ

local cK={ClassName="ModuleScript",Children={},Properties={}}
cK.Name="ReactIs"
cK.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-is/src/ReactIs.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent
-- ROBLOX deviation START: not used
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
-- ROBLOX deviation START: use patched console from shared
-- local console = LuauPolyfill.console
local console = require(Packages.Shared).console
-- ROBLOX deviation END
local exports = {}
-- ROBLOX deviation START: fix import
-- local sharedReactSymbolsModule = require(Packages.shared.ReactSymbols)
local sharedReactSymbolsModule = require(Packages.Shared).ReactSymbols
-- ROBLOX deviation END
local REACT_CONTEXT_TYPE = sharedReactSymbolsModule.REACT_CONTEXT_TYPE
local REACT_ELEMENT_TYPE = sharedReactSymbolsModule.REACT_ELEMENT_TYPE
local REACT_FORWARD_REF_TYPE = sharedReactSymbolsModule.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = sharedReactSymbolsModule.REACT_FRAGMENT_TYPE
local REACT_LAZY_TYPE = sharedReactSymbolsModule.REACT_LAZY_TYPE
local REACT_MEMO_TYPE = sharedReactSymbolsModule.REACT_MEMO_TYPE
local REACT_PORTAL_TYPE = sharedReactSymbolsModule.REACT_PORTAL_TYPE
local REACT_PROFILER_TYPE = sharedReactSymbolsModule.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = sharedReactSymbolsModule.REACT_PROVIDER_TYPE
local REACT_STRICT_MODE_TYPE = sharedReactSymbolsModule.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = sharedReactSymbolsModule.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = sharedReactSymbolsModule.REACT_SUSPENSE_LIST_TYPE
-- ROBLOX deviation START: fix import
-- local isValidElementType = require(Packages.shared.isValidElementType).default
local isValidElementType = require(Packages.Shared).isValidElementType
-- ROBLOX deviation END
-- ROBLOX deviation START: additional imports
local REACT_BINDING_TYPE = sharedReactSymbolsModule.REACT_BINDING_TYPE
-- ROBLOX deviation END
local function typeOf(object: any)
	if typeof(object) == "table" and object ~= nil then
		local __typeof --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof \]\] =
			object["$$typeof"]
		-- ROBLOX deviation START: simplified switch statement conversion, adds Binding type check
		-- repeat --\[\[ ROBLOX comment: switch statement conversion \]\]
		-- 	local entered_, break_ = false, false
		-- 	local condition_ = __typeof --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof \]\]
		-- 	for _, v in ipairs({ REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE }) do
		-- 		if condition_ == v then
		-- 			if v == REACT_ELEMENT_TYPE then
		-- 				entered_ = true
		-- 				local type_ = object.type
		-- 				local condition_ = type_
		-- 				if
		-- 					condition_ == REACT_FRAGMENT_TYPE
		-- 					or condition_ == REACT_PROFILER_TYPE
		-- 					or condition_ == REACT_STRICT_MODE_TYPE
		-- 					or condition_ == REACT_SUSPENSE_TYPE
		-- 					or condition_ == REACT_SUSPENSE_LIST_TYPE
		-- 				then
		-- 					return type_
		-- 				else
		-- 					local __typeofType --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType \]\] = if Boolean.toJSBoolean(
		-- 							type_
		-- 						)
		-- 						then type_["$$typeof"]
		-- 						else type_
		-- 					local condition_ = __typeofType --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType \]\]
		-- 					if
		-- 						condition_ == REACT_CONTEXT_TYPE
		-- 						or condition_ == REACT_FORWARD_REF_TYPE
		-- 						or condition_ == REACT_LAZY_TYPE
		-- 						or condition_ == REACT_MEMO_TYPE
		-- 						or condition_ == REACT_PROVIDER_TYPE
		-- 					then
		-- 						return __typeofType --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeofType \]\]
		-- 					else
		-- 						return __typeof --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof \]\]
		-- 					end
		-- 				end
		-- 			end
		-- 			if v == REACT_PORTAL_TYPE or entered_ then
		-- 				entered_ = true
		-- 				return __typeof --\[\[ ROBLOX CHECK: replaced unhandled characters in identifier. Original identifier: $$typeof \]\]
		-- 			end
		-- 		end
		-- 	end
		-- until true
		if __typeof == REACT_ELEMENT_TYPE then
			local __type = object.type

			if
				__type == REACT_FRAGMENT_TYPE
				or __type == REACT_PROFILER_TYPE
				or __type == REACT_STRICT_MODE_TYPE
				or __type == REACT_SUSPENSE_TYPE
				or __type == REACT_SUSPENSE_LIST_TYPE
			then
				return __type
			else
				-- ROBLOX note: We need to check that __type is a table before we
				-- index into it, or Luau will throw errors
				local __typeofType = __type
					and typeof(__type) == "table"
					and __type["$$typeof"]

				if
					__typeofType == REACT_CONTEXT_TYPE
					or __typeofType == REACT_FORWARD_REF_TYPE
					or __typeofType == REACT_LAZY_TYPE
					or __typeofType == REACT_MEMO_TYPE
					or __typeofType == REACT_PROVIDER_TYPE
				then
					return __typeofType
				else
					return __typeof
				end
			end
		elseif
			__typeof == REACT_PORTAL_TYPE
			-- ROBLOX note: Bindings are a feature migrated from Roact
			or __typeof == REACT_BINDING_TYPE
		then
			return __typeof
		end
		-- ROBLOX deviation END
	end
	return nil
end
exports.typeOf = typeOf
local ContextConsumer = REACT_CONTEXT_TYPE
exports.ContextConsumer = ContextConsumer
local ContextProvider = REACT_PROVIDER_TYPE
exports.ContextProvider = ContextProvider
local Element = REACT_ELEMENT_TYPE
exports.Element = Element
local ForwardRef = REACT_FORWARD_REF_TYPE
exports.ForwardRef = ForwardRef
local Fragment = REACT_FRAGMENT_TYPE
exports.Fragment = Fragment
local Lazy = REACT_LAZY_TYPE
exports.Lazy = Lazy
local Memo = REACT_MEMO_TYPE
exports.Memo = Memo
local Portal = REACT_PORTAL_TYPE
exports.Portal = Portal
local Profiler = REACT_PROFILER_TYPE
exports.Profiler = Profiler
local StrictMode = REACT_STRICT_MODE_TYPE
exports.StrictMode = StrictMode
local Suspense = REACT_SUSPENSE_TYPE
exports.Suspense = Suspense
-- ROBLOX deviation START: export Roblox Only type
exports.Binding = sharedReactSymbolsModule.REACT_BINDING_TYPE
-- ROBLOX deviation END
exports.isValidElementType = isValidElementType
local hasWarnedAboutDeprecatedIsAsyncMode = false
local hasWarnedAboutDeprecatedIsConcurrentMode = false -- AsyncMode should be deprecated
local function isAsyncMode(object: any)
	-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
	-- if Boolean.toJSBoolean(__DEV__) then
	-- 	if not Boolean.toJSBoolean(hasWarnedAboutDeprecatedIsAsyncMode) then
	if _G.__DEV__ then
		if not hasWarnedAboutDeprecatedIsAsyncMode then
			-- ROBLOX deviation END
			hasWarnedAboutDeprecatedIsAsyncMode = true -- Using console['warn'] to evade Babel and ESLint
			console["warn"](
				"The ReactIs.isAsyncMode() alias has been deprecated, "
					.. "and will be removed in React 18+."
			)
		end
	end
	return false
end
exports.isAsyncMode = isAsyncMode
local function isConcurrentMode(object: any)
	-- ROBLOX deviation START: remove toJSBoolean, use _G.__DEV__
	-- if Boolean.toJSBoolean(__DEV__) then
	-- 	if not Boolean.toJSBoolean(hasWarnedAboutDeprecatedIsConcurrentMode) then
	if _G.__DEV__ then
		if not hasWarnedAboutDeprecatedIsConcurrentMode then
			-- ROBLOX deviation END
			hasWarnedAboutDeprecatedIsConcurrentMode = true -- Using console['warn'] to evade Babel and ESLint
			console["warn"](
				"The ReactIs.isConcurrentMode() alias has been deprecated, "
					.. "and will be removed in React 18+."
			)
		end
	end
	return false
end
exports.isConcurrentMode = isConcurrentMode
local function isContextConsumer(object: any)
	return typeOf(object) == REACT_CONTEXT_TYPE
end
exports.isContextConsumer = isContextConsumer
local function isContextProvider(object: any)
	return typeOf(object) == REACT_PROVIDER_TYPE
end
exports.isContextProvider = isContextProvider
local function isElement(object: any)
	return typeof(object) == "table"
		and object ~= nil
		and object["$$typeof"] == REACT_ELEMENT_TYPE
end
exports.isElement = isElement
local function isForwardRef(object: any)
	return typeOf(object) == REACT_FORWARD_REF_TYPE
end
exports.isForwardRef = isForwardRef
local function isFragment(object: any)
	return typeOf(object) == REACT_FRAGMENT_TYPE
end
exports.isFragment = isFragment
local function isLazy(object: any)
	return typeOf(object) == REACT_LAZY_TYPE
end
exports.isLazy = isLazy
local function isMemo(object: any)
	return typeOf(object) == REACT_MEMO_TYPE
end
exports.isMemo = isMemo
local function isPortal(object: any)
	return typeOf(object) == REACT_PORTAL_TYPE
end
exports.isPortal = isPortal
local function isProfiler(object: any)
	return typeOf(object) == REACT_PROFILER_TYPE
end
exports.isProfiler = isProfiler
local function isStrictMode(object: any)
	return typeOf(object) == REACT_STRICT_MODE_TYPE
end
exports.isStrictMode = isStrictMode
local function isSuspense(object: any)
	return typeOf(object) == REACT_SUSPENSE_TYPE
end
exports.isSuspense = isSuspense
-- ROBLOX deviation START: Bindings are a feature migrated from Roact
exports.isBinding = function(object: any)
	return typeOf(object) == REACT_BINDING_TYPE
end
-- ROBLOX deviation END
return exports ]]
c.Children._d9122407f70de17e8124db2bfcc67804=cK
local cL
local cM={ClassName="Folder",Children={},Properties={}}
cM.Name="__tests__"
cL.Children._e5ea8630d57e69e14c2f851d53148e55=cM
local cN
local cO={ClassName="ModuleScript",Children={},Properties={}}
cO.Name="ReactIs.spec"
cO.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-is/src/__tests__/ReactIs-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]
local Packages = script.Parent.Parent.Parent
-- ROBLOX deviation START: fix import
-- local LuauPolyfill = require(Packages.LuauPolyfill)
local LuauPolyfill = require(Packages.Dev.LuauPolyfill)
-- ROBLOX deviation END
-- ROBLOX deviation START: not used
-- local Boolean = LuauPolyfill.Boolean
-- ROBLOX deviation END
local Object = LuauPolyfill.Object
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest

-- ROBLOX deviation START: add imports
local Promise = require(Packages.Dev.Promise)
local ReactTypes = require(Packages.Shared)
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>
-- ROBLOX deviation END
local React
local ReactDOM
local ReactIs
describe("ReactIs", function()
	beforeEach(function()
		jest.resetModules()
		-- ROBLOX deviation START: additional flag to switch for tests
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		-- ROBLOX deviation END
		-- ROBLOX deviation START: fix imports
		-- React = require_("react")
		-- ReactDOM = require_("react-dom")
		-- ReactIs = require_("react-is")
		React = require(Packages.Dev.React)
		ReactIs = require(Packages.ReactIs)
		ReactDOM = require(Packages.Dev.ReactRoblox)
		-- ROBLOX deviation END
	end)
	it("should return undefined for unknown/invalid types", function()
		expect(ReactIs.typeOf("abc")).toBe(nil)
		expect(ReactIs.typeOf(true)).toBe(nil)
		expect(ReactIs.typeOf(123)).toBe(nil)
		expect(ReactIs.typeOf({})).toBe(nil)
		expect(ReactIs.typeOf(nil)).toBe(nil)
		-- ROBLOX deviation START: no undefined in Lua, we only support nil
		-- expect(ReactIs.typeOf(nil)).toBe(nil)
		-- ROBLOX deviation END
	end)
	it("identifies valid element types", function()
		type Component = React_Component<any, any> & {}
		type Component_statics = {}
		local Component =
			React.Component:extend("Component") :: Component & Component_statics
		function Component.render(self: Component)
			-- ROBLOX deviation START: replace div with TextLabel
			-- return React.createElement("div")
			return React.createElement("TextLabel")
			-- ROBLOX deviation END
		end

		local function FunctionComponent()
			-- ROBLOX deviation START: replace div with TextLabel
			-- return React.createElement("div")
			return React.createElement("TextLabel")
			-- ROBLOX deviation END
		end
		local ForwardRefComponent = React.forwardRef(function(props, ref)
			return React.createElement(
				Component,
				Object.assign({}, { forwardedRef = ref }, props)
			)
		end)
		-- ROBLOX TODO: this is incorrect in upstream
		-- ROBLOX note: Lazy will need deeper adaptation for the Luau module system
		-- ROBLOX deviation START: convert return type to thenable
		-- local LazyComponent = React.lazy(function()
		-- 	return Component
		-- end)
		local LazyComponent = React.lazy(function()
			return Promise.delay(0):andThen(function()
				return { default = Component }
			end)
		end)
		-- ROBLOX deviation END
		-- ROBLOX note: Should memo accept a LazyComponent?
		local MemoComponent = React.memo(Component)
		local Context = React.createContext(false)
		expect(ReactIs.isValidElementType("div")).toEqual(true)
		expect(ReactIs.isValidElementType(Component)).toEqual(true)
		expect(ReactIs.isValidElementType(FunctionComponent)).toEqual(true)
		expect(ReactIs.isValidElementType(ForwardRefComponent)).toEqual(true)
		expect(ReactIs.isValidElementType(LazyComponent)).toEqual(true)
		expect(ReactIs.isValidElementType(MemoComponent)).toEqual(true)
		expect(ReactIs.isValidElementType(Context.Provider)).toEqual(true)
		expect(ReactIs.isValidElementType(Context.Consumer)).toEqual(true)
		-- ROBLOX deviation START: we don't support things that are already deprecated
		-- if not Boolean.toJSBoolean(__EXPERIMENTAL__) then
		-- 	local factory
		-- 	expect(function()
		-- 		factory = React.createFactory("div")
		-- 	end).toWarnDev(
		-- 		"Warning: React.createFactory() is deprecated and will be removed in a "
		-- 			.. "future major release. Consider using JSX or use React.createElement() "
		-- 			.. "directly instead.",
		-- 		{ withoutStack = true }
		-- 	)
		-- 	expect(ReactIs:isValidElementType(factory)).toEqual(true)
		-- end
		-- ROBLOX deviation END
		expect(ReactIs.isValidElementType(React.Fragment)).toEqual(true)
		expect(ReactIs.isValidElementType(React.StrictMode)).toEqual(true)
		expect(ReactIs.isValidElementType(React.Suspense)).toEqual(true)
		expect(ReactIs.isValidElementType(true)).toEqual(false)
		expect(ReactIs.isValidElementType(123)).toEqual(false)
		expect(ReactIs.isValidElementType({})).toEqual(false)
		expect(ReactIs.isValidElementType(nil)).toEqual(false)
		-- ROBLOX deviation START: no difference between nil and undefined in Lua, skip
		-- expect(ReactIs.isValidElementType(nil)).toEqual(false)
		-- ROBLOX deviation END
		-- ROBLOX deviation START: replace "div" with "TextLabel", use dot notation
		-- expect(ReactIs.isValidElementType({ type = "div", props = {} })).toEqual(false)
		expect(ReactIs.isValidElementType({ type = "TextLabel", props = {} })).toEqual(
			false
		)
		-- ROBLOX deviation END
	end)
	it("should identify context consumers", function()
		local Context = React.createContext(false)
		expect(ReactIs.isValidElementType(Context.Consumer)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(Context.Consumer, nil))).toBe(
			ReactIs.ContextConsumer
		)
		expect(ReactIs.isContextConsumer(React.createElement(Context.Consumer, nil))).toBe(
			true
		)
		expect(ReactIs.isContextConsumer(React.createElement(Context.Provider, nil))).toBe(
			false
		)
		expect(ReactIs.isContextConsumer(React.createElement("div", nil))).toBe(false)
	end)
	it("should identify context providers", function()
		local Context = React.createContext(false)
		expect(ReactIs.isValidElementType(Context.Provider)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(Context.Provider, nil))).toBe(
			ReactIs.ContextProvider
		)
		expect(ReactIs.isContextProvider(React.createElement(Context.Provider, nil))).toBe(
			true
		)
		expect(ReactIs.isContextProvider(React.createElement(Context.Consumer, nil))).toBe(
			false
		)
		expect(ReactIs.isContextProvider(React.createElement("div", nil))).toBe(false)
	end)
	it("should identify elements", function()
		expect(ReactIs.typeOf(React.createElement("div", nil))).toBe(ReactIs.Element)
		expect(ReactIs.isElement(React.createElement("div", nil))).toBe(true)
		expect(ReactIs.isElement("div")).toBe(false)
		expect(ReactIs.isElement(true)).toBe(false)
		expect(ReactIs.isElement(123)).toBe(false)
		expect(ReactIs.isElement(nil)).toBe(false)
		-- ROBLOX deviation START: no difference between nil and undefined in Lua
		-- expect(ReactIs.isElement(nil)).toBe(false)
		-- ROBLOX deviation END
		expect(ReactIs.isElement({})).toBe(false) -- It should also identify more specific types as elements
		local Context = React.createContext(false)
		expect(ReactIs.isElement(React.createElement(Context.Provider, nil))).toBe(true)
		expect(ReactIs.isElement(React.createElement(Context.Consumer, nil))).toBe(true)
		expect(ReactIs.isElement(React.createElement(React.Fragment, nil))).toBe(true)
		expect(ReactIs.isElement(React.createElement(React.StrictMode, nil))).toBe(true)
		expect(ReactIs.isElement(React.createElement(React.Suspense, nil))).toBe(true)
	end)
	it("should identify ref forwarding component", function()
		local RefForwardingComponent = React.forwardRef(function(props, ref)
			return nil
		end)
		expect(ReactIs.isValidElementType(RefForwardingComponent)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(RefForwardingComponent, nil))).toBe(
			ReactIs.ForwardRef
		)
		expect(ReactIs.isForwardRef(React.createElement(RefForwardingComponent, nil))).toBe(
			true
		)
		expect(ReactIs.isForwardRef({ type = ReactIs.StrictMode })).toBe(false)
		expect(ReactIs.isForwardRef(React.createElement("div", nil))).toBe(false)
	end)
	it("should identify fragments", function()
		expect(ReactIs.isValidElementType(React.Fragment)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(React.Fragment, nil))).toBe(
			ReactIs.Fragment
		)
		expect(ReactIs.isFragment(React.createElement(React.Fragment, nil))).toBe(true)
		expect(ReactIs.isFragment({ type = ReactIs.Fragment })).toBe(false)
		expect(ReactIs.isFragment("React.Fragment")).toBe(false)
		expect(ReactIs.isFragment(React.createElement("div", nil))).toBe(false)
		expect(ReactIs.isFragment({})).toBe(false)
	end)
	it("should identify portals", function()
		-- ROBLOX deviation START: replace created element attachaed to DOM
		-- local div = document:createElement("div")
		local div = Instance.new("ScreenGui")
		-- ROBLOX deviation END
		-- ROBLOX deviation START: replace "div" with "Frame"
		-- local portal = ReactDOM:createPortal(React.createElement("div", nil), div)
		local portal = ReactDOM.createPortal(React.createElement("Frame"), div)
		-- ROBLOX deviation END
		expect(ReactIs.isValidElementType(portal)).toBe(false)
		expect(ReactIs.typeOf(portal)).toBe(ReactIs.Portal)
		expect(ReactIs.isPortal(portal)).toBe(true)
		expect(ReactIs.isPortal(div)).toBe(false)
	end)
	it("should identify memo", function()
		local function Component()
			return React.createElement("div")
		end
		local Memoized = React.memo(Component)
		expect(ReactIs.isValidElementType(Memoized)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(Memoized, nil))).toBe(ReactIs.Memo)
		expect(ReactIs.isMemo(React.createElement(Memoized, nil))).toBe(true)
		expect(ReactIs.isMemo(React.createElement(Component, nil))).toBe(false)
	end)
	it("should identify lazy", function()
		local function Component()
			return React.createElement("div")
		end
		-- ROBLOX TODO: this is incorrect in upstream
		-- ROBLOX deviation START: return thenable
		-- local LazyComponent = React.lazy(function()
		-- 	return Component
		-- end)
		local LazyComponent = React.lazy(function()
			return Promise.delay(0):andThen(function()
				return { default = Component }
			end)
		end)
		-- ROBLOX deviation END
		expect(ReactIs.isValidElementType(LazyComponent)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(LazyComponent, nil))).toBe(ReactIs.Lazy)
		expect(ReactIs.isLazy(React.createElement(LazyComponent, nil))).toBe(true)
		expect(ReactIs.isLazy(React.createElement(Component, nil))).toBe(false)
	end)
	it("should identify strict mode", function()
		expect(ReactIs.isValidElementType(React.StrictMode)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(React.StrictMode, nil))).toBe(
			ReactIs.StrictMode
		)
		expect(ReactIs.isStrictMode(React.createElement(React.StrictMode, nil))).toBe(
			true
		)
		expect(ReactIs.isStrictMode({ type = ReactIs.StrictMode })).toBe(false)
		expect(ReactIs.isStrictMode(React.createElement("div", nil))).toBe(false)
	end)
	it("should identify suspense", function()
		expect(ReactIs.isValidElementType(React.Suspense)).toBe(true)
		expect(ReactIs.typeOf(React.createElement(React.Suspense, nil))).toBe(
			ReactIs.Suspense
		)
		expect(ReactIs.isSuspense(React.createElement(React.Suspense, nil))).toBe(true)
		expect(ReactIs.isSuspense({ type = ReactIs.Suspense })).toBe(false)
		expect(ReactIs.isSuspense("React.Suspense")).toBe(false)
		expect(ReactIs.isSuspense(React.createElement("div", nil))).toBe(false)
	end)
	it("should identify profile root", function()
		expect(ReactIs.isValidElementType(React.Profiler)).toBe(true)
		expect(
			ReactIs.typeOf(
				React.createElement(React.Profiler, { id = "foo", onRender = jest.fn() })
			)
		).toBe(ReactIs.Profiler)
		expect(
			ReactIs.isProfiler(
				React.createElement(React.Profiler, { id = "foo", onRender = jest.fn() })
			)
		).toBe(true)
		expect(ReactIs.isProfiler({ type = ReactIs.Profiler })).toBe(false)
		expect(ReactIs.isProfiler(React.createElement("div", nil))).toBe(false)
	end)
	-- ROBLOX deviation START: added this test to cover deprecation warning
	it("should warn for deprecated functions", function()
		expect(function()
			ReactIs.isConcurrentMode(nil)
		end).toWarnDev("deprecated", { withoutStack = true })
		expect(function()
			ReactIs.isAsyncMode(nil)
		end).toWarnDev("deprecated", { withoutStack = true })
	end)
	-- ROBLOX deviation END
	-- ROBLOX deviation START: add Roblox specific tests - bindings are a feature migrated from Roact
	it("should identify bindings", function()
		local binding, _ = React.createBinding(nil)
		expect(ReactIs.isBinding(binding)).toBe(true)
		local mappedBinding = React.createBinding(nil):map(tostring)
		expect(ReactIs.isBinding(mappedBinding)).toBe(true)
		local joinedBinding = React.joinBindings({
			X = React.createBinding(0),
			Y = React.createBinding(0),
		})
		expect(ReactIs.isBinding(joinedBinding)).toBe(true)
		-- In Roact 17, `ref` objects are implemented in terms of bindings!
		expect(ReactIs.isBinding(React.createRef())).toBe(true)
	end)
	-- ROBLOX deviation END
end) ]]
cN.Children._e593e3e21511ac154286cf61bf81bf22=cO
local cP

local cQ={ClassName="ModuleScript",Children={},Properties={}}
cQ.Name="ReactNoopRenderer"
cQ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/e7b255341b059b4e2a109847395d0d0ba2633999/packages/react-noop-renderer/src/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *\]\]

--!strict
return require(script.ReactNoop) ]]
c.Children._d5058d3c6150a42d74b8d20446b4d52a=cQ
local cR
local cS={ClassName="ModuleScript",Children={},Properties={}}
cS.Name="ReactNoop"
cS.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/faa697f4f9afe9f1c98e315b2a9e70f5a74a7a74/packages/react-noop-renderer/src/ReactNoop.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[*
 * This is a renderer of React that doesn't have a render target output.
 * It is useful to demonstrate the internals of the reconciler in isolation
 * and for testing semantics of reconciliation separate from the host
 * environment.
\]\]

local Packages = script.Parent.Parent
local ReactFiberReconciler = require(Packages.ReactReconciler)
local createReactNoop = require(script.Parent.createReactNoop)

local NoopRenderer = createReactNoop(
	ReactFiberReconciler, -- reconciler
	true -- useMutation
)

return {
	_Scheduler = NoopRenderer._Scheduler,
	getChildren = NoopRenderer.getChildren,
	getPendingChildren = NoopRenderer.getPendingChildren,
	getOrCreateRootContainer = NoopRenderer.getOrCreateRootContainer,
	createRoot = NoopRenderer.createRoot,
	createBlockingRoot = NoopRenderer.createBlockingRoot,
	createLegacyRoot = NoopRenderer.createLegacyRoot,
	getChildrenAsJSX = NoopRenderer.getChildrenAsJSX,
	getPendingChildrenAsJSX = NoopRenderer.getPendingChildrenAsJSX,
	createPortal = NoopRenderer.createPortal,
	render = NoopRenderer.render,
	renderLegacySyncRoot = NoopRenderer.renderLegacySyncRoot,
	renderToRootWithID = NoopRenderer.renderToRootWithID,
	unmountRootWithID = NoopRenderer.unmountRootWithID,
	findInstance = NoopRenderer.findInstance,
	flushNextYield = NoopRenderer.flushNextYield,
	flushWithHostCounters = NoopRenderer.flushWithHostCounters,
	expire = NoopRenderer.expire,
	flushExpired = NoopRenderer.flushExpired,
	batchedUpdates = NoopRenderer.batchedUpdates,
	deferredUpdates = NoopRenderer.deferredUpdates,
	unbatchedUpdates = NoopRenderer.unbatchedUpdates,
	discreteUpdates = NoopRenderer.discreteUpdates,
	flushDiscreteUpdates = NoopRenderer.flushDiscreteUpdates,
	flushSync = NoopRenderer.flushSync,
	flushPassiveEffects = NoopRenderer.flushPassiveEffects,
	act = NoopRenderer.act,
	dumpTree = NoopRenderer.dumpTree,
	getRoot = NoopRenderer.getRoot,
	-- TODO: Remove this after callers migrate to alternatives.
	unstable_runWithPriority = NoopRenderer.unstable_runWithPriority,
} ]]
cR.Children._f89c7b470362ed98dacbab8f1166d5ae=cS
local cT

local cU={ClassName="ModuleScript",Children={},Properties={}}
cU.Name="createReactNoop"
cU.Properties.Source=[[ --!nonstrict
-- ROBLOX upstream: https://github.com/facebook/react/blob/e7b255341b059b4e2a109847395d0d0ba2633999/packages/react-noop-renderer/src/createReactNoop.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[*
 * This is a renderer of React that doesn't have a render target output.
 * It is useful to demonstrate the internals of the reconciler in isolation
 * and for testing semantics of reconciliation separate from the host
 * environment.
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)

local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
type Function = (...any) -> ...any
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout
local console = require(Packages.Shared).console
local jest = require(Packages.JestGlobals).jest

local ReactReconciler = require(Packages.ReactReconciler)
type Fiber = ReactReconciler.Fiber
type UpdateQueue<T> = ReactReconciler.UpdateQueue<T>
local ReactShared = require(Packages.Shared)
type ReactNodeList = ReactShared.ReactNodeList
type Thenable<T> = ReactShared.Thenable<T>
type RootTag = ReactReconciler.RootTag

local Scheduler = require(Packages.Scheduler)
-- deviation: These are only used for the JSX logic that's currently omitted
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE

-- local ConcurrentRoot = ReactRootTags.ConcurrentRoot
-- local BlockingRoot = ReactRootTags.BlockingRoot
-- local LegacyRoot = ReactRootTags.LegacyRoot

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local enqueueTask = require(Packages.Shared).enqueueTask
local IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing

type Object = { [string]: any }
type Array<T> = { [number]: T }

type HostContext = Object
type Container = {
	rootID: string,
	children: Array<Instance | TextInstance>,
	pendingChildren: Array<Instance | TextInstance>,
	-- ...
}
type Props = {
	prop: any,
	hidden: boolean,
	children: any?,
	bottom: number?,
	left: number?,
	right: number?,
	top: number?,
	-- ...
}
type Instance = {
	type: string,
	id: number,
	children: Array<Instance | TextInstance>,
	text: string | nil,
	prop: any,
	hidden: boolean,
	context: HostContext,
}
type TextInstance = {
	text: string,
	id: number,
	hidden: boolean,
	context: HostContext,
}

local NO_CONTEXT = {}
local UPPERCASE_CONTEXT = {}
local UPDATE_SIGNAL = {}
if _G.__DEV__ then
	Object.freeze(NO_CONTEXT)
	Object.freeze(UPDATE_SIGNAL)
end

local function createReactNoop(reconciler, useMutation: boolean)
	local instanceCounter = 0
	local hostDiffCounter = 0
	local hostUpdateCounter = 0
	local hostCloneCounter = 0

	-- deviation: Pre-declare so lua understands that these exist
	local flushActWork, shouldSetTextContent, computeText, cloneInstance

	local function appendChildToContainerOrInstance(
		parentInstance: Container | Instance,
		child: Instance | TextInstance
	): ()
		local index = Array.indexOf(parentInstance.children, child)
		if index ~= -1 then
			Array.splice(parentInstance.children, index, 1)
		end
		table.insert(parentInstance.children, child)
	end

	local function appendChildToContainer(
		parentInstance: Container,
		child: Instance | TextInstance
	): ()
		if typeof(parentInstance.rootID) ~= "string" then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("appendChildToContainer() first argument is not a container."))
		end
		appendChildToContainerOrInstance(parentInstance, child)
	end

	local function appendChild(
		parentInstance: Instance,
		child: Instance | TextInstance
	): ()
		if typeof((parentInstance :: any).rootID) == "string" then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("appendChild() first argument is not an instance."))
		end
		appendChildToContainerOrInstance(parentInstance, child)
	end

	local function insertInContainerOrInstanceBefore(
		parentInstance: Container | Instance,
		child: Instance | TextInstance,
		beforeChild: Instance | TextInstance
	): ()
		local index = Array.indexOf(parentInstance.children, child)
		if index ~= -1 then
			Array.splice(parentInstance.children, index, 1)
		end
		local beforeIndex = Array.indexOf(parentInstance.children, beforeChild)
		if beforeIndex == -1 then
			error(Error("This child does not exist."))
		end
		Array.splice(parentInstance.children, beforeIndex, 0, child)
	end

	local function insertInContainerBefore(
		parentInstance: Container,
		child: Instance | TextInstance,
		beforeChild: Instance | TextInstance
	)
		if typeof(parentInstance.rootID) ~= "string" then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("insertInContainerBefore() first argument is not a container."))
		end
		insertInContainerOrInstanceBefore(parentInstance, child, beforeChild)
	end

	local function insertBefore(
		parentInstance: Instance,
		child: Instance | TextInstance,
		beforeChild: Instance | TextInstance
	)
		if typeof((parentInstance :: any).rootID) ~= "string" then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("insertBefore() first argument is not an instance."))
		end
		insertInContainerOrInstanceBefore(parentInstance, child, beforeChild)
	end

	local function clearContainer(container: Container)
		Array.splice(container.children, 0)
	end

	local function removeChildFromContainerOrInstance(
		parentInstance: Container | Instance,
		child: Instance | TextInstance
	)
		local index = Array.indexOf(parentInstance.children, child)
		if index == -1 then
			error(Error("This child does not exist."))
		end
		Array.splice(parentInstance.children, index, 1)
	end

	local function removeChildFromContainer(
		parentInstance: Container,
		child: Instance | TextInstance
	)
		if
			typeof(parentInstance) == "table"
			and typeof(parentInstance.rootID) ~= "string"
		then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("removeChildFromContainer() first argument is not a container."))
		end
		removeChildFromContainerOrInstance(parentInstance, child)
	end

	local function removeChild(parentInstance: Instance, child: Instance | TextInstance)
		if typeof((parentInstance :: any).rootID) == "string" then
			-- Some calls to this aren't typesafe.
			-- This helps surface mistakes in tests.
			error(Error("removeChild() first argument is not an instance."))
		end
		removeChildFromContainerOrInstance(parentInstance, child)
	end

	cloneInstance = function(
		instance: Instance,
		updatePayload: Object?,
		type: string,
		oldProps: Props,
		newProps: Props,
		internalInstanceHandle: Object,
		keepChildren: boolean,
		recyclableInstance: Instance?
	)
		-- deviation: use metatable to define non-enumerable properties
		local children
		if keepChildren then
			children = instance.children
		else
			children = {}
		end

		local clone = setmetatable({
			type = type,
			children = children,
			prop = newProps.prop,
			-- ROBLOX TODO: matches upstream, but does it make sense in Lua?
			hidden = not not newProps.hidden,
		}, {
			__index = {
				id = instance.id,
				-- deviation: Not sure about this one
				-- text: shouldSetTextContent(type, newProps)
				-- 	? computeText((newProps.children: any) + '', instance.context)
				-- 	: null,
				text = shouldSetTextContent(type, newProps)
						and computeText(tostring(newProps.children), instance.context)
					or nil,
				context = instance.context,
			},
		})
		hostCloneCounter += 1
		return clone
	end

	shouldSetTextContent = function(type: string, props: Props): boolean
		if type == "errorInBeginPhase" then
			error(Error("Error in host config."))
		end
		return typeof(props.children) == "string" or typeof(props.children) == "number"
	end

	computeText = function(rawText, hostContext)
		-- ROBLOX FIXME Luau: TypeError: Type 'string' could not be converted into 'nil'
		return if hostContext == UPPERCASE_CONTEXT then string.upper(rawText) else rawText
	end

	local sharedHostConfig = {
		getRootHostContext = function()
			return NO_CONTEXT
		end,

		getChildHostContext = function(
			parentHostContext: HostContext,
			type: string,
			rootcontainerInstance: Container
		)
			if type == "uppercase" then
				return UPPERCASE_CONTEXT
			end
			return NO_CONTEXT
		end,

		getPublicInstance = function(instance)
			return instance
		end,

		createInstance = function(
			type: string,
			props: Props,
			rootContainerInstance: Container,
			hostContext: HostContext
		): Instance
			if type == "errorInCompletePhase" then
				error(Error("Error in host config."))
			end

			-- deviation: use metatable to define non-enumerable properties
			local inst = setmetatable({
				type = type,
				children = {},
				prop = props.prop,
				hidden = not not props.hidden,
			}, {
				-- Hide from unit tests
				__index = {
					id = instanceCounter,
					-- deviation: Not sure about this one
					-- text: shouldSetTextContent(type, props)
					-- 	? computeText((props.children: any) + '', hostContext)
					-- 	: null,
					text = shouldSetTextContent(type, props)
							and computeText(tostring(props.children), hostContext)
						or nil,
					context = hostContext,
				},
			})
			instanceCounter += 1
			return inst
		end,

		appendInitialChild = function(parentInstance: Instance, child: Instance | TextInstance)
			table.insert(parentInstance.children, child)
		end,

		finalizeInitialChildren = function(
			_domElement: Instance,
			_type: string,
			_props: Props
		): boolean
			return false
		end,

		prepareUpdate = function(
			instanceH: Instance,
			type: string,
			oldProps: Props,
			newProps: Props
		): Object?
			if type == "errorInCompletePhase" then
				error(Error("Error in host config."))
			end
			if oldProps == nil then
				error(Error("Should have old props"))
			end
			if newProps == nil then
				error(Error("Should have new props"))
			end
			hostDiffCounter += 1
			return UPDATE_SIGNAL
		end,

		shouldSetTextContent = shouldSetTextContent,

		-- deviation: FIXME: this might not make any sense in Roblox, which has
		-- no notion of non-styled text nodes
		createTextInstance = function(
			text: string,
			rootContainerInstance,
			hostContext: { [any]: any },
			internalInstanceHandle: { [any]: any }
		): TextInstance
			if hostContext == UPPERCASE_CONTEXT then
				text = string.upper(text)
			end
			-- deviation: use metatable to define non-enumerable properties
			local inst = setmetatable({
				text = text,
				hidden = false,
			}, {
				-- Hide from unit tests
				__index = {
					id = instanceCounter,
					context = hostContext,
				},
			})
			instanceCounter += 1
			return inst
		end,

		scheduleTimeout = setTimeout,
		cancelTimeout = clearTimeout,
		noTimeout = -1,

		prepareForCommit = function(): nil | { [any]: any }
			return nil
		end,

		resetAfterCommit = function() end,

		now = Scheduler.unstable_now,

		isPrimaryRenderer = true,
		warnsIfNotActing = true,
		supportsHydration = false,

		getFundamentalComponentInstance = function(fundamentalInstance): Instance
			local impl = fundamentalInstance.impl
			local props = fundamentalInstance.props
			local state = fundamentalInstance.state
			return impl.getInstance(nil, props, state)
		end,

		mountFundamentalComponent = function(fundamentalInstance)
			local impl = fundamentalInstance.impl
			local instance = fundamentalInstance.instance
			local props = fundamentalInstance.props
			local state = fundamentalInstance.state
			local onMount = impl.onUpdate
			if onMount ~= nil then
				onMount(nil, instance, props, state)
			end
		end,

		shouldUpdateFundamentalComponent = function(fundamentalInstance): boolean
			local impl = fundamentalInstance.impl
			local instance = fundamentalInstance.instance
			local prevProps = fundamentalInstance.prevProps
			local props = fundamentalInstance.props
			local state = fundamentalInstance.state
			local shouldUpdate = impl.shouldUpdate
			if shouldUpdate ~= nil then
				return shouldUpdate(nil, instance, prevProps, props, state)
			end
			return true
		end,

		updateFundamentalComponent = function(fundamentalInstance)
			local impl = fundamentalInstance.impl
			local instance = fundamentalInstance.instance
			local prevProps = fundamentalInstance.prevProps
			local props = fundamentalInstance.props
			local state = fundamentalInstance.state
			local onUpdate = impl.onUpdate
			if onUpdate ~= nil then
				onUpdate(nil, instance, prevProps, props, state)
			end
		end,

		unmountFundamentalComponent = function(fundamentalInstance)
			local impl = fundamentalInstance.impl
			local instance = fundamentalInstance.instance
			local props = fundamentalInstance.props
			local state = fundamentalInstance.state
			local onUnmount = impl.onUnmount
			if onUnmount ~= nil then
				onUnmount(nil, instance, props, state)
			end
		end,

		cloneFundamentalInstance = function(fundamentalInstance): Instance
			local instance = fundamentalInstance.instance
			-- TODO (roblox): Do we have to indirect some of these to make them
			-- not enumerable, like we do in `createInstance`
			return {
				children = {},
				text = instance.text,
				type = instance.type,
				prop = instance.prop,
				id = instance.id,
				context = instance.context,
				hidden = instance.hidden,
			}
		end,

		getInstanceFromNode = function()
			error(Error("Not yet implemented."))
		end,

		beforeActiveInstanceBlur = function()
			-- NO-OP
		end,

		afterActiveInstanceBlur = function()
			-- NO-OP
		end,

		preparePortalMount = function()
			-- NO-OP
		end,

		prepareScopeUpdate = function() end,

		getInstanceFromScope = function()
			error(Error("Not yet implemented."))
		end,
	}

	-- deviation: replace spread with manual table creation
	local hostConfig
	if useMutation then
		hostConfig = Object.assign({}, sharedHostConfig, {
			supportsMutation = true,
			supportsPersistence = false,

			commitMount = function(instance: Instance, type: string, newProps: Props)
				-- Noop
			end,

			commitUpdate = function(
				instance: Instance,
				updatePayload: Object,
				type: string,
				oldProps: Props,
				newProps: Props
			)
				if oldProps == nil then
					error(Error("Should have old props"))
				end
				hostUpdateCounter += 1
				instance.prop = newProps.prop
				instance.hidden = not not newProps.hidden
				if shouldSetTextContent(type, newProps) then
					-- deviation: Not sure about this one
					instance.text =
						computeText(tostring(newProps.children), instance.context)
				end
			end,

			commitTextUpdate = function(
				textInstance: TextInstance,
				oldText: string,
				newText: string
			)
				hostUpdateCounter += 1
				textInstance.text = computeText(newText, textInstance.context)
			end,

			appendChild = appendChild,
			appendChildToContainer = appendChildToContainer,
			insertBefore = insertBefore,
			insertInContainerBefore = insertInContainerBefore,
			removeChild = removeChild,
			removeChildFromContainer = removeChildFromContainer,
			clearContainer = clearContainer,

			hideInstance = function(instance: Instance)
				instance.hidden = true
			end,

			hideTextInstance = function(textInstance: TextInstance)
				textInstance.hidden = true
			end,

			unhideInstance = function(instance: Instance, props: Props)
				if not props.hidden then
					instance.hidden = false
				end
			end,

			unhideTextInstance = function(textInstance: TextInstance, text: string)
				textInstance.hidden = false
			end,

			resetTextContent = function(instance: Instance)
				instance.text = nil
			end,
		})
	else
		hostConfig = Object.assign({}, sharedHostConfig, {
			supportsMutation = false,
			supportsPersistence = true,

			cloneInstance = cloneInstance,
			clearContainer = clearContainer,

			createContainerChildSet = function(
				container: Container
			): Array<Instance | TextInstance>
				return {}
			end,

			appendChildToContainerChildSet = function(
				childSet: Array<Instance | TextInstance>,
				child: Instance | TextInstance
			)
				table.insert(childSet, child)
			end,

			finalizeContainerChildren = function(
				container: Container,
				newChildren: Array<Instance | TextInstance>
			)
				container.pendingChildren = newChildren
				if
					#newChildren == 1
					and newChildren[1].text == "Error when completing root"
				then
					-- Trigger an error for testing purposes
					error(Error("Error when completing root"))
				end
			end,

			replaceContainerChildren = function(
				container: Container,
				newChildren: Array<Instance | TextInstance>
			)
				container.children = newChildren
			end,

			cloneHiddenInstance = function(
				instance: Instance,
				type: string,
				props: Props,
				internalInstanceHandle: Object
			)
				local clone = cloneInstance(
					instance,
					nil,
					type,
					props,
					props,
					internalInstanceHandle,
					true,
					nil
				)
				clone.hidden = true
				return clone
			end,

			cloneHiddenTextInstance = function(
				instance: TextInstance,
				text: string,
				internalInstanceHandle: Object
			)
				-- deviation: use metatable to define non-enumerable properties
				local clone = setmetatable({
					text = instance.text,
					hidden = true,
				}, {
					-- Hide from unit tests
					__index = {
						id = instanceCounter,
						context = instance.context,
					},
				})
				instanceCounter += 1
				return clone
			end,
		})
	end

	local NoopRenderer = reconciler(hostConfig)
	-- ROBLOX deviation: We can't reach into the reconciler for these, so we
	-- extract them after we've initialized a mock reconciler
	local ReactRootTags = NoopRenderer.ReactRootTags
	local ConcurrentRoot = ReactRootTags.ConcurrentRoot
	local BlockingRoot = ReactRootTags.BlockingRoot
	local LegacyRoot = ReactRootTags.LegacyRoot

	local rootContainers = {}
	local roots = {}
	local DEFAULT_ROOT_ID = "<default>"

	local function childToJSX(child, text)
		if text ~= nil then
			return text
		end
		if child == nil then
			return nil
		end
		if typeof(child) == "string" then
			return child
		end
		if Array.isArray(child) then
			if #child == 0 then
				return nil
			end
			if #child == 1 then
				return childToJSX(child[1])
			end
			local children = Array.map(child, function(c)
				return childToJSX(c)
			end)
			if
				Array.every(children, function(c)
					return typeof(c) == "string" or typeof(c) == "number"
				end)
			then
				return Array.join(children, "")
			end
			return children
		end
		if Array.isArray(child.children) then
			-- ROBLOX DEVIATION: Luau flow syntax unsupported by Selene 0.11
			-- local instance: Instance = (child :: any)
			local instance = child
			local children = childToJSX(instance.children, instance.text)
			-- ROBLOX DEVIATION: Luau flow syntax unsupported by Selene 0.11
			-- local props = ({prop = instance.prop} :: any)
			local props = { prop = instance.prop }
			if instance.hidden then
				props.hidden = true
			end
			if children ~= nil then
				props.children = children
			end
			local store = nil
			if _G.__DEV__ then
				store = {}
			end
			return {
				["$$typeof"] = REACT_ELEMENT_TYPE,
				type = instance.type,
				key = nil,
				ref = nil,
				props = props,
				_owner = nil,
				_store = store,
			}
		end
		-- ROBLOX deviation: type erasure to workaround Luau narrowing issues
		-- local textInstance: TextInstance = (child: any)
		local textInstance = child
		if textInstance.hidden then
			return ""
		end
		return textInstance.text
	end

	local function getChildren(root)
		if root then
			return root.children
		else
			return nil
		end
	end

	local function getPendingChildren(root)
		if root then
			return root.pendingChildren
		else
			return nil
		end
	end

	local function getChildrenAsJSX(root)
		local children = childToJSX(getChildren(root))
		if children == nil then
			return nil
		end
		if Array.isArray(children) then
			local store = nil
			if _G.__DEV__ then
				store = {}
			end
			return {
				["$$typeof"] = REACT_ELEMENT_TYPE,
				type = REACT_FRAGMENT_TYPE,
				key = nil,
				ref = nil,
				props = { children },
				_owner = nil,
				_store = store,
			}
		end
		return children
	end

	-- deviation: disabling JSX-related functionality
	local function getPendingChildrenAsJSX(root)
		error(Error("JSX Unsupported"))
	end
	-- function getPendingChildrenAsJSX(root) {
	-- 	local children = childToJSX(getChildren(root))
	-- 	if (children == nil) {
	-- 		return nil
	-- 	}
	-- 	if (Array.isArray(children)) {
	-- 		return {
	-- 			$$typeof: REACT_ELEMENT_TYPE,
	-- 			type: REACT_FRAGMENT_TYPE,
	-- 			key: nil,
	-- 			ref: nil,
	-- 			props: {children},
	-- 			_owner: nil,
	-- 			_store: _G.__DEV__ ? {} : undefined,
	-- 		}
	-- 	}
	-- 	return children
	-- }

	local idCounter = 0

	local ReactNoop
	ReactNoop = {
		_Scheduler = Scheduler,

		getChildren = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			local container = rootContainers[rootID]
			return getChildren(container)
		end,

		getPendingChildren = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			local container = rootContainers[rootID]
			return getPendingChildren(container)
		end,

		getOrCreateRootContainer = function(rootID: string?, tag: RootTag)
			rootID = rootID or DEFAULT_ROOT_ID
			local root = roots[rootID]
			if not root then
				local container = {
					rootID = rootID :: string,
					pendingChildren = {},
					children = {},
				}
				rootContainers[rootID] = container
				root = NoopRenderer.createContainer(container, tag, false)
				roots[rootID] = root
			end
			return root.current.stateNode.containerInfo
		end,

		-- TODO: Replace ReactNoop.render with createRoot + root.render
		createRoot = function()
			local container = {
				rootID = tostring(idCounter),
				pendingChildren = {},
				children = {},
			}
			idCounter += 1
			local fiberRoot =
				NoopRenderer.createContainer(container, ConcurrentRoot, false, nil)
			return {
				_Scheduler = Scheduler,
				render = function(children)
					NoopRenderer.updateContainer(children, fiberRoot, nil)
				end,
				getChildren = function()
					return getChildren(container)
				end,
				getChildrenAsJSX = function()
					return getChildrenAsJSX(container)
				end,
			}
		end,

		createBlockingRoot = function()
			local container = {
				rootID = tostring(idCounter),
				pendingChildren = {},
				children = {},
			}
			idCounter += 1
			local fiberRoot =
				NoopRenderer.createContainer(container, BlockingRoot, false, nil)
			return {
				_Scheduler = Scheduler,
				render = function(children)
					NoopRenderer.updateContainer(children, fiberRoot, nil)
				end,
				getChildren = function()
					return getChildren(container)
				end,
				getChildrenAsJSX = function()
					return getChildrenAsJSX(container)
				end,
			}
		end,

		createLegacyRoot = function()
			local container = {
				rootID = tostring(idCounter),
				pendingChildren = {},
				children = {},
			}
			idCounter += 1
			local fiberRoot =
				NoopRenderer.createContainer(container, LegacyRoot, false, nil)
			return {
				_Scheduler = Scheduler,
				render = function(children)
					NoopRenderer.updateContainer(children, fiberRoot, nil)
				end,
				getChildren = function()
					return getChildren(container)
				end,
				getChildrenAsJSX = function()
					return getChildrenAsJSX(container)
				end,
			}
		end,

		getChildrenAsJSX = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			local container = rootContainers[rootID]
			return getChildrenAsJSX(container)
		end,

		getPendingChildrenAsJSX = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			local container = rootContainers[rootID]
			return getPendingChildrenAsJSX(container)
		end,

		createPortal = function(children, container: Container, key: string?)
			return NoopRenderer.createPortal(children, container, nil, key)
		end,

		-- Shortcut for testing a single root
		render = function(element, callback: Function?)
			ReactNoop.renderToRootWithID(element, DEFAULT_ROOT_ID, callback)
		end,

		renderLegacySyncRoot = function(element, callback: Function?)
			local rootID = DEFAULT_ROOT_ID
			local container = ReactNoop.getOrCreateRootContainer(rootID, LegacyRoot)
			local root = roots[container.rootID]
			NoopRenderer.updateContainer(element, root, nil, callback)
		end,

		renderToRootWithID = function(element, rootID: string, callback: Function?)
			local container = ReactNoop.getOrCreateRootContainer(rootID, ConcurrentRoot)
			local root = roots[container.rootID]
			NoopRenderer.updateContainer(element, root, nil, callback)
		end,

		unmountRootWithID = function(rootID: string)
			local root = roots[rootID]
			if root then
				NoopRenderer.updateContainer(nil, root, nil, function()
					roots[rootID] = nil
					rootContainers[rootID] = nil
				end)
			end
		end,

		findInstance = function(componentOrElement): nil | Instance | TextInstance
			if componentOrElement == nil then
				return nil
			end
			-- Unsound duck typing.
			local component: any = componentOrElement
			if typeof(component.id) == "number" then
				return component
			end
			if _G.__DEV__ then
				return NoopRenderer.findHostInstanceWithWarning(component, "findInstance")
			end
			return NoopRenderer.findHostInstance(component)
		end,

		flushNextYield = function(): Array<any>
			Scheduler.unstable_flushNumberOfYields(1)
			return Scheduler.unstable_clearYields()
		end,

		flushWithHostCounters = function(_fn: () -> ()): {
			hostDiffCounter: number,
			hostUpdateCounter: number,
		} | {
			hostDiffCounter: number,
			hostCloneCounter: number,
		}
			hostDiffCounter = 0
			hostUpdateCounter = 0
			hostCloneCounter = 0
			local ok, result = pcall(function()
				Scheduler.unstable_flushAll()
				if useMutation then
					return {
						hostDiffCounter = hostDiffCounter,
						hostUpdateCounter = hostUpdateCounter,
					}
				else
					return {
						hostDiffCounter = hostDiffCounter,
						hostCloneCounter = hostCloneCounter,
					}
				end
			end)

			hostDiffCounter = 0
			hostUpdateCounter = 0
			hostCloneCounter = 0

			if not ok then
				error(result)
			end
			return result
		end,

		expire = Scheduler.unstable_advanceTime,

		flushExpired = function(): Array<any>
			return Scheduler.unstable_flushExpired()
		end,

		unstable_runWithPriority = NoopRenderer.runWithPriority,

		batchedUpdates = NoopRenderer.batchedUpdates,

		deferredUpdates = NoopRenderer.deferredUpdates,

		unbatchedUpdates = NoopRenderer.unbatchedUpdates,

		discreteUpdates = NoopRenderer.discreteUpdates,

		flushDiscreteUpdates = NoopRenderer.flushDiscreteUpdates,

		flushSync = function(fn: () -> any)
			NoopRenderer.flushSync(fn)
		end,

		flushPassiveEffects = NoopRenderer.flushPassiveEffects,

		-- ROBLOX deviation: can't assign this now, since even if it's pre-declared,
		-- the current value will be nil
		-- act = noopAct,

		-- Logs the current state of the tree.
		dumpTree = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			local root = roots[rootID]
			local rootContainer = rootContainers[rootID]
			if not root or not rootContainer then
				-- eslint-disable-next-line react-internal/no-production-logging
				console.log("Nothing rendered yet.")
				return
			end

			local bufferedLog = {}
			local function log(...)
				local argCount = select("#", ...)
				for i = 1, argCount do
					local arg = select(i, ...)
					table.insert(bufferedLog, arg)
				end
				table.insert(bufferedLog, "\n")
			end

			-- ROBLOX FIXME: This likely needs to be adopted to Roblox
			-- Instance structure as opposed to HTML DOM nodes
			local function logHostInstances(
				children: Array<Instance | TextInstance>,
				depth: number
			)
				-- ROBLOX deviation: May not be able to assume children is an array in
				-- Roblox (we use keys as names), so iterate with `pairs`

				-- ROBLOX FIXME: Might want to iterate in array order if
				-- children _is_ an array
				for _, child in children do
					local indent = string.rep("  ", depth)
					if typeof(child.text) == "string" then
						log(indent .. "- " .. (child :: TextInstance).text)
					else
						-- $FlowFixMe - The child should've been refined now.
						log(
							indent
								.. "- "
								.. (child :: Instance).type
								.. "#"
								.. tostring(child.id)
						)
						-- $FlowFixMe - The child should've been refined now.
						logHostInstances((child :: Instance).children, depth + 1)
					end
				end
			end

			local function logContainer(container: Container, depth: number)
				log(string.rep("  ", depth) .. "- [root#" .. container.rootID .. "]")
				logHostInstances(container.children, depth + 1)
			end

			local function logUpdateQueue(updateQueue: UpdateQueue<any>, depth: number)
				log(string.rep("  ", depth + 1) .. "QUEUED UPDATES")
				local first = updateQueue.firstBaseUpdate
				local update = first
				if update ~= nil then
					repeat
						log(
							string.rep("  ", depth + 1) .. "~",
							-- ROBLOX TODO: this is a bogus field, even in upstream
							"[" .. tostring((update :: any).expirationTime) .. "]"
						)
					until update == nil
				end

				local lastPending = updateQueue.shared.pending
				if lastPending ~= nil then
					local firstPending = lastPending.next
					local pendingUpdate = firstPending
					if pendingUpdate ~= nil then
						repeat
							log(
								string.rep("  ", depth + 1) .. "~",
								-- ROBLOX TODO: this is a bogus field, even in upstream
								"[" .. tostring((update :: any).expirationTime) .. "]"
							)
						until pendingUpdate == nil or pendingUpdate == firstPending
					end
				end
			end

			local function logFiber(fiber: Fiber, depth: number)
				log(
					string.rep("  ", depth)
						.. "- "
						-- need to explicitly coerce Symbol to a string
						.. if fiber.type
							then (fiber.type.name or tostring(fiber.type))
							else "[root]",
					"["
						-- ROBLOX TODO: this field is bogus even in upstream, will always be nil
						.. tostring((fiber :: any).childExpirationTime)
						.. (if fiber.pendingProps then "*" else "")
						.. "]"
				)
				if fiber.updateQueue then
					logUpdateQueue(fiber.updateQueue, depth)
				end
				-- local childInProgress = fiber.progressedChild
				-- if childInProgress and childInProgress ~= fiber.child then
				--   log(
				--     string.rep('  ', depth + 1) .. 'IN PROGRESS: ' .. tostring(fiber.pendingWorkPriority)
				--   )
				--   logFiber(childInProgress, depth + 1)
				--   if fiber.child then
				--     log(string.rep('  ', depth + 1) .. 'CURRENT')
				--   end
				-- elseif fiber.child and fiber.updateQueue then
				--   log(string.rep('  ', depth + 1) .. 'CHILDREN')
				-- end
				if fiber.child then
					logFiber(fiber.child, depth + 1)
				end
				if fiber.sibling then
					logFiber(fiber.sibling, depth)
				end
			end

			log("HOST INSTANCES:")
			logContainer(rootContainer, 0)
			log("FIBERS:")
			logFiber(root.current, 0)

			-- eslint-disable-next-line react-internal/no-production-logging
			for _, line in bufferedLog do
				console.log(line)
			end
		end,

		getRoot = function(rootID: string?)
			rootID = rootID or DEFAULT_ROOT_ID
			return roots[rootID]
		end,
	}

	-- This version of `act` is only used by our tests. Unlike the public version
	-- of `act`, it's designed to work identically in both production and
	-- development. It may have slightly different behavior from the public
	-- version, too, since our constraints in our test suite are not the same as
	-- those of developers using React — we're testing React itself, as opposed to
	-- building an app with React.

	local batchedUpdates = NoopRenderer.batchedUpdates
	local IsThisRendererActing = NoopRenderer.IsThisRendererActing
	local actingUpdatesScopeDepth = 0

	local function noopAct(scope: (() -> Thenable<any>) | () -> ())
		if Scheduler.unstable_flushAllWithoutAsserting == nil then
			error(
				Error("This version of `act` requires a special mock build of Scheduler.")
			)
		end
		if typeof(setTimeout) == "table" and setTimeout._isMockFunction ~= true then
			error(
				Error(
					"This version of `act` requires Jest's timer mocks "
						.. "(i.e. jest.useFakeTimers)."
				)
			)
		end

		local previousActingUpdatesScopeDepth = actingUpdatesScopeDepth
		local previousIsSomeRendererActing = IsSomeRendererActing.current
		local previousIsThisRendererActing = IsThisRendererActing.current
		IsSomeRendererActing.current = true
		IsThisRendererActing.current = true
		actingUpdatesScopeDepth += 1

		local unwind = function()
			actingUpdatesScopeDepth -= 1
			IsSomeRendererActing.current = previousIsSomeRendererActing
			IsThisRendererActing.current = previousIsThisRendererActing

			if _G.__DEV__ then
				if actingUpdatesScopeDepth > previousActingUpdatesScopeDepth then
					-- if it's _less than_ previousActingUpdatesScopeDepth, then we can
					-- assume the 'other' one has warned
					console.error(
						"You seem to have overlapping act() calls, this is not supported. "
							.. "Be sure to await previous act() calls before making a new one. "
					)
				end
			end
		end

		-- TODO: This would be way simpler if 1) we required a promise to be
		-- returned and 2) we could use async/await. Since it's only our used in
		-- our test suite, we should be able to.
		local ok, result = pcall(function()
			local thenable = batchedUpdates(scope)
			if typeof(thenable) == "table" and typeof(thenable.andThen) == "function" then
				return {
					andThen = function(self, resolve: () -> (), reject: (any) -> ())
						thenable:andThen(function()
							flushActWork(function()
								unwind()
								resolve()
							end, function(error_)
								unwind()
								reject(error_)
							end)
						end, function(err)
							unwind()
							reject(err)
						end)
					end,
				}
			else
				local ok, result = pcall(function()
					-- TODO: Let's not support non-async scopes at all in our tests. Need to
					-- migrate existing tests.
					local didFlushWork
					repeat
						didFlushWork = Scheduler.unstable_flushAllWithoutAsserting()
					until not didFlushWork
				end)
				unwind()
				if not ok then
					error(result)
				end
				-- ROBLOX deviation: upstream flowtype doesn't mind the inconsistent return, but Luau does
				return nil
			end
		end)
		if not ok then
			unwind()
			error(result)
		end
		return result
	end

	flushActWork = function(resolve, reject)
		-- Flush suspended fallbacks

		-- $FlowFixMe: Flow doesn't know about global Jest object
		jest.runOnlyPendingTimers()

		enqueueTask(function()
			local ok, result = pcall(function()
				local didFlushWork = Scheduler.unstable_flushAllWithoutAsserting()
				if didFlushWork then
					flushActWork(resolve, reject)
				else
					resolve()
				end
			end)
			if not ok then
				reject(result)
			end
		end)
	end

	-- ROBLOX deviation: assign this at the end once it's non-nil
	ReactNoop.act = noopAct

	return ReactNoop
end

return createReactNoop ]]
cR.Children._35c4deb83c987fc18d747cb55adba755=cU
local cV

local cW={ClassName="ModuleScript",Children={},Properties={}}
cW.Name="ReactReconciler"
cW.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

--!strict
local ReactInternalTypes = require(script.ReactInternalTypes)
local ReactRootTags = require(script.ReactRootTags)

export type Dispatcher = ReactInternalTypes.Dispatcher
export type Fiber = ReactInternalTypes.Fiber
export type FiberRoot = ReactInternalTypes.FiberRoot

-- ROBLOX deviation: explicit export for use in createReactNoop
export type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>

export type RootTag = ReactRootTags.RootTag

-- ROBLOX deviation: In order to allow host config to be spliced in, we export
-- this top-level package as an initializer function that returns the configured
-- reconciler module
-- ROBLOX TODO: this effectively disconnects type checking from above to reconciler to below
local function initialize(config): { [string]: any }
	local ReactFiberHostConfig = require(script.ReactFiberHostConfig)
	for name, implementation in config do
		ReactFiberHostConfig[name] = implementation
	end

	return require(script.ReactFiberReconciler)
end

return initialize ]]
c.Children._2ad11420b2b47d55efad72cd20849561=cW
local cX
local cY={ClassName="ModuleScript",Children={},Properties={}}
cY.Name="DebugTracing"
cY.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/DebugTracing.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent
type Array<T> = { [number]: T }
type Map<K, V> = { [K]: V }
type Object = { [string]: any }
type Function = (any) -> any?
local Shared = require(Packages.Shared)
local console = Shared.console
local exports = {}

-- ROBLOX deviation: hoist log so it's visible
local log
-- ROBLOX deviation: the nucelus emoji `(%c\u{269B}\u{FE0F}%c)` has been replaced with `*`

local ReactFiberLaneModule = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLaneModule.Lane
type Lanes = ReactFiberLaneModule.Lanes
type Wakeable = Shared.Wakeable

local enableDebugTracing = require(Packages.Shared).ReactFeatureFlags.enableDebugTracing

local nativeConsole: Object = console
local nativeConsoleLog: nil | Function = nil

local pendingGroupArgs: Array<any> = {}
-- ROBLOX deviation: adjust starting indea for Lua 1-based arrays
local printedGroupIndex: number = 0

-- ROBLOX deviation: Luau has no built-in way to convert decimal number to binary string
function decimalToBinaryString(decimal: number): string
	local result = ""
	repeat
		local divres = decimal / 2
		local int, frac = math.modf(divres)
		decimal = int
		result = math.ceil(frac) .. result
	until decimal == 0

	local nbZero = 31 - string.len(result)
	return string.rep("0", nbZero) .. result
end

local function formatLanes(laneOrLanes: Lane | Lanes): string
	return "0b"
		-- ROBLOX deviation: Luau has no built-in way to convert decimal number to binary string
		.. decimalToBinaryString(laneOrLanes)
end

local function group(...): ()
	for _, groupArg in { ... } do
		table.insert(pendingGroupArgs, groupArg)
	end
	if nativeConsoleLog == nil then
		nativeConsoleLog = nativeConsole.log
		nativeConsole.log = log
	end
end

local function groupEnd(): ()
	table.remove(pendingGroupArgs, 1)
	while printedGroupIndex > #pendingGroupArgs do
		nativeConsole.groupEnd()
		printedGroupIndex -= 1
	end
	if #pendingGroupArgs == 0 then
		nativeConsole.log = nativeConsoleLog
		nativeConsoleLog = nil
	end
end

function log(...): ()
	if printedGroupIndex < #pendingGroupArgs then
		for i = printedGroupIndex + 1, #pendingGroupArgs do
			local groupArgs = pendingGroupArgs[i]
			nativeConsole.group(groupArgs)
		end
		printedGroupIndex = #pendingGroupArgs
	end
	if typeof(nativeConsoleLog) == "function" then
		(nativeConsoleLog :: any)(...)
	else
		nativeConsole.log(...)
	end
end

-- ROBLOX deviation: remove color styling
local REACT_LOGO_STYLE = ""

local function logCommitStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* commit (%s)", formatLanes(lanes)),
				REACT_LOGO_STYLE,
				"",
				-- ROBLOX deviation: remove style
				""
			)
		end
	end
end
exports.logCommitStarted = logCommitStarted

local function logCommitStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logCommitStopped = logCommitStopped

-- ROBLOX deviation: use raw Lua table
-- const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
-- $FlowFixMe: Flow cannot handle polymorphic WeakMaps

-- ROBLOX TODO: restore the color message formatting from upstream
-- local wakeableIDs: Map<Wakeable, number> = {}
-- local wakeableID: number = 0
-- local function getWakeableID(wakeable: Wakeable): number
-- 	if not wakeableIDs[wakeable] ~= nil then
-- 		wakeableIDs[wakeable] =
-- 			(function()
-- 				local result = wakeableID
-- 				wakeableID += 1
-- 				return result
-- 			end)()
-- 	end
-- 	return wakeableIDs[wakeable]
-- end

local function logComponentSuspended(componentName: string, wakeable: Wakeable): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			-- local _id = getWakeableID(wakeable)
			-- ROBLOX deviation: our Wakeable can be a function or a callable table
			-- local _display = wakeable.displayName or wakeable
			log(
				string.format("* %s suspended", componentName)
				-- REACT_LOGO_STYLE,
				-- ROBLOX deviation: remove color styling
				-- "",
				-- id,
				-- display
			)
			wakeable:andThen(function()
				log(
					string.format("* %s resolved", componentName)
					-- REACT_LOGO_STYLE,
					-- ROBLOX deviation: remove color styling
					-- "",
					-- id,
					-- display
				)
			end, function()
				log(
					string.format("* %s rejected", componentName)
					-- REACT_LOGO_STYLE,
					-- ROBLOX deviation: remove color styling
					-- "",
					-- id,
					-- display
				)
			end)
		end
	end
end
exports.logComponentSuspended = logComponentSuspended

local function logLayoutEffectsStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* layout effects (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- ROBLOX deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logLayoutEffectsStarted = logLayoutEffectsStarted

local function logLayoutEffectsStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logLayoutEffectsStopped = logLayoutEffectsStopped

local function logPassiveEffectsStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* passive effects (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- ROBLOX deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logPassiveEffectsStarted = logPassiveEffectsStarted

local function logPassiveEffectsStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logPassiveEffectsStopped = logPassiveEffectsStopped

local function logRenderStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* render (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- ROBLOX deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logRenderStarted = logRenderStarted

local function logRenderStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logRenderStopped = logRenderStopped

local function logForceUpdateScheduled(componentName: string, lane: Lane): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			log(
				string.format("* %s forced update (%s)", componentName, formatLanes(lane))
				-- REACT_LOGO_STYLE,
				-- ROBLOX deviation: strip color styling
				-- "",
				-- ""
			)
		end
	end
end
exports.logForceUpdateScheduled = logForceUpdateScheduled

local function logStateUpdateScheduled(
	componentName: string,
	lane: Lane,
	payloadOrAction: any
): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			log(
				string.format("* %s updated state (%s)", componentName, formatLanes(lane))
				-- REACT_LOGO_STYLE,
				-- ROBLOX deviation: strip color styling
				-- "",
				-- "",
				-- payloadOrAction
			)
		end
	end
end
exports.logStateUpdateScheduled = logStateUpdateScheduled
return exports ]]
cX.Children._42a58db5c4debef977ffce199ea65d13=cY
local cZ

local c_={ClassName="ModuleScript",Children={},Properties={}}
c_.Name="MaxInts"
c_.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/MaxInts.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

-- // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
-- // Math.pow(2, 30) - 1
-- // 0b111111111111111111111111111111
return { MAX_SIGNED_31_BIT_INT = 1073741823 } ]]
cX.Children._eb5300887b627c326040c1e71e3e4941=c_
local c0

local c1={ClassName="ModuleScript",Children={},Properties={}}
c1.Name="ReactCapturedValue"
c1.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactCapturedValue.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local getStackByFiberInDevAndProd =
	require(script.Parent.ReactFiberComponentStack).getStackByFiberInDevAndProd

export type CapturedValue<T> = {
	value: T,
	source: Fiber | nil,
	stack: string | nil,
}

local exports = {}

exports.createCapturedValue = function<T>(value: T, source: Fiber | nil): CapturedValue<T>
	-- If the value is an error, call this function immediately after it is thrown
	-- so the stack is accurate.
	return {
		value = value,
		source = source,
		stack = getStackByFiberInDevAndProd(source),
	}
end

return exports ]]
cX.Children._73c0a209151ba0189501061233ba6a30=c1
local c2

local c3={ClassName="ModuleScript",Children={},Properties={}}
c3.Name="ReactChildFiber.new"
c3.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactChildFiber.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
type Array<T> = { [number]: T }
type Set<T> = { [T]: boolean }
type Object = { [any]: any }
type Map<K, V> = { [K]: V }
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local describeError = require(Packages.Shared).describeError

local ReactTypes = require(Packages.Shared)
-- ROBLOX deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactTypes.ReactElement<any, any>
type ReactPortal = ReactTypes.ReactPortal

local React = require(Packages.React)
type LazyComponent<T, P> = React.LazyComponent<T, P>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type RoactStableKey = ReactInternalTypes.RoactStableKey
local ReactFiberLanes = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLanes.Lanes

local getComponentName = require(Packages.Shared).getComponentName
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Placement = ReactFiberFlags.Placement
local Deletion = ReactFiberFlags.Deletion
local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local Block = ReactWorkTags.Block
local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- ROBLOX deviation: we do not support string refs
-- local warnAboutStringRefs = ReactFeatureFlags.warnAboutStringRefs
local enableLazyElements = ReactFeatureFlags.enableLazyElements
local enableBlocksAPI = ReactFeatureFlags.enableBlocksAPI

local ReactFiber = require(script.Parent["ReactFiber.new"])
local createWorkInProgress = ReactFiber.createWorkInProgress
local resetWorkInProgress = ReactFiber.resetWorkInProgress
local createFiberFromElement = ReactFiber.createFiberFromElement
local createFiberFromFragment = ReactFiber.createFiberFromFragment
local createFiberFromText = ReactFiber.createFiberFromText
local createFiberFromPortal = ReactFiber.createFiberFromPortal
-- ROBLOX deviation: we do not support string refs
-- local emptyRefsObject =
-- 	require(script.Parent["ReactFiberClassComponent.new"]).emptyRefsObject
-- local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
-- local isCompatibleFamilyForHotReloading =
-- 	ReactFiberHotReloading.isCompatibleFamilyForHotReloading
-- ROBLOX deviation: we do not support string refs, which removes our use of StrictMode
-- local StrictMode = require(script.Parent.ReactTypeOfMode).StrictMode

local exports = {}

local didWarnAboutMaps
-- ROBLOX deviation: Lua doesn't have built-in generators
-- local didWarnAboutGenerators
-- ROBLOX deviation: we do not support string refs
-- local didWarnAboutStringRefs
local ownerHasKeyUseWarning
local ownerHasFunctionTypeWarning
local warnForMissingKey = function(child: any, returnFiber: Fiber) end

if __DEV__ then
	didWarnAboutMaps = false
	-- ROBLOX deviation: Lua doesn't have built-in generators
	--   didWarnAboutGenerators = false

	-- ROBLOX deviation: we do not support string refs
	-- didWarnAboutStringRefs = {}

	--\[\[
	Warn if there's no key explicitly set on dynamic arrays of children or
	object keys are not valid. This allows us to keep track of children between
	updates.
  \]\]
	ownerHasKeyUseWarning = {}
	ownerHasFunctionTypeWarning = {}

	-- ROBLOX FIXME: This may need to change depending on how we want children to
	-- be passed. Current Roact accepts a table (keys are built-in) and leaves
	-- ordering up to users via LayoutOrder, but if we accept arrays (and attempt
	-- to somehow map them to LayoutOrder??) we'll need keys for stability
	warnForMissingKey = function(child: any, returnFiber: Fiber)
		if child == nil or type(child) ~= "table" then
			return
		end
		if not child._store or child._store.validated or child.key ~= nil then
			return
		end
		invariant(
			child._store ~= nil and type(child._store) == "table",
			"React Component in warnForMissingKey should have a _store. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
		child._store.validated = true

		local componentName = getComponentName(returnFiber.type) or "Component"

		if ownerHasKeyUseWarning[componentName] then
			return
		end
		ownerHasKeyUseWarning[componentName] = true

		console.error(
			"Each child in a list should have a unique "
				.. '"key" prop. See https://reactjs.org/link/warning-keys for '
				.. "more information."
		)
	end
end

local isArray = Array.isArray

function coerceRef(returnFiber: Fiber, current: Fiber | nil, element: ReactElement)
	local mixedRef = element.ref
	if mixedRef ~= nil and type(mixedRef) == "string" then
		-- ROBLOX deviation: we do not support string refs, and will not coerce
		if
			not element._owner
			or not element._self
			or element._owner.stateNode == element._self
		then
			-- ROBLOX performance: don't get component name unless we have to use it
			local componentName
			if __DEV__ then
				componentName = getComponentName(returnFiber.type) or "Component"
			else
				componentName = "<enable __DEV__ mode for component names>"
			end
			error(
				Error.new(
					string.format(
						'Component "%s" contains the string ref "%s". Support for string refs '
							-- ROBLOX deviation: we removed string ref support ahead of upstream schedule
							.. "has been removed. We recommend using "
							.. "useRef() or createRef() instead. "
							.. "Learn more about using refs safely here: "
							.. "https://reactjs.org/link/strict-mode-string-ref",
						componentName,
						tostring(mixedRef)
					)
				)
			)
		end

		if not element._owner then
			error(
				"Expected ref to be a function or an object returned by React.createRef(), or nil."
			)
		end

		-- if __DEV__ then
		-- 	-- TODO: Clean this up once we turn on the string ref warning for
		-- 	-- everyone, because the strict mode case will no longer be relevant
		-- 	if
		-- 		(bit32.band(returnFiber.mode, StrictMode) ~= 0 or warnAboutStringRefs)
		-- 		-- We warn in ReactElement.js if owner and self are equal for string refs
		-- 		-- because these cannot be automatically converted to an arrow function
		-- 		-- using a codemod. Therefore, we don't have to warn about string refs again.
		-- 		and not (
		-- 			element._owner
		-- 			and element._self
		-- 			and element._owner.stateNode ~= element._self
		-- 		)
		-- 	then
		-- 		local componentName = getComponentName(returnFiber.type) or "Component"
		-- 		if not didWarnAboutStringRefs[componentName] then
		-- 			if warnAboutStringRefs then
		-- 				console.error(
		-- 					'Component "%s" contains the string ref "%s". Support for string refs '
		-- 						.. "will be removed in a future major release. We recommend using "
		-- 						.. "useRef() or createRef() instead. "
		-- 						.. "Learn more about using refs safely here: "
		-- 						.. "https://reactjs.org/link/strict-mode-string-ref",
		-- 					componentName,
		-- 					mixedRef
		-- 				)
		-- 			else
		-- 				console.error(
		-- 					'A string ref, "%s", has been found within a strict mode tree. '
		-- 						.. "String refs are a source of potential bugs and should be avoided. "
		-- 						.. "We recommend using useRef() or createRef() instead. "
		-- 						.. "Learn more about using refs safely here: "
		-- 						.. "https://reactjs.org/link/strict-mode-string-ref",
		-- 					mixedRef
		-- 				)
		-- 			end
		-- 			didWarnAboutStringRefs[componentName] = true
		-- 		end
		-- 	end
		-- end

		-- if element._owner then
		-- 	local owner: Fiber? = element._owner
		-- 	local inst
		-- 	if owner then
		-- 		local ownerFiber = owner
		-- 		invariant(
		-- 			ownerFiber.tag == ClassComponent,
		-- 			"Function components cannot have string refs. "
		-- 				.. "We recommend using useRef() instead. "
		-- 				.. "Learn more about using refs safely here: "
		-- 				.. "https://reactjs.org/link/strict-mode-string-ref"
		-- 		)
		-- 		inst = ownerFiber.stateNode
		-- 	end
		-- 	invariant(
		-- 		inst,
		-- 		"Missing owner for string ref %s. This error is likely caused by a "
		-- 			.. "bug in React. Please file an issue.",
		-- 		mixedRef
		-- 	)

		-- 	-- ROBLOX deviation: explicitly convert to string
		-- 	local stringRef = tostring(mixedRef)
		-- 	-- Check if previous string ref matches new string ref
		-- 	if
		-- 		current ~= nil
		-- 		and (current :: Fiber).ref ~= nil
		-- 		-- ROBLOX deviation: Lua doesn't support fields on functions, so invert this check
		-- 		-- typeof((current :: Fiber).ref) == 'function' and
		-- 		and typeof((current :: Fiber).ref) ~= "function"
		-- 		-- ROBLOX deviation: this partially inlines the ref type from Fiber to workaround Luau refinement issues
		-- 		and ((current :: Fiber).ref :: { _stringRef: string? })._stringRef
		-- 			== stringRef
		-- 	then
		-- 		return (current :: Fiber).ref
		-- 	end
		-- 	-- ROBLOX deviation: make ref a callable table rather than a function
		-- 	local callableRef = function(value)
		-- 		local refs = inst.__refs
		-- 		if refs == emptyRefsObject then
		-- 			-- This is a lazy pooled frozen object, so we need to initialize.
		-- 			inst.__refs = {}
		-- 			refs = inst.__refs
		-- 		end
		-- 		if value == nil then
		-- 			refs[stringRef] = nil
		-- 		else
		-- 			refs[stringRef] = value
		-- 		end
		-- 	end
		-- 	local ref = setmetatable({}, { __call = callableRef })
		-- 	ref._stringRef = stringRef
		-- 	return ref
		-- else
		-- 	invariant(
		-- 		typeof(mixedRef) == "string",
		-- 		"Expected ref to be a function, a string, an object returned by React.createRef(), or nil."
		-- 	)
		-- 	invariant(
		-- 		element._owner,
		-- 		"Element ref was specified as a string (%s) but no owner was set. This could happen for one of"
		-- 			.. " the following reasons:\n"
		-- 			.. "1. You may be adding a ref to a function component\n"
		-- 			.. "2. You may be adding a ref to a component that was not created inside a component's render method\n"
		-- 			.. "3. You have multiple copies of React loaded\n"
		-- 			.. "See https://reactjs.org/link/refs-must-have-owner for more information.",
		-- 		mixedRef
		-- 	)
		-- end
	end
	return mixedRef
end

-- ROBLOX performance: all uses commented out
-- local function throwOnInvalidObjectType(returnFiber: Fiber, newChild: { [any]: any })
-- 	if returnFiber.type ~= "textarea" then
-- ROBLOX FIXME: Need to adjust this to check for "table: <address>" instead
-- and print appropriately
-- unimplemented("throwOnInvalidObjectType textarea")

-- ROBLOX TODO: This is likely a bigger deviation; in Roact today, we allow
-- tables and use the keys as equivalents to the `key` prop
-- invariant(
--   false,
--   "Objects are not valid as a React child (found: %s). " ..
--     "If you meant to render a collection of children, use an array " ..
--     "instead.",
--   tostring(newChild) == "[object Object]"
--     ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
--     : newChild,
-- )
-- 	end
-- end

local function warnOnFunctionType(returnFiber: Fiber)
	if __DEV__ then
		local componentName = getComponentName(returnFiber.type) or "Component"

		if ownerHasFunctionTypeWarning[componentName] then
			return
		end
		ownerHasFunctionTypeWarning[componentName] = true

		console.error(
			"Functions are not valid as a React child. This may happen if "
				.. "you return a Component instead of <Component /> from render. "
				.. "Or maybe you meant to call this function rather than return it."
		)
	end
end

-- // We avoid inlining this to avoid potential deopts from using try/catch.
-- /** @noinline */
function resolveLazyType<T, P>(lazyComponent: LazyComponent<T, P>): LazyComponent<T, P> | T
	-- ROBLOX performance: hoist non-throwable lines so we eliminate an anon function for the pcall
	-- If we can, let's peek at the resulting type.
	local payload = lazyComponent._payload
	local init = lazyComponent._init
	local ok, result = xpcall(init, describeError, payload)
	if not ok then
		-- Leave it in place and let it throw again in the begin phase.
		return lazyComponent
	end

	return result
end

-- This wrapper function exists because I expect to clone the code in each path
-- to be able to optimize each path individually by branching early. This needs
-- a compiler or we can do it manually. Helpers that don't need this branching
-- live outside of this function.
local function ChildReconciler(shouldTrackSideEffects)
	local function deleteChild(returnFiber: Fiber, childToDelete: Fiber)
		if not shouldTrackSideEffects then
			-- Noop.
			return
		end
		local deletions = returnFiber.deletions
		if deletions == nil then
			returnFiber.deletions = { childToDelete }
			returnFiber.flags = bit32.bor(returnFiber.flags, Deletion)
		else
			table.insert(deletions, childToDelete)
		end
	end

	local function deleteRemainingChildren(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil
	)
		if not shouldTrackSideEffects then
			-- Noop.
			return nil
		end

		-- TODO: For the shouldClone case, this could be micro-optimized a bit by
		-- assuming that after the first child we've already added everything.
		local childToDelete = currentFirstChild
		while childToDelete ~= nil do
			deleteChild(returnFiber, childToDelete)
			childToDelete = childToDelete.sibling
		end
		return nil
	end

	local function mapRemainingChildren(
		returnFiber: Fiber,
		currentFirstChild: Fiber
	): { [string | number]: Fiber }
		-- Add the remaining children to a temporary map so that we can find them by
		-- keys quickly. Implicit (null) keys get added to this set with their index
		-- instead.
		local existingChildren: { [string | number]: Fiber } = {}

		-- ROBLOX FIXME Luau: Luau doesn't correctly infer in repeat until nil scenarios
		local existingChild: Fiber? = currentFirstChild
		while existingChild ~= nil do
			if existingChild.key ~= nil then
				existingChildren[existingChild.key] = existingChild
			else
				existingChildren[existingChild.index] = existingChild
			end
			existingChild = existingChild.sibling
		end
		return existingChildren
	end

	local function useFiber(fiber: Fiber, pendingProps: any): Fiber
		-- We currently set sibling to nil and index to 0 here because it is easy
		-- to forget to do before returning it. E.g. for the single child case.
		local clone = createWorkInProgress(fiber, pendingProps)
		-- ROBLOX deviation: set index to 1 for 1-indexing
		clone.index = 1
		clone.sibling = nil
		return clone
	end

	local function placeChild(
		newFiber: Fiber,
		lastPlacedIndex: number,
		newIndex: number
	): number
		newFiber.index = newIndex
		if not shouldTrackSideEffects then
			-- Noop.
			return lastPlacedIndex
		end
		local current = newFiber.alternate
		if current ~= nil then
			local oldIndex = current.index
			if oldIndex < lastPlacedIndex then
				-- This is a move.
				newFiber.flags = bit32.bor(newFiber.flags, Placement)
				return lastPlacedIndex
			else
				-- This item can stay in place.
				return oldIndex
			end
		else
			-- This is an insertion.
			newFiber.flags = bit32.bor(newFiber.flags, Placement)
			return lastPlacedIndex
		end
	end

	local function placeSingleChild(newFiber: Fiber): Fiber
		-- This is simpler for the single child case. We only need to do a
		-- placement for inserting new children.
		if shouldTrackSideEffects and newFiber.alternate == nil then
			newFiber.flags = bit32.bor(newFiber.flags, Placement)
		end
		return newFiber
	end

	local function updateTextNode(
		returnFiber: Fiber,
		current: Fiber | nil,
		textContent: string,
		lanes: Lanes
	)
		-- ROBLOX FIXME: Luau narrowing issue
		if current == nil or (current :: Fiber).tag ~= HostText then
			-- Insert
			local created = createFiberFromText(textContent, returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, textContent)
			existing.return_ = returnFiber
			return existing
		end
	end

	local function updateElement(
		returnFiber: Fiber,
		current: Fiber | nil,
		element: ReactElement,
		lanes: Lanes
	): Fiber
		if current ~= nil then
			if
				(current :: Fiber).elementType == element.type
				-- ROBLOX performance: avoid always-false cmp, hot reloading isn't enabled in Roblox yet
				-- Keep this check inline so it only runs on the false path:
				-- or (__DEV__ and isCompatibleFamilyForHotReloading(current, element))
			then
				-- Move based on index
				local existing = useFiber(current :: Fiber, element.props)
				existing.ref = coerceRef(returnFiber, current, element)
				existing.return_ = returnFiber
				if __DEV__ then
					existing._debugSource = element._source
					existing._debugOwner = element._owner
				end
				return existing
			elseif enableBlocksAPI and (current :: Fiber).tag == Block then
				-- The new Block might not be initialized yet. We need to initialize
				-- it in case initializing it turns out it would match.
				-- ROBLOX FIXME Luau: Luau should analyze closure and create union of assignments
				local type_: any = element.type
				if type(type_) == "table" and type_["$$typeof"] == REACT_LAZY_TYPE then
					type_ = resolveLazyType(type_) :: LazyComponent<any, any>
				end
				if
					type_["$$typeof"] == REACT_BLOCK_TYPE
					and type_._render == (current :: Fiber).type._render
				then
					-- Same as above but also update the .type field.
					local existing = useFiber(current :: Fiber, element.props)
					existing.return_ = returnFiber
					existing.type = type_
					if __DEV__ then
						existing._debugSource = element._source
						existing._debugOwner = element._owner
					end
					return existing
				end
			end
		end
		-- Insert
		local created = createFiberFromElement(element, returnFiber.mode, lanes)
		created.ref = coerceRef(returnFiber, current, element)
		created.return_ = returnFiber
		return created
	end

	local function updatePortal(
		returnFiber: Fiber,
		current: Fiber | nil,
		portal: ReactPortal,
		lanes: Lanes
	): Fiber
		-- ROBLOX FIXME: type narrowing.
		if
			current == nil
			or (current :: Fiber).tag ~= HostPortal
			or (current :: Fiber).stateNode.containerInfo ~= portal.containerInfo
			or (current :: Fiber).stateNode.implementation ~= portal.implementation
		then
			-- Insert
			local created = createFiberFromPortal(portal, returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, portal.children or {})
			existing.return_ = returnFiber
			return existing
		end
	end

	local function updateFragment(
		returnFiber: Fiber,
		current: Fiber | nil,
		-- ROBLOX TODO: figure out how we should define our Iterable type
		--   fragment: Iterable<*>,
		fragment: any,
		lanes: Lanes,
		key: nil | string
	): Fiber
		if current == nil or (current :: Fiber).tag ~= Fragment then
			-- Insert
			local created =
				createFiberFromFragment(fragment, returnFiber.mode, lanes, key)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, fragment)
			existing.return_ = returnFiber
			return existing
		end
	end

	-- ROBLOX deviation: Roact stable keys - Support Roact's implementation of
	-- stable keys, wherein the key used in the `children` table is used as if it
	-- were a `key` prop. Child order doesn't matter in Roblox, so a vast majority
	-- of existing Roact code used table keys in this way.
	local function assignStableKey(tableKey: any?, newChild: Object): ()
		-- If there's no assigned key in the element, and the table key is valid,
		-- assign it as the element's key.
		-- If the key is a table, convert it to a string.

		-- ROBLOX TODO: Investigate if this is safe; maybe we need to shallow-copy
		-- the object if we have a new key, to preserve immutability, but that cost
		-- may be severe
		if newChild.key == nil then
			-- ROBLOX performance? only call typeof once, and only if first condition is true
			local typeOfTableKey = type(tableKey)
			if typeOfTableKey == "string" or typeOfTableKey == "number" then
				newChild.key = tableKey
			elseif typeOfTableKey == "table" then
				newChild.key = tostring(tableKey)
			end
		end
	end

	local function createChild(
		returnFiber: Fiber,
		newChild: any,
		lanes: Lanes,
		-- ROBLOX deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- ROBLOX performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- ROBLOX performance: avoid repeated calls to typeof, since Luau doesn't optimize
		local typeOfNewChild = type(newChild)

		-- ROBLOX performance: hoist more common ROblox case (non-string/number) first to reduce cmp in hot path
		if typeOfNewChild == "table" then
			-- ROBLOX deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			-- ROBLOX performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				local created = createFiberFromElement(newChild, returnFiber.mode, lanes)
				created.ref = coerceRef(returnFiber, nil, newChild)
				created.return_ = returnFiber
				return created
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				local created = createFiberFromPortal(newChild, returnFiber.mode, lanes)
				created.return_ = returnFiber
				return created
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- ROBLOX deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return createChild(returnFiber, init(payload), lanes)
				end
			end

			-- ROBLOX deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			local created =
				createFiberFromFragment(newChild, returnFiber.mode, lanes, nil)
			created.return_ = returnFiber
			return created

			-- ROBLOX performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys. If the previous node is implicitly keyed
			-- we can continue to replace it without aborting even if it is not a text
			-- node.
			local created =
				createFiberFromText(tostring(newChild), returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	local function updateSlot(
		returnFiber: Fiber,
		oldFiber: Fiber | nil,
		newChild: any,
		lanes: Lanes,
		-- ROBLOX deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- ROBLOX performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- Update the fiber if the keys match, otherwise return nil.

		local key = if oldFiber ~= nil then oldFiber.key else nil
		-- ROBLOX performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		if typeOfNewChild == "table" then
			-- ROBLOX deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			-- ROBLOX performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				if newChild.key == key then
					if newChild.type == REACT_FRAGMENT_TYPE then
						return updateFragment(
							returnFiber,
							oldFiber,
							newChild.props.children,
							lanes,
							key :: string?
						)
					end
					return updateElement(returnFiber, oldFiber, newChild, lanes)
				else
					return nil
				end
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				if newChild.key == key then
					return updatePortal(returnFiber, oldFiber, newChild, lanes)
				else
					return nil
				end
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- ROBLOX deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return updateSlot(returnFiber, oldFiber, init(payload), lanes)
				end
			end

			-- ROBLOX deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			if key ~= nil then
				return nil
			end

			return updateFragment(returnFiber, oldFiber, newChild, lanes)

			-- ROBLOX performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		-- ROBLOX performance: do this compare last to save 2 string cmp in typical Roblox hot path
		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys. If the previous node is implicitly keyed
			-- we can continue to replace it without aborting even if it is not a text
			-- node.
			if key ~= nil then
				return nil
			end
			return updateTextNode(returnFiber, oldFiber, tostring(newChild), lanes)
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	local function updateFromMap(
		existingChildren: Map<string | number, Fiber>,
		returnFiber: Fiber,
		newIdx: number,
		newChild: any,
		lanes: Lanes,
		-- ROBLOX deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- ROBLOX performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- ROBLOX performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		if typeOfNewChild == "table" then
			-- ROBLOX deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			local existingChildrenKey
			-- ROBLOX performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				if newChild.key == nil then
					existingChildrenKey = newIdx
				else
					existingChildrenKey = newChild.key
				end
				local matchedFiber = existingChildren[existingChildrenKey]
				if newChild.type == REACT_FRAGMENT_TYPE then
					return updateFragment(
						returnFiber,
						matchedFiber,
						newChild.props.children,
						lanes,
						newChild.key
					)
				end
				return updateElement(returnFiber, matchedFiber, newChild, lanes)
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				if newChild.key == nil then
					existingChildrenKey = newIdx
				else
					existingChildrenKey = newChild.key
				end
				local matchedFiber = existingChildren[existingChildrenKey]
				return updatePortal(returnFiber, matchedFiber, newChild, lanes)
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- ROBLOX deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return updateFromMap(
						existingChildren,
						returnFiber,
						newIdx,
						init(payload),
						lanes
					)
				end
			end

			-- ROBLOX deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			local matchedFiber = existingChildren[newIdx]
			return updateFragment(returnFiber, matchedFiber, newChild, lanes)

			-- ROBLOX performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		-- ROBLOX performance: do this compare last, as Roblox won't really support text nodes directly
		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys, so we neither have to check the old nor
			-- new node for the key. If both are text nodes, they match.
			local matchedFiber = existingChildren[newIdx] or nil
			return updateTextNode(returnFiber, matchedFiber, tostring(newChild), lanes)
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	--\[\[
	Warns if there is a duplicate or missing key
  \]\]
	local function warnOnInvalidKey(
		child: any,
		knownKeys: Set<string> | nil,
		returnFiber: Fiber
	): Set<string> | nil
		if __DEV__ then
			if child == nil or type(child) ~= "table" then
				return knownKeys
			end
			-- ROBLOX performance: avoid repeated indexing to $$typeof
			local childTypeof = child["$$typeof"]
			if childTypeof == REACT_ELEMENT_TYPE or childTypeof == REACT_PORTAL_TYPE then
				warnForMissingKey(child, returnFiber)
				local key = child.key
				if type(key) ~= "string" then
					-- break
				elseif knownKeys == nil then
					knownKeys = {};
					(knownKeys :: Set<string>)[key] = true
				elseif not (knownKeys :: Set<string>)[key] then
					(knownKeys :: Set<string>)[key] = true
				else
					console.error(
						"Encountered two children with the same key, `%s`. "
							.. "Keys should be unique so that components maintain their identity "
							.. "across updates. Non-unique keys may cause children to be "
							.. "duplicated and/or omitted — the behavior is unsupported and "
							.. "could change in a future version.",
						key
					)
				end
			elseif childTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = child._payload
					local init = child._init
					warnOnInvalidKey(init(payload), knownKeys, returnFiber)
				end
			end
		end
		return knownKeys
	end

	local function reconcileChildrenArray(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		newChildren: Array<any>,
		lanes: Lanes
	): Fiber | nil
		-- This algorithm can't optimize by searching from both ends since we
		-- don't have backpointers on fibers. I'm trying to see how far we can get
		-- with that model. If it ends up not being worth the tradeoffs, we can
		-- add it later.

		-- Even with a two ended optimization, we'd want to optimize for the case
		-- where there are few changes and brute force the comparison instead of
		-- going for the Map. It'd like to explore hitting that path first in
		-- forward-only mode and only go for the Map once we notice that we need
		-- lots of look ahead. This doesn't handle reversal as well as two ended
		-- search but that's unusual. Besides, for the two ended optimization to
		-- work on Iterables, we'd need to copy the whole set.

		-- In this first iteration, we'll just live with hitting the bad case
		-- (adding everything to a Map) in for every insert/move.

		-- If you change this code, also update reconcileChildrenIterator() which
		-- uses the same algorithm.

		if __DEV__ then
			-- First, validate keys.
			local knownKeys = nil
			for i, child in newChildren do
				knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
			end
		end

		local resultingFirstChild: Fiber | nil = nil
		local previousNewFiber: Fiber | nil = nil

		local oldFiber: Fiber | nil = currentFirstChild
		local lastPlacedIndex = 1
		local newIdx = 1
		local nextOldFiber: Fiber | nil = nil
		-- ROBLOX performance: don't re-evaluate length of newChildren on each iteration through the loop
		local newChildrenCount = #newChildren
		-- ROBLOX deviation: use while loop in place of modified for loop
		while oldFiber ~= nil and newIdx <= newChildrenCount do
			if oldFiber.index > newIdx then
				nextOldFiber = oldFiber
				oldFiber = nil
			else
				nextOldFiber = oldFiber.sibling
			end
			--\[\[
				ROBLOX DEVIATION: We pass newIdx to createChild to ensure that children are
				assigned a key, assuming the child is not an array itself. We only need to
				pass newIdx if the child is actually a React element. If the child is a
				string or number, a key is never assigned, so we do not pass newIdx as a key.
			\]\]
			local newFiber
			-- ROBLOX performance: avoid repeated indexing of newChildren to newIdx
			local newChildNewIdx = newChildren[newIdx]
			if
				newChildNewIdx ~= nil
				and type(newChildNewIdx) == "table"
				and newChildNewIdx["$$typeof"] ~= nil
			then
				newFiber =
					updateSlot(returnFiber, oldFiber, newChildNewIdx, lanes, newIdx)
			else
				newFiber = updateSlot(returnFiber, oldFiber, newChildNewIdx, lanes)
			end
			if newFiber == nil then
				-- TODO: This breaks on empty slots like nil children. That's
				-- unfortunate because it triggers the slow path all the time. We need
				-- a better way to communicate whether this was a miss or nil,
				-- boolean, undefined, etc.
				if oldFiber == nil then
					oldFiber = nextOldFiber
				end
				break
			end
			if shouldTrackSideEffects then
				-- ROBLOX FIXME Luau: needs type states to understand the continue above
				if oldFiber and (newFiber :: Fiber).alternate == nil then
					-- We matched the slot, but we didn't reuse the existing fiber, so we
					-- need to delete the existing child.
					-- ROBLOX FIXME Luau: needs type states to understand the break above
					deleteChild(returnFiber, oldFiber :: Fiber)
				end
			end
			lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
			if previousNewFiber == nil then
				-- TODO: Move out of the loop. This only happens for the first run.
				resultingFirstChild = newFiber
			else
				-- TODO: Defer siblings if we're not at the right index for this slot.
				-- I.e. if we had nil values before, then we want to defer this
				-- for each nil value. However, we also don't want to call updateSlot
				-- with the previous one.
				(previousNewFiber :: Fiber).sibling = newFiber
			end
			previousNewFiber = newFiber
			oldFiber = nextOldFiber
			-- deviation: increment manually since we're not using a modified for loop
			newIdx += 1
		end

		if newIdx > newChildrenCount then
			-- We've reached the end of the new children. We can delete the rest.
			deleteRemainingChildren(returnFiber, oldFiber)
			return resultingFirstChild
		end

		if oldFiber == nil then
			-- If we don't have any more existing children we can choose a fast path
			-- since the rest will all be insertions.
			-- deviation: use while loop in place of modified for loop
			while newIdx <= newChildrenCount do
				--\[\[
					ROBLOX DEVIATION: We pass newIdx to createChild to ensure that children are
					assigned a key, assuming the child is not an array itself. We only need to
					pass newIdx if the child is actually a React element. If the child is a
					string or number, a key is never assigned, so we do not pass newIdx as a key.
				\]\]
				local newFiber
				-- ROBLOX performance: avoid repeated indexing of newChildren to newIdx
				local newChildNewIdx = newChildren[newIdx]
				if
					newChildNewIdx ~= nil
					and type(newChildNewIdx) == "table"
					and newChildNewIdx["$$typeof"] ~= nil
				then
					newFiber = createChild(returnFiber, newChildNewIdx, lanes, newIdx)
				else
					newFiber = createChild(returnFiber, newChildNewIdx, lanes)
				end
				if newFiber == nil then
					-- ROBLOX deviation: increment manually since we're not using a modified for loop
					newIdx += 1
					continue
				end
				-- ROBLOX FIXME Luau: needs type state to understand the continue above
				lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					-- TODO: Move out of the loop. This only happens for the first run.
					resultingFirstChild = newFiber
				else
					(previousNewFiber :: Fiber).sibling = newFiber
				end
				previousNewFiber = newFiber
				-- deviation: increment manually since we're not using a modified for loop
				newIdx += 1
			end
			return resultingFirstChild
		end

		-- Add all children to a key map for quick lookups.
		-- ROBLOX FIXME Luau: need type state to understand the if/return above
		local existingChildren = mapRemainingChildren(returnFiber, oldFiber :: Fiber)

		-- Keep scanning and use the map to restore deleted items as moves.
		-- ROBLOX deviation: use while loop in place of modified for loop
		while newIdx <= newChildrenCount do
			local newFiber = updateFromMap(
				existingChildren,
				returnFiber,
				newIdx,
				newChildren[newIdx],
				lanes,
				-- ROBLOX deviation: pass newIdx to be used as the key of the element
				newIdx
			)
			if newFiber ~= nil then
				if shouldTrackSideEffects then
					if newFiber.alternate ~= nil then
						-- The new fiber is a work in progress, but if there exists a
						-- current, that means that we reused the fiber. We need to delete
						-- it from the child list so that we don't add it to the deletion
						-- list.
						existingChildren[if newFiber.key == nil
							then newIdx
							else newFiber.key] =
							nil
					end
				end
				lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					resultingFirstChild = newFiber
				else
					(previousNewFiber :: Fiber).sibling = newFiber
				end
				previousNewFiber = newFiber
			end
			-- deviation: increment manually since we're not using a modified for loop
			newIdx += 1
		end

		if shouldTrackSideEffects then
			-- Any existing children that weren't consumed above were deleted. We need
			-- to add them to the deletion list.
			for _, child in existingChildren do
				deleteChild(returnFiber, child)
			end
		end

		return resultingFirstChild
	end

	-- ROBLOX TODO: LUAFDN-254
	local function reconcileChildrenIterator(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		-- ROBLOX TODO: figure out our Iterable<> interface
		--   newChildrenIterable: Iterable<*>,
		newChildrenIterable: any,
		lanes: Lanes,
		-- ROBLOX performance? pass in iteratorFn to avoid two calls to getIteratorFn
		iteratorFn: (...any) -> any
	): Fiber | nil
		-- This is the same implementation as reconcileChildrenArray(),
		-- but using the iterator instead.

		-- local iteratorFn = getIteratorFn(newChildrenIterable)
		-- ROBLOX performance? eliminate 'nice to have' strcmp in hot path
		-- invariant(
		-- 	typeof(iteratorFn) == "function",
		-- 	"An object is not an iterable. This error is likely caused by a bug in "
		-- 		.. "React. Please file an issue."
		-- )

		if __DEV__ then
			-- We don't support rendering Generators because it's a mutation.
			-- See https://github.com/facebook/react/issues/12995
			-- ROBLOX deviation: Lua doesn't have built-in generators
			-- if
			--   typeof(Symbol) == 'function' and
			--   -- $FlowFixMe Flow doesn't know about toStringTag
			--   newChildrenIterable[Symbol.toStringTag] == 'Generator'
			-- then
			--   if not didWarnAboutGenerators then
			--     console.error(
			--       'Using Generators as children is unsupported and will likely yield ' ..
			--         'unexpected results because enumerating a generator mutates it. ' ..
			--         'You may convert it to an array with `Array.from()` or the ' ..
			--         '`[...spread]` operator before rendering. Keep in mind ' ..
			--         'you might need to polyfill these features for older browsers.'
			--     )
			--   end
			--   didWarnAboutGenerators = true
			-- end

			-- Warn about using Maps as children
			if newChildrenIterable.entries == iteratorFn then
				if not didWarnAboutMaps then
					console.error(
						"Using Maps as children is not supported. "
							.. "Use an array of keyed ReactElements instead."
					)
				end
				didWarnAboutMaps = true
			end

			-- First, validate keys.
			-- We'll get a different iterator later for the main pass.
			local newChildren = iteratorFn(newChildrenIterable)
			if newChildren then
				local knownKeys = nil
				local step = newChildren.next()
				while not step.done do
					step = newChildren.next()
					local child = step.value
					knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
				end
			end
		end

		local newChildren = iteratorFn(newChildrenIterable)
		-- ROBLOX performance? eliminate 'nice to have' cmp in hot path
		-- invariant(newChildren ~= nil, "An iterable object provided no iterator.")

		local resultingFirstChild: Fiber | nil = nil
		local previousNewFiber: Fiber = nil

		local oldFiber = currentFirstChild
		local lastPlacedIndex = 1
		local newIdx = 1
		local nextOldFiber: Fiber | nil = nil

		local step = newChildren.next()
		while oldFiber ~= nil and not step.done do
			if oldFiber.index > newIdx then
				nextOldFiber = oldFiber
				oldFiber = nil
			else
				nextOldFiber = oldFiber.sibling
			end
			local newFiber =
				updateSlot(returnFiber, oldFiber, step.value, lanes, step.key)
			if newFiber == nil then
				-- TODO: This breaks on empty slots like nil children. That's
				-- unfortunate because it triggers the slow path all the time. We need
				-- a better way to communicate whether this was a miss or nil,
				-- boolean, undefined, etc.
				if oldFiber == nil then
					oldFiber = nextOldFiber
				end
				break
			end
			if shouldTrackSideEffects then
				-- ROBLOX FIXME Luau: need type states to understand the break above
				if oldFiber and (newFiber :: Fiber).alternate == nil then
					-- We matched the slot, but we didn't reuse the existing fiber, so we
					-- need to delete the existing child.
					deleteChild(returnFiber, oldFiber)
				end
			end
			lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
			if previousNewFiber == nil then
				-- TODO: Move out of the loop. This only happens for the first run.
				resultingFirstChild = newFiber
			else
				-- TODO: Defer siblings if we're not at the right index for this slot.
				-- I.e. if we had nil values before, then we want to defer this
				-- for each nil value. However, we also don't want to call updateSlot
				-- with the previous one.
				previousNewFiber.sibling = newFiber :: Fiber
			end
			previousNewFiber = newFiber :: Fiber
			oldFiber = nextOldFiber

			newIdx += 1
			step = newChildren.next()
		end

		if step.done then
			-- We've reached the end of the new children. We can delete the rest.
			deleteRemainingChildren(returnFiber, oldFiber)
			return resultingFirstChild
		end

		if oldFiber == nil then
			-- If we don't have any more existing children we can choose a fast path
			-- since the rest will all be insertions.
			while not step.done do
				local newFiber = createChild(returnFiber, step.value, lanes, step.key)
				if newFiber == nil then
					newIdx += 1
					step = newChildren.next()
					continue
				end
				-- ROBLOX FIXME Luau: need type states to understand the continue above
				lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					-- TODO: Move out of the loop. This only happens for the first run.
					resultingFirstChild = newFiber
				else
					previousNewFiber.sibling = newFiber
				end
				previousNewFiber = newFiber :: Fiber

				newIdx += 1
				step = newChildren.next()
			end
			return resultingFirstChild
		end

		-- Add all children to a key map for quick lookups.
		-- ROBLOX performance? defer initialization into the loop. extra cmp per loop iter, but avoid call if no loop iter
		local existingChildren

		-- Keep scanning and use the map to restore deleted items as moves.
		while not step.done do
			if not existingChildren then
				-- ROBLOX FIXME LUau: need type states to understand the guard+return above
				existingChildren = mapRemainingChildren(returnFiber, oldFiber :: Fiber)
			end
			local newFiber = updateFromMap(
				existingChildren,
				returnFiber,
				newIdx,
				step.value,
				lanes,
				step.key
			)
			if newFiber ~= nil then
				if shouldTrackSideEffects then
					if newFiber.alternate ~= nil then
						-- The new fiber is a work in progress, but if there exists a
						-- current, that means that we reused the fiber. We need to delete
						-- it from the child list so that we don't add it to the deletion
						-- list.
						if newFiber.key == nil then
							existingChildren[newIdx] = nil
						else
							existingChildren[newFiber.key] = nil
						end
					end
				end
				lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					resultingFirstChild = newFiber
				else
					previousNewFiber.sibling = newFiber
				end
				previousNewFiber = newFiber
			end

			newIdx += 1
			step = newChildren.next()
		end

		if shouldTrackSideEffects then
			-- Any existing children that weren't consumed above were deleted. We need
			-- to add them to the deletion list.
			for _, child in existingChildren do
				deleteChild(returnFiber, child)
			end
		end

		return resultingFirstChild
	end

	local function reconcileSingleTextNode(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		textContent: string,
		lanes: Lanes
	): Fiber
		-- There's no need to check for keys on text nodes since we don't have a
		-- way to define them.
		-- ROBLOX FIXME: Luau narrowing issue
		if currentFirstChild ~= nil and (currentFirstChild :: Fiber).tag == HostText then
			-- We already have an existing node so let's just update it and delete
			-- the rest.
			deleteRemainingChildren(returnFiber, (currentFirstChild :: Fiber).sibling)
			local existing = useFiber(currentFirstChild :: Fiber, textContent)
			existing.return_ = returnFiber
			return existing
		end
		-- The existing first child is not a text node so we need to create one
		-- and delete the existing ones.
		deleteRemainingChildren(returnFiber, currentFirstChild)
		local created = createFiberFromText(textContent, returnFiber.mode, lanes)
		created.return_ = returnFiber
		return created
	end

	local function reconcileSingleElement(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		element: ReactElement,
		lanes: Lanes
	): Fiber
		local key = element.key
		local child = currentFirstChild
		while child ~= nil do
			-- TODO: If key == nil and child.key == nil, then this only applies to
			-- the first item in the list.
			if child.key == key then
				if child.tag == Fragment then
					if element.type == REACT_FRAGMENT_TYPE then
						deleteRemainingChildren(returnFiber, child.sibling)
						local existing = useFiber(child, element.props.children)
						existing.return_ = returnFiber
						if __DEV__ then
							existing._debugSource = element._source
							existing._debugOwner = element._owner
						end
						return existing
					end
					-- ROBLOX performance: avoid always-false cmp in hot path
					-- elseif child.tag == Block then
					-- 	unimplemented("reconcileSingleElement: Block")
					-- if (enableBlocksAPI) {
					--   let type = element.type;
					--   if (type.$$typeof === REACT_LAZY_TYPE) {
					--     type = resolveLazyType(type);
					--   }
					--   if (type.$$typeof === REACT_BLOCK_TYPE) {
					--     // The new Block might not be initialized yet. We need to initialize
					--     // it in case initializing it turns out it would match.
					--     if (
					--       ((type: any): BlockComponent<any, any>)._render ===
					--       (child.type: BlockComponent<any, any>)._render
					--     ) {
					--       deleteRemainingChildren(returnFiber, child.sibling);
					--       const existing = useFiber(child, element.props);
					--       existing.type = type;
					--       existing.return = returnFiber;
					--       if (__DEV__) {
					--         existing._debugSource = element._source;
					--         existing._debugOwner = element._owner;
					--       }
					--       return existing;
					--     }
					--   }
					-- }
					-- // We intentionally fallthrough here if enableBlocksAPI is not on.
					-- // eslint-disable-next-lined no-fallthrough
				else
					if
						child.elementType == element.type
						-- ROBLOX performance: avoid always-false cmp, hot reloading isn't enabled in Roblox yet
						-- Keep this check inline so it only runs on the false path:
						-- or (
						-- 	__DEV__
						-- 	and isCompatibleFamilyForHotReloading(child, element)
						-- )
					then
						deleteRemainingChildren(returnFiber, child.sibling)
						local existing = useFiber(child, element.props)
						existing.ref = coerceRef(returnFiber, child, element)
						existing.return_ = returnFiber
						if __DEV__ then
							existing._debugSource = element._source
							existing._debugOwner = element._owner
						end
						return existing
					end
				end
				-- Didn't match.
				deleteRemainingChildren(returnFiber, child)
				break
			else
				deleteChild(returnFiber, child)
			end
			child = child.sibling
		end

		if element.type == REACT_FRAGMENT_TYPE then
			local created = createFiberFromFragment(
				element.props.children,
				returnFiber.mode,
				lanes,
				-- ROBLOX FIXME Luau: needs normalization: TypeError: Type '(number | string)?' could not be converted into 'string?'
				element.key :: string
			)
			created.return_ = returnFiber
			return created
		else
			local created = createFiberFromElement(element, returnFiber.mode, lanes)
			created.ref = coerceRef(returnFiber, currentFirstChild, element)
			created.return_ = returnFiber
			return created
		end
	end

	local function reconcileSinglePortal(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		portal: ReactPortal,
		lanes: Lanes
	): Fiber
		local key = portal.key
		local child = currentFirstChild
		while child ~= nil do
			-- TODO: If key == nil and child.key == nil, then this only applies to
			-- the first item in the list.
			if child.key == key then
				if
					child.tag == HostPortal
					and child.stateNode.containerInfo == portal.containerInfo
					and child.stateNode.implementation == portal.implementation
				then
					deleteRemainingChildren(returnFiber, child.sibling)
					local existing = useFiber(child, portal.children or {})
					existing.return_ = returnFiber
					return existing
				else
					deleteRemainingChildren(returnFiber, child)
					break
				end
			else
				deleteChild(returnFiber, child)
			end
			child = child.sibling
		end

		local created = createFiberFromPortal(portal, returnFiber.mode, lanes)
		created.return_ = returnFiber
		return created
	end

	-- This API will tag the children with the side-effect of the reconciliation
	-- itself. They will be added to the side-effect list as we pass through the
	-- children and the parent.
	local function reconcileChildFibers(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		newChild: any,
		lanes: Lanes
	): Fiber | nil
		-- This function is not recursive.
		-- If the top level item is an array, we treat it as a set of children,
		-- not as a fragment. Nested arrays on the other hand will be treated as
		-- fragment nodes. Recursion happens at the normal flow.

		-- ROBLOX performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		-- Handle top level unkeyed fragments as if they were arrays.
		-- This leads to an ambiguity between <>{[...]}</> and <>...</>.
		-- We treat the ambiguous cases above the same.
		local isUnkeyedTopLevelFragment = newChild ~= nil
			and typeOfNewChild == "table"
			and newChild.type == REACT_FRAGMENT_TYPE
			and newChild.key == nil
		if isUnkeyedTopLevelFragment then
			newChild = newChild.props.children
			typeOfNewChild = type(newChild)
		end
		local newChildIsArray = isArray(newChild)

		-- Handle object types
		-- ROBLOX deviation: upstream checks for `object`, but we need to manually exclude array
		local isObject = newChild ~= nil
			and typeOfNewChild == "table"
			and not newChildIsArray

		if isObject then
			-- ROBLOX performance: avoid repeated indexing of $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				return placeSingleChild(
					reconcileSingleElement(
						returnFiber,
						currentFirstChild,
						newChild,
						lanes
					)
				)
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				return placeSingleChild(
					reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)
				)
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- TODO: This function is supposed to be non-recursive.
					return reconcileChildFibers(
						returnFiber,
						currentFirstChild,
						init(payload),
						lanes
					)
				end
			end
		-- ROBLOX performance: make these next blocks `elseif`, as they're mutually exclusive to `isObject` above
		elseif newChildIsArray then
			return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
		elseif typeOfNewChild == "string" or typeOfNewChild == "number" then
			return placeSingleChild(
				reconcileSingleTextNode(
					returnFiber,
					currentFirstChild,
					tostring(newChild),
					lanes
				)
			)
		end

		-- ROBLOX performance? only call getIteratorFn once, pass in the value
		local newChildIteratorFn = getIteratorFn(newChild)
		if newChildIteratorFn then
			return reconcileChildrenIterator(
				returnFiber,
				currentFirstChild,
				newChild,
				lanes,
				newChildIteratorFn
			)
		end

		-- ROBLOX performance? eliminate a cmp in hot path for something unimplemented anyway
		-- if isObject then
		-- 	unimplemented("throwOnInvalidObjectType")
		-- 	-- throwOnInvalidObjectType(returnFiber, newChild)
		-- end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end
		if newChild == nil and not isUnkeyedTopLevelFragment then
			-- deviation: need a flag here to simulate switch/case fallthrough + break
			local shouldFallThrough = false
			-- If the new child is undefined, and the return fiber is a composite
			-- component, throw an error. If Fiber return types are disabled,
			-- we already threw above.
			-- ROBLOX deviation: With coercion of no returns to `nil`, it
			-- if returnFiber.tag == ClassComponent then
			--   if __DEV__ then
			-- isn't necessary to special case this scenario
			-- local instance = returnFiber.stateNode
			-- if instance.render._isMockFunction then
			--   -- We allow auto-mocks to proceed as if they're returning nil.
			--   shouldFallThrough = true
			-- end
			--   end
			-- end
			-- Intentionally fall through to the next case, which handles both
			-- functions and classes
			-- eslint-disable-next-lined no-fallthrough
			if
				shouldFallThrough
				and (
					returnFiber.tag == ClassComponent
					or returnFiber.tag == FunctionComponent
					or returnFiber.tag == ForwardRef
					or returnFiber.tag == SimpleMemoComponent
				)
			then
				invariant(
					false,
					"%s(...): Nothing was returned from render. This usually means a "
						.. "return statement is missing. Or, to render nothing, "
						.. "return nil.",
					getComponentName(returnFiber.type) or "Component"
				)
			end
		end

		-- Remaining cases are all treated as empty.
		return deleteRemainingChildren(returnFiber, currentFirstChild)
	end

	return reconcileChildFibers
end

exports.reconcileChildFibers = ChildReconciler(true)
exports.mountChildFibers = ChildReconciler(false)

exports.cloneChildFibers = function(current: Fiber | nil, workInProgress: Fiber)
	-- ROBLOX deviation: This message isn't tested upstream, remove for hot path optimization
	-- invariant(
	-- 	current == nil or workInProgress.child == (current :: Fiber).child,
	-- 	"Resuming work not yet implemented."
	-- )

	if workInProgress.child == nil then
		return
	end

	local currentChild = workInProgress.child :: Fiber
	local newChild = createWorkInProgress(currentChild, currentChild.pendingProps)
	workInProgress.child = newChild

	newChild.return_ = workInProgress
	while currentChild.sibling ~= nil do
		currentChild = currentChild.sibling
		newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps)
		-- ROBLOX FIXME Luau: luau doesn't track/narrow the direct assignment on the line above
		newChild = newChild.sibling :: Fiber
		newChild.return_ = workInProgress
	end
	newChild.sibling = nil
end

-- Reset a workInProgress child set to prepare it for a second pass.
exports.resetChildFibers = function(workInProgress: Fiber, lanes: Lanes): ()
	local child = workInProgress.child
	while child ~= nil do
		resetWorkInProgress(child, lanes)
		child = child.sibling
	end
end

return exports ]]
cX.Children._cdc75000bee274e5c6de3eb923d5ec15=c3
local c4

local c5={ClassName="ModuleScript",Children={},Properties={}}
c5.Name="ReactCurrentFiber"
c5.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/b0cb137bcbd3a11d8eff3c2229cd6b8379d29785/packages/react-reconciler/src/ReactCurrentFiber.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFiberComponentStack = require(script.Parent.ReactFiberComponentStack)
local getStackByFiberInDevAndProd = ReactFiberComponentStack.getStackByFiberInDevAndProd
local getComponentName = require(Packages.Shared).getComponentName

local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

-- deviation: Pre-declare type of exports, including values we'll initialize
type Exports = {
	current: Fiber | nil,
	isRendering: boolean,
	-- remaining functions declare their own types
	[string]: any,
}

local exports: Exports = {
	current = nil,
	isRendering = false,
}

exports.getCurrentFiberOwnerNameInDevOrNull = function(): string?
	if __DEV__ then
		if exports.current == nil then
			return nil
		end
		-- ROBLOX FIXME Luau: Luau doesn't understand guard above
		local owner = (exports.current :: Fiber)._debugOwner
		if owner then
			return getComponentName(owner.type)
		end
	end
	return nil
end

local function getCurrentFiberStackInDev(): string
	if __DEV__ then
		if exports.current == nil then
			return ""
		end
		-- Safe because if current fiber exists, we are reconciling,
		-- and it is guaranteed to be the work-in-progress version.
		-- ROBLOX FIXME Luau: Luau doesn't understand guard above
		return getStackByFiberInDevAndProd(exports.current :: Fiber)
	end
	return ""
end

exports.resetCurrentFiber = function(): ()
	if __DEV__ then
		-- ROBLOX FIXME Luau: Expected type table, got 'ReactDebugCurrentFrame | { setExtraStackFrame: () -> () }' instead
		(ReactDebugCurrentFrame :: any).getCurrentStack = nil
		exports.current = nil
		exports.isRendering = false
	end
end

exports.setCurrentFiber = function(fiber: Fiber): ()
	if __DEV__ then
		-- ROBLOX FIXME Luau: Expected type table, got 'ReactDebugCurrentFrame | { setExtraStackFrame: () -> () }' instead
		(ReactDebugCurrentFrame :: any).getCurrentStack = getCurrentFiberStackInDev
		exports.current = fiber
		exports.isRendering = false
	end
end

exports.setIsRendering = function(rendering: boolean): ()
	if __DEV__ then
		exports.isRendering = rendering
	end
end

exports.getIsRendering = function(): boolean
	if __DEV__ then
		return exports.isRendering
	end
	return false
end

return exports ]]
cX.Children._e4ca5bc99642512790586bc4c2e34757=c5
local c6

local c7={ClassName="ModuleScript",Children={},Properties={}}
c7.Name="ReactFiber.new"
c7.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiber.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local __DEV__ = _G.__DEV__
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Array = LuauPolyfill.Array
local inspect = LuauPolyfill.util.inspect

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
-- ROBLOX deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactTypes.ReactElement<any, any>
type ReactFragment = ReactTypes.ReactFragment
type ReactPortal = ReactTypes.ReactPortal
type ReactFundamentalComponent<T, U> = ReactTypes.ReactFundamentalComponent<T, U>
type ReactScope = ReactTypes.ReactScope
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
export type Fiber = ReactInternalTypes.Fiber

-- ROBLOX deviation: Allow number keys for sparse arrays
type RoactStableKey = ReactInternalTypes.RoactStableKey
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag
local ReactWorkTags = require(script.Parent.ReactWorkTags)
type WorkTag = ReactWorkTags.WorkTag
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
type TypeOfMode = ReactTypeOfMode.TypeOfMode
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenProps = ReactFiberOffscreenComponent.OffscreenProps

local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local Placement = ReactFiberFlags.Placement
local StaticMask = ReactFiberFlags.StaticMask
local ConcurrentRoot = ReactRootTags.ConcurrentRoot
local BlockingRoot = ReactRootTags.BlockingRoot
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local DehydratedFragment = ReactWorkTags.DehydratedFragment
local FunctionComponent = ReactWorkTags.FunctionComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local getComponentName = require(Packages.Shared).getComponentName

local ReactFiberDevToolsHook = require(script.Parent["ReactFiberDevToolsHook.new"])
local isDevToolsPresent = ReactFiberDevToolsHook.isDevToolsPresent
local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
local resolveClassForHotReloading = ReactFiberHotReloading.resolveClassForHotReloading
local resolveFunctionForHotReloading =
	ReactFiberHotReloading.resolveFunctionForHotReloading
local resolveForwardRefForHotReloading =
	ReactFiberHotReloading.resolveForwardRefForHotReloading
local NoLanes = ReactFiberLane.NoLanes
local NoMode = ReactTypeOfMode.NoMode
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local ProfileMode = ReactTypeOfMode.ProfileMode
local StrictMode = ReactTypeOfMode.StrictMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_DEBUG_TRACING_MODE_TYPE = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
-- local REACT_FUNDAMENTAL_TYPE = ReactSymbols.REACT_FUNDAMENTAL_TYPE
-- local REACT_SCOPE_TYPE = ReactSymbols.REACT_SCOPE_TYPE
local REACT_OFFSCREEN_TYPE = ReactSymbols.REACT_OFFSCREEN_TYPE
local REACT_LEGACY_HIDDEN_TYPE = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE

-- deviation: We probably don't have to worry about this scenario, since we use
-- simple tables as maps

-- local hasBadMapPolyfill

-- if __DEV__ then
-- 	hasBadMapPolyfill = false
-- 	try {
-- 		local nonExtensibleObject = Object.preventExtensions({})
-- 		--\[\[ eslint-disable no-new \]\]
-- 		new Map(\[\[nonExtensibleObject, nil\]\])
-- 		new Set([nonExtensibleObject])
-- 		--\[\[ eslint-enable no-new \]\]
-- 	} catch (e)
-- 		-- TODO: Consider warning about bad polyfills
-- 		hasBadMapPolyfill = true
-- 	end
-- end

local createFiberFromScope, createFiberFromProfiler, createFiberFromFragment, createFiberFromFundamental, createFiberFromSuspense, createFiberFromOffscreen, createFiberFromLegacyHidden, createFiberFromSuspenseList

local debugCounter = 1

-- ROBLOX deviation START: inline this into its only caller to save hot path performance
-- function FiberNode(
-- 	tag: WorkTag,
-- 	pendingProps: any,
-- 	key: RoactStableKey?,
-- 	mode: TypeOfMode
-- ): Fiber
-- 	return {} :: any
-- end
-- ROBLOX deviation END

-- This is a constructor function, rather than a POJO constructor, still
-- please ensure we do the following:
-- 1) Nobody should add any instance methods on this. Instance methods can be
--    more difficult to predict when they get optimized and they are almost
--    never inlined properly in static compilers.
-- 2) Nobody should rely on `instanceof Fiber` for type testing. We should
--    always know when it is a fiber.
-- 3) We might want to experiment with using numeric keys since they are easier
--    to optimize in a non-JIT environment.
-- 4) We can easily go from a constructor to a createFiber object literal if that
--    is faster.
-- 5) It should be easy to port this to a C struct and keep a C implementation
--    compatible.
-- ROBLOX deviation START: add elementType, type, and lanes arguments so the table is created in a one-shot to avoid rehashing
local function createFiber(
	tag: WorkTag,
	pendingProps: any,
	key: RoactStableKey?,
	mode: TypeOfMode,
	elementType: any?,
	type_: any?,
	stateNode: any?,
	lanes: Lanes?
): Fiber
	-- $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
	-- ROBLOX deviation START: inline FiberNode(), do the table as a one-shot and avoid initializing nil fields for hot-path performance
	local node: Fiber = {
		-- Instance
		tag = tag,
		key = key,
		elementType = elementType,
		type = type_,
		stateNode = stateNode,

		-- Fiber
		-- node.return_ = nil
		-- node.child = nil
		-- node.sibling = nil
		index = 1,

		-- node.ref = nil

		pendingProps = pendingProps,
		-- memoizedProps = nil
		-- updateQueue = nil
		-- memoizedState = nil
		-- dependencies = nil

		mode = mode,

		-- Effects
		flags = NoFlags,
		subtreeFlags = NoFlags,
		-- deletions = nil

		lanes = if lanes then lanes else NoLanes,
		childLanes = NoLanes,

		-- alternate = nil
	} :: any

	if enableProfilerTimer then
		-- deviation: Unlikely that we have this same performance problem
		--\[\[
			-- Note: The following is done to avoid a v8 performance cliff.
			--
			-- Initializing the fields below to smis and later updating them with
			-- double values will cause Fibers to end up having separate shapes.
			-- This behavior/bug has something to do with Object.preventExtension().
			-- Fortunately this only impacts DEV builds.
			-- Unfortunately it makes React unusably slow for some applications.
			-- To work around this, initialize the fields below with doubles.
			--
			-- Learn more about this here:
			-- https://github.com/facebook/react/issues/14365
			-- https://bugs.chromium.org/p/v8/issues/detail?id=8538
			node.actualDuration = Number.NaN
			node.actualStartTime = Number.NaN
			node.selfBaseDuration = Number.NaN
			node.treeBaseDuration = Number.NaN

			-- It's okay to replace the initial doubles with smis after initialization.
			-- This won't trigger the performance cliff mentioned above,
			-- and it simplifies other profiler code (including DevTools).
		\]\]
		node.actualDuration = 0
		node.actualStartTime = -1
		node.selfBaseDuration = 0
		node.treeBaseDuration = 0
	end

	if __DEV__ then
		-- This isn't directly used but is handy for debugging internals:
		node._debugID = debugCounter
		debugCounter += 1
		node._debugSource = nil
		node._debugOwner = nil
		node._debugNeedsRemount = false
		node._debugHookTypes = nil
		-- deviation: We can just make sure this is always valid
		-- if not hasBadMapPolyfill and typeof(Object.preventExtensions) == "function"

		-- deviation: FIXME - we can't actually distinguish between 'nil' and
		-- absent, so if we do this here, we won't be able to initialize fields
		-- that start out as 'nil'
		-- Object.preventExtensions(node)

		-- end
	end
	return node
	-- ROBLOX deviation END
end

-- ROBLOX deviation START: we inline all uses of this function for performance in hot path
function _shouldConstruct(Component)
	-- deviation: With Lua metatables, members of the "prototype" can be
	-- accessed directly. so we don't need to check for a prototype separately
	return type(Component) ~= "function" and not not Component.isReactComponent
end
-- ROBLOX deviation END

local function isSimpleFunctionComponent(type_: any)
	-- ROBLOX deviation START: inline shouldConstruct logic for hot path performance
	return type(type_) == "function"
	-- deviation: function components don't support this anyway
	-- type.defaultProps == undefined
	-- ROBLOX deviation END: inline shouldConstruct logic for hot path performance
end

local function resolveLazyComponentTag(Component: any): WorkTag
	local typeofComponent = typeof(Component)
	if typeofComponent == "function" then
		return FunctionComponent
	end

	if typeofComponent == "table" then
		if Component.isReactComponent then
			return ClassComponent
		end
		local __typeof = Component["$$typeof"]
		if __typeof == REACT_FORWARD_REF_TYPE then
			return ForwardRef
		end
		if __typeof == REACT_MEMO_TYPE then
			return MemoComponent
		end
	end

	return IndeterminateComponent
end

-- This is used to create an alternate fiber to do work on.
local function createWorkInProgress(current: Fiber, pendingProps: any): Fiber
	-- ROBLOX FIXME Luau: Luau doesn't understand if nil then create pattern
	local workInProgress = current.alternate :: Fiber
	if workInProgress == nil then
		-- We use a double buffering pooling technique because we know that we'll
		-- only ever need at most two versions of a tree. We pool the "other" unused
		-- node that we're free to reuse. This is lazily created to avoid allocating
		-- extra objects for things that are never updated. It also allow us to
		-- reclaim the extra memory if needed.
		workInProgress = createFiber(
			current.tag,
			pendingProps,
			current.key,
			current.mode,
			current.elementType,
			current.type,
			current.stateNode
		)

		if __DEV__ then
			-- DEV-only fields
			workInProgress._debugID = current._debugID
			workInProgress._debugSource = current._debugSource
			workInProgress._debugOwner = current._debugOwner
			workInProgress._debugHookTypes = current._debugHookTypes
		end

		workInProgress.alternate = current
		current.alternate = workInProgress
	else
		workInProgress.pendingProps = pendingProps
		-- Needed because Blocks store data on type.
		workInProgress.type = current.type

		-- We already have an alternate.
		-- Reset the effect tag.
		workInProgress.flags = NoFlags

		-- The current effects are no longer valid
		workInProgress.subtreeFlags = NoFlags
		workInProgress.deletions = nil

		if enableProfilerTimer then
			-- We intentionally reset, rather than copy, actualDuration & actualStartTime.
			-- This prevents time from endlessly accumulating in new commits.
			-- This has the downside of resetting values for different priority renders,
			-- But works for yielding (the common case) and should support resuming.
			workInProgress.actualDuration = 0
			workInProgress.actualStartTime = -1
		end
	end

	-- Reset all effects except static ones.
	-- Static effects are not specific to a render.
	workInProgress.flags = bit32.band(current.flags, StaticMask)
	workInProgress.childLanes = current.childLanes
	workInProgress.lanes = current.lanes

	workInProgress.child = current.child
	workInProgress.memoizedProps = current.memoizedProps
	workInProgress.memoizedState = current.memoizedState
	workInProgress.updateQueue = current.updateQueue

	-- Clone the dependencies object. This is mutated during the render phase, so
	-- it cannot be shared with the current fiber.
	local currentDependencies = current.dependencies
	if currentDependencies == nil then
		workInProgress.dependencies = nil
	else
		workInProgress.dependencies = {
			lanes = currentDependencies.lanes,
			firstContext = currentDependencies.firstContext,
		}
	end

	-- These will be overridden during the parent's reconciliation
	workInProgress.sibling = current.sibling
	workInProgress.index = current.index
	workInProgress.ref = current.ref

	if enableProfilerTimer then
		workInProgress.selfBaseDuration = current.selfBaseDuration
		workInProgress.treeBaseDuration = current.treeBaseDuration
	end

	if __DEV__ then
		workInProgress._debugNeedsRemount = current._debugNeedsRemount
		if
			workInProgress.tag == IndeterminateComponent
			or workInProgress.tag == FunctionComponent
			or workInProgress.tag == SimpleMemoComponent
		then
			workInProgress.type = resolveFunctionForHotReloading(current.type)
		elseif workInProgress.tag == ClassComponent then
			workInProgress.type = resolveClassForHotReloading(current.type)
		elseif workInProgress.tag == ForwardRef then
			workInProgress.type = resolveForwardRefForHotReloading(current.type)
		end
	end

	return workInProgress
end

-- Used to reuse a Fiber for a second pass.
local function resetWorkInProgress(workInProgress: Fiber, renderLanes: Lanes)
	-- This resets the Fiber to what createFiber or createWorkInProgress would
	-- have set the values to before during the first pass. Ideally this wouldn't
	-- be necessary but unfortunately many code paths reads from the workInProgress
	-- when they should be reading from current and writing to workInProgress.

	-- We assume pendingProps, index, key, ref, return are still untouched to
	-- avoid doing another reconciliation.

	-- Reset the effect tag but keep any Placement tags, since that's something
	-- that child fiber is setting, not the reconciliation.
	workInProgress.flags =
		bit32.band(workInProgress.flags, bit32.bor(StaticMask, Placement))

	-- The effects are no longer valid

	local current = workInProgress.alternate
	if current == nil then
		-- Reset to createFiber's initial values.
		workInProgress.childLanes = NoLanes
		workInProgress.lanes = renderLanes

		workInProgress.child = nil
		workInProgress.subtreeFlags = NoFlags
		workInProgress.memoizedProps = nil
		workInProgress.memoizedState = nil
		workInProgress.updateQueue = nil

		workInProgress.dependencies = nil

		workInProgress.stateNode = nil

		if enableProfilerTimer then
			-- Note: We don't reset the actualTime counts. It's useful to accumulate
			-- actual time across multiple render passes.
			workInProgress.selfBaseDuration = 0
			workInProgress.treeBaseDuration = 0
		end
	else
		-- Reset to the cloned values that createWorkInProgress would've.
		workInProgress.childLanes = current.childLanes
		workInProgress.lanes = current.lanes

		workInProgress.child = current.child
		workInProgress.subtreeFlags = current.subtreeFlags
		workInProgress.deletions = nil
		workInProgress.memoizedProps = current.memoizedProps
		workInProgress.memoizedState = current.memoizedState
		workInProgress.updateQueue = current.updateQueue
		-- Needed because Blocks store data on type.
		workInProgress.type = current.type

		-- Clone the dependencies object. This is mutated during the render phase, so
		-- it cannot be shared with the current fiber.
		local currentDependencies = current.dependencies
		if currentDependencies == nil then
			workInProgress.dependencies = nil
		else
			workInProgress.dependencies = {
				lanes = currentDependencies.lanes,
				firstContext = currentDependencies.firstContext,
			}
		end

		if enableProfilerTimer then
			-- Note: We don't reset the actualTime counts. It's useful to accumulate
			-- actual time across multiple render passes.
			workInProgress.selfBaseDuration = current.selfBaseDuration
			workInProgress.treeBaseDuration = current.treeBaseDuration
		end
	end

	return workInProgress
end

local function createHostRootFiber(tag: RootTag): Fiber
	local mode
	if tag == ConcurrentRoot then
		mode = bit32.bor(ConcurrentMode, BlockingMode, StrictMode)
	elseif tag == BlockingRoot then
		mode = bit32.bor(BlockingMode, StrictMode)
	else
		mode = NoMode
	end

	-- ROBLOX deviation: We use a function for isDevtoolsPresent to handle the hook being changed at runtime
	if enableProfilerTimer and isDevToolsPresent() then
		-- Always collect profile timings when DevTools are present.
		-- This enables DevTools to start capturing timing at any point–
		-- Without some nodes in the tree having empty base times.
		mode = bit32.bor(mode, ProfileMode)
	end

	return createFiber(HostRoot, nil, nil, mode)
end

local function createFiberFromTypeAndProps(
	type_: any, -- React$ElementType
	key: string?,
	pendingProps: any,
	owner: nil | Fiber,
	mode: TypeOfMode,
	lanes: Lanes
): Fiber
	local fiberTag = IndeterminateComponent
	-- The resolved type is set if we know what the final type will be. I.e. it's not lazy.
	-- deviation: FIXME: Account for deviated class v. function component type logic
	local resolvedType = type_
	local typeOfType_ = type(type_)
	-- deviation: since our class components aren't functions, we have to look
	-- for them more explicitly (inlines logic from `shouldConstruct`)
	if typeOfType_ == "function" then
		if __DEV__ then
			resolvedType = resolveFunctionForHotReloading(resolvedType)
		end
	elseif typeOfType_ == "table" and not not type_.isReactComponent then
		fiberTag = ClassComponent
		if __DEV__ then
			resolvedType = resolveClassForHotReloading(resolvedType)
		end
	elseif typeOfType_ == "string" then
		fiberTag = HostComponent
	else
		if type_ == REACT_FRAGMENT_TYPE then
			return createFiberFromFragment(pendingProps.children, mode, lanes, key)
		elseif type_ == REACT_DEBUG_TRACING_MODE_TYPE then
			fiberTag = Mode
			mode = bit32.bor(mode, DebugTracingMode)
		elseif type_ == REACT_STRICT_MODE_TYPE then
			fiberTag = Mode
			mode = bit32.bor(mode, StrictMode)
		elseif type_ == REACT_PROFILER_TYPE then
			return createFiberFromProfiler(pendingProps, mode, lanes, key)
		elseif type_ == REACT_SUSPENSE_TYPE then
			return createFiberFromSuspense(pendingProps, mode, lanes, key)
			-- elseif type_ == REACT_SUSPENSE_LIST_TYPE then
			-- 	return createFiberFromSuspenseList(pendingProps, mode, lanes, key)
		elseif type_ == REACT_OFFSCREEN_TYPE then
			return createFiberFromOffscreen(pendingProps, mode, lanes, key)
		elseif type_ == REACT_LEGACY_HIDDEN_TYPE then
			return createFiberFromLegacyHidden(pendingProps, mode, lanes, key)
			-- elseif type_ == REACT_SCOPE_TYPE then
			-- 	if enableScopeAPI then
			-- 		return createFiberFromScope(type_, pendingProps, mode, lanes, key)
			-- 	end
		else
			local shouldBreak = false
			local type_typeof
			if typeOfType_ == "table" then
				type_typeof = type_["$$typeof"]
				if type_typeof == REACT_PROVIDER_TYPE then
					fiberTag = ContextProvider
					shouldBreak = true
				elseif type_typeof == REACT_CONTEXT_TYPE then
					-- This is a consumer
					fiberTag = ContextConsumer
					shouldBreak = true
				elseif type_typeof == REACT_FORWARD_REF_TYPE then
					fiberTag = ForwardRef
					if __DEV__ then
						resolvedType = resolveForwardRefForHotReloading(resolvedType)
					end
					shouldBreak = true
				elseif type_typeof == REACT_MEMO_TYPE then
					fiberTag = MemoComponent
					shouldBreak = true
				elseif type_typeof == REACT_LAZY_TYPE then
					fiberTag = LazyComponent
					resolvedType = nil
					shouldBreak = true
					-- elseif type_typeof == REACT_FUNDAMENTAL_TYPE then
					-- 	if enableFundamentalAPI then
					-- 		return createFiberFromFundamental(
					-- 			type_,
					-- 			pendingProps,
					-- 			mode,
					-- 			lanes,
					-- 			key
					-- 		)
					-- 	end
				end
			end
			if not shouldBreak then
				local info = ""
				if __DEV__ then
					if
						type_ == nil
						or (typeOfType_ == "table" and #Object.keys(type_) == 0)
					then
						info ..= " You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and " .. "named imports."
					elseif type_ ~= nil and typeOfType_ == "table" then
						-- ROBLOX deviation: print the table/string in readable form to give a clue, if no other info was gathered
						info ..= "\n" .. inspect(type_)
					end
					local ownerName
					if owner then
						ownerName = getComponentName(owner.type)
					end
					if ownerName ~= nil and ownerName ~= "" then
						info ..= "\n\nCheck the render method of `" .. ownerName .. "`."
					elseif owner then
						-- ROBLOX deviation: print the raw table in readable
						-- form to give a clue, if no other info was gathered
						info ..= "\n" .. inspect(owner)
					end
				end

				-- ROBLOX deviation: make output logic consistent across ReactFiber, ElementValidator, Memo, Context, and Lazy
				local typeString
				if type_ == nil then
					typeString = "nil"
				elseif Array.isArray(type_) then
					typeString = "array"
				elseif typeOfType_ == "table" and type_typeof == REACT_ELEMENT_TYPE then
					typeString =
						string.format("<%s />", getComponentName(type_.type) or "Unknown")
					info =
						" Did you accidentally export a JSX literal or Element instead of a component?"
				else
					typeString = typeOfType_
				end

				invariant(
					false,
					"Element type is invalid: expected a string (for built-in "
						.. "components) or a class/function (for composite components) "
						.. "but got: %s.%s",
					typeString,
					info
				)
			end
		end
	end

	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber =
		createFiber(fiberTag, pendingProps, key, mode, type_, resolvedType, nil, lanes)

	-- fiber.elementType = type_
	-- fiber.type = resolvedType
	-- fiber.lanes = lanes
	-- ROBLOX deviation END

	if __DEV__ then
		fiber._debugOwner = owner
	end

	return fiber
end

local function createFiberFromElement(
	element: ReactElement,
	mode: TypeOfMode,
	lanes: Lanes
): Fiber
	local owner = nil
	if __DEV__ then
		owner = element._owner
	end
	local type = element.type
	local key = element.key
	local pendingProps = element.props
	local fiber = createFiberFromTypeAndProps(
		type,
		-- ROBLOX FIXME: according to upstream types, key can only be string?, but RoactStableKey deviation also says number
		key :: string,
		pendingProps,
		owner,
		mode,
		lanes
	)
	if __DEV__ then
		fiber._debugSource = element._source
		fiber._debugOwner = element._owner
	end
	return fiber
end

function createFiberFromFragment(
	elements: ReactFragment,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(Fragment, elements, key, mode, nil, nil, nil, lanes)
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromFundamental(
	fundamentalComponent: ReactFundamentalComponent<any, any>,
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		FundamentalComponent,
		pendingProps,
		key,
		mode,
		fundamentalComponent,
		fundamentalComponent,
		nil,
		lanes
	)
	-- fiber.elementType = fundamentalComponent
	-- fiber.type = fundamentalComponent
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromScope(
	scope: ReactScope,
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber =
		createFiber(ScopeComponent, pendingProps, key, mode, scope, scope, nil, lanes)
	-- fiber.type = scope
	-- fiber.elementType = scope
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromProfiler(
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	if __DEV__ then
		if typeof(pendingProps.id) ~= "string" then
			console.error('Profiler must specify an "id" as a prop')
		end
	end

	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		Profiler,
		pendingProps,
		key,
		bit32.bor(mode, ProfileMode),
		REACT_PROFILER_TYPE,
		REACT_PROFILER_TYPE,
		if enableProfilerTimer
			then {
				effectDuration = 0,
				passiveEffectDuration = 0,
			}
			else nil,
		lanes
	)
	-- TODO: The Profiler fiber shouldn't have a type. It has a tag.
	-- fiber.elementType = REACT_PROFILER_TYPE
	-- fiber.type = REACT_PROFILER_TYPE
	-- fiber.lanes = lanes
	-- ROBLOX deviation END

	-- if enableProfilerTimer then
	-- 	fiber.stateNode = {
	-- 		effectDuration = 0,
	-- 		passiveEffectDuration = 0,
	-- 	}
	-- end

	return fiber
end

function createFiberFromSuspense(
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		SuspenseComponent,
		pendingProps,
		key,
		mode,
		REACT_SUSPENSE_TYPE,
		REACT_SUSPENSE_TYPE,
		nil,
		lanes
	)

	-- TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- fiber.type = REACT_SUSPENSE_TYPE
	-- fiber.elementType = REACT_SUSPENSE_TYPE

	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromSuspenseList(
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		SuspenseListComponent,
		pendingProps,
		key,
		mode,
		REACT_SUSPENSE_LIST_TYPE,
		if __DEV__ then REACT_SUSPENSE_LIST_TYPE else nil,
		nil,
		lanes
	)
	-- if __DEV__ then
	-- 	-- TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
	-- 	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- 	-- instead.
	-- 	fiber.type = REACT_SUSPENSE_LIST_TYPE
	-- end
	-- fiber.elementType = REACT_SUSPENSE_LIST_TYPE
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromOffscreen(
	pendingProps: OffscreenProps,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		OffscreenComponent,
		pendingProps,
		key,
		mode,
		REACT_OFFSCREEN_TYPE,
		if __DEV__ then REACT_OFFSCREEN_TYPE else nil,
		nil,
		lanes
	)
	-- TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- if __DEV__ then
	-- 	fiber.type = REACT_OFFSCREEN_TYPE
	-- end
	-- fiber.elementType = REACT_OFFSCREEN_TYPE
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

function createFiberFromLegacyHidden(
	pendingProps: OffscreenProps,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		LegacyHiddenComponent,
		pendingProps,
		key,
		mode,
		REACT_LEGACY_HIDDEN_TYPE,
		if __DEV__ then REACT_LEGACY_HIDDEN_TYPE else nil,
		nil,
		lanes
	)
	-- TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- if __DEV__ then
	-- 	fiber.type = REACT_LEGACY_HIDDEN_TYPE
	-- end
	-- fiber.elementType = REACT_LEGACY_HIDDEN_TYPE
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

local function createFiberFromText(content: string, mode: TypeOfMode, lanes: Lanes): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostText, content, nil, mode, nil, nil, nil, lanes)
	-- fiber.lanes = lanes
	-- ROBLOX deviation END
	return fiber
end

local function createFiberFromHostInstanceForDeletion(): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostComponent, nil, nil, NoMode, "DELETED", "DELETED")
	-- TODO: These should not need a type.
	-- fiber.elementType = "DELETED"
	-- fiber.type = "DELETED"
	-- ROBLOX deviation END
	return fiber
end

local function createFiberFromDehydratedFragment(dehydratedNode: SuspenseInstance): Fiber
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber =
		createFiber(DehydratedFragment, nil, nil, NoMode, nil, nil, dehydratedNode)
	-- fiber.stateNode = dehydratedNode
	-- ROBLOX deviation END
	return fiber
end

local function createFiberFromPortal(
	portal: ReactPortal,
	mode: TypeOfMode,
	lanes: Lanes
): Fiber
	local pendingProps = if portal.children ~= nil then portal.children else {}
	-- ROBLOX deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostPortal, pendingProps, portal.key, mode, nil, nil, {
		containerInfo = portal.containerInfo,
		pendingChildren = nil, -- Used by persistent updates
		implementation = portal.implementation,
	}, lanes)
	-- fiber.lanes = lanes
	-- fiber.stateNode = {
	-- 	containerInfo = portal.containerInfo,
	-- 	pendingChildren = nil, -- Used by persistent updates
	-- 	implementation = portal.implementation,
	-- }
	-- ROBLOX deviation END
	return fiber
end

-- Used for stashing WIP properties to replay failed work in DEV.
-- ROBLOX FIXME: `target: Fiber | nil` - Narrowing doesn't work even with nil check
local function assignFiberPropertiesInDEV(target: Fiber, source: Fiber): Fiber
	if target == nil then
		-- This Fiber's initial properties will always be overwritten.
		-- We only use a Fiber to ensure the same hidden class so DEV isn't slow.
		target = createFiber(IndeterminateComponent, nil, nil, NoMode)
	end

	-- This is intentionally written as a list of all properties.
	-- We tried to use Object.assign() instead but this is called in
	-- the hottest path, and Object.assign() was too slow:
	-- https://github.com/facebook/react/issues/12502
	-- This code is DEV-only so size is not a concern.

	target.tag = source.tag
	target.key = source.key
	target.elementType = source.elementType
	target.type = source.type
	target.stateNode = source.stateNode
	target.return_ = source.return_
	target.child = source.child
	target.sibling = source.sibling
	target.index = source.index
	target.ref = source.ref
	target.pendingProps = source.pendingProps
	target.memoizedProps = source.memoizedProps
	target.updateQueue = source.updateQueue
	target.memoizedState = source.memoizedState
	target.dependencies = source.dependencies
	target.mode = source.mode
	target.flags = source.flags
	target.subtreeFlags = source.subtreeFlags
	target.deletions = source.deletions
	target.lanes = source.lanes
	target.childLanes = source.childLanes
	target.alternate = source.alternate
	if enableProfilerTimer then
		target.actualDuration = source.actualDuration
		target.actualStartTime = source.actualStartTime
		target.selfBaseDuration = source.selfBaseDuration
		target.treeBaseDuration = source.treeBaseDuration
	end
	target._debugID = source._debugID
	target._debugSource = source._debugSource
	target._debugOwner = source._debugOwner
	target._debugNeedsRemount = source._debugNeedsRemount
	target._debugHookTypes = source._debugHookTypes
	return target
end

-- deviation: more convenient to export entire interface at the end
return {
	isSimpleFunctionComponent = isSimpleFunctionComponent,
	resolveLazyComponentTag = resolveLazyComponentTag,
	createWorkInProgress = createWorkInProgress,
	resetWorkInProgress = resetWorkInProgress,
	createHostRootFiber = createHostRootFiber,
	createFiberFromTypeAndProps = createFiberFromTypeAndProps,
	createFiberFromElement = createFiberFromElement,
	createFiberFromFragment = createFiberFromFragment,
	createFiberFromFundamental = createFiberFromFundamental,
	createFiberFromSuspense = createFiberFromSuspense,
	createFiberFromSuspenseList = createFiberFromSuspenseList,
	createFiberFromOffscreen = createFiberFromOffscreen,
	createFiberFromLegacyHidden = createFiberFromLegacyHidden,
	createFiberFromText = createFiberFromText,
	createFiberFromHostInstanceForDeletion = createFiberFromHostInstanceForDeletion,
	createFiberFromDehydratedFragment = createFiberFromDehydratedFragment,
	createFiberFromPortal = createFiberFromPortal,
	assignFiberPropertiesInDEV = assignFiberPropertiesInDEV,
} ]]
cX.Children._a8bbc8fe1c42df665ff612cf5e338ebe=c7
local c8

local c9={ClassName="ModuleScript",Children={},Properties={}}
c9.Name="ReactFiberBeginWork.new"
c9.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberBeginWork.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
-- ROBLOX TODO remove this when CLI-38793 lands
--!nolint LocalShadow
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local __DEV__ = _G.__DEV__ :: boolean
local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ =
	_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ :: boolean
local __COMPAT_WARNINGS__ = _G.__COMPAT_WARNINGS__ :: boolean

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from Shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local inspect = LuauPolyfill.util.inspect

local ReactTypes = require(Packages.Shared)
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type ReactContext<T> = ReactTypes.ReactContext<T>
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>

local React = require(Packages.React)
type LazyComponentType<T, P> = React.LazyComponent<T, P>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
-- type Lane = ReactFiberLane.Lane;
-- local type {MutableSource} = require(Packages.Shared.ReactTypes)

local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
type SuspenseListRenderState = ReactFiberSuspenseComponent.SuspenseListRenderState
type SuspenseListTailMode = ReactFiberSuspenseComponent.SuspenseListTailMode
local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext

local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenProps = ReactFiberOffscreenComponent.OffscreenProps
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState

local checkPropTypes = require(Packages.Shared).checkPropTypes

local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
-- local FundamentalComponent = ReactWorkTags.FundamentalComponent
-- local ScopeComponent = ReactWorkTags.ScopeComponent
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local StaticMask = ReactFiberFlags.StaticMask
local PerformedWork = ReactFiberFlags.PerformedWork
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
local ContentReset = ReactFiberFlags.ContentReset
local DidCapture = ReactFiberFlags.DidCapture
-- local Update = ReactFiberFlags.Update
local Ref = ReactFiberFlags.Ref
local Deletion = ReactFiberFlags.Deletion
local ForceUpdateForLegacySuspense = ReactFiberFlags.ForceUpdateForLegacySuspense
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode =
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode
local disableLegacyContext = ReactFeatureFlags.disableLegacyContext
local disableModulePatternComponents = ReactFeatureFlags.disableModulePatternComponents
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local warnAboutDefaultPropsOnFunctionComponents =
	ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local shallowEqual = require(Packages.Shared).shallowEqual
local getComponentName = require(Packages.Shared).getComponentName
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local _getIteratorFn = ReactSymbols.getIteratorFn
local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local getCurrentFiberOwnerNameInDevOrNull =
	ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull
local setIsRendering = ReactCurrentFiber.setIsRendering
local ReactFiberHotReloadingModule = require(script.Parent["ReactFiberHotReloading.new"])
local resolveFunctionForHotReloading =
	ReactFiberHotReloadingModule.resolveFunctionForHotReloading
local resolveForwardRefForHotReloading =
	ReactFiberHotReloadingModule.resolveForwardRefForHotReloading
local resolveClassForHotReloading =
	ReactFiberHotReloadingModule.resolveClassForHotReloading

local ReactChildFiber = require(script.Parent["ReactChildFiber.new"]) :: any
local mountChildFibers = ReactChildFiber.mountChildFibers
local reconcileChildFibers = ReactChildFiber.reconcileChildFibers
local cloneChildFibers = ReactChildFiber.cloneChildFibers
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local processUpdateQueue = ReactUpdateQueue.processUpdateQueue
local cloneUpdateQueue = ReactUpdateQueue.cloneUpdateQueue
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local NoMode = ReactTypeOfMode.NoMode
local ProfileMode = ReactTypeOfMode.ProfileMode
local StrictMode = ReactTypeOfMode.StrictMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local shouldSetTextContent = ReactFiberHostConfig.shouldSetTextContent
local isSuspenseInstancePending = ReactFiberHostConfig.isSuspenseInstancePending
local isSuspenseInstanceFallback = ReactFiberHostConfig.isSuspenseInstanceFallback
local registerSuspenseInstanceRetry = ReactFiberHostConfig.registerSuspenseInstanceRetry
local supportsHydration = ReactFiberHostConfig.supportsHydration
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance

local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local pushHostContext = ReactFiberHostContext.pushHostContext
local pushHostContainer = ReactFiberHostContext.pushHostContainer
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor
local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
local ForceSuspenseFallback = ReactFiberSuspenseContext.ForceSuspenseFallback
local addSubtreeSuspenseContext = ReactFiberSuspenseContext.addSubtreeSuspenseContext
local InvisibleParentSuspenseContext =
	ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local pushSuspenseContext = ReactFiberSuspenseContext.pushSuspenseContext
-- local setShallowSuspenseContext = ReactFiberSuspenseContext.setShallowSuspenseContext
local setDefaultShallowSuspenseContext =
	ReactFiberSuspenseContext.setDefaultShallowSuspenseContext
-- local {findFirstSuspended} = require(script.Parent.ReactFiberSuspenseComponent.new)
-- local {
--   ,
local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local propagateContextChange = ReactFiberNewContext.propagateContextChange
local readContext = ReactFiberNewContext.readContext
local calculateChangedBits = ReactFiberNewContext.calculateChangedBits
-- local scheduleWorkOnParentPath = ReactFiberNewContext.scheduleWorkOnParentPath
local prepareToReadContext = ReactFiberNewContext.prepareToReadContext
local pushProvider = ReactFiberNewContext.pushProvider

-- ROBLOX deviation: Lazy init all methods from ReactFiberHooks
local lazyRefs = {
	renderWithHooksRef = nil :: any,
	bailoutHooksRef = nil :: any,
	shouldSuspendRef = nil :: any,
}

local function shouldSuspend(fiber: Fiber): boolean
	if not lazyRefs.shouldSuspendRef then
		lazyRefs.shouldSuspendRef =
			require(script.Parent.ReactFiberReconciler).shouldSuspend
	end
	return lazyRefs.shouldSuspendRef(fiber)
end

-- ROBLOX deviation: collective lazy init methods from ReactFiberHooks
local function initReactFiberHooks()
	local ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
	lazyRefs.renderWithHooksRef = ReactFiberHooks.renderWithHooks
	lazyRefs.bailoutHooksRef = ReactFiberHooks.bailoutHooks
end

-- ROBLOX deviation: Lazy init renderWithHooks from ReactFiberHooks
local function renderWithHooks(...)
	if not lazyRefs.renderWithHooksRef then
		initReactFiberHooks()
	end
	return lazyRefs.renderWithHooksRef(...)
end

-- ROBLOX deviation: Lazy init bailoutHooks from ReactFiberHooks
local function bailoutHooks(...)
	if not lazyRefs.bailoutHooksRef then
		initReactFiberHooks()
	end
	return lazyRefs.bailoutHooksRef(...)
end

local stopProfilerTimerIfRunning =
	require(script.Parent["ReactProfilerTimer.new"]).stopProfilerTimerIfRunning
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local getMaskedContext = ReactFiberContext.getMaskedContext
local getUnmaskedContext = ReactFiberContext.getUnmaskedContext
local hasLegacyContextChanged = ReactFiberContext.hasContextChanged
local pushLegacyContextProvider = ReactFiberContext.pushContextProvider
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local pushTopLevelContextObject = ReactFiberContext.pushTopLevelContextObject
local invalidateContextProvider = ReactFiberContext.invalidateContextProvider

local ReactFiberHydrationContext =
	require(script.Parent["ReactFiberHydrationContext.new"])
local resetHydrationState = ReactFiberHydrationContext.resetHydrationState
local enterHydrationState = ReactFiberHydrationContext.enterHydrationState
local reenterHydrationStateFromDehydratedSuspenseInstance =
	ReactFiberHydrationContext.reenterHydrationStateFromDehydratedSuspenseInstance
local tryToClaimNextHydratableInstance =
	ReactFiberHydrationContext.tryToClaimNextHydratableInstance
local warnIfHydrating = ReactFiberHydrationContext.warnIfHydrating
local ReactFiberClassComponent =
	require(script.Parent["ReactFiberClassComponent.new"]) :: any
local adoptClassInstance = ReactFiberClassComponent.adoptClassInstance
local applyDerivedStateFromProps = ReactFiberClassComponent.applyDerivedStateFromProps
local constructClassInstance = ReactFiberClassComponent.constructClassInstance
local mountClassInstance = ReactFiberClassComponent.mountClassInstance
local resumeMountClassInstance = ReactFiberClassComponent.resumeMountClassInstance
local updateClassInstance = ReactFiberClassComponent.updateClassInstance

local resolveDefaultProps =
	require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactFiber = require(script.Parent["ReactFiber.new"])
local resolveLazyComponentTag = ReactFiber.resolveLazyComponentTag
local createFiberFromFragment = ReactFiber.createFiberFromFragment
local createFiberFromOffscreen = ReactFiber.createFiberFromOffscreen

local createFiberFromTypeAndProps = ReactFiber.createFiberFromTypeAndProps
local isSimpleFunctionComponent = ReactFiber.isSimpleFunctionComponent
local createWorkInProgress = ReactFiber.createWorkInProgress
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local pushRenderLanes = ReactFiberWorkLoop.pushRenderLanes
local markSpawnedWork = ReactFiberWorkLoop.markSpawnedWork
local retryDehydratedSuspenseBoundary = ReactFiberWorkLoop.retryDehydratedSuspenseBoundary
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local renderDidSuspendDelayIfPossible = ReactFiberWorkLoop.renderDidSuspendDelayIfPossible
local getWorkInProgressRoot = ReactFiberWorkLoop.getWorkInProgressRoot
local getExecutionContext = ReactFiberWorkLoop.getExecutionContext
local RetryAfterError = ReactFiberWorkLoop.RetryAfterError
local NoContext = ReactFiberWorkLoop.NoContext

local Schedule_tracing_wrap
local setWorkInProgressVersion =
	require(script.Parent["ReactMutableSource.new"]).setWorkInProgressVersion
local markSkippedUpdateLanes =
	require(script.Parent.ReactFiberWorkInProgress).markSkippedUpdateLanes
local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner

local exports: { [string]: any } = {}

-- ROBLOX deviation: Pre-declare functions
local bailoutOnAlreadyFinishedWork, updateFunctionComponent

local didReceiveUpdate: boolean = false

-- ROBLOX deviation: put didWarns in table to reduce number of local variables
local DidWarn = {
	didWarnAboutBadClass = {} :: { [string]: boolean },
	didWarnAboutModulePatternComponent = {} :: { [string]: boolean },
	didWarnAboutContextTypeOnFunctionComponent = {} :: { [string]: boolean },
	didWarnAboutGetDerivedStateOnFunctionComponent = {} :: { [string]: boolean },
	didWarnAboutFunctionRefs = {} :: { [string]: boolean },
	didWarnAboutDefaultPropsOnFunctionComponent = {} :: { [string]: boolean },
}
-- export local didWarnAboutReassigningProps
-- local didWarnAboutRevealOrder
-- local didWarnAboutTailOptions
local updateSimpleMemoComponent

if __DEV__ then
	DidWarn.didWarnAboutBadClass = {}
	DidWarn.didWarnAboutModulePatternComponent = {}
	DidWarn.didWarnAboutContextTypeOnFunctionComponent = {}
	DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent = {}
	DidWarn.didWarnAboutFunctionRefs = {}
	exports.didWarnAboutReassigningProps = false
	--   didWarnAboutRevealOrder = {}
	--   didWarnAboutTailOptions = {}
	DidWarn.didWarnAboutDefaultPropsOnFunctionComponent = {}
end

local function reconcileChildren(
	current: Fiber | nil,
	workInProgress: Fiber,
	nextChildren: any,
	renderLanes: Lanes
)
	if current == nil then
		-- If this is a fresh new component that hasn't been rendered yet, we
		-- won't update its child set by applying minimal side-effects. Instead,
		-- we will add them all to the child before it gets rendered. That means
		-- we can optimize this reconciliation pass by not tracking side-effects.
		workInProgress.child =
			mountChildFibers(workInProgress, nil, nextChildren, renderLanes)
	else
		-- If the current child is the same as the work in progress, it means that
		-- we haven't yet started any work on these children. Therefore, we use
		-- the clone algorithm to create a copy of all the current children.

		-- If we had any progressed work already, that is invalid at this point so
		-- let's throw it out.
		workInProgress.child = reconcileChildFibers(
			workInProgress,
			(current :: Fiber).child,
			nextChildren,
			renderLanes
		)
	end
end

local function forceUnmountCurrentAndReconcile(
	current: Fiber,
	workInProgress: Fiber,
	nextChildren: any,
	renderLanes: Lanes
)
	-- This function is fork of reconcileChildren. It's used in cases where we
	-- want to reconcile without matching against the existing set. This has the
	-- effect of all current children being unmounted; even if the type and key
	-- are the same, the old child is unmounted and a new child is created.
	--
	-- To do this, we're going to go through the reconcile algorithm twice. In
	-- the first pass, we schedule a deletion for all the current children by
	-- passing nil.
	workInProgress.child =
		reconcileChildFibers(workInProgress, current.child, nil, renderLanes)
	-- In the second pass, we mount the new children. The trick here is that we
	-- pass nil in place of where we usually pass the current child set. This has
	-- the effect of remounting all children regardless of whether their
	-- identities match.
	workInProgress.child =
		reconcileChildFibers(workInProgress, nil, nextChildren, renderLanes)
end

local function updateForwardRef(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	renderLanes: Lanes
)
	-- TODO: current can be non-null here even if the component
	-- hasn't yet mounted. This happens after the first render suspends.
	-- We'll need to figure out if this is fine or can cause issues.

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes = Component.propTypes
			local validateProps = Component.validateProps
			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	local render = Component.render
	local ref = workInProgress.ref

	-- The rest is a fork of updateFunctionComponent
	local nextChildren
	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		nextChildren =
			renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes)
		if
			debugRenderPhaseSideEffectsForStrictMode
			and bit32.band(workInProgress.mode, StrictMode) ~= 0
		then
			disableLogs()
			local ok, result = xpcall(
				renderWithHooks,
				describeError,
				current,
				workInProgress,
				render,
				nextProps,
				ref,
				renderLanes
			)
			if ok then
				nextChildren = result
			end
			-- finally
			reenableLogs()

			if not ok then
				error(result)
			end
		end
		setIsRendering(false)
	else
		nextChildren =
			renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes)
	end

	if current ~= nil and not didReceiveUpdate then
		bailoutHooks(current, workInProgress, renderLanes)
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function updateMemoComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	updateLanes: Lanes,
	renderLanes: Lanes
): nil | Fiber
	if current == nil then
		local type_ = Component.type
		if
			isSimpleFunctionComponent(type_)
			and Component.compare == nil
			-- SimpleMemoComponent codepath doesn't resolve outer props either.
			and Component.defaultProps == nil
		then
			local resolvedType = type_
			if __DEV__ then
				resolvedType = resolveFunctionForHotReloading(type_)
			end
			-- If this is a plain function component without default props,
			-- and with only the default shallow comparison, we upgrade it
			-- to a SimpleMemoComponent to allow fast path updates.
			workInProgress.tag = SimpleMemoComponent
			workInProgress.type = resolvedType
			if __DEV__ then
				validateFunctionComponentInDev(workInProgress, type_)
			end
			return updateSimpleMemoComponent(
				current,
				workInProgress,
				resolvedType,
				nextProps,
				updateLanes,
				renderLanes
			)
		end
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes
			local validateProps
			-- ROBLOX deviation: avoid accessing propTypes on a function, Lua doesn't support fields on functions
			if type(type_) == "table" then
				innerPropTypes = type_.propTypes
				validateProps = type_.validateProps
			end

			if innerPropTypes or validateProps then
				-- Inner memo component props aren't currently validated in createElement.
				-- We could move it there, but we'd still need this for lazy code path.
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(type_)
				)
			end
		end
		local child = createFiberFromTypeAndProps(
			Component.type,
			nil,
			nextProps,
			workInProgress,
			workInProgress.mode,
			renderLanes
		)
		child.ref = workInProgress.ref
		child.return_ = workInProgress
		workInProgress.child = child
		return child
	end
	-- ROBLOX TODO Deviation: remove redefinition + typecast when this lands: CLI-38793
	-- ROBLOX the if clause above returns early if current is nil
	local current = current :: Fiber
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local type_ = Component.type
		-- ROBLOX deviation: adds support for legacy Roact's validateProps()
		local innerPropTypes
		local validateProps
		-- ROBLOX deviation: only check for propTypes on class components, Lua doesn't support fields on functions
		if type(type_) == "table" then
			innerPropTypes = type_.propTypes
			validateProps = type_.validateProps
		end

		if innerPropTypes or validateProps then
			-- Inner memo component props aren't currently validated in createElement.
			-- We could move it there, but we'd still need this for lazy code path.
			checkPropTypes(
				innerPropTypes,
				validateProps,
				nextProps, -- Resolved props
				"prop",
				getComponentName(type_)
			)
		end
	end
	local currentChild = (current.child :: any) :: Fiber -- This is always exactly one child
	if not ReactFiberLane.includesSomeLane(updateLanes, renderLanes) then
		-- This will be the props with resolved defaultProps,
		-- unlike current.memoizedProps which will be the unresolved ones.
		local prevProps = currentChild.memoizedProps
		-- Default to shallow comparison
		local compare = Component.compare
		if compare == nil then
			compare = shallowEqual
		end
		if compare(prevProps, nextProps) and current.ref == workInProgress.ref then
			return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		end
	end
	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	local newChild = createWorkInProgress(currentChild, nextProps)
	newChild.ref = workInProgress.ref
	newChild.return_ = workInProgress
	workInProgress.child = newChild
	return newChild
end

function updateSimpleMemoComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	updateLanes: Lanes,
	renderLanes: Lanes
): nil | Fiber
	-- TODO: current can be non-null here even if the component
	-- hasn't yet mounted. This happens when the inner render suspends.
	-- We'll need to figure out if this is fine or can cause issues.

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			local outerMemoType = workInProgress.elementType
			if outerMemoType["$$typeof"] == REACT_LAZY_TYPE then
				-- We warn when you define propTypes on lazy()
				-- so let's just skip over it to find memo() outer wrapper.
				-- Inner props for memo are validated later.
				local lazyComponent: LazyComponentType<any, any> = outerMemoType
				local payload = lazyComponent._payload
				local init = lazyComponent._init
				local ok, result = xpcall(init, describeError, payload)
				if ok then
					outerMemoType = result
				else
					outerMemoType = nil
				end
				-- Inner propTypes will be validated in the function component path.
				-- ROBLOX deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes
				local validateProps
				-- ROBLOX deviation: avoid accessing propTypes on a function, Lua doesn't support fields on functions
				if outerMemoType ~= nil and type(outerMemoType) == "table" then
					outerPropTypes = (outerMemoType :: any).propTypes
					-- ROBLOX deviation: support legacy Roact's equivalent of propTypes
					validateProps = (outerMemoType :: any).validateProps
				end

				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						nextProps, -- Resolved (SimpleMemoComponent has no defaultProps)
						"prop",
						getComponentName(outerMemoType)
					)
				end
			end
		end
	end
	if current ~= nil then
		-- ROBLOX TODO Deviation: remove redefinition + typecast when this lands: CLI-38793
		-- This unfortunately breaks if current gets reassigned somewhere in this if clause
		local current = current :: Fiber
		local prevProps = current.memoizedProps
		-- ROBLOX Deviation: replacing ternary operator
		local preventBailout = true
		if __DEV__ then
			preventBailout = workInProgress.type == current.type
		end
		if
			shallowEqual(prevProps, nextProps)
			and current.ref == workInProgress.ref
			-- Prevent bailout if the implementation changed due to hot reload.
			and preventBailout
		then
			didReceiveUpdate = false
			if not ReactFiberLane.includesSomeLane(renderLanes, updateLanes) then
				-- The pending lanes were cleared at the beginning of beginWork. We're
				-- about to bail out, but there might be other lanes that weren't
				-- included in the current render. Usually, the priority level of the
				-- remaining updates is accumlated during the evaluation of the
				-- component (i.e. when processing the update queue). But since since
				-- we're bailing out early *without* evaluating the component, we need
				-- to account for it here, too. Reset to the value of the current fiber.
				-- NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
				-- because a MemoComponent fiber does not have hooks or an update queue
				-- rather, it wraps around an inner component, which may or may not
				-- contains hooks.
				-- TODO: Move the reset at in beginWork out of the common path so that
				-- this is no longer necessary.
				workInProgress.lanes = current.lanes
				return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
			elseif bit32.band(current.flags, ForceUpdateForLegacySuspense) ~= NoFlags then
				-- This is a special case that only exists for legacy mode.
				-- See https://github.com/facebook/react/pull/19216.
				didReceiveUpdate = true
			end
		end
	end
	return updateFunctionComponent(
		current,
		workInProgress,
		Component,
		nextProps,
		renderLanes
	)
end

local function updateOffscreenComponent(
	current: Fiber?,
	workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | nil
	local nextProps: OffscreenProps = workInProgress.pendingProps
	local nextChildren = nextProps.children

	local prevState: OffscreenState?
	if current ~= nil then
		-- ROBLOX FIXME: remove :: recast once Luau understands if-statement nil checks
		prevState = (current :: Fiber).memoizedState
	end

	if
		nextProps.mode == "hidden"
		or nextProps.mode == "unstable-defer-without-hiding"
	then
		if bit32.band(workInProgress.mode, ConcurrentMode) == NoMode then
			-- In legacy sync mode, don't defer the subtree. Render it now.
			-- TODO: Figure out what we should do in Blocking mode.
			local nextState: OffscreenState = {
				baseLanes = ReactFiberLane.NoLanes,
			}
			workInProgress.memoizedState = nextState
			pushRenderLanes(workInProgress, renderLanes)
		-- ROBLOX TODO: recast ReactFiberLane.OffscreenLane to type Lane
		elseif
			not ReactFiberLane.includesSomeLane(renderLanes, ReactFiberLane.OffscreenLane)
		then
			local nextBaseLanes
			if prevState ~= nil then
				-- ROBLOX FIXME: remove :: recast once Luau understands if-statement nil check
				local prevBaseLanes = (prevState :: OffscreenState).baseLanes
				nextBaseLanes = ReactFiberLane.mergeLanes(prevBaseLanes, renderLanes)
			else
				nextBaseLanes = renderLanes
			end

			-- Schedule this fiber to re-render at offscreen priority. Then bailout.
			if enableSchedulerTracing then
				markSpawnedWork(ReactFiberLane.OffscreenLane)
			end

			-- deviation: unchain multiple assignment into two discrete assignments.
			workInProgress.childLanes =
				ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane)
			workInProgress.lanes = workInProgress.childLanes

			local nextState: OffscreenState = {
				baseLanes = nextBaseLanes,
			}
			workInProgress.memoizedState = nextState
			-- We're about to bail out, but we need to push this to the stack anyway
			-- to avoid a push/pop misalignment.
			pushRenderLanes(workInProgress, nextBaseLanes)
			return nil
		else
			-- Rendering at offscreen, so we can clear the base lanes.
			local nextState: OffscreenState = {
				baseLanes = ReactFiberLane.NoLanes,
			}
			workInProgress.memoizedState = nextState
			-- Push the lanes that were skipped when we bailed out.
			local subtreeRenderLanes = renderLanes

			-- deviation: ternary converted to if statement
			if prevState ~= nil then
				-- ROBLOX FIXME: remove :: recast once Luau understands if-statement nil check
				subtreeRenderLanes = (prevState :: OffscreenState).baseLanes
			end

			pushRenderLanes(workInProgress, subtreeRenderLanes)
		end
	else
		local subtreeRenderLanes
		if prevState ~= nil then
			-- ROBLOX FIXME: remove :: recast once Luau understands if-statement nil check
			subtreeRenderLanes = ReactFiberLane.mergeLanes(
				(prevState :: OffscreenState).baseLanes,
				renderLanes
			)
			-- Since we're not hidden anymore, reset the state
			workInProgress.memoizedState = nil
		else
			-- We weren't previously hidden, and we still aren't, so there's nothing
			-- special to do. Need to push to the stack regardless, though, to avoid
			-- a push/pop misalignment.
			subtreeRenderLanes = renderLanes
		end
		pushRenderLanes(workInProgress, subtreeRenderLanes)
	end

	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

-- Note: These happen to have identical begin phases, for now. We shouldn't hold
-- ourselves to this constraint, though. If the behavior diverges, we should
-- fork the function.
local updateLegacyHiddenComponent = updateOffscreenComponent

function updateFragment(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local nextChildren = workInProgress.pendingProps
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

function updateMode(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local nextChildren = workInProgress.pendingProps.children
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

function updateProfiler(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	if enableProfilerTimer then
		-- Reset effect durations for the next eventual effect phase.
		-- These are reset during render to allow the DevTools commit hook a chance to read them,
		local stateNode = workInProgress.stateNode
		stateNode.effectDuration = 0
		stateNode.passiveEffectDuration = 0
	end
	local nextProps = workInProgress.pendingProps
	local nextChildren = nextProps.children
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function markRef(current: Fiber | nil, workInProgress: Fiber)
	local ref = workInProgress.ref
	if
		(current == nil and ref ~= nil)
		or (current ~= nil and (current :: Fiber).ref ~= ref)
	then
		-- Schedule a Ref effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Ref)
	end
end

function updateFunctionComponent(
	current,
	workInProgress,
	Component,
	nextProps: any,
	renderLanes
)
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		-- ROBLOX deviation: function components can't have props in Lua
		if
			type(Component) ~= "function"
			and (workInProgress.type ~= workInProgress.elementType)
		then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes
			local validateProps
			-- ROBLOX deviation: Roact won't support propTypes on functional components
			if type(Component) == "table" then
				innerPropTypes = (Component :: any).propTypes
				validateProps = (Component :: any).validateProps
			end

			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	local context
	if not disableLegacyContext then
		local unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
		context = getMaskedContext(workInProgress, unmaskedContext)
	end

	local nextChildren
	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		nextChildren = renderWithHooks(
			current,
			workInProgress,
			Component,
			nextProps,
			context,
			renderLanes
		)
		if
			debugRenderPhaseSideEffectsForStrictMode
			and bit32.band(workInProgress.mode, StrictMode) ~= 0
		then
			disableLogs()
			local ok, result = xpcall(
				renderWithHooks,
				describeError,
				current,
				workInProgress,
				Component,
				nextProps,
				context,
				renderLanes
			)
			-- finally
			reenableLogs()
			if ok then
				nextChildren = result
			else
				error(result)
			end
		end
		setIsRendering(false)
	else
		nextChildren = renderWithHooks(
			current,
			workInProgress,
			Component,
			nextProps,
			context,
			renderLanes
		)
	end

	if current ~= nil and not didReceiveUpdate then
		bailoutHooks(current, workInProgress, renderLanes)
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

-- function updateBlock<Props, Data>(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   block: BlockComponent<Props, Data>,
--   nextProps: any,
--   renderLanes: Lanes,
-- )
--   -- TODO: current can be non-null here even if the component
--   -- hasn't yet mounted. This happens after the first render suspends.
--   -- We'll need to figure out if this is fine or can cause issues.

--   local render = block._render
--   local data = block._data

--   -- The rest is a fork of updateFunctionComponent
--   local nextChildren
--   prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
--   if  __DEV__ then
--     ReactCurrentOwner.current = workInProgress
--     setIsRendering(true)
--     nextChildren = renderWithHooks(
--       current,
--       workInProgress,
--       render,
--       nextProps,
--       data,
--       renderLanes,
--     )
--     if
--       debugRenderPhaseSideEffectsForStrictMode and
--       workInProgress.mode & StrictMode
--     )
--       disableLogs()
--       try {
--         nextChildren = renderWithHooks(
--           current,
--           workInProgress,
--           render,
--           nextProps,
--           data,
--           renderLanes,
--         )
--       } finally {
--         reenableLogs()
--       end
--     end
--     setIsRendering(false)
--   else
--     nextChildren = renderWithHooks(
--       current,
--       workInProgress,
--       render,
--       nextProps,
--       data,
--       renderLanes,
--     )
--   end

--   if current ~= nil and !didReceiveUpdate)
--     bailoutHooks(current, workInProgress, renderLanes)
--     return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
--   end

--   -- React DevTools reads this flag.
--   workInProgress.flags |= PerformedWork
--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

-- ROBLOX FIXME: type refinement
-- local function updateClassComponent(
--   current: Fiber | nil,
--   ...
-- )
local function updateClassComponent(
	current: any,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	renderLanes: Lanes
)
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes = Component.propTypes
			local validateProps = Component.validateProps
			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	-- Push context providers early to prevent context stack mismatches.
	-- During mounting we don't know the child context yet as the instance doesn't exist.
	-- We will invalidate the child context in finishClassComponent() right after rendering.
	local hasContext
	if isLegacyContextProvider(Component) then
		hasContext = true
		pushLegacyContextProvider(workInProgress)
	else
		hasContext = false
	end
	-- ROBLOX deviation: pass in function to break cyclic require dependency
	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)

	local instance = workInProgress.stateNode
	local shouldUpdate
	if instance == nil then
		if current ~= nil then
			-- A class component without an instance only mounts if it suspended
			-- inside a non-concurrent tree, in an inconsistent state. We want to
			-- treat it like a new mount, even though an empty version of it already
			-- committed. Disconnect the alternate pointers.
			current.alternate = nil
			workInProgress.alternate = nil
			-- Since this is conceptually a new fiber, schedule a Placement effect
			workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
		end
		-- In the initial pass we might need to construct the instance.
		constructClassInstance(workInProgress, Component, nextProps)
		mountClassInstance(workInProgress, Component, nextProps, renderLanes)
		shouldUpdate = true
	elseif current == nil then
		-- In a resume, we'll already have an instance we can reuse.
		shouldUpdate =
			resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes)
	else
		shouldUpdate = updateClassInstance(
			current,
			workInProgress,
			Component,
			nextProps,
			renderLanes
		)
	end
	local nextUnitOfWork = finishClassComponent(
		current,
		workInProgress,
		Component,
		shouldUpdate,
		hasContext,
		renderLanes
	)
	if __DEV__ then
		local inst = workInProgress.stateNode
		if shouldUpdate and inst.props ~= nextProps then
			if not exports.didWarnAboutReassigningProps then
				console.error(
					"It looks like %s is reassigning its own `this.props` while rendering. "
						.. "This is not supported and can lead to confusing bugs.",
					getComponentName(workInProgress.type) or "a component"
				)
			end
			exports.didWarnAboutReassigningProps = true
		end
	end
	return nextUnitOfWork
end

function finishClassComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	shouldUpdate: boolean,
	hasContext: boolean,
	renderLanes: Lanes
)
	-- Refs should update even if shouldComponentUpdate returns false
	markRef(current, workInProgress)

	local didCaptureError = bit32.band(workInProgress.flags, DidCapture) ~= NoFlags

	if not shouldUpdate and not didCaptureError then
		-- Context providers should defer to sCU for rendering
		if hasContext then
			invalidateContextProvider(workInProgress, Component, false)
		end

		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	local instance = workInProgress.stateNode

	-- Rerender
	ReactCurrentOwner.current = workInProgress
	local nextChildren
	if
		didCaptureError
		and (
			Component.getDerivedStateFromError == nil
			or type(Component.getDerivedStateFromError) ~= "function"
		)
	then
		-- If we captured an error, but getDerivedStateFromError is not defined,
		-- unmount all the children. componentDidCatch will schedule an update to
		-- re-render a fallback. This is temporary until we migrate everyone to
		-- the new API.
		-- TODO: Warn in a future release.
		nextChildren = nil

		if enableProfilerTimer then
			stopProfilerTimerIfRunning(workInProgress)
		end
	else
		if __DEV__ then
			setIsRendering(true)
			-- deviation: Call with ':' instead of '.' so that render can access self
			nextChildren = instance:render()
			if
				debugRenderPhaseSideEffectsForStrictMode
				and bit32.band(workInProgress.mode, StrictMode) ~= 0
			then
				disableLogs()
				-- deviation: Pass instance so that render can access self
				local ok, result = xpcall(instance.render, describeError, instance)
				-- finally
				reenableLogs()
				if not ok then
					error(result)
				end
			end
			setIsRendering(false)
		else
			-- deviation: Call with ':' instead of '.' so that render can access self
			nextChildren = instance:render()
		end
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	if current ~= nil and didCaptureError then
		-- If we're recovering from an error, reconcile without reusing any of
		-- the existing children. Conceptually, the normal children and the children
		-- that are shown on error are two different sets, so we shouldn't reuse
		-- normal children even if their identities match.
		forceUnmountCurrentAndReconcile(
			current :: Fiber,
			workInProgress,
			nextChildren,
			renderLanes
		)
	else
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	end

	-- Memoize state using the values we just used to render.
	-- TODO: Restructure so we never read values from the instance.
	workInProgress.memoizedState = instance.state

	-- The context might have changed so we need to recalculate it.
	if hasContext then
		invalidateContextProvider(workInProgress, Component, true)
	end

	return workInProgress.child
end

local function pushHostRootContext(workInProgress)
	-- FIXME (roblox): type refinement '(workInProgress.stateNode: FiberRoot)'
	local root = workInProgress.stateNode
	if root.pendingContext then
		pushTopLevelContextObject(
			workInProgress,
			root.pendingContext,
			root.pendingContext ~= root.context
		)
	elseif root.context then
		-- Should always be set
		pushTopLevelContextObject(workInProgress, root.context, false)
	end
	pushHostContainer(workInProgress, root.containerInfo)
end

local function updateHostRoot(current, workInProgress, renderLanes)
	pushHostRootContext(workInProgress)
	local updateQueue = workInProgress.updateQueue
	invariant(
		current ~= nil and updateQueue ~= nil,
		"If the root does not have an updateQueue, we should have already "
			.. "bailed out. This error is likely caused by a bug in React. Please "
			.. "file an issue."
	)
	local nextProps = workInProgress.pendingProps
	local prevState = workInProgress.memoizedState
	local prevChildren
	if prevState ~= nil then
		prevChildren = prevState.element
	end
	cloneUpdateQueue(current, workInProgress)
	processUpdateQueue(workInProgress, nextProps, nil, renderLanes)
	local nextState = workInProgress.memoizedState
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	local nextChildren = nextState.element
	if nextChildren == prevChildren then
		resetHydrationState()
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end
	local root: FiberRoot = workInProgress.stateNode
	if root.hydrate and enterHydrationState(workInProgress) then
		-- If we don't have any current children this might be the first pass.
		-- We always try to hydrate. If this isn't a hydration pass there won't
		-- be any children to hydrate which is effectively the same thing as
		-- not hydrating.

		if supportsHydration then
			local mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData
			if mutableSourceEagerHydrationData ~= nil then
				for i = 1, #mutableSourceEagerHydrationData, 2 do
					-- FIXME (roblox): type refinement
					-- local mutableSource = ((mutableSourceEagerHydrationData[
					--   i
					-- ]: any): MutableSource<any>)
					local mutableSource = mutableSourceEagerHydrationData[i]
					local version = mutableSourceEagerHydrationData[i + 1]
					setWorkInProgressVersion(mutableSource, version)
				end
			end
		end

		local child = mountChildFibers(workInProgress, nil, nextChildren, renderLanes)
		workInProgress.child = child

		local node = child
		while node do
			-- Mark each child as hydrating. This is a fast path to know whether this
			-- tree is part of a hydrating tree. This is used to determine if a child
			-- node has fully mounted yet, and for scheduling event replaying.
			-- Conceptually this is similar to Placement in that a new subtree is
			-- inserted into the React tree here. It just happens to not need DOM
			-- mutations because it already exists.
			node.flags =
				bit32.bor(bit32.band(node.flags, bit32.bnot(Placement)), Hydrating)
			node = node.sibling
		end
	else
		-- Otherwise reset hydration state in case we aborted and resumed another
		-- root.
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
		resetHydrationState()
	end
	return workInProgress.child
end

-- FIXME (roblox): type refinement
-- local function updateHostComponent(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes
-- )
local function updateHostComponent(
	current: any,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	pushHostContext(workInProgress)

	if current == nil then
		tryToClaimNextHydratableInstance(workInProgress)
	end

	local type_ = workInProgress.type
	local nextProps = workInProgress.pendingProps
	local prevProps
	if current ~= nil then
		prevProps = current.memoizedProps
	end

	local nextChildren = nextProps.children
	local isDirectTextChild = shouldSetTextContent(type_, nextProps)

	if isDirectTextChild then
		-- We special case a direct text child of a host node. This is a common
		-- case. We won't handle it as a reified child. We will instead handle
		-- this in the host environment that also has access to this prop. That
		-- avoids allocating another HostText fiber and traversing it.
		nextChildren = nil
	elseif prevProps ~= nil and shouldSetTextContent(type_, prevProps) then
		-- If we're switching from a direct text child to a normal child, or to
		-- empty, we need to schedule the text content to be reset.
		workInProgress.flags = bit32.bor(workInProgress.flags, ContentReset)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)

	markRef(current, workInProgress)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function updateHostText(current, workInProgress)
	if current == nil then
		tryToClaimNextHydratableInstance(workInProgress)
	end
	-- Nothing to do here. This is terminal. We'll do the completion step
	-- immediately after.
	return nil
end

local function mountLazyComponent(
	_current,
	workInProgress,
	elementType,
	updateLanes,
	renderLanes
)
	if _current ~= nil then
		-- A lazy component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		_current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	local props = workInProgress.pendingProps
	local lazyComponent: LazyComponentType<any, any> = elementType
	local payload = lazyComponent._payload
	local init = lazyComponent._init
	local Component = init(payload)
	-- Store the unwrapped component in the type.
	workInProgress.type = Component
	workInProgress.tag = resolveLazyComponentTag(Component)
	local resolvedTag = workInProgress.tag
	local resolvedProps = resolveDefaultProps(Component, props)
	local child
	if resolvedTag == FunctionComponent then
		if __DEV__ then
			validateFunctionComponentInDev(workInProgress, Component)
			Component = resolveFunctionForHotReloading(Component)
			workInProgress.type = Component
		end
		child = updateFunctionComponent(
			nil,
			workInProgress,
			Component,
			resolvedProps,
			renderLanes
		)
		return child
	elseif resolvedTag == ClassComponent then
		if __DEV__ then
			Component = resolveClassForHotReloading(Component)
			workInProgress.type = Component
		end
		child = updateClassComponent(
			nil,
			workInProgress,
			Component,
			resolvedProps,
			renderLanes
		)
		return child
	elseif resolvedTag == ForwardRef then
		if __DEV__ then
			Component = resolveForwardRefForHotReloading(Component)
			workInProgress.type = Component
		end
		child =
			updateForwardRef(nil, workInProgress, Component, resolvedProps, renderLanes)
		return child
	elseif resolvedTag == MemoComponent then
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			if workInProgress.type ~= workInProgress.elementType then
				-- ROBLOX deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes = Component.propTypes
				local validateProps = Component.validateProps
				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						resolvedProps, -- Resolved for outer only
						"prop",
						getComponentName(Component)
					)
				end
			end
		end
		child = updateMemoComponent(
			nil,
			workInProgress,
			Component,
			resolveDefaultProps(Component.type, resolvedProps), -- The inner type can have defaults too
			updateLanes,
			renderLanes
		)
		return child
		-- elseif resolvedTag == Block then
		--   unimplemented("Blocks API")
		--   if enableBlocksAPI then
		--     -- TODO: Resolve for Hot Reloading.
		--     child = updateBlock(
		--       nil,
		--       workInProgress,
		--       Component,
		--       props,
		--       renderLanes,
		--     )
		--     return child
		--   end
		--   -- ROBLOX deviation: break
	end
	local hint = ""
	if __DEV__ then
		if
			Component ~= nil
			and type(Component) == "table"
			and Component["$$typeof"] == REACT_LAZY_TYPE
		then
			hint = " Did you wrap a component in React.lazy() more than once?"
		elseif type(Component) == "table" and Component["$$typeof"] == nil then
			hint = "\n" .. inspect(Component)
		end
	end
	-- This message intentionally doesn't mention ForwardRef or MemoComponent
	-- because the fact that it's a separate type of work is an
	-- implementation detail.
	invariant(
		false,
		"Element type is invalid. Received a promise that resolves to: %s. "
			.. "Lazy element type must resolve to a class or function.%s",
		tostring(Component),
		hint
	)
	-- ROBLOX deviation: add nil to satisfy Luau, which doesn't doesn't bubble up the unconditional error() inside invariant
	return nil
end

function mountIncompleteClassComponent(
	_current,
	workInProgress,
	Component,
	nextProps,
	renderLanes
)
	if _current ~= nil then
		-- An incomplete component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		_current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	-- Promote the fiber to a class and try rendering again.
	workInProgress.tag = ClassComponent

	-- The rest of this function is a fork of `updateClassComponent`

	-- Push context providers early to prevent context stack mismatches.
	-- During mounting we don't know the child context yet as the instance doesn't exist.
	-- We will invalidate the child context in finishClassComponent() right after rendering.
	local hasContext
	if isLegacyContextProvider(Component) then
		hasContext = true
		pushLegacyContextProvider(workInProgress)
	else
		hasContext = false
	end
	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)

	constructClassInstance(workInProgress, Component, nextProps)
	mountClassInstance(workInProgress, Component, nextProps, renderLanes)

	return finishClassComponent(
		nil,
		workInProgress,
		Component,
		true,
		hasContext,
		renderLanes
	)
end

local function mountIndeterminateComponent(
	current,
	workInProgress,
	Component,
	renderLanes
)
	if current ~= nil then
		-- An indeterminate component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	local props = workInProgress.pendingProps
	local context
	if not disableLegacyContext then
		local unmaskedContext = getUnmaskedContext(workInProgress, Component, false)
		context = getMaskedContext(workInProgress, unmaskedContext)
	end

	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)
	local value

	if __DEV__ then
		if
			-- deviation: Instead of checking for the prototype, see if Component is a
			-- table with a render function
			type(Component) == "table" and type(Component.render) == "function"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutBadClass[componentName] then
				console.error(
					"The <%s /> component appears to have a render method, but doesn't extend React.Component. "
						.. "This is likely to cause errors. Change %s to extend React.Component instead.",
					componentName,
					componentName
				)
				DidWarn.didWarnAboutBadClass[componentName] = true
			end
		end

		if bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress)
		end

		setIsRendering(true)
		ReactCurrentOwner.current = workInProgress
		value =
			renderWithHooks(nil, workInProgress, Component, props, context, renderLanes)
		setIsRendering(false)
	else
		value =
			renderWithHooks(nil, workInProgress, Component, props, context, renderLanes)
	end
	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	-- ROBLOX deviation START: cache type(value)
	local typeofValue = type(value)
	-- ROBLOX deviation END

	if __DEV__ then
		-- Support for module components is deprecated and is removed behind a flag.
		-- Whether or not it would crash later, we want to show a good message in DEV first.
		if
			value ~= nil
			and typeofValue == "table"
			and type(value.render) == "function"
			and value["$$typeof"] == nil
		then
			local componentName = getComponentName(Component) or "Unknown"
			if not DidWarn.didWarnAboutModulePatternComponent[componentName] then
				console.error(
					"The <%s /> component appears to be a function component that returns a class instance. "
						.. "Change %s to a class that extends React.Component instead. ",
					-- ROBLOX deviation: Don't print JS-specific remediation advice
					-- "If you can't use a class try assigning the prototype on the function as a workaround. " ..
					-- "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " ..
					-- "cannot be called with `new` by React.",
					componentName,
					componentName
					-- componentName
				)
				DidWarn.didWarnAboutModulePatternComponent[componentName] = true
			end
		end
	end

	if
		-- Run these checks in production only if the flag is off.
		-- Eventually we'll delete this branch altogether.
		not disableModulePatternComponents
		and value ~= nil
		and typeofValue == "table"
		and type(value.render) == "function"
		and value["$$typeof"] == nil
	then
		if __DEV__ then
			local componentName = getComponentName(Component) or "Unknown"
			if not DidWarn.didWarnAboutModulePatternComponent[componentName] then
				console.error(
					"The <%s /> component appears to be a function component that returns a class instance. "
						.. "Change %s to a class that extends React.Component instead. "
						-- ROBLOX deviation: Don't print JS-specific remediation advice
						-- "If you can't use a class try assigning the prototype on the function as a workaround. " ..
						-- "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " ..
						-- "cannot be called with `new` by React.",
						.. componentName,
					componentName
					-- componentName
				)
				DidWarn.didWarnAboutModulePatternComponent[componentName] = true
			end
		end

		-- Proceed under the assumption that this is a class instance
		workInProgress.tag = ClassComponent

		-- Throw out any hooks that were used.
		workInProgress.memoizedState = nil
		workInProgress.updateQueue = nil

		-- Push context providers early to prevent context stack mismatches.
		-- During mounting we don't know the child context yet as the instance doesn't exist.
		-- We will invalidate the child context in finishClassComponent() right after rendering.
		local hasContext = false
		if isLegacyContextProvider(Component) then
			hasContext = true
			pushLegacyContextProvider(workInProgress)
		else
			hasContext = false
		end

		-- deviation: Lua doesn't need to coerce `T | null | undefined` to `T | null`
		workInProgress.memoizedState = value.state

		initializeUpdateQueue(workInProgress)

		-- ROBLOX deviation: don't access field on function
		local getDerivedStateFromProps
		if type(Component) ~= "function" then
			getDerivedStateFromProps = (Component :: React_Component<any, any>).getDerivedStateFromProps
		end
		if
			getDerivedStateFromProps ~= nil
			and type(getDerivedStateFromProps) == "function"
		then
			applyDerivedStateFromProps(
				workInProgress,
				Component,
				getDerivedStateFromProps,
				props
			)
		end

		adoptClassInstance(workInProgress, value)
		mountClassInstance(workInProgress, Component, props, renderLanes)
		return finishClassComponent(
			nil,
			workInProgress,
			Component,
			true,
			hasContext,
			renderLanes
		)
	else
		-- Proceed under the assumption that this is a function component
		workInProgress.tag = FunctionComponent
		if __DEV__ then
			if disableLegacyContext and Component.contextTypes then
				console.error(
					"%s uses the legacy contextTypes API which is no longer supported. "
						.. "Use React.createContext() with React.useContext() instead.",
					getComponentName(Component) or "Unknown"
				)
			end

			if
				debugRenderPhaseSideEffectsForStrictMode
				and bit32.band(workInProgress.mode, StrictMode) ~= 0
			then
				disableLogs()
				local ok, result = xpcall(
					renderWithHooks,
					describeError,
					nil,
					workInProgress,
					Component,
					props,
					context,
					renderLanes
				)
				-- finally
				reenableLogs()
				if ok then
					value = result
				else
					error(result)
				end
			end
		end
		reconcileChildren(nil, workInProgress, value, renderLanes)
		if __DEV__ then
			validateFunctionComponentInDev(workInProgress, Component)
		end
		return workInProgress.child
	end
end

function validateFunctionComponentInDev(workInProgress: Fiber, Component: any)
	if __DEV__ then
		-- ROBLOX deviation: Lua doesn't allow fields on functions, so this never happens
		-- if Component then
		--   if Component.childContextTypes then
		--     console.error(
		--       '%s(...): childContextTypes cannot be defined on a function component.',
		--       Component.displayName or Component.name or 'Component'
		--     )
		--   end
		-- end
		if workInProgress.ref ~= nil then
			local info = ""
			local ownerName = getCurrentFiberOwnerNameInDevOrNull()
			if ownerName then
				info ..= "\n\nCheck the render method of `" .. ownerName .. "`."
			end

			local warningKey = ownerName or workInProgress._debugID or ""
			local debugSource = workInProgress._debugSource
			if debugSource then
				warningKey = debugSource.fileName .. ":" .. debugSource.lineNumber
			end
			if not DidWarn.didWarnAboutFunctionRefs[warningKey] then
				DidWarn.didWarnAboutFunctionRefs[warningKey] = true
				console.error(
					"Function components cannot be given refs. "
						.. "Attempts to access this ref will fail. "
						.. "Did you mean to use React.forwardRef()?%s",
					info
				)
			end
		end

		if
			warnAboutDefaultPropsOnFunctionComponents
			-- ROBLOX deviation: functions can't have fields in Lua
			and type(Component) ~= "function"
			and Component.defaultProps ~= nil
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName] then
				console.error(
					"%s: Support for defaultProps will be removed from function components "
						-- ROBLOX deviation: Don't print JS-specific remediation advice
						.. "in a future major release.", -- Use JavaScript default parameters instead.',
					componentName
				)
				DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true
			end
		end

		-- ROBLOX deviation: Lua functions can't have fields
		if
			type(Component) ~= "function"
			and Component.getDerivedStateFromProps ~= nil
			and type(Component.getDerivedStateFromProps) == "function"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if
				not DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName]
			then
				console.error(
					"%s: Function components do not support getDerivedStateFromProps.",
					componentName
				)
				DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName] =
					true
			end
		end

		-- ROBLOX deviation: Lua functions can't have fields
		if
			type(Component) ~= "function"
			and Component.contextType ~= nil
			and type(Component.contextType) == "table"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName] then
				console.error(
					"%s: Function components do not support contextType.",
					componentName
				)
				DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName] = true
			end
		end
	end
end

local SUSPENDED_MARKER: SuspenseState = {
	dehydrated = nil,
	retryLane = ReactFiberLane.NoLane,
}

local function mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState
	return {
		baseLanes = renderLanes,
	}
end

local function updateSuspenseOffscreenState(
	prevOffscreenState: OffscreenState,
	renderLanes: Lanes
): OffscreenState
	return {
		baseLanes = ReactFiberLane.mergeLanes(prevOffscreenState.baseLanes, renderLanes),
	}
end

-- TODO: Probably should inline this back
local function shouldRemainOnFallback(
	suspenseContext: SuspenseContext,
	current: nil | Fiber,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	-- If we're already showing a fallback, there are cases where we need to
	-- remain on that fallback regardless of whether the content has resolved.
	-- For example, SuspenseList coordinates when nested content appears.
	if current ~= nil then
		local suspenseState: SuspenseState = (current :: Fiber).memoizedState
		if suspenseState == nil then
			-- Currently showing content. Don't hide it, even if ForceSuspenseFallack
			-- is true. More precise name might be "ForceRemainSuspenseFallback".
			-- Note: This is a factoring smell. Can't remain on a fallback if there's
			-- no fallback to remain on.
			return false
		end
	end

	-- Not currently showing content. Consult the Suspense context.
	return hasSuspenseContext(suspenseContext, ForceSuspenseFallback)
end

local function getRemainingWorkInPrimaryTree(current: Fiber, renderLanes)
	-- TODO: Should not remove render lanes that were pinged during this render
	return ReactFiberLane.removeLanes(current.childLanes, renderLanes)
end

-- ROBLOX deviation: predeclare these methods to resolve method declaration ordering
local updateSuspensePrimaryChildren
local mountDehydratedSuspenseComponent
local mountSuspensePrimaryChildren
local updateSuspenseFallbackChildren
local updateDehydratedSuspenseComponent

local function updateSuspenseComponent(current, workInProgress, renderLanes)
	local nextProps = workInProgress.pendingProps

	-- This is used by DevTools to force a boundary to suspend.
	if __DEV__ then
		if shouldSuspend(workInProgress) then
			workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
		end
	end

	local suspenseContext: SuspenseContext = suspenseStackCursor.current

	local showFallback = false
	local didSuspend = bit32.band(workInProgress.flags, DidCapture) ~= NoFlags

	if
		didSuspend
		or shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes)
	then
		-- Something in this boundary's subtree already suspended. Switch to
		-- rendering the fallback children.
		showFallback = true
		workInProgress.flags = bit32.band(workInProgress.flags, bit32.bnot(DidCapture))
	else
		-- Attempting the main content
		if current == nil or current.memoizedState ~= nil then
			-- This is a new mount or this boundary is already showing a fallback state.
			-- Mark this subtree context as having at least one invisible parent that could
			-- handle the fallback state.
			-- Boundaries without fallbacks or should be avoided are not considered since
			-- they cannot handle preferred fallback states.
			if
				nextProps.fallback ~= nil
				and nextProps.unstable_avoidThisFallback ~= true
			then
				suspenseContext = addSubtreeSuspenseContext(
					suspenseContext,
					InvisibleParentSuspenseContext
				)
			end
		end
	end

	suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)

	pushSuspenseContext(workInProgress, suspenseContext)

	-- OK, the next part is confusing. We're about to reconcile the Suspense
	-- boundary's children. This involves some custom reconcilation logic. Two
	-- main reasons this is so complicated.
	--
	-- First, Legacy Mode has different semantics for backwards compatibility. The
	-- primary tree will commit in an inconsistent state, so when we do the
	-- second pass to render the fallback, we do some exceedingly, uh, clever
	-- hacks to make that not totally break. Like transferring effects and
	-- deletions from hidden tree. In Concurrent Mode, it's much simpler,
	-- because we bailout on the primary tree completely and leave it in its old
	-- state, no effects. Same as what we do for Offscreen (except that
	-- Offscreen doesn't have the first render pass).
	--
	-- Second is hydration. During hydration, the Suspense fiber has a slightly
	-- different layout, where the child points to a dehydrated fragment, which
	-- contains the DOM rendered by the server.
	--
	-- Third, even if you set all that aside, Suspense is like error boundaries in
	-- that we first we try to render one tree, and if that fails, we render again
	-- and switch to a different tree. Like a try/catch block. So we have to track
	-- which branch we're currently rendering. Ideally we would model this using
	-- a stack.
	if current == nil then
		-- Initial mount
		-- If we're currently hydrating, try to hydrate this boundary.
		-- But only if this has a fallback.
		if nextProps.fallback ~= nil then
			tryToClaimNextHydratableInstance(workInProgress)
			-- This could've been a dehydrated suspense component.
			if enableSuspenseServerRenderer then
				local suspenseState: nil | SuspenseState = workInProgress.memoizedState
				if suspenseState ~= nil then
					local dehydrated = (suspenseState :: SuspenseState).dehydrated
					if dehydrated ~= nil then
						return mountDehydratedSuspenseComponent(
							workInProgress,
							dehydrated,
							renderLanes
						)
					end
				end
			end
		end

		local nextPrimaryChildren = nextProps.children
		local nextFallbackChildren = nextProps.fallback
		if showFallback then
			local fallbackFragment = mountSuspenseFallbackChildren(
				workInProgress,
				nextPrimaryChildren,
				nextFallbackChildren,
				renderLanes
			)
			local primaryChildFragment: Fiber = workInProgress.child :: any
			primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
			workInProgress.memoizedState = SUSPENDED_MARKER
			return fallbackFragment
		elseif
			nextProps.unstable_expectedLoadTime ~= nil
			and type(nextProps.unstable_expectedLoadTime) == "number"
		then
			-- This is a CPU-bound tree. Skip this tree and show a placeholder to
			-- unblock the surrounding content. Then immediately retry after the
			-- initial commit.
			local fallbackFragment = mountSuspenseFallbackChildren(
				workInProgress,
				nextPrimaryChildren,
				nextFallbackChildren,
				renderLanes
			)
			local primaryChildFragment: Fiber = workInProgress.child :: any
			primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
			workInProgress.memoizedState = SUSPENDED_MARKER

			-- Since nothing actually suspended, there will nothing to ping this to
			-- get it started back up to attempt the next item. While in terms of
			-- priority this work has the same priority as this current render, it's
			-- not part of the same transition once the transition has committed. If
			-- it's sync, we still want to yield so that it can be painted.
			-- Conceptually, this is really the same as pinging. We can use any
			-- RetryLane even if it's the one currently rendering since we're leaving
			-- it behind on this node.
			workInProgress.lanes = ReactFiberLane.SomeRetryLane
			if enableSchedulerTracing then
				markSpawnedWork(ReactFiberLane.SomeRetryLane)
			end
			return fallbackFragment
		else
			return mountSuspensePrimaryChildren(
				workInProgress,
				nextPrimaryChildren,
				renderLanes
			)
		end
	else
		-- This is an update.

		-- If the current fiber has a SuspenseState, that means it's already showing
		-- a fallback.
		local prevState: nil | SuspenseState = current.memoizedState
		if prevState ~= nil then
			-- The current tree is already showing a fallback

			-- Special path for hydration
			if enableSuspenseServerRenderer then
				-- ROBLOX FIXME: remove :: when Luau understands ~= nil
				local dehydrated = (prevState :: SuspenseState).dehydrated

				if dehydrated ~= nil then
					if not didSuspend then
						return updateDehydratedSuspenseComponent(
							current,
							workInProgress,
							dehydrated,
							prevState,
							renderLanes
						)
					elseif workInProgress.memoizedState ~= nil then
						-- Something suspended and we should still be in dehydrated mode.
						-- Leave the existing child in place.
						workInProgress.child = current.child
						-- The dehydrated completion pass expects this flag to be there
						-- but the normal suspense pass doesn't.
						workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
						return nil
					else
						-- Suspended but we should no longer be in dehydrated mode.
						-- Therefore we now have to render the fallback.
						local nextPrimaryChildren = nextProps.children
						local nextFallbackChildren = nextProps.fallback
						local fallbackChildFragment =
							mountSuspenseFallbackAfterRetryWithoutHydrating(
								current,
								workInProgress,
								nextPrimaryChildren,
								nextFallbackChildren,
								renderLanes
							)
						local primaryChildFragment: Fiber = workInProgress.child :: any
						primaryChildFragment.memoizedState =
							mountSuspenseOffscreenState(renderLanes)
						workInProgress.memoizedState = SUSPENDED_MARKER
						return fallbackChildFragment
					end
				end
			end

			if showFallback then
				local nextFallbackChildren = nextProps.fallback
				local nextPrimaryChildren = nextProps.children
				local fallbackChildFragment = updateSuspenseFallbackChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					nextFallbackChildren,
					renderLanes
				)
				local primaryChildFragment: Fiber = workInProgress.child :: any
				local prevOffscreenState: OffscreenState | nil = (current.child :: any).memoizedState

				-- ROBLOX deviation: if/else in place of ternary
				if prevOffscreenState == nil then
					primaryChildFragment.memoizedState =
						mountSuspenseOffscreenState(renderLanes)
				else
					-- ROBLOX FIXME: remove :: when Luau understands ~= nil
					primaryChildFragment.memoizedState = updateSuspenseOffscreenState(
						prevOffscreenState :: OffscreenState,
						renderLanes
					)
				end

				primaryChildFragment.childLanes =
					getRemainingWorkInPrimaryTree(current, renderLanes)
				workInProgress.memoizedState = SUSPENDED_MARKER
				return fallbackChildFragment
			else
				local nextPrimaryChildren = nextProps.children
				local primaryChildFragment = updateSuspensePrimaryChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					renderLanes
				)
				workInProgress.memoizedState = nil
				return primaryChildFragment
			end
		else
			-- The current tree is not already showing a fallback.
			if showFallback then
				-- Timed out.
				local nextFallbackChildren = nextProps.fallback
				local nextPrimaryChildren = nextProps.children
				local fallbackChildFragment = updateSuspenseFallbackChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					nextFallbackChildren,
					renderLanes
				)
				local primaryChildFragment: Fiber = workInProgress.child :: any
				local prevOffscreenState: OffscreenState | nil = (current.child :: any).memoizedState

				-- ROBLOX deviation: if/else in place of ternary
				if prevOffscreenState == nil then
					primaryChildFragment.memoizedState =
						mountSuspenseOffscreenState(renderLanes)
				else
					-- ROBLOX FIXME: remove :: once Luau understands nil check
					primaryChildFragment.memoizedState = updateSuspenseOffscreenState(
						prevOffscreenState :: OffscreenState,
						renderLanes
					)
				end

				primaryChildFragment.childLanes =
					getRemainingWorkInPrimaryTree(current, renderLanes)
				-- Skip the primary children, and continue working on the
				-- fallback children.
				workInProgress.memoizedState = SUSPENDED_MARKER
				return fallbackChildFragment
			else
				-- Still haven't timed out. Continue rendering the children, like we
				-- normally do.
				local nextPrimaryChildren = nextProps.children
				local primaryChildFragment = updateSuspensePrimaryChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					renderLanes
				)
				workInProgress.memoizedState = nil
				return primaryChildFragment
			end
		end
	end
end

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
	local mode = workInProgress.mode
	local primaryChildProps: OffscreenProps = {
		mode = "visible",
		children = primaryChildren,
	}
	local primaryChildFragment =
		createFiberFromOffscreen(primaryChildProps, mode, renderLanes, nil)
	primaryChildFragment.return_ = workInProgress
	workInProgress.child = primaryChildFragment
	return primaryChildFragment
end

function mountSuspenseFallbackChildren(
	workInProgress,
	primaryChildren,
	fallbackChildren,
	renderLanes
)
	local mode = workInProgress.mode
	local progressedPrimaryFragment: Fiber | nil = workInProgress.child

	local primaryChildProps: OffscreenProps = {
		mode = "hidden",
		children = primaryChildren,
	}

	local primaryChildFragment
	local fallbackChildFragment
	if bit32.band(mode, BlockingMode) == NoMode and progressedPrimaryFragment ~= nil then
		-- In legacy mode, we commit the primary tree as if it successfully
		-- completed, even though it's in an inconsistent state.
		primaryChildFragment = progressedPrimaryFragment
		primaryChildFragment.childLanes = ReactFiberLane.NoLanes
		primaryChildFragment.pendingProps = primaryChildProps

		if enableProfilerTimer and bit32.band(workInProgress.mode, ProfileMode) ~= 0 then
			-- Reset the durations from the first pass so they aren't included in the
			-- final amounts. This seems counterintuitive, since we're intentionally
			-- not measuring part of the render phase, but this makes it match what we
			-- do in Concurrent Mode.
			primaryChildFragment.actualDuration = 0
			primaryChildFragment.actualStartTime = -1
			primaryChildFragment.selfBaseDuration = 0
			primaryChildFragment.treeBaseDuration = 0
		end

		fallbackChildFragment =
			createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	else
		primaryChildFragment =
			createFiberFromOffscreen(primaryChildProps, mode, ReactFiberLane.NoLanes, nil)
		fallbackChildFragment =
			createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	end

	primaryChildFragment.return_ = workInProgress
	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment
	return fallbackChildFragment
end

local function createWorkInProgressOffscreenFiber(
	current: Fiber,
	offscreenProps: OffscreenProps
)
	-- The props argument to `createWorkInProgress` is `any` typed, so we use this
	-- wrapper function to constrain it.
	return createWorkInProgress(current, offscreenProps)
end

function updateSuspensePrimaryChildren(
	current,
	workInProgress,
	primaryChildren,
	renderLanes
)
	local currentPrimaryChildFragment: Fiber = current.child :: any
	local currentFallbackChildFragment: Fiber | nil = currentPrimaryChildFragment.sibling

	local primaryChildFragment =
		createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
			mode = "visible",
			children = primaryChildren,
		})
	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		primaryChildFragment.lanes = renderLanes
	end
	primaryChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = nil
	if currentFallbackChildFragment ~= nil then
		-- Delete the fallback child fragment
		local deletions = workInProgress.deletions
		if deletions == nil then
			workInProgress.deletions = { currentFallbackChildFragment }
			-- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
			workInProgress.flags = bit32.bor(workInProgress.flags, Deletion)
		else
			table.insert(deletions, currentFallbackChildFragment)
		end
	end

	workInProgress.child = primaryChildFragment
	return primaryChildFragment
end

function updateSuspenseFallbackChildren(
	current,
	workInProgress,
	primaryChildren,
	fallbackChildren,
	renderLanes
)
	local mode = workInProgress.mode
	local currentPrimaryChildFragment: Fiber = current.child :: any
	local currentFallbackChildFragment: Fiber | nil = currentPrimaryChildFragment.sibling

	local primaryChildProps: OffscreenProps = {
		mode = "hidden",
		children = primaryChildren,
	}

	local primaryChildFragment
	if
		-- In legacy mode, we commit the primary tree as if it successfully
		-- completed, even though it's in an inconsistent state.
		bit32.band(mode, BlockingMode) == NoMode
		-- Make sure we're on the second pass, i.e. the primary child fragment was
		-- already cloned. In legacy mode, the only case where this isn't true is
		-- when DevTools forces us to display a fallback; we skip the first render
		-- pass entirely and go straight to rendering the fallback. (In Concurrent
		-- Mode, SuspenseList can also trigger this scenario, but this is a legacy-
		-- only codepath.)
		and workInProgress.child ~= currentPrimaryChildFragment
	then
		local progressedPrimaryFragment: Fiber = workInProgress.child
		primaryChildFragment = progressedPrimaryFragment
		primaryChildFragment.childLanes = ReactFiberLane.NoLanes
		primaryChildFragment.pendingProps = primaryChildProps

		if enableProfilerTimer and bit32.band(workInProgress.mode, ProfileMode) ~= 0 then
			-- Reset the durations from the first pass so they aren't included in the
			-- final amounts. This seems counterintuitive, since we're intentionally
			-- not measuring part of the render phase, but this makes it match what we
			-- do in Concurrent Mode.
			primaryChildFragment.actualDuration = 0
			primaryChildFragment.actualStartTime = -1
			primaryChildFragment.selfBaseDuration =
				currentPrimaryChildFragment.selfBaseDuration
			primaryChildFragment.treeBaseDuration =
				currentPrimaryChildFragment.treeBaseDuration
		end

		-- The fallback fiber was added as a deletion effect during the first pass.
		-- However, since we're going to remain on the fallback, we no longer want
		-- to delete it.
		workInProgress.deletions = nil
	else
		primaryChildFragment = createWorkInProgressOffscreenFiber(
			currentPrimaryChildFragment,
			primaryChildProps
		)

		-- Since we're reusing a current tree, we need to reuse the flags, too.
		-- (We don't do this in legacy mode, because in legacy mode we don't re-use
		-- the current tree; see previous branch.)
		primaryChildFragment.subtreeFlags =
			bit32.band(currentPrimaryChildFragment.subtreeFlags, StaticMask)
	end
	local fallbackChildFragment
	if currentFallbackChildFragment ~= nil then
		fallbackChildFragment =
			createWorkInProgress(currentFallbackChildFragment, fallbackChildren)
	else
		fallbackChildFragment =
			createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
		-- Needs a placement effect because the parent (the Suspense boundary) already
		-- mounted but this is a new fiber.
		fallbackChildFragment.flags = bit32.bor(fallbackChildFragment.flags, Placement)
	end

	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment

	return fallbackChildFragment
end

local function retrySuspenseComponentWithoutHydrating(
	current: Fiber,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	-- This will add the old fiber to the deletion list
	reconcileChildFibers(workInProgress, current.child, nil, renderLanes)

	-- We're now not suspended nor dehydrated.
	local nextProps = workInProgress.pendingProps
	local primaryChildren = nextProps.children
	local primaryChildFragment =
		mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
	-- Needs a placement effect because the parent (the Suspense boundary) already
	-- mounted but this is a new fiber.
	primaryChildFragment.flags = bit32.bor(primaryChildFragment.flags, Placement)
	workInProgress.memoizedState = nil

	return primaryChildFragment
end

function mountSuspenseFallbackAfterRetryWithoutHydrating(
	current,
	workInProgress,
	primaryChildren,
	fallbackChildren,
	renderLanes
)
	local mode = workInProgress.mode
	local primaryChildFragment =
		createFiberFromOffscreen(primaryChildren, mode, ReactFiberLane.NoLanes, nil)
	local fallbackChildFragment =
		createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	-- Needs a placement effect because the parent (the Suspense
	-- boundary) already mounted but this is a new fiber.
	fallbackChildFragment.flags = bit32.bor(fallbackChildFragment.flags, Placement)

	primaryChildFragment.return_ = workInProgress
	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment

	if bit32.band(workInProgress.mode, BlockingMode) ~= NoMode then
		-- We will have dropped the effect list which contains the
		-- deletion. We need to reconcile to delete the current child.
		reconcileChildFibers(workInProgress, current.child, nil, renderLanes)
	end

	return fallbackChildFragment
end

function mountDehydratedSuspenseComponent(
	workInProgress: Fiber,
	suspenseInstance: SuspenseInstance,
	renderLanes: Lanes
): nil | Fiber
	-- During the first pass, we'll bail out and not drill into the children.
	-- Instead, we'll leave the content in place and try to hydrate it later.
	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		if __DEV__ then
			console.error(
				"Cannot hydrate Suspense in legacy mode. Switch from"
					.. "ReactDOM.hydrate(element, container) to "
					.. "ReactDOM.createBlockingRoot(container, { hydrate: true })"
					.. ".render(element) or remove the Suspense components"
					.. "the server rendered components."
			)
		end
		workInProgress.lanes = ReactFiberLane.laneToLanes(ReactFiberLane.SyncLane)
	elseif isSuspenseInstanceFallback(suspenseInstance) then
		-- This is a client-only boundary. Since we won't get any content from the server
		-- for this, we need to schedule that at a higher priority based on when it would
		-- have timed out. In theory we could render it in this pass but it would have the
		-- wrong priority associated with it and will prevent hydration of parent path.
		-- Instead, we'll leave work left on it to render it in a separate commit.

		-- TODO This time should be the time at which the server rendered response that is
		-- a parent to this boundary was displayed. However, since we currently don't have
		-- a protocol to transfer that time, we'll just estimate it by using the current
		-- time. This will mean that Suspense timeouts are slightly shifted to later than
		-- they should be.
		-- Schedule a normal pri update to render this content.
		if enableSchedulerTracing then
			markSpawnedWork(ReactFiberLane.DefaultHydrationLane)
		end
		workInProgress.lanes =
			ReactFiberLane.laneToLanes(ReactFiberLane.DefaultHydrationLane)
	else
		-- We'll continue hydrating the rest at offscreen priority since we'll already
		-- be showing the right content coming from the server, it is no rush.
		workInProgress.lanes = ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane)
		if enableSchedulerTracing then
			markSpawnedWork(ReactFiberLane.OffscreenLane)
		end
	end
	return nil
end

function updateDehydratedSuspenseComponent(
	current: Fiber,
	workInProgress: Fiber,
	suspenseInstance: SuspenseInstance,
	suspenseState: SuspenseState,
	renderLanes: Lanes
): nil | Fiber
	-- We should never be hydrating at this point because it is the first pass,
	-- but after we've already committed once.
	warnIfHydrating()

	if bit32.band(getExecutionContext(), RetryAfterError) ~= NoContext then
		return retrySuspenseComponentWithoutHydrating(
			current,
			workInProgress,
			renderLanes
		)
	end

	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		return retrySuspenseComponentWithoutHydrating(
			current,
			workInProgress,
			renderLanes
		)
	end

	if isSuspenseInstanceFallback(suspenseInstance) then
		-- This boundary is in a permanent fallback state. In this case, we'll never
		-- get an update and we'll never be able to hydrate the final content. Let's just try the
		-- client side render instead.
		return retrySuspenseComponentWithoutHydrating(
			current,
			workInProgress,
			renderLanes
		)
	end
	-- We use lanes to indicate that a child might depend on context, so if
	-- any context has changed, we need to treat is as if the input might have changed.
	local hasContextChanged =
		ReactFiberLane.includesSomeLane(renderLanes, current.childLanes)
	if didReceiveUpdate or hasContextChanged then
		-- This boundary has changed since the first render. This means that we are now unable to
		-- hydrate it. We might still be able to hydrate it using a higher priority lane.
		local root = getWorkInProgressRoot()
		if root ~= nil then
			local attemptHydrationAtLane =
				ReactFiberLane.getBumpedLaneForHydration(root, renderLanes)
			if
				attemptHydrationAtLane ~= ReactFiberLane.NoLane
				and attemptHydrationAtLane ~= suspenseState.retryLane
			then
				-- Intentionally mutating since this render will get interrupted. This
				-- is one of the very rare times where we mutate the current tree
				-- during the render phase.
				suspenseState.retryLane = attemptHydrationAtLane
				-- TODO: Ideally this would inherit the event time of the current render
				local eventTime = ReactFiberLane.NoTimestamp
				scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime)
			else
				-- We have already tried to ping at a higher priority than we're rendering with
				-- so if we got here, we must have failed to hydrate at those levels. We must
				-- now give up. Instead, we're going to delete the whole subtree and instead inject
				-- a new real Suspense boundary to take its place, which may render content
				-- or fallback. This might suspend for a while and if it does we might still have
				-- an opportunity to hydrate before this pass commits.
			end
		end

		-- If we have scheduled higher pri work above, this will probably just abort the render
		-- since we now have higher priority work, but in case it doesn't, we need to prepare to
		-- render something, if we time out. Even if that requires us to delete everything and
		-- skip hydration.
		-- Delay having to do this as long as the suspense timeout allows us.
		renderDidSuspendDelayIfPossible()
		return retrySuspenseComponentWithoutHydrating(
			current,
			workInProgress,
			renderLanes
		)
	elseif isSuspenseInstancePending(suspenseInstance) then
		-- This component is still pending more data from the server, so we can't hydrate its
		-- content. We treat it as if this component suspended itself. It might seem as if
		-- we could just try to render it client-side instead. However, this will perform a
		-- lot of unnecessary work and is unlikely to complete since it often will suspend
		-- on missing data anyway. Additionally, the server might be able to render more
		-- than we can on the client yet. In that case we'd end up with more fallback states
		-- on the client than if we just leave it alone. If the server times out or errors
		-- these should update this boundary to the permanent Fallback state instead.
		-- Mark it as having captured (i.e. suspended).
		workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
		-- Leave the child in place. I.e. the dehydrated fragment.
		workInProgress.child = current.child

		-- Register a callback to retry this boundary once the server has sent the result.
		-- ROBLOX deviation: wrapper function in place of bind
		local retry = function()
			return retryDehydratedSuspenseBoundary(current)
		end

		if enableSchedulerTracing then
			if Schedule_tracing_wrap == nil then
				Schedule_tracing_wrap = require(Packages.Scheduler).tracing.unstable_wrap
			end
			retry = Schedule_tracing_wrap(retry)
		end

		registerSuspenseInstanceRetry(suspenseInstance, retry)
		return nil
	else
		-- This is the first attempt.
		reenterHydrationStateFromDehydratedSuspenseInstance(
			workInProgress,
			suspenseInstance
		)
		local nextProps = workInProgress.pendingProps
		local primaryChildren = nextProps.children
		local primaryChildFragment =
			mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
		-- Mark the children as hydrating. This is a fast path to know whether this
		-- tree is part of a hydrating tree. This is used to determine if a child
		-- node has fully mounted yet, and for scheduling event replaying.
		-- Conceptually this is similar to Placement in that a new subtree is
		-- inserted into the React tree here. It just happens to not need DOM
		-- mutations because it already exists.
		primaryChildFragment.flags = bit32.bor(primaryChildFragment.flags, Hydrating)
		return primaryChildFragment
	end
end

-- function scheduleWorkOnFiber(fiber: Fiber, renderLanes: Lanes)
--   fiber.lanes = ReactFiberLane.mergeLanes(fiber.lanes, renderLanes)
--   local alternate = fiber.alternate
--   if alternate ~= nil)
--     alternate.lanes = ReactFiberLane.mergeLanes(alternate.lanes, renderLanes)
--   end
--   scheduleWorkOnParentPath(fiber.return, renderLanes)
-- end

-- function propagateSuspenseContextChange(
--   workInProgress: Fiber,
--   firstChild: nil | Fiber,
--   renderLanes: Lanes,
-- ): void {
--   -- Mark any Suspense boundaries with fallbacks as having work to do.
--   -- If they were previously forced into fallbacks, they may now be able
--   -- to unblock.
--   local node = firstChild
--   while (node ~= nil)
--     if node.tag == SuspenseComponent)
--       local state: SuspenseState | nil = node.memoizedState
--       if state ~= nil)
--         scheduleWorkOnFiber(node, renderLanes)
--       end
--     } elseif node.tag == SuspenseListComponent)
--       -- If the tail is hidden there might not be an Suspense boundaries
--       -- to schedule work on. In this case we have to schedule it on the
--       -- list itself.
--       -- We don't have to traverse to the children of the list since
--       -- the list will propagate the change when it rerenders.
--       scheduleWorkOnFiber(node, renderLanes)
--     } elseif node.child ~= nil)
--       node.child.return = node
--       node = node.child
--       continue
--     end
--     if node == workInProgress)
--       return
--     end
--     while (node.sibling == nil)
--       if node.return == nil or node.return == workInProgress)
--         return
--       end
--       node = node.return
--     end
--     node.sibling.return = node.return
--     node = node.sibling
--   end
-- end

-- function findLastContentRow(firstChild: nil | Fiber): nil | Fiber {
--   -- This is going to find the last row among these children that is already
--   -- showing content on the screen, as opposed to being in fallback state or
--   -- new. If a row has multiple Suspense boundaries, any of them being in the
--   -- fallback state, counts as the whole row being in a fallback state.
--   -- Note that the "rows" will be workInProgress, but any nested children
--   -- will still be current since we haven't rendered them yet. The mounted
--   -- order may not be the same as the new order. We use the new order.
--   local row = firstChild
--   local lastContentRow: nil | Fiber = nil
--   while (row ~= nil)
--     local currentRow = row.alternate
--     -- New rows can't be content rows.
--     if currentRow ~= nil and findFirstSuspended(currentRow) == nil)
--       lastContentRow = row
--     end
--     row = row.sibling
--   end
--   return lastContentRow
-- end

-- type SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void

-- function validateRevealOrder(revealOrder: SuspenseListRevealOrder)
--   if  __DEV__ then
--     if
--       revealOrder ~= undefined and
--       revealOrder ~= 'forwards' and
--       revealOrder ~= 'backwards' and
--       revealOrder ~= 'together' and
--       !didWarnAboutRevealOrder[revealOrder]
--     )
--       didWarnAboutRevealOrder[revealOrder] = true
--       if typeof revealOrder == 'string')
--         switch (revealOrder.toLowerCase())
--           case 'together':
--           case 'forwards':
--           case 'backwards': {
--             console.error(
--               '"%s" is not a valid value for revealOrder on <SuspenseList />. ' +
--                 'Use lowercase "%s" instead.',
--               revealOrder,
--               revealOrder.toLowerCase(),
--             )
--             break
--           end
--           case 'forward':
--           case 'backward': {
--             console.error(
--               '"%s" is not a valid value for revealOrder on <SuspenseList />. ' +
--                 'React uses the -s suffix in the spelling. Use "%ss" instead.',
--               revealOrder,
--               revealOrder.toLowerCase(),
--             )
--             break
--           end
--           default:
--             console.error(
--               '"%s" is not a supported revealOrder on <SuspenseList />. ' +
--                 'Did you mean "together", "forwards" or "backwards"?',
--               revealOrder,
--             )
--             break
--         end
--       else
--         console.error(
--           '%s is not a supported value for revealOrder on <SuspenseList />. ' +
--             'Did you mean "together", "forwards" or "backwards"?',
--           revealOrder,
--         )
--       end
--     end
--   end
-- end

-- function validateTailOptions(
--   tailMode: SuspenseListTailMode,
--   revealOrder: SuspenseListRevealOrder,
-- )
--   if  __DEV__ then
--     if tailMode ~= undefined and !didWarnAboutTailOptions[tailMode])
--       if tailMode ~= 'collapsed' and tailMode ~= 'hidden')
--         didWarnAboutTailOptions[tailMode] = true
--         console.error(
--           '"%s" is not a supported value for tail on <SuspenseList />. ' +
--             'Did you mean "collapsed" or "hidden"?',
--           tailMode,
--         )
--       } elseif revealOrder ~= 'forwards' and revealOrder ~= 'backwards')
--         didWarnAboutTailOptions[tailMode] = true
--         console.error(
--           '<SuspenseList tail="%s" /> is only valid if revealOrder is ' +
--             '"forwards" or "backwards". ' +
--             'Did you mean to specify revealOrder="forwards"?',
--           tailMode,
--         )
--       end
--     end
--   end
-- end

-- function validateSuspenseListNestedChild(childSlot: mixed, index: number)
--   if  __DEV__ then
--     local isArray = Array.isArray(childSlot)
--     local isIterable =
--       !isArray and typeof getIteratorFn(childSlot) == 'function'
--     if isArray or isIterable)
--       local type = isArray ? 'array' : 'iterable'
--       console.error(
--         'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +
--           'an additional SuspenseList to configure its revealOrder: ' +
--           '<SuspenseList revealOrder=...> ... ' +
--           '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +
--           '</SuspenseList>',
--         type,
--         index,
--         type,
--       )
--       return false
--     end
--   end
--   return true
-- end

-- function validateSuspenseListChildren(
--   children: mixed,
--   revealOrder: SuspenseListRevealOrder,
-- )
--   if  __DEV__ then
--     if
--       (revealOrder == 'forwards' or revealOrder == 'backwards') and
--       children ~= undefined and
--       children ~= nil and
--       children ~= false
--     )
--       if Array.isArray(children))
--         for (local i = 0; i < children.length; i++)
--           if not validateSuspenseListNestedChild(children[i], i))
--             return
--           end
--         end
--       else
--         local iteratorFn = getIteratorFn(children)
--         if typeof iteratorFn == 'function')
--           local childrenIterator = iteratorFn.call(children)
--           if childrenIterator)
--             local step = childrenIterator.next()
--             local i = 0
--             for (; !step.done; step = childrenIterator.next())
--               if not validateSuspenseListNestedChild(step.value, i))
--                 return
--               end
--               i++
--             end
--           end
--         else
--           console.error(
--             'A single row was passed to a <SuspenseList revealOrder="%s" />. ' +
--               'This is not useful since it needs multiple rows. ' +
--               'Did you mean to pass multiple children or an array?',
--             revealOrder,
--           )
--         end
--       end
--     end
--   end
-- end

-- function initSuspenseListRenderState(
--   workInProgress: Fiber,
--   isBackwards: boolean,
--   tail: nil | Fiber,
--   lastContentRow: nil | Fiber,
--   tailMode: SuspenseListTailMode,
-- ): void {
--   local renderState: nil | SuspenseListRenderState =
--     workInProgress.memoizedState
--   if renderState == nil)
--     workInProgress.memoizedState = ({
--       isBackwards: isBackwards,
--       rendering: nil,
--       renderingStartTime: 0,
--       last: lastContentRow,
--       tail: tail,
--       tailMode: tailMode,
--     }: SuspenseListRenderState)
--   else
--     -- We can reuse the existing object from previous renders.
--     renderState.isBackwards = isBackwards
--     renderState.rendering = nil
--     renderState.renderingStartTime = 0
--     renderState.last = lastContentRow
--     renderState.tail = tail
--     renderState.tailMode = tailMode
--   end
-- end

-- -- This can end up rendering this component multiple passes.
-- -- The first pass splits the children fibers into two sets. A head and tail.
-- -- We first render the head. If anything is in fallback state, we do another
-- -- pass through beginWork to rerender all children (including the tail) with
-- -- the force suspend context. If the first render didn't have anything in
-- -- in fallback state. Then we render each row in the tail one-by-one.
-- -- That happens in the completeWork phase without going back to beginWork.
-- function updateSuspenseListComponent(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes,
-- )
--   local nextProps = workInProgress.pendingProps
--   local revealOrder: SuspenseListRevealOrder = nextProps.revealOrder
--   local tailMode: SuspenseListTailMode = nextProps.tail
--   local newChildren = nextProps.children

--   validateRevealOrder(revealOrder)
--   validateTailOptions(tailMode, revealOrder)
--   validateSuspenseListChildren(newChildren, revealOrder)

--   reconcileChildren(current, workInProgress, newChildren, renderLanes)

--   local suspenseContext: SuspenseContext = suspenseStackCursor.current

--   local shouldForceFallback = hasSuspenseContext(
--     suspenseContext,
--     (ForceSuspenseFallback: SuspenseContext),
--   )
--   if shouldForceFallback)
--     suspenseContext = setShallowSuspenseContext(
--       suspenseContext,
--       ForceSuspenseFallback,
--     )
--     workInProgress.flags |= DidCapture
--   else
--     local didSuspendBefore =
--       current ~= nil and (current.flags & DidCapture) ~= NoFlags
--     if didSuspendBefore)
--       -- If we previously forced a fallback, we need to schedule work
--       -- on any nested boundaries to local them know to try to render
--       -- again. This is the same as context updating.
--       propagateSuspenseContextChange(
--         workInProgress,
--         workInProgress.child,
--         renderLanes,
--       )
--     end
--     suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
--   end
--   pushSuspenseContext(workInProgress, suspenseContext)

--   if (workInProgress.mode & BlockingMode) == NoMode)
--     -- In legacy mode, SuspenseList doesn't work so we just
--     -- use make it a noop by treating it as the default revealOrder.
--     workInProgress.memoizedState = nil
--   else
--     switch (revealOrder)
--       case 'forwards': {
--         local lastContentRow = findLastContentRow(workInProgress.child)
--         local tail
--         if lastContentRow == nil)
--           -- The whole list is part of the tail.
--           -- TODO: We could fast path by just rendering the tail now.
--           tail = workInProgress.child
--           workInProgress.child = nil
--         else
--           -- Disconnect the tail rows after the content row.
--           -- We're going to render them separately later.
--           tail = lastContentRow.sibling
--           lastContentRow.sibling = nil
--         end
--         initSuspenseListRenderState(
--           workInProgress,
--           false, -- isBackwards
--           tail,
--           lastContentRow,
--           tailMode,
--         )
--         break
--       end
--       case 'backwards': {
--         -- We're going to find the first row that has existing content.
--         -- At the same time we're going to reverse the list of everything
--         -- we pass in the meantime. That's going to be our tail in reverse
--         -- order.
--         local tail = nil
--         local row = workInProgress.child
--         workInProgress.child = nil
--         while (row ~= nil)
--           local currentRow = row.alternate
--           -- New rows can't be content rows.
--           if currentRow ~= nil and findFirstSuspended(currentRow) == nil)
--             -- This is the beginning of the main content.
--             workInProgress.child = row
--             break
--           end
--           local nextRow = row.sibling
--           row.sibling = tail
--           tail = row
--           row = nextRow
--         end
--         -- TODO: If workInProgress.child is nil, we can continue on the tail immediately.
--         initSuspenseListRenderState(
--           workInProgress,
--           true, -- isBackwards
--           tail,
--           nil, -- last
--           tailMode,
--         )
--         break
--       end
--       case 'together': {
--         initSuspenseListRenderState(
--           workInProgress,
--           false, -- isBackwards
--           nil, -- tail
--           nil, -- last
--           undefined,
--         )
--         break
--       end
--       default: {
--         -- The default reveal order is the same as not having
--         -- a boundary.
--         workInProgress.memoizedState = nil
--       end
--     end
--   end
--   return workInProgress.child
-- end

function updatePortalComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo)
	local nextChildren = workInProgress.pendingProps
	if current == nil then
		-- Portals are special because we don't append the children during mount
		-- but at commit. Therefore we need to track insertions which the normal
		-- flow doesn't do during mount. This doesn't happen at the root because
		-- the root always starts with a "current" with a nil child.
		-- TODO: Consider unifying this with how the root works.
		workInProgress.child =
			reconcileChildFibers(workInProgress, nil, nextChildren, renderLanes)
	else
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	end
	return workInProgress.child
end

local hasWarnedAboutUsingNoValuePropOnContextProvider = false

local function updateContextProvider(
	current: Fiber | nil,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	local providerType: ReactProviderType<any> = workInProgress.type
	local context: ReactContext<any> = providerType._context

	local newProps = workInProgress.pendingProps
	local oldProps = workInProgress.memoizedProps

	local newValue = newProps.value

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if Array.indexOf(Object.keys(newProps), "value") < 1 then
			if not hasWarnedAboutUsingNoValuePropOnContextProvider then
				hasWarnedAboutUsingNoValuePropOnContextProvider = true
				console.error(
					"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
				)
			end
		end
		-- ROBLOX deviation: adds support for legacy Roact's validateProps()
		local providerPropTypes = workInProgress.type.propTypes
		local validateProps = workInProgress.type.validateProps

		if providerPropTypes or validateProps then
			checkPropTypes(
				providerPropTypes,
				validateProps,
				newProps,
				"prop",
				"Context.Provider"
			)
		end
	end

	pushProvider(workInProgress, newValue)

	if oldProps ~= nil then
		local oldValue = oldProps.value
		local changedBits = calculateChangedBits(context, newValue, oldValue)
		if changedBits == 0 then
			-- No change. Bailout early if children are the same.
			if
				oldProps.children == newProps.children
				and not hasLegacyContextChanged()
			then
				return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
			end
		else
			-- The context value changed. Search for matching consumers and schedule
			-- them to update.
			propagateContextChange(workInProgress, context, changedBits, renderLanes)
		end
	end

	local newChildren = newProps.children
	reconcileChildren(current, workInProgress, newChildren, renderLanes)
	return workInProgress.child
end

-- ROBLOX deviation: combine two warning flags to dodge the registers limit
local hasWarnedAbout = {
	usingContextAsConsumer = false,
	usingLegacyConsumer = false,
}

function updateContextConsumer(
	current: Fiber | nil,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	local context: ReactContext<any> = workInProgress.type
	-- The logic below for Context differs depending on PROD or DEV mode. In
	-- DEV mode, we create a separate object for Context.Consumer that acts
	-- like a proxy to Context. This proxy object adds unnecessary code in PROD
	-- so we use the old behaviour (Context.Consumer references Context) to
	-- reduce size and overhead. The separate object references context via
	-- a property called "_context", which also gives us the ability to check
	-- in DEV mode if this property exists or not and warn if it does not.
	if __DEV__ then
		if (context :: any)._context == nil then
			-- This may be because it's a Context (rather than a Consumer).
			-- Or it may be because it's older React where they're the same thing.
			-- We only want to warn if we're sure it's a new React.
			if context ~= context.Consumer then
				if not hasWarnedAbout.usingContextAsConsumer then
					hasWarnedAbout.usingContextAsConsumer = true
					console.error(
						"Rendering <Context> directly is not supported and will be removed in "
							.. "a future major release. Did you mean to render <Context.Consumer> instead?"
					)
				end
			end
		else
			context = (context :: any)._context
		end
	end
	local newProps = workInProgress.pendingProps

	-- ROBLOX deviation: compatibility for old Roact's context consumer API
	local render
	if newProps.render then
		if __DEV__ and __COMPAT_WARNINGS__ then
			if not hasWarnedAbout.usingLegacyConsumer then
				hasWarnedAbout.usingLegacyConsumer = true
				console.warn(
					"Your Context.Consumer component is using legacy Roact syntax, which won't be supported in future versions of Roact. \n"
						.. "Please provide no props and supply the 'render' function as a child (the 3rd argument of createElement). For example: \n"
						.. "       createElement(ContextConsumer, {render = function(...) end})\n"
						.. "becomes:\n"
						.. "       createElement(ContextConsumer, nil, function(...) end)\n"
						.. "For more info, reference the React documentation here: \n"
						.. "https://reactjs.org/docs/context.html#contextconsumer"
				)
			end
		end
		render = newProps.render
	else
		render = newProps.children
	end

	if __DEV__ then
		if type(render) ~= "function" then
			console.error(
				"A context consumer was rendered with multiple children, or a child "
					.. "that isn't a function. A context consumer expects a single child "
					.. "that is a function. If you did pass a function, make sure there "
					.. "is no trailing or leading whitespace around it."
			)
		end
	end

	prepareToReadContext(
		workInProgress,
		renderLanes,
		exports.markWorkInProgressReceivedUpdate
	)
	local newValue = readContext(context, newProps.unstable_observedBits)
	local newChildren
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		newChildren = render(newValue)
		setIsRendering(false)
	else
		newChildren = render(newValue)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, newChildren, renderLanes)
	return workInProgress.child
end

-- ROBLOX TODO: fundamental component is removed in React 18, clean up all traces when we upgrade
-- function updateFundamentalComponent(current, workInProgress, renderLanes)
--   local fundamentalImpl = workInProgress.type.impl
--   if fundamentalImpl.reconcileChildren == false then
--     return nil
--   end
--   local nextProps = workInProgress.pendingProps
--   local nextChildren = nextProps.children

--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

-- ROBLOX TODO: scope component is disabled in our FeatureFlags, uncomment when we enable it
-- function updateScopeComponent(current, workInProgress, renderLanes)
--   local nextProps = workInProgress.pendingProps
--   local nextChildren = nextProps.children

--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

exports.markWorkInProgressReceivedUpdate = function()
	didReceiveUpdate = true
end

function bailoutOnAlreadyFinishedWork(
	current: Fiber | nil,
	workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | nil
	if current then
		-- Reuse previous dependencies
		workInProgress.dependencies = current.dependencies
	end

	if enableProfilerTimer then
		-- Don't update "base" render times for bailouts.
		stopProfilerTimerIfRunning(workInProgress)
	end

	markSkippedUpdateLanes(workInProgress.lanes)

	-- Check if the children have any pending work.
	if not ReactFiberLane.includesSomeLane(renderLanes, workInProgress.childLanes) then
		-- The children don't have any work either. We can skip them.
		-- TODO: Once we add back resuming, we should check if the children are
		-- a work-in-progress set. If so, we need to transfer their effects.
		return nil
	else
		-- This fiber doesn't have work, but its subtree does. Clone the child
		-- fibers and continue.
		cloneChildFibers(current, workInProgress)
		return workInProgress.child
	end
end

function remountFiber(
	current: Fiber,
	oldWorkInProgress: Fiber,
	newWorkInProgress: Fiber
): Fiber | nil
	if __DEV__ then
		local returnFiber = oldWorkInProgress.return_
		if returnFiber == nil then
			error("Cannot swap the root fiber.")
		end
		-- ROBLOX FIXME Luau: remove this assert when Luau type states understands the above guard
		assert(returnFiber ~= nil, "returnFiber was nil in remountFiber")

		-- Disconnect from the old current.
		-- It will get deleted.
		current.alternate = nil
		oldWorkInProgress.alternate = nil

		-- Connect to the new tree.
		newWorkInProgress.index = oldWorkInProgress.index
		newWorkInProgress.sibling = oldWorkInProgress.sibling
		newWorkInProgress.return_ = oldWorkInProgress.return_
		newWorkInProgress.ref = oldWorkInProgress.ref

		-- Replace the child/sibling pointers above it.
		if oldWorkInProgress == returnFiber.child then
			returnFiber.child = newWorkInProgress
		else
			local prevSibling = returnFiber.child
			if prevSibling == nil then
				error("Expected parent to have a child.")
			end
			-- ROBLOX FIXME Luau: remove this assert when Luau type states understands the above guard
			assert(prevSibling ~= nil, "prevSibling was nil in remountFiber")

			while prevSibling.sibling ~= oldWorkInProgress do
				prevSibling = prevSibling.sibling
				if prevSibling == nil then
					error("Expected to find the previous sibling.")
				end
			end
			prevSibling.sibling = newWorkInProgress
		end

		-- Delete the old fiber and place the new one.
		-- Since the old fiber is disconnected, we have to schedule it manually.
		local deletions = returnFiber.deletions
		if deletions == nil then
			returnFiber.deletions = { current }
			-- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
			returnFiber.flags = bit32.bor(returnFiber.flags, Deletion)
		else
			table.insert(deletions, current)
		end

		newWorkInProgress.flags = bit32.bor(newWorkInProgress.flags, Placement)

		-- Restart work from the new fiber.
		return newWorkInProgress
	else
		error(
			"Did not expect this call in production. "
				.. "This is a bug in React. Please file an issue."
		)
	end
end

-- FIXME (roblox): restore types when refinement is better:
-- current: Fiber | nil,
local function beginWork(current: any, workInProgress: Fiber, renderLanes: Lanes): Fiber?
	local updateLanes = workInProgress.lanes

	if __DEV__ then
		if workInProgress._debugNeedsRemount and current ~= nil then
			-- This will restart the begin phase with a new fiber.
			return remountFiber(
				current,
				workInProgress,
				createFiberFromTypeAndProps(
					workInProgress.type,
					-- ROBLOX FIXME: we widen this to be number|string for Roact compatibility
					workInProgress.key :: string?,
					workInProgress.pendingProps,
					workInProgress._debugOwner or nil,
					workInProgress.mode,
					workInProgress.lanes
				)
			)
		end
	end

	if current ~= nil then
		local oldProps = current.memoizedProps
		local newProps = workInProgress.pendingProps

		if
			oldProps ~= newProps
			or hasLegacyContextChanged()
			-- Force a re-render if the implementation changed due to hot reload:
			or if __DEV__ then workInProgress.type ~= current.type else false
		then
			-- If props or context changed, mark the fiber as having performed work.
			-- This may be unset if the props are determined to be equal later (memo).
			didReceiveUpdate = true
		elseif not ReactFiberLane.includesSomeLane(renderLanes, updateLanes) then
			didReceiveUpdate = false
			-- This fiber does not have any pending work. Bailout without entering
			-- the begin phase. There's still some bookkeeping we that needs to be done
			-- in this optimized path, mostly pushing stuff onto the stack.
			if workInProgress.tag == HostRoot then
				pushHostRootContext(workInProgress)
				resetHydrationState()
			elseif workInProgress.tag == HostComponent then
				pushHostContext(workInProgress)
			elseif workInProgress.tag == ClassComponent then
				local Component = workInProgress.type
				if isLegacyContextProvider(Component) then
					pushLegacyContextProvider(workInProgress)
				end
			elseif workInProgress.tag == HostPortal then
				pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo)
			elseif workInProgress.tag == ContextProvider then
				local newValue = workInProgress.memoizedProps.value
				pushProvider(workInProgress, newValue)
			elseif workInProgress.tag == Profiler then
				if enableProfilerTimer then
					-- Reset effect durations for the next eventual effect phase.
					-- These are reset during render to allow the DevTools commit hook a chance to read them,
					local stateNode = workInProgress.stateNode
					stateNode.effectDuration = 0
					stateNode.passiveEffectDuration = 0
				end
			elseif workInProgress.tag == SuspenseComponent then
				local state: SuspenseState | nil = workInProgress.memoizedState
				if state ~= nil then
					if enableSuspenseServerRenderer then
						if (state :: SuspenseState).dehydrated ~= nil then
							pushSuspenseContext(
								workInProgress,
								setDefaultShallowSuspenseContext(
									suspenseStackCursor.current
								)
							)
							-- We know that this component will suspend again because if it has
							-- been unsuspended it has committed as a resolved Suspense component.
							-- If it needs to be retried, it should have work scheduled on it.
							workInProgress.flags =
								bit32.bor(workInProgress.flags, DidCapture)
							-- We should never render the children of a dehydrated boundary until we
							-- upgrade it. We return nil instead of bailoutOnAlreadyFinishedWork.
							return nil
						end
					end

					-- If this boundary is currently timed out, we need to decide
					-- whether to retry the primary children, or to skip over it and
					-- go straight to the fallback. Check the priority of the primary
					-- child fragment.
					local primaryChildFragment: Fiber = workInProgress.child :: any
					local primaryChildLanes = primaryChildFragment.childLanes
					if
						ReactFiberLane.includesSomeLane(renderLanes, primaryChildLanes)
					then
						-- The primary children have pending work. Use the normal path
						-- to attempt to render the primary children again.
						return updateSuspenseComponent(
							current,
							workInProgress,
							renderLanes
						)
					else
						-- The primary child fragment does not have pending work marked
						-- on it
						pushSuspenseContext(
							workInProgress,
							setDefaultShallowSuspenseContext(suspenseStackCursor.current)
						)
						-- The primary children do not have pending work with sufficient
						-- priority. Bailout.
						local child = bailoutOnAlreadyFinishedWork(
							current,
							workInProgress,
							renderLanes
						)
						if child ~= nil then
							-- The fallback children have pending work. Skip over the
							-- primary children and work on the fallback.
							return child.sibling
						else
							return nil
						end
					end
				else
					pushSuspenseContext(
						workInProgress,
						setDefaultShallowSuspenseContext(suspenseStackCursor.current)
					)
				end
			elseif workInProgress.tag == SuspenseListComponent then
				unimplemented("beginWork: SuspenseListComponent")
			-- local didSuspendBefore = bit32.band(current.flags, DidCapture) ~= NoFlags

			-- local hasChildWork = ReactFiberLane.includesSomeLane(
			--   renderLanes,
			--   workInProgress.childLanes
			-- )

			-- if didSuspendBefore then
			--   if hasChildWork then
			--     -- If something was in fallback state last time, and we have all the
			--     -- same children then we're still in progressive loading state.
			--     -- Something might get unblocked by state updates or retries in the
			--     -- tree which will affect the tail. So we need to use the normal
			--     -- path to compute the correct tail.
			--     return updateSuspenseListComponent(
			--       current,
			--       workInProgress,
			--       renderLanes
			--     )
			--   end
			--   -- If none of the children had any work, that means that none of
			--   -- them got retried so they'll still be blocked in the same way
			--   -- as before. We can fast bail out.
			--   workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
			-- end

			-- -- If nothing suspended before and we're rendering the same children,
			-- -- then the tail doesn't matter. Anything new that suspends will work
			-- -- in the "together" mode, so we can continue from the state we had.
			-- local renderState = workInProgress.memoizedState
			-- if renderState ~= nil then
			--   -- Reset to the "together" mode in case we've started a different
			--   -- update in the past but didn't complete it.
			--   renderState.rendering = nil
			--   renderState.tail = nil
			-- end
			-- pushSuspenseContext(workInProgress, suspenseStackCursor.current)

			-- if not hasChildWork then
			--   -- If none of the children had any work, that means that none of
			--   -- them got retried so they'll still be blocked in the same way
			--   -- as before. We can fast bail out.
			--   return nil
			-- end
			elseif
				workInProgress.tag == OffscreenComponent
				or workInProgress.tag == LegacyHiddenComponent
			then
				-- Need to check if the tree still needs to be deferred. This is
				-- almost identical to the logic used in the normal update path,
				-- so we'll just enter that. The only difference is we'll bail out
				-- at the next level instead of this one, because the child props
				-- have not changed. Which is fine.
				-- TODO: Probably should refactor `beginWork` to split the bailout
				-- path from the normal path. I'm tempted to do a labeled break here
				-- but I won't :)
				workInProgress.lanes = ReactFiberLane.NoLanes
				return updateOffscreenComponent(current, workInProgress, renderLanes)
			end
			return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		else
			if bit32.band(current.flags, ForceUpdateForLegacySuspense) ~= NoFlags then
				-- This is a special case that only exists for legacy mode.
				-- See https://github.com/facebook/react/pull/19216.
				didReceiveUpdate = true
			else
				-- An update was scheduled on this fiber, but there are no new props
				-- nor legacy context. Set this to false. If an update queue or context
				-- consumer produces a changed value, it will set this to true. Otherwise,
				-- the component will assume the children have not changed and bail out.
				didReceiveUpdate = false
			end
		end
	else
		didReceiveUpdate = false
	end

	-- Before entering the begin phase, clear pending update priority.
	-- TODO: This assumes that we're about to evaluate the component and process
	-- the update queue. However, there's an exception: SimpleMemoComponent
	-- sometimes bails out later in the begin phase. This indicates that we should
	-- move this assignment out of the common path and into each branch.
	workInProgress.lanes = ReactFiberLane.NoLanes

	if workInProgress.tag == ReactWorkTags.IndeterminateComponent then
		return mountIndeterminateComponent(
			current,
			workInProgress,
			workInProgress.type,
			renderLanes
		)
	elseif workInProgress.tag == LazyComponent then
		local elementType = workInProgress.elementType
		return mountLazyComponent(
			current,
			workInProgress,
			elementType,
			updateLanes,
			renderLanes
		)
	elseif workInProgress.tag == FunctionComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps
		if workInProgress.elementType == Component then
			resolvedProps = unresolvedProps
		else
			resolvedProps = resolveDefaultProps(Component, unresolvedProps)
		end
		return updateFunctionComponent(
			current,
			workInProgress,
			Component,
			resolvedProps,
			renderLanes
		)
	elseif workInProgress.tag == ClassComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = workInProgress.elementType == Component and unresolvedProps
			or resolveDefaultProps(Component, unresolvedProps)
		return updateClassComponent(
			current,
			workInProgress,
			Component,
			resolvedProps,
			renderLanes
		)
	elseif workInProgress.tag == HostRoot then
		return updateHostRoot(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostComponent then
		return updateHostComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostText then
		return updateHostText(current, workInProgress)
	elseif workInProgress.tag == SuspenseComponent then
		return updateSuspenseComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostPortal then
		return updatePortalComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ForwardRef then
		local type = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = unresolvedProps
		if workInProgress.elementType ~= type then
			resolvedProps = resolveDefaultProps(type, unresolvedProps)
		end
		return updateForwardRef(current, workInProgress, type, resolvedProps, renderLanes)
	elseif workInProgress.tag == Fragment then
		return updateFragment(current, workInProgress, renderLanes)
	elseif workInProgress.tag == Mode then
		return updateMode(current, workInProgress, renderLanes)
	elseif workInProgress.tag == Profiler then
		return updateProfiler(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ContextProvider then
		return updateContextProvider(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ContextConsumer then
		return updateContextConsumer(current, workInProgress, renderLanes)
	elseif workInProgress.tag == MemoComponent then
		local type_ = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		-- Resolve outer props first, then resolve inner props.
		local resolvedProps = resolveDefaultProps(type_, unresolvedProps)
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			if workInProgress.type ~= workInProgress.elementType then
				-- ROBLOX deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes
				local validateProps
				-- ROBLOX deviation: only get propTypes from class components, Lua doesn't support fields on functions
				if type(type_) == "table" then
					outerPropTypes = type_.propTypes
					validateProps = type_.validateProps
				end
				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						resolvedProps, -- Resolved for outer only
						"prop",
						getComponentName(type_)
					)
				end
			end
		end
		resolvedProps = resolveDefaultProps(type_.type, resolvedProps)
		return updateMemoComponent(
			current,
			workInProgress,
			type_,
			resolvedProps,
			updateLanes,
			renderLanes
		)
	elseif workInProgress.tag == SimpleMemoComponent then
		return updateSimpleMemoComponent(
			current,
			workInProgress,
			workInProgress.type,
			workInProgress.pendingProps,
			updateLanes,
			renderLanes
		)
	elseif workInProgress.tag == IncompleteClassComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = workInProgress.elementType == Component and unresolvedProps
			or resolveDefaultProps(Component, unresolvedProps)
		return mountIncompleteClassComponent(
			current,
			workInProgress,
			Component,
			resolvedProps,
			renderLanes
		)
	-- elseif workInProgress.tag == SuspenseListComponent then
	--   unimplemented("beginWork: SuspenseListComponent")
	-- return updateSuspenseListComponent(current, workInProgress, renderLanes)
	-- elseif workInProgress.tag == FundamentalComponent then
	--   if enableFundamentalAPI then
	--     return updateFundamentalComponent(current, workInProgress, renderLanes)
	--   end
	-- elseif workInProgress.tag == ScopeComponent then
	--   if enableScopeAPI then
	--     return updateScopeComponent(current, workInProgress, renderLanes)
	--   end
	elseif workInProgress.tag == OffscreenComponent then
		return updateOffscreenComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == LegacyHiddenComponent then
		return updateLegacyHiddenComponent(current, workInProgress, renderLanes)
	end
	invariant(
		false,
		"Unknown unit of work tag (%s). This error is likely caused by a bug in "
			.. "React. Please file an issue.",
		tostring(workInProgress.tag)
	)
	return nil
end
exports.beginWork = beginWork

return exports ]]
cX.Children._5c733b7bc446d36ed9773d5a72e70e8d=c9
local da

local db={ClassName="ModuleScript",Children={},Properties={}}
db.Name="ReactFiberClassComponent.new"
db.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/c63741fb3daef6c1e8746cbe7d7b07ecb281a9fd/packages/react-reconciler/src/ReactFiberClassComponent.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type UpdateQueue<State> = ReactInternalTypes.UpdateQueue<State>

local ReactTypes = require(Packages.Shared)
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>

local React = require(Packages.React)

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Update = ReactFiberFlags.Update
local Snapshot = ReactFiberFlags.Snapshot
local MountLayoutDev = ReactFiberFlags.MountLayoutDev

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode =
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode
local disableLegacyContext = ReactFeatureFlags.disableLegacyContext
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local warnAboutDeprecatedLifecycles = ReactFeatureFlags.warnAboutDeprecatedLifecycles
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects

local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local isMounted = require(script.Parent.ReactFiberTreeReflection).isMounted
local ReactInstanceMap = require(Packages.Shared).ReactInstanceMap
local getInstance = ReactInstanceMap.get
local setInstance = ReactInstanceMap.set
local shallowEqual = require(Packages.Shared).shallowEqual
local getComponentName = require(Packages.Shared).getComponentName
local UninitializedState = require(Packages.Shared).UninitializedState
local describeError = require(Packages.Shared).describeError
-- local invariant = require(Packages.Shared).invariant
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE

local resolveDefaultProps =
	require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local StrictMode = ReactTypeOfMode.StrictMode

local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local processUpdateQueue = ReactUpdateQueue.processUpdateQueue
local checkHasForceUpdateAfterProcessing =
	ReactUpdateQueue.checkHasForceUpdateAfterProcessing
local resetHasForceUpdateBeforeProcessing =
	ReactUpdateQueue.resetHasForceUpdateBeforeProcessing
local createUpdate = ReactUpdateQueue.createUpdate
local ReplaceState = ReactUpdateQueue.ReplaceState
local ForceUpdate = ReactUpdateQueue.ForceUpdate
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local cloneUpdateQueue = ReactUpdateQueue.cloneUpdateQueue
local NoLanes = ReactFiberLane.NoLanes

local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local cacheContext = ReactFiberContext.cacheContext
local getMaskedContext = ReactFiberContext.getMaskedContext
local getUnmaskedContext = ReactFiberContext.getUnmaskedContext
local hasContextChanged = ReactFiberContext.hasContextChanged
local emptyContextObject = ReactFiberContext.emptyContextObject

local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local readContext = ReactFiberNewContext.readContext

-- local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
-- local requestEventTime = ReactFiberWorkLoop.requestEventTime
-- local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
-- local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local DebugTracing = require(script.Parent.DebugTracing)
local logForceUpdateScheduled = DebugTracing.logForceUpdateScheduled
local logStateUpdateScheduled = DebugTracing.logStateUpdateScheduled

local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local SchedulingProfiler = require(script.Parent.SchedulingProfiler)
local markForceUpdateScheduled = SchedulingProfiler.markForceUpdateScheduled
local markStateUpdateScheduled = SchedulingProfiler.markStateUpdateScheduled

local fakeInternalInstance = {}
-- ROBLOX TODO: If this is being localized, it might be for a hot path; that's
-- concerning, since our version of `isArray` is much more complex
-- local isArray = Array.isArray

-- React.Component uses a shared frozen object by default.
-- We'll use it to determine whether we need to initialize legacy refs.
-- ROBLOX deviation: Uses __refs instead of refs to avoid conflicts
-- local emptyRefsObject = React.Component:extend("").refs
local emptyRefsObject = React.Component:extend("").__refs

local didWarnAboutStateAssignmentForComponent
local didWarnAboutUninitializedState
local didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
local didWarnAboutLegacyLifecyclesAndDerivedState
local _didWarnAboutUndefinedDerivedState
local warnOnUndefinedDerivedState
local warnOnInvalidCallback
local didWarnAboutDirectlyAssigningPropsToState
local didWarnAboutContextTypeAndContextTypes
local didWarnAboutInvalidateContextType

if __DEV__ then
	didWarnAboutStateAssignmentForComponent = {}
	didWarnAboutUninitializedState = {}
	didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = {}
	didWarnAboutLegacyLifecyclesAndDerivedState = {}
	didWarnAboutDirectlyAssigningPropsToState = {}
	_didWarnAboutUndefinedDerivedState = {}
	didWarnAboutContextTypeAndContextTypes = {}
	didWarnAboutInvalidateContextType = {}

	local didWarnOnInvalidCallback = {}

	function warnOnInvalidCallback(callback: any, callerName: string)
		if callback == nil or type(callback) == "function" then
			return
		end
		local key = callerName .. "_" .. tostring(callback)
		if not didWarnOnInvalidCallback[key] then
			didWarnOnInvalidCallback[key] = true
			console.error(
				"%s(...): Expected the last optional `callback` argument to be a "
					.. "function. Instead received: %s.",
				callerName,
				tostring(callback)
			)
		end
	end

	function warnOnUndefinedDerivedState(type_, partialState)
		-- ROBLOX deviation: `nil` is a valid return for getDerivedStateFromProps, but
		-- `undefined` is not possible for us to return; we could try to detect
		-- returning zero values, but that's likely not possible without tracking it
		-- differently at the original callsite (e.g. the value we save to
		-- `partialState` would still be nil)

		-- if partialState == nil then
		--   local componentName = getComponentName(type_) or "Component"
		--   if not didWarnAboutUndefinedDerivedState[componentName] then
		--     didWarnAboutUndefinedDerivedState[componentName] = true
		--     console.error(
		--       "%s.getDerivedStateFromProps(): A valid state object (or nil) must be returned. " ..
		--         "You have returned undefined.",
		--       componentName
		--     )
		--   end
		-- end
	end

	--   -- ROBLOX FIXME: I'm not sure this applies, need to revisit it
	--   -- -- This is so gross but it's at least non-critical and can be removed if
	--   -- -- it causes problems. This is meant to give a nicer error message for
	--   -- -- ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
	--   -- -- ...)) which otherwise throws a "_processChildContext is not a function"
	--   -- -- exception.
	--   -- Object.defineProperty(fakeInternalInstance, '_processChildContext', {
	--   --   enumerable: false,
	--   --   value: function()
	--   --     invariant(
	--   --       false,
	--   --       '_processChildContext is not available in React 16+. This likely ' +
	--   --         'means you have multiple copies of React and are attempting to nest ' +
	--   --         'a React 15 tree inside a React 16 tree using ' +
	--   --         "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
	--   --         'to make sure you have only one copy of React (and ideally, switch ' +
	--   --         'to ReactDOM.createPortal).',
	--   --     )
	--   --   },
	--   -- })
	--   Object.freeze(fakeInternalInstance)
end

local function applyDerivedStateFromProps<Props, State>(
	workInProgress: Fiber,
	ctor: React_Component<Props, State>,
	getDerivedStateFromProps: (Props, State) -> State?,
	nextProps: Props
)
	local prevState = workInProgress.memoizedState

	if __DEV__ then
		if
			debugRenderPhaseSideEffectsForStrictMode
			and bit32.band(workInProgress.mode, StrictMode) ~= 0
		then
			disableLogs()
			-- Invoke the function an extra time to help detect side-effects.
			local ok, result =
				xpcall(getDerivedStateFromProps, describeError, nextProps, prevState)

			reenableLogs()

			if not ok then
				error(result)
			end
		end
	end

	local partialState = getDerivedStateFromProps(nextProps, prevState)

	if __DEV__ then
		warnOnUndefinedDerivedState(ctor, partialState)
	end
	-- Merge the partial state and the previous state.
	local memoizedState = if partialState == nil
		then prevState
		else Object.assign({}, prevState, partialState)
	workInProgress.memoizedState = memoizedState

	-- Once the update queue is empty, persist the derived state onto the
	-- base state.
	if workInProgress.lanes == NoLanes then
		-- Queue is always non-null for classes
		local updateQueue: UpdateQueue<any> = workInProgress.updateQueue
		updateQueue.baseState = memoizedState
	end
end

-- deviation: lazy initialize this to avoid cycles
local classComponentUpdater = nil
local function initializeClassComponentUpdater()
	local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	local requestEventTime = ReactFiberWorkLoop.requestEventTime
	local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
	local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber

	classComponentUpdater = {
		isMounted = isMounted,
		enqueueSetState = function(inst, payload, callback: (() -> (...any))?)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, payload, callback)
			-- update.payload = payload
			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "setState")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logStateUpdateScheduled(name, lane, payload)
					end
				end
			end

			if enableSchedulingProfiler then
				markStateUpdateScheduled(fiber, lane)
			end
		end,
		enqueueReplaceState = function(inst, payload, callback)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, payload, callback)
			update.tag = ReplaceState
			-- update.payload = payload

			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "replaceState")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logStateUpdateScheduled(name, lane, payload)
					end
				end
			end

			if enableSchedulingProfiler then
				markStateUpdateScheduled(fiber, lane)
			end
		end,
		enqueueForceUpdate = function(inst, callback)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, nil, callback)
			update.tag = ForceUpdate

			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "forceUpdate")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logForceUpdateScheduled(name, lane)
					end
				end
			end

			if enableSchedulingProfiler then
				markForceUpdateScheduled(fiber, lane)
			end
		end,
	}
end

local function getClassComponentUpdater()
	if classComponentUpdater == nil then
		initializeClassComponentUpdater()
	end
	return classComponentUpdater
end

function checkShouldComponentUpdate(
	workInProgress,
	ctor,
	oldProps,
	newProps,
	oldState,
	newState,
	nextContext
)
	local instance = workInProgress.stateNode
	if
		instance.shouldComponentUpdate ~= nil
		and type(instance.shouldComponentUpdate) == "function"
	then
		if __DEV__ then
			if
				debugRenderPhaseSideEffectsForStrictMode
				and bit32.band(workInProgress.mode, StrictMode) ~= 0
			then
				disableLogs()
				-- deviation: Pass instance so that the method receives self
				-- Invoke the function an extra time to help detect side-effects.
				local ok, result = xpcall(
					instance.shouldComponentUpdate,
					describeError,
					instance,
					newProps,
					newState,
					nextContext
				)
				-- finally
				reenableLogs()
				if not ok then
					error(result)
				end
			end
		end
		-- deviation: Call with ":" so that the method receives self
		local shouldUpdate =
			instance:shouldComponentUpdate(newProps, newState, nextContext)

		if __DEV__ then
			if shouldUpdate == nil then
				console.error(
					"%s.shouldComponentUpdate(): Returned nil instead of a "
						.. "boolean value. Make sure to return true or false.",
					getComponentName(ctor) or "Component"
				)
			end
		end

		return shouldUpdate
	end

	-- ROBLOX deviation: for us, the isPureReactComponent flag will be visible as a
	-- direct member of the 'ctor', which in reality is the component definition
	if type(ctor) == "table" and ctor.isPureReactComponent then
		return (
			not shallowEqual(oldProps, newProps) or not shallowEqual(oldState, newState)
		)
	end

	return true
end

local function checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any)
	local instance = workInProgress.stateNode
	if __DEV__ then
		local name = getComponentName(ctor) or "Component"
		local renderPresent = instance.render

		if not renderPresent then
			-- ROBLOX deviation: for us, the render function will be visible as a direct
			-- member of the 'ctor', which in reality is the component definition
			if type(ctor.render) == "function" then
				console.error(
					"%s(...): No `render` method found on the returned component "
						.. "instance: did you accidentally return an object from the constructor?",
					name
				)
			else
				console.error(
					"%s(...): No `render` method found on the returned component "
						.. "instance: you may have forgotten to define `render`.",
					name
				)
			end
		end

		if
			instance.getInitialState
			and not instance.getInitialState.isReactClassApproved
			and not instance.state
		then
			console.error(
				"getInitialState was defined on %s, a plain JavaScript class. "
					.. "This is only supported for classes created using React.createClass. "
					.. "Did you mean to define a state property instead?",
				name
			)
		end
		if
			instance.getDefaultProps
			and not instance.getDefaultProps.isReactClassApproved
		then
			console.error(
				"getDefaultProps was defined on %s, a plain JavaScript class. "
					.. "This is only supported for classes created using React.createClass. "
					.. "Use a static property to define defaultProps instead.",
				name
			)
		end
		-- ROBLOX TODO? the original check causes false positives, this adjustment should live up to the intention
		if instance.propTypes and not ctor.propTypes then
			console.error(
				"propTypes was defined as an instance property on %s. Use a static "
					.. "property to define propTypes instead.",
				name
			)
		end
		-- ROBLOX TODO? the original check causes false positives, this adjustment should live up to the intention
		if instance.contextType and not ctor.contextType then
			console.error(
				"contextType was defined as an instance property on %s. Use a static "
					.. "property to define contextType instead.",
				name
			)
		end

		if disableLegacyContext then
			if ctor.childContextTypes then
				console.error(
					"%s uses the legacy childContextTypes API which is no longer supported. "
						.. "Use React.createContext() instead.",
					name
				)
			end
			if ctor.contextTypes then
				console.error(
					"%s uses the legacy contextTypes API which is no longer supported. "
						.. "Use React.createContext() with static contextType instead.",
					name
				)
			end
		else
			-- ROBLOX TODO? the original check causes false positives, this adjustment should live up to the intention
			if instance.contextTypes and not ctor.contextTypes then
				console.error(
					"contextTypes was defined as an instance property on %s. Use a static "
						.. "property to define contextTypes instead.",
					name
				)
			end

			-- ROBLOX deviation: don't access fields on a function
			if
				type(ctor) == "table"
				and ctor.contextType
				and ctor.contextTypes
				and not didWarnAboutContextTypeAndContextTypes[ctor]
			then
				didWarnAboutContextTypeAndContextTypes[ctor] = true
				console.error(
					"%s declares both contextTypes and contextType static properties. "
						.. "The legacy contextTypes property will be ignored.",
					name
				)
			end
		end

		if type(instance.componentShouldUpdate) == "function" then
			console.error(
				"%s has a method called "
					.. "componentShouldUpdate(). Did you mean shouldComponentUpdate()? "
					.. "The name is phrased as a question because the function is "
					.. "expected to return a value.",
				name
			)
		end
		-- ROBLOX deviation: don't access fields on a function
		if
			type(ctor) == "table"
			and ctor.isPureReactComponent
			and instance.shouldComponentUpdate ~= nil
		then
			console.error(
				"%s has a method called shouldComponentUpdate(). "
					.. "shouldComponentUpdate should not be used when extending React.PureComponent. "
					.. "Please extend React.Component if shouldComponentUpdate is used.",
				getComponentName(ctor) or "A pure component"
			)
		end
		if type(instance.componentDidUnmount) == "function" then
			console.error(
				"%s has a method called "
					.. "componentDidUnmount(). But there is no such lifecycle method. "
					.. "Did you mean componentWillUnmount()?",
				name
			)
		end
		if type(instance.componentDidReceiveProps) == "function" then
			console.error(
				"%s has a method called "
					.. "componentDidReceiveProps(). But there is no such lifecycle method. "
					.. "If you meant to update the state in response to changing props, "
					.. "use componentWillReceiveProps(). If you meant to fetch data or "
					.. "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
				name
			)
		end
		if type(instance.componentWillRecieveProps) == "function" then
			console.error(
				"%s has a method called "
					.. "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
				name
			)
		end
		if type(instance.UNSAFE_componentWillRecieveProps) == "function" then
			console.error(
				"%s has a method called "
					.. "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
				name
			)
		end
		local hasMutatedProps = instance.props ~= newProps
		if instance.props ~= nil and hasMutatedProps then
			console.error(
				"%s(...): When calling super() in `%s`, make sure to pass "
					.. "up the same props that your component's constructor was passed.",
				name,
				name
			)
		end
		if rawget(instance, "defaultProps") then
			console.error(
				"Setting defaultProps as an instance property on %s is not supported and will be ignored."
					.. " Instead, define defaultProps as a static property on %s.",
				name,
				name
			)
		end

		if
			type(instance.getSnapshotBeforeUpdate) == "function"
			and type(instance.componentDidUpdate) ~= "function"
			and not didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor]
		then
			didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor] = true
			console.error(
				"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). "
					.. "This component defines getSnapshotBeforeUpdate() only.",
				getComponentName(ctor)
			)
		end

		-- ROBLOX TODO: get function arity to see if it takes >0 arguments. if it takes 1, assume it's self, and warn
		-- if type(instance.getDerivedStateFromProps) == "function" then
		--   console.error(
		--     "%s: getDerivedStateFromProps() is defined as an instance method " ..
		--       "and will be ignored. Instead, declare it as a static method.",
		--     name
		--   )
		-- end
		-- if type(instance.getDerivedStateFromError) == "function" then
		--   console.error(
		--     "%s: getDerivedStateFromError() is defined as an instance method " ..
		--       "and will be ignored. Instead, declare it as a static method.",
		--     name
		--   )
		-- end
		-- if type(ctor.getSnapshotBeforeUpdate) == "function" then
		--   console.error(
		--     "%s: getSnapshotBeforeUpdate() is defined as a static method " ..
		--       "and will be ignored. Instead, declare it as an instance method.",
		--     name
		--   )
		-- end
		local state = instance.state
		-- deviation: It's not useful for us to try to distinguish an array from an
		-- object in this case
		-- if state and (type(state) ~= "table" or Array.isArray(state)) then
		if state ~= nil and type(state) ~= "table" then
			console.error("%s.state: must be set to an object or nil", name)
		end
		-- ROBLOX deviation: don't access fields on a function
		if
			type(ctor) == "table"
			and type(instance.getChildContext) == "function"
			and type(ctor.childContextTypes) ~= "table"
		then
			console.error(
				"%s.getChildContext(): childContextTypes must be defined in order to "
					.. "use getChildContext().",
				name
			)
		end
	end
end

local function adoptClassInstance(workInProgress: Fiber, instance: any)
	-- ROBLOX performance? it looks like this lazy init is a perf problem in tab switching hot path
	instance.__updater = getClassComponentUpdater()
	workInProgress.stateNode = instance
	-- The instance needs access to the fiber so that it can schedule updates
	setInstance(instance, workInProgress)
	if __DEV__ then
		instance._reactInternalInstance = fakeInternalInstance
	end
end

local function constructClassInstance(workInProgress: Fiber, ctor: any, props: any): any
	local isLegacyContextConsumer = false
	local unmaskedContext = emptyContextObject
	local context = emptyContextObject
	local contextType = ctor.contextType

	if __DEV__ then
		-- deviation: `ctor` is actually a table, in our case; use normal indexing
		if ctor["contextType"] ~= nil then
			-- ROBLOX TODO: Double-check this boolean for accuracy
			local isValid =
				-- Allow nil for conditional declaration
				contextType == nil or (contextType["$$typeof"] == REACT_CONTEXT_TYPE and contextType._context == nil) -- Not a <Context.Consumer>

			if not isValid and not didWarnAboutInvalidateContextType[ctor] then
				didWarnAboutInvalidateContextType[ctor] = true

				local addendum = ""
				if contextType == nil then
					addendum =
						-- ROBLOX deviation: s/undefined/nil
						" However, it is set to nil. " .. "This can be caused by a typo or by mixing up named and default imports. " .. "This can also happen due to a circular dependency, so " .. "try moving the createContext() call to a separate file."
				elseif type(contextType) ~= "table" then
					addendum = " However, it is set to a " .. type(contextType) .. "."
				elseif contextType["$$typeof"] == REACT_PROVIDER_TYPE then
					addendum = " Did you accidentally pass the Context.Provider instead?"
				elseif contextType._context ~= nil then
					-- <Context.Consumer>
					addendum = " Did you accidentally pass the Context.Consumer instead?"
				else
					addendum ..= " However, it is set to an object with keys {"
					for key, _ in contextType do
						addendum ..= key .. ", "
					end
					addendum ..= "}."
				end
				console.error(
					"%s defines an invalid contextType. "
						.. "contextType should point to the Context object returned by React.createContext().%s",
					getComponentName(ctor) or "Component",
					addendum
				)
			end
		end
	end

	-- ROBLOX performance: check for nil first to avoid typeof when possible
	if contextType ~= nil and type(contextType) == "table" then
		context = readContext(contextType)
	elseif not disableLegacyContext then
		unmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		local contextTypes = ctor.contextTypes
		isLegacyContextConsumer = contextTypes ~= nil
		context = isLegacyContextConsumer
				and getMaskedContext(workInProgress, unmaskedContext)
			or emptyContextObject
	end

	-- Instantiate twice to help detect side-effects.
	if __DEV__ then
		if
			debugRenderPhaseSideEffectsForStrictMode
			and bit32.band(workInProgress.mode, StrictMode) ~= 0
		then
			disableLogs()
			-- deviation: ctor will actually refer to a class component, we use the
			-- `__ctor` function that it exposes
			local ok, result = xpcall(ctor.__ctor, describeError, props, context) -- eslint-disable-line no-new
			-- finally
			reenableLogs()

			if not ok then
				error(result)
			end
		end
	end

	-- deviation: ctor will actually refer to a class component, we use the
	-- `__ctor` function that it exposes
	local instance = ctor.__ctor(props, context)
	-- deviation: no need to worry about undefined
	-- local state = (workInProgress.memoizedState =
	--   instance.state ~= nil and instance.state ~= undefined
	--     ? instance.state
	--     : nil)
	workInProgress.memoizedState = instance.state
	local state = workInProgress.memoizedState
	adoptClassInstance(workInProgress, instance)

	if __DEV__ then
		-- ROBLOX deviation: Instead of checking if state is nil, we check if it is our
		-- UninitializedState singleton.
		if
			type(ctor.getDerivedStateFromProps) == "function"
			and state == UninitializedState
		then
			local componentName = getComponentName(ctor) or "Component"
			if not didWarnAboutUninitializedState[componentName] then
				didWarnAboutUninitializedState[componentName] = true
				-- ROBLOX deviation: message adjusted for accuracy with Lua "class" components
				console.error(
					"`%s` uses `getDerivedStateFromProps` but its initial state has not been initialized. "
						.. "This is not recommended. Instead, define the initial state by "
						.. "passing an object to `self:setState` in the `init` method of `%s`. "
						.. "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
					componentName,
					-- deviation: no need to worry about undefined
					-- instance.state == nil and 'nil' or 'undefined',
					componentName
				)
			end
		end

		-- If new component APIs are defined, "unsafe" lifecycles won't be called.
		-- Warn about these lifecycles if they are present.
		-- Don't warn about react-lifecycles-compat polyfilled methods though.
		if
			type(ctor.getDerivedStateFromProps) == "function"
			or type(instance.getSnapshotBeforeUpdate) == "function"
		then
			local foundWillMountName = nil
			local foundWillReceivePropsName = nil
			local foundWillUpdateName = nil
			if
				-- ROBLOX FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillMount) == "function" -- and
				-- instance.componentWillMount.__suppressDeprecationWarning ~= true
			then
				foundWillMountName = "componentWillMount"
			elseif type(instance.UNSAFE_componentWillMount) == "function" then
				foundWillMountName = "UNSAFE_componentWillMount"
			end
			if
				-- ROBLOX FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillReceiveProps) == "function" -- and
				-- instance.componentWillReceiveProps.__suppressDeprecationWarning ~= true
			then
				foundWillReceivePropsName = "componentWillReceiveProps"
			elseif type(instance.UNSAFE_componentWillReceiveProps) == "function" then
				foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"
			end
			if
				-- ROBLOX FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillUpdate) == "function" -- and
				-- instance.componentWillUpdate.__suppressDeprecationWarning ~= true
			then
				foundWillUpdateName = "componentWillUpdate"
			elseif type(instance.UNSAFE_componentWillUpdate) == "function" then
				foundWillUpdateName = "UNSAFE_componentWillUpdate"
			end
			if
				foundWillMountName ~= nil
				or foundWillReceivePropsName ~= nil
				or foundWillUpdateName ~= nil
			then
				local componentName = getComponentName(ctor) or "Component"
				local newApiName
				if type(ctor.getDerivedStateFromProps) == "function" then
					newApiName = "getDerivedStateFromProps()"
				else
					newApiName = "getSnapshotBeforeUpdate()"
				end

				local willMountName
				if foundWillMountName ~= nil then
					willMountName = ("\n  " .. tostring(foundWillMountName))
				else
					willMountName = ""
				end

				local willReceievePropsName
				if foundWillReceivePropsName ~= nil then
					willReceievePropsName = (
						"\n  " .. tostring(foundWillReceivePropsName)
					)
				else
					willReceievePropsName = ""
				end

				local willUpdateName
				if foundWillUpdateName ~= nil then
					willUpdateName = "\n  " .. tostring(foundWillUpdateName)
				else
					willUpdateName = ""
				end

				if not didWarnAboutLegacyLifecyclesAndDerivedState[componentName] then
					didWarnAboutLegacyLifecyclesAndDerivedState[componentName] = true
					console.error(
						"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
							.. "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n"
							.. "The above lifecycles should be removed. Learn more about this warning here:\n"
							.. "https://reactjs.org/link/unsafe-component-lifecycles",
						componentName,
						newApiName,
						willMountName,
						willReceievePropsName,
						willUpdateName
					)
				end
			end
		end
	end

	-- Cache unmasked context so we can avoid recreating masked context unless necessary.
	-- ReactFiberContext usually updates this cache but can't for newly-created instances.
	if isLegacyContextConsumer then
		cacheContext(workInProgress, unmaskedContext, context)
	end

	return instance
end

local function callComponentWillMount(workInProgress, instance)
	local oldState = instance.state

	if
		instance.componentWillMount ~= nil
		and type(instance.componentWillMount) == "function"
	then
		-- deviation: Call with ":" so that the method receives self
		instance:componentWillMount()
	end
	-- ROBLOX TODO: Should we really run both of these?
	if
		instance.UNSAFE_componentWillMount ~= nil
		and type(instance.UNSAFE_componentWillMount) == "function"
	then
		-- deviation: Call with ":" so that the method receives self
		instance:UNSAFE_componentWillMount()
	end

	if oldState ~= instance.state then
		if __DEV__ then
			console.error(
				"%s.componentWillMount(): Assigning directly to this.state is "
					.. "deprecated (except inside a component's "
					.. "constructor). Use setState instead.",
				getComponentName(workInProgress.type) or "Component"
			)
		end
		getClassComponentUpdater().enqueueReplaceState(instance, instance.state)
	end
end

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
	local oldState = instance.state
	if
		instance.componentWillReceiveProps ~= nil
		and type(instance.componentWillReceiveProps) == "function"
	then
		-- deviation: Call with ":" so that the method receives self
		instance:componentWillReceiveProps(newProps, nextContext)
	end
	if
		instance.UNSAFE_componentWillReceiveProps ~= nil
		and type(instance.UNSAFE_componentWillReceiveProps) == "function"
	then
		-- deviation: Call with ":" so that the method receives self
		instance:UNSAFE_componentWillReceiveProps(newProps, nextContext)
	end

	if instance.state ~= oldState then
		if __DEV__ then
			local componentName = getComponentName(workInProgress.type) or "Component"
			if not didWarnAboutStateAssignmentForComponent[componentName] then
				didWarnAboutStateAssignmentForComponent[componentName] = true
				console.error(
					"%s.componentWillReceiveProps(): Assigning directly to "
						.. "this.state is deprecated (except inside a component's "
						.. "constructor). Use setState instead.",
					componentName
				)
			end
		end
		getClassComponentUpdater().enqueueReplaceState(instance, instance.state)
	end
end

-- Invokes the mount life-cycles on a previously never rendered instance.
local function mountClassInstance(
	workInProgress: Fiber,
	ctor: any,
	newProps: any,
	renderLanes: Lanes
)
	if __DEV__ then
		checkClassInstance(workInProgress, ctor, newProps)
	end

	local instance = workInProgress.stateNode
	instance.props = newProps
	instance.state = workInProgress.memoizedState
	-- ROBLOX deviation: Uses __refs instead of refs to avoid conflicts
	-- instance.refs = emptyRefsObject
	instance.__refs = emptyRefsObject

	initializeUpdateQueue(workInProgress)

	-- ROBLOX deviation: don't access field on a function
	local contextType
	if type(ctor) == "table" then
		contextType = ctor.contextType
	end
	-- ROBLOX deviation: nil check first so we don't call typeof() unnecessarily
	if contextType ~= nil and type(contextType) == "table" then
		instance.context = readContext(contextType)
	elseif disableLegacyContext then
		instance.context = emptyContextObject
	else
		local unmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		instance.context = getMaskedContext(workInProgress, unmaskedContext)
	end

	if __DEV__ then
		if instance.state == newProps then
			local componentName = getComponentName(ctor) or "Component"
			if not didWarnAboutDirectlyAssigningPropsToState[componentName] then
				didWarnAboutDirectlyAssigningPropsToState[componentName] = true
				console.error(
					"%s: It is not recommended to assign props directly to state "
						.. "because updates to props won't be reflected in state. "
						.. "In most cases, it is better to use props directly.",
					componentName
				)
			end
		end

		if bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance)
		end

		if warnAboutDeprecatedLifecycles then
			ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
				workInProgress,
				instance
			)
		end
	end

	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	instance.state = workInProgress.memoizedState

	-- ROBLOX deviation START: don't access field on a function, cache typeofCtor
	local typeofCtor = type(ctor)
	local getDerivedStateFromProps
	if type(ctor) == "table" then
		getDerivedStateFromProps = ctor.getDerivedStateFromProps
	end
	if
		getDerivedStateFromProps ~= nil
		and type(getDerivedStateFromProps) == "function"
	then
		applyDerivedStateFromProps(
			workInProgress,
			ctor,
			getDerivedStateFromProps,
			newProps
		)
		instance.state = workInProgress.memoizedState
	end

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	-- ROBLOX deviation: don't access fields on a function
	if
		typeofCtor == "table"
		and type(ctor.getDerivedStateFromProps) ~= "function"
		and type(instance.getSnapshotBeforeUpdate) ~= "function"
		and (
			type(instance.UNSAFE_componentWillMount) == "function"
			or type(instance.componentWillMount) == "function"
		)
	then
		callComponentWillMount(workInProgress, instance)
		-- If we had additional state updates during this life-cycle, let's
		-- process them now.
		processUpdateQueue(workInProgress, newProps, instance, renderLanes)
		instance.state = workInProgress.memoizedState
	end

	if type(instance.componentDidMount) == "function" then
		if __DEV__ and enableDoubleInvokingEffects then
			workInProgress.flags =
				bit32.bor(workInProgress.flags, bit32.bor(MountLayoutDev, Update))
		else
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
	end
end

function resumeMountClassInstance(
	workInProgress: Fiber,
	ctor: any,
	newProps: any,
	renderLanes: Lanes
): boolean
	local instance = workInProgress.stateNode

	local oldProps = workInProgress.memoizedProps
	instance.props = oldProps

	local oldContext = instance.context
	local contextType = ctor.contextType
	local nextContext = emptyContextObject

	-- ROBLOX performance: check for nil first to avoid typeof when possible
	if contextType ~= nil and type(contextType) == "table" then
		nextContext = readContext(contextType)
	elseif not disableLegacyContext then
		local nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext)
	end

	local getDerivedStateFromProps = ctor.getDerivedStateFromProps
	local hasNewLifecycles = type(getDerivedStateFromProps) == "function"
		or type(instance.getSnapshotBeforeUpdate) == "function"

	-- Note: During these life-cycles, instance.props/instance.state are what
	-- ever the previously attempted to render - not the "current". However,
	-- during componentDidUpdate we pass the "current" props.

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	if
		not hasNewLifecycles
		and (
			type(instance.UNSAFE_componentWillReceiveProps) == "function"
			or type(instance.componentWillReceiveProps) == "function"
		)
	then
		if oldProps ~= newProps or oldContext ~= nextContext then
			callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
		end
	end

	resetHasForceUpdateBeforeProcessing()

	local oldState = workInProgress.memoizedState
	instance.state = oldState
	local newState = oldState
	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	newState = workInProgress.memoizedState
	if
		oldProps == newProps
		and oldState == newState
		and not hasContextChanged()
		and not checkHasForceUpdateAfterProcessing()
	then
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags =
					bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		return false
	end

	if
		getDerivedStateFromProps ~= nil
		and type(getDerivedStateFromProps) == "function"
	then
		applyDerivedStateFromProps(
			workInProgress,
			ctor,
			getDerivedStateFromProps,
			newProps
		)
		newState = workInProgress.memoizedState
	end

	local shouldUpdate = checkHasForceUpdateAfterProcessing()
		or checkShouldComponentUpdate(
			workInProgress,
			ctor,
			oldProps,
			newProps,
			oldState,
			newState,
			nextContext
		)

	if shouldUpdate then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			not hasNewLifecycles
			and (
				type(instance.UNSAFE_componentWillMount) == "function"
				or type(instance.componentWillMount) == "function"
			)
		then
			if type(instance.componentWillMount) == "function" then
				instance:componentWillMount()
			end
			if type(instance.UNSAFE_componentWillMount) == "function" then
				instance:UNSAFE_componentWillMount()
			end
		end
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags =
					bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
	else
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags =
					bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end

		-- If shouldComponentUpdate returned false, we should still update the
		-- memoized state to indicate that this work can be reused.
		workInProgress.memoizedProps = newProps
		workInProgress.memoizedState = newState
	end

	-- Update the existing instance's state, props, and context pointers even
	-- if shouldComponentUpdate returns false.
	instance.props = newProps
	instance.state = newState
	instance.context = nextContext

	return shouldUpdate
end

-- Invokes the update life-cycles and returns false if it shouldn't rerender.
local function updateClassInstance(
	current: Fiber,
	workInProgress: Fiber,
	ctor: any,
	newProps: any,
	renderLanes: Lanes
): boolean
	local instance = workInProgress.stateNode

	cloneUpdateQueue(current, workInProgress)

	local unresolvedOldProps = workInProgress.memoizedProps
	local oldProps = if workInProgress.type == workInProgress.elementType
		then unresolvedOldProps
		else resolveDefaultProps(workInProgress.type, unresolvedOldProps)
	instance.props = oldProps
	local unresolvedNewProps = workInProgress.pendingProps

	local oldContext = instance.context
	local contextType
	local getDerivedStateFromProps
	-- ROBLOX deviation: don't access fields on a function
	if type(ctor) == "table" then
		contextType = ctor.contextType
		getDerivedStateFromProps = ctor.getDerivedStateFromProps
	end
	local nextContext = emptyContextObject
	if type(contextType) == "table" then
		nextContext = readContext(contextType)
	elseif not disableLegacyContext then
		local nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		nextContext = getMaskedContext(workInProgress, nextUnmaskedContext)
	end

	local hasNewLifecycles = (
		getDerivedStateFromProps ~= nil
		and type(getDerivedStateFromProps) == "function"
	)
		or (
			instance.getSnapshotBeforeUpdate ~= nil
			and type(instance.getSnapshotBeforeUpdate) == "function"
		)

	-- Note: During these life-cycles, instance.props/instance.state are what
	-- ever the previously attempted to render - not the "current". However,
	-- during componentDidUpdate we pass the "current" props.

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	if
		not hasNewLifecycles
		and (
			(
				instance.UNSAFE_componentWillReceiveProps ~= nil
				and type(instance.UNSAFE_componentWillReceiveProps) == "function"
			)
			or (
				instance.componentWillReceiveProps ~= nil
				and type(instance.componentWillReceiveProps) == "function"
			)
		)
	then
		if unresolvedOldProps ~= unresolvedNewProps or oldContext ~= nextContext then
			callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
		end
	end

	resetHasForceUpdateBeforeProcessing()

	local oldState = workInProgress.memoizedState
	instance.state = oldState
	local newState = instance.state
	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	newState = workInProgress.memoizedState

	if
		unresolvedOldProps == unresolvedNewProps
		and oldState == newState
		and not hasContextChanged()
		and not checkHasForceUpdateAfterProcessing()
	then
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if
			instance.componentDidUpdate ~= nil
			and type(instance.componentDidUpdate) == "function"
		then
			if
				unresolvedOldProps ~= current.memoizedProps
				or oldState ~= current.memoizedState
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if
			instance.getSnapshotBeforeUpdate ~= nil
			and type(instance.getSnapshotBeforeUpdate) == "function"
		then
			if
				unresolvedOldProps ~= current.memoizedProps
				or oldState ~= current.memoizedState
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end
		return false
	end

	if
		getDerivedStateFromProps ~= nil
		and type(getDerivedStateFromProps) == "function"
	then
		applyDerivedStateFromProps(
			workInProgress,
			ctor,
			getDerivedStateFromProps,
			newProps
		)
		newState = workInProgress.memoizedState
	end

	local shouldUpdate = checkHasForceUpdateAfterProcessing()
		or checkShouldComponentUpdate(
			workInProgress,
			ctor,
			oldProps,
			newProps,
			oldState,
			newState,
			nextContext
		)

	if shouldUpdate then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			not hasNewLifecycles
			and (
				(
					instance.UNSAFE_componentWillUpdate ~= nil
					and type(instance.UNSAFE_componentWillUpdate) == "function"
				)
				or (
					instance.componentWillUpdate ~= nil
					and type(instance.componentWillUpdate) == "function"
				)
			)
		then
			if
				instance.componentWillUpdate ~= nil
				and type(instance.componentWillUpdate) == "function"
			then
				-- deviation: Call with ":" so that the method receives self
				instance:componentWillUpdate(newProps, newState, nextContext)
			end
			if
				instance.UNSAFE_componentWillUpdate ~= nil
				and type(instance.UNSAFE_componentWillUpdate) == "function"
			then
				-- deviation: Call with ":" so that the method receives self
				instance:UNSAFE_componentWillUpdate(newProps, newState, nextContext)
			end
		end
		if
			instance.componentDidUpdate ~= nil
			and type(instance.componentDidUpdate) == "function"
		then
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
		if
			instance.getSnapshotBeforeUpdate ~= nil
			and type(instance.getSnapshotBeforeUpdate) == "function"
		then
			workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
		end
	else
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if
			instance.componentDidUpdate ~= nil
			and type(instance.componentDidUpdate) == "function"
		then
			if
				unresolvedOldProps ~= current.memoizedProps
				or oldState ~= current.memoizedState
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if
			instance.getSnapshotBeforeUpdate ~= nil
			and type(instance.getSnapshotBeforeUpdate) == "function"
		then
			if
				unresolvedOldProps ~= current.memoizedProps
				or oldState ~= current.memoizedState
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end

		-- If shouldComponentUpdate returned false, we should still update the
		-- memoized props/state to indicate that this work can be reused.
		workInProgress.memoizedProps = newProps
		workInProgress.memoizedState = newState
	end

	-- Update the existing instance's state, props, and context pointers even
	-- if shouldComponentUpdate returns false.
	instance.props = newProps
	instance.state = newState
	instance.context = nextContext

	return shouldUpdate
end

return {
	adoptClassInstance = adoptClassInstance,
	constructClassInstance = constructClassInstance,
	mountClassInstance = mountClassInstance,
	resumeMountClassInstance = resumeMountClassInstance,
	updateClassInstance = updateClassInstance,

	applyDerivedStateFromProps = applyDerivedStateFromProps,
	-- deviation: this should be safe to export, since it gets assigned only once
	emptyRefsObject = emptyRefsObject,
} ]]
cX.Children._c0b6de2dca7c257c39bf5b48590b008f=db
local dc

local dd={ClassName="ModuleScript",Children={},Properties={}}
dd.Name="ReactFiberCommitWork.new"
dd.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/7f08e908b10a58cda902611378ec053003d371ed/packages/react-reconciler/src/ReactFiberCommitWork.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local __DEV__ = _G.__DEV__ :: boolean
local __YOLO__ = _G.__YOLO__ :: boolean
-- ROBLOX DEVIATION: keep track of the pcall run depth and stop wrapping pcalls after we hit MAX_RUN_DEPTH.
-- ROBLOX note: if this number is raised to 195, the test in RoactRecursiveLayoutPcallDepth will fail
local runDepth = 0
local MAX_RUN_DEPTH = 20

local function isCallable(value)
	if typeof(value) == "function" then
		return true
	end
	if typeof(value) == "table" then
		local mt = getmetatable(value)
		if mt and rawget(mt, "__call") then
			return true
		end
		if value._isMockFunction then
			return true
		end
	end
	return false
end

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local Set = LuauPolyfill.Set
type Array<T> = { [number]: T }

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type Container = ReactFiberHostConfig.Container
type TextInstance = ReactFiberHostConfig.TextInstance
-- ROBLOX deviation START: we have to inline, because type imports don't work across dynamic requires like HostConfig
-- local type {
--   SuspenseInstance,
--   ChildSet,
--   UpdatePayload,
type UpdatePayload = Array<any>
-- } = require(script.Parent.ReactFiberHostConfig)
-- ROBLOX deviation END
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactUpdateQueueModule = require(script.Parent["ReactUpdateQueue.new"])
type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>

-- local ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
-- type FunctionComponentUpdateQueue = ReactFiberHooks.FunctionComponentUpdateQueue
-- ROBLOX deviation: inline the typedef here to avoid circular dependency
type Effect = {
	tag: HookFlags,
	create: () -> (() -> ())?,
	destroy: (() -> ())?,
	deps: Array<any>?,
	next: Effect,
}
type FunctionComponentUpdateQueue = {
	lastEffect: Effect?,
}

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable

type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState
local ReactHookEffectTags = require(script.Parent.ReactHookEffectTags)
type HookFlags = ReactHookEffectTags.HookFlags

-- ROBLOX deviation: import tracing as a top-level export to avoid direct file access
local Schedule_tracing_wrap = require(Packages.Scheduler).tracing.unstable_wrap
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableProfilerCommitHooks = ReactFeatureFlags.enableProfilerCommitHooks
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FunctionComponent = ReactWorkTags.FunctionComponent
local ForwardRef = ReactWorkTags.ForwardRef
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local DehydratedFragment = ReactWorkTags.DehydratedFragment
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local Block = ReactWorkTags.Block
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactErrorUtils = require(Packages.Shared).ReactErrorUtils
local invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback
local hasCaughtError = ReactErrorUtils.hasCaughtError
local clearCaughtError = ReactErrorUtils.clearCaughtError
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local ContentReset = ReactFiberFlags.ContentReset
local Placement = ReactFiberFlags.Placement
local Snapshot = ReactFiberFlags.Snapshot
local Update = ReactFiberFlags.Update
local Callback = ReactFiberFlags.Callback
local LayoutMask = ReactFiberFlags.LayoutMask
local PassiveMask = ReactFiberFlags.PassiveMask
local Ref = ReactFiberFlags.Ref
local getComponentName = require(Packages.Shared).getComponentName
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
--  ROBLOX deviation: this property would be captured as values instead of bound
local currentDebugFiberInDEV = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local onCommitUnmount =
	require(script.Parent["ReactFiberDevToolsHook.new"]).onCommitUnmount
local resolveDefaultProps =
	require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])
local startLayoutEffectTimer = ReactProfilerTimer.startLayoutEffectTimer
local recordPassiveEffectDuration = ReactProfilerTimer.recordPassiveEffectDuration
local recordLayoutEffectDuration = ReactProfilerTimer.recordLayoutEffectDuration
local startPassiveEffectTimer = ReactProfilerTimer.startPassiveEffectTimer
local getCommitTime = ReactProfilerTimer.getCommitTime
local ProfileMode = require(script.Parent.ReactTypeOfMode).ProfileMode
local commitUpdateQueue = ReactUpdateQueueModule.commitUpdateQueue
local getPublicInstance = ReactFiberHostConfig.getPublicInstance
local supportsMutation = ReactFiberHostConfig.supportsMutation
local supportsPersistence = ReactFiberHostConfig.supportsPersistence
local supportsHydration = ReactFiberHostConfig.supportsHydration
local commitMount = ReactFiberHostConfig.commitMount
local commitUpdate = ReactFiberHostConfig.commitUpdate
local resetTextContent = ReactFiberHostConfig.resetTextContent
local commitTextUpdate = ReactFiberHostConfig.commitTextUpdate
local appendChild = ReactFiberHostConfig.appendChild
local appendChildToContainer = ReactFiberHostConfig.appendChildToContainer
local insertBefore = ReactFiberHostConfig.insertBefore
local insertInContainerBefore = ReactFiberHostConfig.insertInContainerBefore
local removeChild = ReactFiberHostConfig.removeChild
local removeChildFromContainer = ReactFiberHostConfig.removeChildFromContainer
-- local clearSuspenseBoundary = ReactFiberHostConfig.clearSuspenseBoundary
-- local clearSuspenseBoundaryFromContainer = ReactFiberHostConfig.clearSuspenseBoundaryFromContainer
-- local replaceContainerChildren = ReactFiberHostConfig.replaceContainerChildren
-- local createContainerChildSet = ReactFiberHostConfig.createContainerChildSet
local hideInstance = ReactFiberHostConfig.hideInstance
local hideTextInstance = ReactFiberHostConfig.hideTextInstance
local unhideInstance = ReactFiberHostConfig.unhideInstance
local unhideTextInstance = ReactFiberHostConfig.unhideTextInstance
-- local unmountFundamentalComponent = ReactFiberHostConfig.unmountFundamentalComponent
-- local updateFundamentalComponent = ReactFiberHostConfig.updateFundamentalComponent
-- local commitHydratedContainer = ReactFiberHostConfig.commitHydratedContainer
local commitHydratedSuspenseInstance = ReactFiberHostConfig.commitHydratedSuspenseInstance
local clearContainer = ReactFiberHostConfig.clearContainer
-- local prepareScopeUpdate = ReactFiberHostConfig.prepareScopeUpdate

-- ROBLOX deviation: Lazy init to avoid circular dependencies
local ReactFiberWorkLoop

local function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable): ()
	if not ReactFiberWorkLoop then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
	end
	ReactFiberWorkLoop.resolveRetryWakeable(boundaryFiber, wakeable)
end

local function markCommitTimeOfFallback(): ()
	if not ReactFiberWorkLoop then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
	end
	ReactFiberWorkLoop.markCommitTimeOfFallback()
end

-- deviation: stub to allow dependency injection that breaks circular dependency
local function schedulePassiveEffectCallback(): ()
	console.warn(
		"ReactFiberCommitWork: schedulePassiveEffectCallback causes a dependency cycle\n"
			.. debug.traceback()
	)
end

-- deviation: stub to allow dependency injection that breaks circular dependency
local function captureCommitPhaseError(
	rootFiber: Fiber,
	sourceFiber: Fiber | nil,
	error_: any?
): ()
	console.warn(
		"ReactFiberCommitWork: captureCommitPhaseError causes a dependency cycle"
	)
	error(error_)
end

local NoHookEffect = ReactHookEffectTags.NoFlags
local HookHasEffect = ReactHookEffectTags.HasEffect
local HookLayout = ReactHookEffectTags.Layout
local HookPassive = ReactHookEffectTags.Passive

-- ROBLOX deviation: lazy init to break cyclic dependency
local didWarnAboutReassigningPropsRef
local didWarnAboutReassigningProps = function()
	if not didWarnAboutReassigningPropsRef then
		didWarnAboutReassigningPropsRef =
			require(script.Parent["ReactFiberBeginWork.new"]).didWarnAboutReassigningProps
	end
	return didWarnAboutReassigningPropsRef
end

-- deviation: Common types
type Set<T> = { [T]: boolean }

-- deviation: pre-declare functions when necessary
local isHostParent, getHostSibling, insertOrAppendPlacementNode, insertOrAppendPlacementNodeIntoContainer, commitLayoutEffectsForHostRoot, commitLayoutEffectsForHostComponent, commitLayoutEffectsForClassComponent, unmountHostComponents, commitNestedUnmounts, commitUnmount

-- Used to avoid traversing the return path to find the nearest Profiler ancestor during commit.
local nearestProfilerOnStack: Fiber | nil = nil

-- deviation: Not possible to return `undefined` in lua
-- local didWarnAboutUndefinedSnapshotBeforeUpdate: Set<any>? = nil
-- if __DEV__ then
--   didWarnAboutUndefinedSnapshotBeforeUpdate = {}
-- end

-- local PossiblyWeakSet = typeof WeakSet == 'function' ? WeakSet : Set

local function callComponentWillUnmountWithTimer(current, instance)
	instance.props = current.memoizedProps
	instance.state = current.memoizedState
	if
		enableProfilerTimer
		and enableProfilerCommitHooks
		and bit32.band(current.mode, ProfileMode) ~= 0
	then
		-- ROBLOX performance? we could hoist start...Timer() out and eliminate the anon function, but then the timer would incldue the pcall overhead
		local ok, exception = xpcall(function()
			startLayoutEffectTimer()
			-- ROBLOX deviation: Call with ":" so that the method receives self
			instance:componentWillUnmount()
		end, describeError)

		recordLayoutEffectDuration(current)

		if not ok then
			error(exception)
		end
	else
		-- ROBLOX deviation: Call with ":" so that the method receives self
		instance:componentWillUnmount()
	end
end

-- Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(
	current: Fiber,
	instance: any,
	nearestMountedAncestor
): ()
	-- ROBLOX performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
	local ok, error_ =
		xpcall(callComponentWillUnmountWithTimer, describeError, current, instance)

	if not ok then
		captureCommitPhaseError(current, nearestMountedAncestor, error_)
	end
end

local function safelyDetachRef(current: Fiber, nearestMountedAncestor: Fiber): ()
	local ref = current.ref
	if ref ~= nil then
		if typeof(ref) == "function" then
			-- ROBLOX performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
			local ok, error_ = xpcall(ref, describeError)
			if not ok then
				captureCommitPhaseError(current, nearestMountedAncestor, error_)
			end
		else
			-- ROBLOX FIXME Luau: next line gets Expected type table, got 'RefObject | {| [string]: any, _stringRef: string? |}' instead
			ref.current = nil
		end
	end
end

local function safelyCallDestroy(
	current: Fiber,
	nearestMountedAncestor: Fiber | nil,
	destroy: () -> ()
): ()
	-- ROBLOX performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
	local ok, error_ = xpcall(destroy, describeError)
	if not ok then
		captureCommitPhaseError(current, nearestMountedAncestor, error_)
	end
end

local function commitBeforeMutationLifeCycles(
	current: Fiber | nil,
	finishedWork: Fiber
): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		return
	elseif finishedWork.tag == ClassComponent then
		if bit32.band(finishedWork.flags, Snapshot) ~= 0 then
			if current ~= nil then
				local prevProps = (current :: Fiber).memoizedProps
				local prevState = (current :: Fiber).memoizedState
				local instance = finishedWork.stateNode
				-- We could update instance props and state here,
				-- but instead we rely on them being set during last render.
				-- TODO: revisit this when we implement resuming.
				if __DEV__ then
					if
						finishedWork.type == finishedWork.elementType
						and not didWarnAboutReassigningProps
					then
						if instance.props ~= finishedWork.memoizedProps then
							console.error(
								"Expected %s props to match memoized props before "
									.. "getSnapshotBeforeUpdate. "
									.. "This might either be because of a bug in React, or because "
									.. "a component reassigns its own `this.props`. "
									.. "Please file an issue.",
								getComponentName(finishedWork.type) or "instance"
							)
						end
						if instance.state ~= finishedWork.memoizedState then
							console.error(
								"Expected %s state to match memoized state before "
									.. "getSnapshotBeforeUpdate. "
									.. "This might either be because of a bug in React, or because "
									.. "a component reassigns its own `this.state`. "
									.. "Please file an issue.",
								getComponentName(finishedWork.type) or "instance"
							)
						end
					end
				end
				-- deviation: Call with ':' instead of '.' so that self is available
				local snapshot = instance:getSnapshotBeforeUpdate(
					finishedWork.elementType == finishedWork.type and prevProps
						or resolveDefaultProps(finishedWork.type, prevProps),
					prevState
				)
				if __DEV__ then
					-- ROBLOX deviation: not possible to return `undefined` in Lua
					-- local didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>)
					-- if snapshot == nil and not didWarnSet[finishedWork.type] then
					--   didWarnSet[finishedWork.type] = true
					--   console.error(
					--     "%s.getSnapshotBeforeUpdate(): A snapshot value (or nil) " ..
					--       "must be returned. You have returned undefined.",
					--     getComponentName(finishedWork.type)
					--   )
					-- end
				end
				instance.__reactInternalSnapshotBeforeUpdate = snapshot
			end
		end
		return
	elseif finishedWork.tag == HostRoot then
		if supportsMutation then
			if bit32.band(finishedWork.flags, Snapshot) ~= 0 then
				local root = finishedWork.stateNode
				clearContainer(root.containerInfo)
			end
		end
		return
	elseif
		finishedWork.tag == HostComponent
		or finishedWork.tag == HostText
		or finishedWork.tag == HostPortal
		or finishedWork.tag == IncompleteClassComponent
	then
		-- Nothing to do for these component types
		return
	end
	invariant(
		false,
		"This unit of work tag should not have side-effects. This error is "
			.. "likely caused by a bug in React. Please file an issue."
	)
end

local function commitHookEffectListUnmount(
	flags: HookFlags,
	finishedWork: Fiber,
	nearestMountedAncestor: Fiber?
)
	local updateQueue: FunctionComponentUpdateQueue | nil = finishedWork.updateQueue
	local lastEffect
	if updateQueue ~= nil then
		lastEffect = (updateQueue :: FunctionComponentUpdateQueue).lastEffect
	end

	if lastEffect ~= nil then
		local firstEffect = lastEffect.next
		local effect = firstEffect
		repeat
			if bit32.band(effect.tag, flags) == flags then
				-- Unmount
				local destroy = effect.destroy
				effect.destroy = nil
				if destroy ~= nil then
					safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy)
				end
			end
			effect = effect.next
		until effect == firstEffect
	end
end

local function commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber)
	local updateQueue: FunctionComponentUpdateQueue | nil =
		finishedWork.updateQueue :: any
	local lastEffect = if updateQueue ~= nil then updateQueue.lastEffect else nil
	if lastEffect ~= nil then
		local firstEffect = lastEffect.next
		local effect = firstEffect
		repeat
			if bit32.band(effect.tag, flags) == flags then
				-- Mount
				local create = effect.create
				effect.destroy = create()

				if __DEV__ then
					local destroy = effect.destroy
					if destroy ~= nil and typeof(destroy) ~= "function" then
						local addendum
						if destroy == nil then
							addendum = " You returned nil. If your effect does not require clean "
								.. "up, return nil (or nothing)."
						elseif typeof(destroy.andThen) == "function" then
							addendum =
								-- ROBLOX FIXME: write a real program that does the equivalent and update this example, LUAFDN-754
								"\n\nIt looks like you wrote useEffect(Promise.new(function() --\[\[...\]\] end) or returned a Promise. " .. "Instead, write the async function inside your effect " .. "and call it immediately:\n\n" .. "useEffect(function()\n" .. "  function fetchData()\n" .. "    -- You can await here\n" .. "    local response = MyAPI.getData(someId):await()\n" .. "    -- ...\n" .. "  end\n" .. "  fetchData()\n" .. "end, {someId}) -- Or {} if effect doesn't need props or state\n\n" .. "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"
						else
							addendum = " You returned: " .. destroy
						end
						console.error(
							"An effect function must not return anything besides a function, "
								.. "which is used for clean-up.%s",
							addendum
						)
					end
				end
			end
			effect = effect.next
		until effect == firstEffect
	end
end

function commitProfilerPassiveEffect(finishedRoot: FiberRoot, finishedWork: Fiber): ()
	if enableProfilerTimer and enableProfilerCommitHooks then
		if finishedWork.tag == Profiler then
			local passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration
			local id, onPostCommit =
				finishedWork.memoizedProps.id, finishedWork.memoizedProps.onPostCommit

			-- This value will still reflect the previous commit phase.
			-- It does not get reset until the start of the next commit phase.
			local commitTime = getCommitTime()

			if typeof(onPostCommit) == "function" then
				if enableSchedulerTracing then
					onPostCommit(
						id,
						if finishedWork.alternate == nil then "mount" else "update",
						passiveEffectDuration,
						commitTime,
						finishedRoot.memoizedInteractions
					)
				else
					onPostCommit(
						id,
						if finishedWork.alternate == nil then "mount" else "update",
						passiveEffectDuration,
						commitTime
					)
				end
			end
		end
	end
end

local function recursivelyCommitLayoutEffects(
	finishedWork: Fiber,
	finishedRoot: FiberRoot,
	-- ROBLOX deviation: pass in these functions to avoid dependency cycle
	_captureCommitPhaseError: (
		sourceFiber: Fiber,
		nearestMountedAncestor: Fiber?,
		error: any
	) -> (),
	_schedulePassiveEffectCallback: () -> ()
)
	if _captureCommitPhaseError ~= nil then
		captureCommitPhaseError = _captureCommitPhaseError
	end
	if _schedulePassiveEffectCallback ~= nil then
		schedulePassiveEffectCallback = _schedulePassiveEffectCallback
	end
	local flags = finishedWork.flags
	local tag = finishedWork.tag
	if tag == Profiler then
		local prevProfilerOnStack = nil
		if enableProfilerTimer and enableProfilerCommitHooks then
			prevProfilerOnStack = nearestProfilerOnStack
			nearestProfilerOnStack = finishedWork
		end

		local child = finishedWork.child
		while child ~= nil do
			local primarySubtreeFlags = bit32.band(finishedWork.subtreeFlags, LayoutMask)
			if primarySubtreeFlags ~= NoFlags then
				if __DEV__ then
					local prevCurrentFiberInDEV = currentDebugFiberInDEV
					setCurrentDebugFiberInDEV(child)
					invokeGuardedCallback(
						nil,
						recursivelyCommitLayoutEffects,
						nil,
						child,
						finishedRoot,
						-- ROBLOX deviation: pass in these functions to avoid dependency cycle
						captureCommitPhaseError,
						schedulePassiveEffectCallback
					)
					if hasCaughtError() then
						local error_ = clearCaughtError()
						captureCommitPhaseError(child, finishedWork, error_)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					local ok, error_ = xpcall(
						-- ROBLOX deviation: pass in captureCommitPhaseError function to avoid dependency cycle
						recursivelyCommitLayoutEffects,
						describeError,
						child,
						finishedRoot,
						captureCommitPhaseError,
						schedulePassiveEffectCallback
					)
					if not ok then
						captureCommitPhaseError(child, finishedWork, error_)
					end
				end
			end
			child = child.sibling
		end

		local primaryFlags = bit32.band(flags, bit32.bor(Update, Callback))
		if primaryFlags ~= NoFlags then
			if enableProfilerTimer then
				if __DEV__ then
					local prevCurrentFiberInDEV = currentDebugFiberInDEV
					setCurrentDebugFiberInDEV(finishedWork)
					invokeGuardedCallback(
						nil,
						commitLayoutEffectsForProfiler,
						nil,
						finishedWork,
						finishedRoot
					)
					if hasCaughtError() then
						local error_ = clearCaughtError()
						captureCommitPhaseError(
							finishedWork,
							finishedWork.return_,
							error_
						)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					-- ROBLOX TODO? pass in captureCommitPhaseError?
					local ok, error_ = xpcall(
						commitLayoutEffectsForProfiler,
						describeError,
						finishedWork,
						finishedRoot
					)
					if not ok then
						captureCommitPhaseError(
							finishedWork,
							finishedWork.return_,
							error_
						)
					end
				end
			end
		end

		if enableProfilerTimer and enableProfilerCommitHooks then
			-- Propagate layout effect durations to the next nearest Profiler ancestor.
			-- Do not reset these values until the next render so DevTools has a chance to read them first.
			if prevProfilerOnStack ~= nil then
				prevProfilerOnStack.stateNode.effectDuration += finishedWork.stateNode.effectDuration
			end

			nearestProfilerOnStack = prevProfilerOnStack
		end
	-- elseif tag == Offscreen then
	-- TODO: Fast path to invoke all nested layout effects when Offscren goes from hidden to visible.
	else
		local child = finishedWork.child
		while child ~= nil do
			local primarySubtreeFlags = bit32.band(finishedWork.subtreeFlags, LayoutMask)
			if primarySubtreeFlags ~= NoFlags then
				if __DEV__ then
					local prevCurrentFiberInDEV = ReactCurrentFiber.current
					setCurrentDebugFiberInDEV(child)
					--\[\[
              ROBLOX DEVIATION: In DEV, After MAX_RUN_DEPTH pcalls, do not wrap recursive calls in pcall. Otherwise,
              we hit the stack limit and get a stack overflow error.
            \]\]
					if runDepth < MAX_RUN_DEPTH then
						runDepth += 1
						invokeGuardedCallback(
							nil,
							recursivelyCommitLayoutEffects,
							nil,
							child,
							finishedRoot,
							-- ROBLOX deviation: pass in this function to avoid dependency cycle
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
						runDepth -= 1

						if hasCaughtError() then
							local error_ = clearCaughtError()
							captureCommitPhaseError(child, finishedWork, error_)
						end
					else
						recursivelyCommitLayoutEffects(
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					-- ROBLOX deviation: YOLO flag for disabling pcall
					local ok, error_
					if not __YOLO__ and runDepth < MAX_RUN_DEPTH then
						--\[\[
              ROBLOX DEVIATION: After MAX_RUN_DEPTH pcalls, do not wrap recursive calls in pcall. Otherwise, we hit the
              stack limit and get a stack overflow error.
            \]\]
						runDepth += 1

						ok, error_ = xpcall(
							-- ROBLOX deviation: pass in this function to avoid dependency cycle
							recursivelyCommitLayoutEffects,
							describeError,
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)

						runDepth -= 1
					else
						ok = true
						recursivelyCommitLayoutEffects(
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
					end

					if not ok then
						captureCommitPhaseError(child, finishedWork, error_)
					end
				end
			end
			child = child.sibling
		end

		local primaryFlags = bit32.band(flags, bit32.bor(Update, Callback))
		if primaryFlags ~= NoFlags then
			if
				tag == FunctionComponent
				or tag == ForwardRef
				or tag == SimpleMemoComponent
				or tag == Block
			then
				if
					enableProfilerTimer
					and enableProfilerCommitHooks
					and bit32.band(finishedWork.mode, ProfileMode) ~= 0
				then
					-- ROBLOX try
					local ok, error_ = xpcall(function()
						startLayoutEffectTimer()
						commitHookEffectListMount(
							bit32.bor(HookLayout, HookHasEffect),
							finishedWork
						)
					end, describeError)
					-- ROBLOX finally
					recordLayoutEffectDuration(finishedWork)
					if not ok then
						error(error_)
					end
				else
					commitHookEffectListMount(
						bit32.bor(HookLayout, HookHasEffect),
						finishedWork
					)
				end

				if bit32.band(finishedWork.subtreeFlags, PassiveMask) ~= NoFlags then
					schedulePassiveEffectCallback()
				end
			elseif tag == ClassComponent then
				-- NOTE: Layout effect durations are measured within this function.
				commitLayoutEffectsForClassComponent(finishedWork)
			elseif tag == HostRoot then
				commitLayoutEffectsForHostRoot(finishedWork)
			elseif tag == HostComponent then
				commitLayoutEffectsForHostComponent(finishedWork)
			elseif tag == SuspenseComponent then
				commitSuspenseHydrationCallbacks(finishedRoot, finishedWork)
			elseif
				tag == FundamentalComponent
				or tag == HostPortal
				or tag == HostText
				or tag == IncompleteClassComponent
				or tag == LegacyHiddenComponent
				or tag == OffscreenComponent
				or tag == ScopeComponent
				or tag == SuspenseListComponent
			then
			-- break
			else
				invariant(
					false,
					"This unit of work tag should not have side-effects. This error is "
						.. "likely caused by a bug in React. Please file an issue."
				)
			end
		end

		-- ROBLOX performance: avoid cmp on always-false value
		-- if enableScopeAPI then
		--   -- TODO: This is a temporary solution that allowed us to transition away from React Flare on www.
		--   if bit32.band(flags, Ref) ~= 0 and tag ~= ScopeComponent then
		--     commitAttachRef(finishedWork)
		--   end
		-- else
		if bit32.band(flags, Ref) ~= 0 then
			commitAttachRef(finishedWork)
		end
		-- end
	end
end

function commitLayoutEffectsForProfiler(finishedWork: Fiber, finishedRoot: FiberRoot)
	if enableProfilerTimer then
		local flags = finishedWork.flags
		local current = finishedWork.alternate

		local onCommit, onRender =
			finishedWork.memoizedProps.onCommit, finishedWork.memoizedProps.onRender
		local effectDuration = finishedWork.stateNode.effectDuration

		local commitTime = getCommitTime()

		local OnRenderFlag = Update
		local OnCommitFlag = Callback

		if
			bit32.band(flags, OnRenderFlag) ~= NoFlags
			-- ROBLOX deviation: our mocked functions are tables with __call, since they have fields
			and isCallable(onRender)
		then
			if enableSchedulerTracing then
				onRender(
					finishedWork.memoizedProps.id,
					if current == nil then "mount" else "update",
					finishedWork.actualDuration,
					finishedWork.treeBaseDuration,
					finishedWork.actualStartTime,
					commitTime,
					finishedRoot.memoizedInteractions
				)
			else
				onRender(
					finishedWork.memoizedProps.id,
					if current == nil then "mount" else "update",
					finishedWork.actualDuration,
					finishedWork.treeBaseDuration,
					finishedWork.actualStartTime,
					commitTime
				)
			end
		end

		if enableProfilerCommitHooks then
			if
				bit32.band(flags, OnCommitFlag) ~= NoFlags
				-- ROBLOX deviation: our mocked functions are tables with __call, since they have fields
				and isCallable(onCommit)
			then
				if enableSchedulerTracing then
					onCommit(
						finishedWork.memoizedProps.id,
						if current == nil then "mount" else "update",
						effectDuration,
						commitTime,
						finishedRoot.memoizedInteractions
					)
				else
					onCommit(
						finishedWork.memoizedProps.id,
						if current == nil then "mount" else "update",
						effectDuration,
						commitTime
					)
				end
			end
		end
	end
end

function commitLayoutEffectsForClassComponent(finishedWork: Fiber)
	local instance = finishedWork.stateNode
	local current = finishedWork.alternate
	if bit32.band(finishedWork.flags, Update) ~= 0 then
		if current == nil then
			-- We could update instance props and state here,
			-- but instead we rely on them being set during last render.
			-- TODO: revisit this when we implement resuming.
			if __DEV__ then
				if
					finishedWork.type == finishedWork.elementType
					and not didWarnAboutReassigningProps
				then
					if instance.props ~= finishedWork.memoizedProps then
						console.error(
							"Expected %s props to match memoized props before "
								.. "componentDidMount. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.props`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
					if instance.state ~= finishedWork.memoizedState then
						console.error(
							"Expected %s state to match memoized state before "
								.. "componentDidMount. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.state`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
				end
			end
			if
				enableProfilerTimer
				and enableProfilerCommitHooks
				and bit32.band(finishedWork.mode, ProfileMode) ~= 0
			then
				local ok, result = xpcall(function()
					startLayoutEffectTimer()
					-- ROBLOX deviation: Call with ":" so that the method receives self
					instance:componentDidMount()
				end, describeError)
				-- finally
				recordLayoutEffectDuration(finishedWork)
				if not ok then
					error(result)
				end
			else
				-- ROBLOX deviation: Call with ":" so that the method receives self
				instance:componentDidMount()
			end
		else
			local prevProps = finishedWork.elementType == finishedWork.type
					and current.memoizedProps
				or resolveDefaultProps(finishedWork.type, current.memoizedProps)
			local prevState = current.memoizedState
			-- We could update instance props and state here,
			-- but instead we rely on them being set during last render.
			-- TODO: revisit this when we implement resuming.
			if __DEV__ then
				if
					finishedWork.type == finishedWork.elementType
					and not didWarnAboutReassigningProps
				then
					if instance.props ~= finishedWork.memoizedProps then
						console.error(
							"Expected %s props to match memoized props before "
								.. "componentDidUpdate. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.props`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
					if instance.state ~= finishedWork.memoizedState then
						console.error(
							"Expected %s state to match memoized state before "
								.. "componentDidUpdate. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.state`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
				end
			end
			if
				enableProfilerTimer
				and enableProfilerCommitHooks
				and bit32.band(finishedWork.mode, ProfileMode) ~= 0
			then
				local ok, result = xpcall(function()
					startLayoutEffectTimer()
					-- deviation: Call with ":" so that the method receives self
					instance:componentDidUpdate(
						prevProps,
						prevState,
						instance.__reactInternalSnapshotBeforeUpdate
					)
				end, describeError)
				-- finally
				recordLayoutEffectDuration(finishedWork)
				if not ok then
					error(result)
				end
			else
				-- deviation: Call with ":" so that the method receives self
				instance:componentDidUpdate(
					prevProps,
					prevState,
					instance.__reactInternalSnapshotBeforeUpdate
				)
			end
		end
	end

	-- TODO: I think this is now always non-null by the time it reaches the
	-- commit phase. Consider removing the type check.
	local updateQueue: UpdateQueue<any> | nil = finishedWork.updateQueue
	if updateQueue ~= nil then
		if __DEV__ then
			if
				finishedWork.type == finishedWork.elementType
				and not didWarnAboutReassigningProps
			then
				if instance.props ~= finishedWork.memoizedProps then
					console.error(
						"Expected %s props to match memoized props before "
							.. "processing the update queue. "
							.. "This might either be because of a bug in React, or because "
							.. "a component reassigns its own `this.props`. "
							.. "Please file an issue.",
						getComponentName(finishedWork.type) or "instance"
					)
				end
				if instance.state ~= finishedWork.memoizedState then
					console.error(
						"Expected %s state to match memoized state before "
							.. "processing the update queue. "
							.. "This might either be because of a bug in React, or because "
							.. "a component reassigns its own `this.state`. "
							.. "Please file an issue.",
						getComponentName(finishedWork.type) or "instance"
					)
				end
			end
		end
		-- We could update instance props and state here,
		-- but instead we rely on them being set during last render.
		-- TODO: revisit this when we implement resuming.
		commitUpdateQueue(finishedWork, updateQueue, instance)
	end
end

function commitLayoutEffectsForHostRoot(finishedWork: Fiber)
	-- TODO: I think this is now always non-null by the time it reaches the
	-- commit phase. Consider removing the type check.
	local updateQueue: UpdateQueue<any> | nil = finishedWork.updateQueue
	if updateQueue ~= nil then
		local instance = nil
		if finishedWork.child ~= nil then
			-- ROBLOX TODO: localize child, workaround Luau type refinement shortcomings
			local child = finishedWork.child
			if child.tag == HostComponent then
				instance = getPublicInstance(child.stateNode)
			elseif child.tag == ClassComponent then
				instance = child.stateNode
			end
		end
		commitUpdateQueue(finishedWork, updateQueue, instance)
	end
end

function commitLayoutEffectsForHostComponent(finishedWork: Fiber)
	local instance: Instance = finishedWork.stateNode
	local current = finishedWork.alternate

	-- Renderers may schedule work to be done after host components are mounted
	-- (eg DOM renderer may schedule auto-focus for inputs and form controls).
	-- These effects should only be committed when components are first mounted,
	-- aka when there is no current/alternate.
	if current == nil and bit32.band(finishedWork.flags, Update) ~= 0 then
		local type = finishedWork.type
		local props = finishedWork.memoizedProps
		commitMount(instance, type, props, finishedWork)
	end
end

local function hideOrUnhideAllChildren(finishedWork, isHidden)
	if supportsMutation then
		-- We only have the top Fiber that was inserted but we need to recurse down its
		-- children to find all the terminal nodes.
		local node: Fiber = finishedWork
		while true do
			if node.tag == HostComponent then
				local instance = node.stateNode
				if isHidden then
					hideInstance(instance)
				else
					unhideInstance(node.stateNode, node.memoizedProps)
				end
			elseif node.tag == HostText then
				local instance = node.stateNode
				if isHidden then
					hideTextInstance(instance)
				else
					unhideTextInstance(instance, node.memoizedProps)
				end
			elseif
				(node.tag == OffscreenComponent or node.tag == LegacyHiddenComponent)
				and (node.memoizedState :: OffscreenState) ~= nil
				and node ~= finishedWork
			then
			-- Found a nested Offscreen component that is hidden. Don't search
			-- any deeper. This tree should remain hidden.
			elseif node.child ~= nil then
				-- ROBLOX FIXME: type casts to silence analyze, Luau doesn't understand nil check
				(node.child :: Fiber).return_ = node
				node = node.child :: Fiber
				continue
			end
			if node == finishedWork then
				return
			end
			while node.sibling == nil do
				if node.return_ == nil or node.return_ == finishedWork then
					return
				end
				node = node.return_ :: Fiber -- ROBLOX TODO: Luau narrowing doesn't understand this loop until nil pattern
			end
			-- ROBLOX FIXME: cast to any to silence analyze
			(node.sibling :: Fiber).return_ = node.return_
			-- ROBLOX FIXME: recast to silence analyze while Luau doesn't understand nil check
			node = node.sibling :: Fiber
		end
	end
end

function commitAttachRef(finishedWork: Fiber)
	local ref = finishedWork.ref
	if ref ~= nil then
		local instance = finishedWork.stateNode
		local instanceToUse
		if finishedWork.tag == HostComponent then
			instanceToUse = getPublicInstance(instance)
		else
			instanceToUse = instance
		end
		-- Moved outside to ensure DCE works with this flag
		-- ROBLOX performance: avoid cmp on always-false value
		-- if enableScopeAPI and finishedWork.tag == ScopeComponent then
		--   instanceToUse = instance
		-- end
		if typeof(ref) == "function" then
			ref(instanceToUse)
		else
			if __DEV__ then
				-- ROBLOX FIXME: We won't be able to recognize a ref object by checking
				-- for the existence of the `current` key, since it won't be initialized
				-- at this point. We might consider using a symbol to uniquely identify
				-- ref objects, or relying more heavily on Luau types
				-- if not ref.current then
				if typeof(ref) ~= "table" then
					console.error(
						"Unexpected ref object provided for %s. "
							.. "Use either a ref-setter function or React.createRef().",
						getComponentName(finishedWork.type) or "instance"
					)
					return
				end
			end

			ref.current = instanceToUse
		end
	end
end

function commitDetachRef(current: Fiber)
	local currentRef = current.ref
	if currentRef ~= nil then
		if typeof(currentRef) == "function" then
			currentRef(nil)
		else
			currentRef.current = nil
		end
	end
end

-- User-originating errors (lifecycles and refs) should not interrupt
-- deletion, so don't local them throw. Host-originating errors should
-- interrupt deletion, so it's okay
function commitUnmount(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	onCommitUnmount(current)

	if
		current.tag == FunctionComponent
		or current.tag == ForwardRef
		or current.tag == MemoComponent
		or current.tag == SimpleMemoComponent
		or current.tag == Block
	then
		local updateQueue: FunctionComponentUpdateQueue | nil = current.updateQueue
		if updateQueue ~= nil then
			local lastEffect = (updateQueue :: FunctionComponentUpdateQueue).lastEffect
			if lastEffect ~= nil then
				local firstEffect = lastEffect.next

				local effect = firstEffect
				repeat
					if effect.destroy ~= nil then
						if bit32.band(effect.tag, HookLayout) ~= NoHookEffect then
							if
								enableProfilerTimer
								and enableProfilerCommitHooks
								and bit32.band(current.mode, ProfileMode) ~= 0
							then
								startLayoutEffectTimer()
								safelyCallDestroy(
									current,
									nearestMountedAncestor,
									effect.destroy
								)
								recordLayoutEffectDuration(current)
							else
								safelyCallDestroy(
									current,
									nearestMountedAncestor,
									effect.destroy
								)
							end
						end
					end
					effect = effect.next
				until effect == firstEffect
			end
		end
		return
	elseif current.tag == ClassComponent then
		safelyDetachRef(current, nearestMountedAncestor)
		local instance = current.stateNode
		if typeof(instance.componentWillUnmount) == "function" then
			safelyCallComponentWillUnmount(current, instance, nearestMountedAncestor)
		end
		return
	elseif current.tag == HostComponent then
		safelyDetachRef(current, nearestMountedAncestor)
		return
	elseif current.tag == HostPortal then
		-- TODO: this is recursive.
		-- We are also not using this parent because
		-- the portal will get pushed immediately.
		if supportsMutation then
			unmountHostComponents(
				finishedRoot,
				current,
				nearestMountedAncestor,
				renderPriorityLevel
			)
		elseif supportsPersistence then
			unimplemented("emptyPortalContainer")
			-- emptyPortalContainer(current)
		end
		return
		-- elseif current.tag == FundamentalComponent then
		--   unimplemented("commitUnmount - FundamentalComponent")
		-- if enableFundamentalAPI then
		--   local fundamentalInstance = current.stateNode
		--   if fundamentalInstance ~= nil then
		--     unmountFundamentalComponent(fundamentalInstance)
		--     current.stateNode = nil
		--   end
		-- end
		-- return
		-- elseif current.tag == DehydratedFragment then
		--   unimplemented("commitUnmount - DehydratedFragment")
		-- if enableSuspenseCallback then
		--   local hydrationCallbacks = finishedRoot.hydrationCallbacks
		--   if hydrationCallbacks ~= nil then
		--     local onDeleted = hydrationCallbacks.onDeleted
		--     if onDeleted then
		--       onDeleted((current.stateNode: SuspenseInstance))
		--     end
		--   end
		-- end
		-- return
		-- elseif current.tag == ScopeComponent then
		--   if enableScopeAPI then
		--     safelyDetachRef(current, nearestMountedAncestor)
		--   end
		--   return
	end
end

function commitNestedUnmounts(
	finishedRoot: FiberRoot,
	root: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
)
	-- While we're inside a removed host node we don't want to call
	-- removeChild on the inner nodes because they're removed by the top
	-- call anyway. We also want to call componentWillUnmount on all
	-- composites before this host node is removed from the tree. Therefore
	-- we do an inner loop while we're still inside the host node.
	local node: Fiber = root
	while true do
		commitUnmount(finishedRoot, node, nearestMountedAncestor, renderPriorityLevel)
		-- Visit children because they may contain more composite or host nodes.
		-- Skip portals because commitUnmount() currently visits them recursively.
		if
			node.child ~= nil
			-- If we use mutation we drill down into portals using commitUnmount above.
			-- If we don't use mutation we drill down into portals here instead.
			and (not supportsMutation or node.tag ~= HostPortal)
		then
			(node.child :: Fiber).return_ = node
			node = node.child :: Fiber
			continue
		end
		if node == root then
			return
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == root then
				return
			end
			node = node.return_ :: Fiber -- ROBLOX TODO: Luau narrowing doesn't understand this loop until nil pattern
		end
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
end

local function detachFiberMutation(fiber: Fiber)
	-- Cut off the return pointer to disconnect it from the tree.
	-- This enables us to detect and warn against state updates on an unmounted component.
	-- It also prevents events from bubbling from within disconnected components.
	--
	-- Ideally, we should also clear the child pointer of the parent alternate to local this
	-- get GC:ed but we don't know which for sure which parent is the current
	-- one so we'll settle for GC:ing the subtree of this child.
	-- This child itself will be GC:ed when the parent updates the next time.
	--
	-- Note that we can't clear child or sibling pointers yet.
	-- They're needed for passive effects and for findDOMNode.
	-- We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).
	local alternate = fiber.alternate
	if alternate ~= nil then
		alternate.return_ = nil
		fiber.alternate = nil
	end
	fiber.return_ = nil
end

-- function emptyPortalContainer(current: Fiber)
--   if !supportsPersistence)
--     return
--   end

--   local portal: {
--     containerInfo: Container,
--     pendingChildren: ChildSet,
--     ...
--   } = current.stateNode
--   local {containerInfo} = portal
--   local emptyChildSet = createContainerChildSet(containerInfo)
--   replaceContainerChildren(containerInfo, emptyChildSet)
-- end

-- function commitContainer(finishedWork: Fiber)
--   if !supportsPersistence)
--     return
--   end

--   switch (finishedWork.tag)
--     case ClassComponent:
--     case HostComponent:
--     case HostText:
--     case FundamentalComponent: {
--       return
--     end
--     case HostRoot:
--     case HostPortal: {
--       local portalOrRoot: {
--         containerInfo: Container,
--         pendingChildren: ChildSet,
--         ...
--       } = finishedWork.stateNode
--       local {containerInfo, pendingChildren} = portalOrRoot
--       replaceContainerChildren(containerInfo, pendingChildren)
--       return
--     end
--   end
--   invariant(
--     false,
--     'This unit of work tag should not have side-effects. This error is ' +
--       'likely caused by a bug in React. Please file an issue.',
--   )
-- end

local function getHostParentFiber(fiber: Fiber): Fiber
	local parent = fiber.return_
	while parent ~= nil do
		if isHostParent(parent) then
			return parent
		end
		parent = parent.return_
	end
	-- ROBLOX deviation START: use React 18 approach, which Luau understands better than invariant
	error(
		Error.new(
			"Expected to find a host parent. This error is likely caused by a bug "
				.. "in React. Please file an issue."
		)
	)
	-- ROBLOX deviation END
end

function isHostParent(fiber: Fiber): boolean
	return fiber.tag == HostComponent or fiber.tag == HostRoot or fiber.tag == HostPortal
end

function getHostSibling(fiber: Fiber): Instance?
	-- We're going to search forward into the tree until we find a sibling host
	-- node. Unfortunately, if multiple insertions are done in a row we have to
	-- search past them. This leads to exponential search for the next sibling.
	-- TODO: Find a more efficient way to do this.
	local node: Fiber = fiber
	while true do
		-- ROBLOX deviation: we can't `continue` with labels in luau, so some variable
		-- juggling is used instead
		local continueOuter = false
		-- If we didn't find anything, let's try the next sibling.
		while node.sibling == nil do
			if node.return_ == nil or isHostParent(node.return_) then
				-- If we pop out of the root or hit the parent the fiber we are the
				-- last sibling.
				return nil
			end
			node = node.return_ :: Fiber -- ROBLOX TODO: Luau narrowing doesn't understand this loop until nil pattern
		end
		(node.sibling :: Fiber).return_ = node.return_ :: Fiber
		node = node.sibling :: Fiber
		while
			node.tag ~= HostComponent
			and node.tag ~= HostText
			and node.tag ~= DehydratedFragment
		do
			-- If it is not host node and, we might have a host node inside it.
			-- Try to search down until we find one.
			if bit32.band(node.flags, Placement) ~= 0 then
				-- If we don't have a child, try the siblings instead.
				continueOuter = true
				break
			end
			-- If we don't have a child, try the siblings instead.
			-- We also skip portals because they are not part of this host tree.
			if node.child == nil or node.tag == HostPortal then
				continueOuter = true
				break
			else
				(node.child :: Fiber).return_ = node
				node = node.child :: Fiber
			end
		end
		if continueOuter then
			continue
		end
		-- Check if this host node is stable or about to be placed.
		if bit32.band(node.flags, Placement) == 0 then
			-- Found it!
			return node.stateNode
		end
	end
end

local function commitPlacement(finishedWork: Fiber)
	if not supportsMutation then
		return
	end

	-- Recursively insert all host nodes into the parent.
	local parentFiber = getHostParentFiber(finishedWork)

	-- Note: these two variables *must* always be updated together.
	local parent
	local isContainer
	local parentStateNode = parentFiber.stateNode
	if parentFiber.tag == HostComponent then
		parent = parentStateNode
		isContainer = false
	elseif parentFiber.tag == HostRoot then
		parent = parentStateNode.containerInfo
		isContainer = true
	elseif parentFiber.tag == HostPortal then
		parent = parentStateNode.containerInfo
		isContainer = true
	-- elseif parentFiber.tag == FundamentalComponent then
	--   if enableFundamentalAPI then
	--     parent = parentStateNode.instance
	--     isContainer = false
	--   end
	else
		-- eslint-disable-next-line-no-fallthrough
		invariant(
			false,
			"Invalid host parent fiber. This error is likely caused by a bug "
				.. "in React. Please file an issue."
		)
	end
	if bit32.band(parentFiber.flags, ContentReset) ~= 0 then
		-- Reset the text content of the parent before doing any insertions
		resetTextContent(parent)
		-- Clear ContentReset from the effect tag
		parentFiber.flags = bit32.band(parentFiber.flags, bit32.bnot(ContentReset))
	end

	local before = getHostSibling(finishedWork)
	-- We only have the top Fiber that was inserted but we need to recurse down its
	-- children to find all the terminal nodes.
	if isContainer then
		insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent)
	else
		insertOrAppendPlacementNode(finishedWork, before, parent)
	end
end

function insertOrAppendPlacementNodeIntoContainer(
	node: Fiber,
	before: Instance?,
	parent: Container
)
	local tag = node.tag
	local isHost = tag == HostComponent or tag == HostText
	-- ROBLOX performance: avoid always-false compare for Roblox renderer in hot path
	if isHost then -- or (enableFundamentalAPI and tag == FundamentalComponent) then
		local stateNode = node.stateNode
		if before then
			insertInContainerBefore(parent, stateNode, before)
		else
			appendChildToContainer(parent, stateNode)
		end
	elseif tag == HostPortal then
	-- If the insertion itself is a portal, then we don't want to traverse
	-- down its children. Instead, we'll get insertions from each child in
	-- the portal directly.
	else
		local child = node.child
		if child ~= nil then
			insertOrAppendPlacementNodeIntoContainer(child, before, parent)
			local sibling = child.sibling
			while sibling ~= nil do
				insertOrAppendPlacementNodeIntoContainer(sibling, before, parent)
				sibling = sibling.sibling
			end
		end
	end
end

function insertOrAppendPlacementNode(node: Fiber, before: Instance?, parent: Instance): ()
	local tag = node.tag
	local isHost = tag == HostComponent or tag == HostText
	-- ROBLOX performance: avoid always-false compare for Roblox renderer in hot path
	if isHost then -- or (enableFundamentalAPI and tag == FundamentalComponent) then
		local stateNode = node.stateNode
		if before then
			insertBefore(parent, stateNode, before)
		else
			appendChild(parent, stateNode)
		end
	elseif tag == HostPortal then
	-- If the insertion itself is a portal, then we don't want to traverse
	-- down its children. Instead, we'll get insertions from each child in
	-- the portal directly.
	else
		local child = node.child
		if child ~= nil then
			insertOrAppendPlacementNode(child, before, parent)
			local sibling = child.sibling
			while sibling ~= nil do
				insertOrAppendPlacementNode(sibling, before, parent)
				sibling = sibling.sibling
			end
		end
	end
end

function unmountHostComponents(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	-- We only have the top Fiber that was deleted but we need to recurse down its
	-- children to find all the terminal nodes.
	local node: Fiber = current

	-- Each iteration, currentParent is populated with node's host parent if not
	-- currentParentIsValid.
	local currentParentIsValid = false

	-- Note: these two variables *must* always be updated together.
	local currentParent
	local currentParentIsContainer

	while true do
		if not currentParentIsValid then
			-- ROBLOX FIXME Luau: Luau doesn't understand the nil guard at the top of the loop
			local parent = node.return_ :: Fiber
			while true do
				-- ROBLOX deviation START: use React 18 approach so Luau understands control flow better
				if parent == nil then
					error(
						Error.new(
							"Expected to find a host parent. This error is likely caused by "
								.. "a bug in React. Please file an issue."
						)
					)
				end
				-- ROBLOX deviation END
				local parentStateNode = parent.stateNode
				if parent.tag == HostComponent then
					currentParent = parentStateNode
					currentParentIsContainer = false
					break
				elseif parent.tag == HostRoot then
					currentParent = parentStateNode.containerInfo
					currentParentIsContainer = true
					break
				elseif parent.tag == HostPortal then
					currentParent = parentStateNode.containerInfo
					currentParentIsContainer = true
					break
					-- ROBLOX performance: eliminate always-false compare for Roblox in hot path
					-- elseif parent.tag == FundamentalComponent then
					--   if enableFundamentalAPI then
					--     currentParent = parentStateNode.instance
					--     currentParentIsContainer = false
					--   end
				end
				-- ROBLOX FIXME Luau: Luau doesn't understand the nil guard at the top of the loop
				parent = parent.return_ :: Fiber
			end
			currentParentIsValid = true
		end

		if node.tag == HostComponent or node.tag == HostText then
			commitNestedUnmounts(
				finishedRoot,
				node,
				nearestMountedAncestor,
				renderPriorityLevel
			)
			-- After all the children have unmounted, it is now safe to remove the
			-- node from the tree.
			if currentParentIsContainer then
				-- removeChildFromContainer(
				--   ((currentParent: any): Container),
				--   (fundamentalNode: Instance),
				-- )
				-- ROBLOX FIXME: type coercion
				removeChildFromContainer(currentParent, node.stateNode)
			else
				-- removeChild(
				--   ((currentParent: any): Instance),
				--   (fundamentalNode: Instance),
				-- )
				-- ROBLOX FIXME: type coercion
				removeChild(currentParent, node.stateNode)
			end
		-- Don't visit children because we already visited them.
		-- ROBLOX performance? fundamentalAPI  and suspenseServerRender are always false for Roblox. avoid unnecessary cmp in hot path
		-- elseif enableFundamentalAPI and node.tag == FundamentalComponent then
		--   local fundamentalNode = node.stateNode.instance
		--   commitNestedUnmounts(
		--     finishedRoot,
		--     node,
		--     nearestMountedAncestor,
		--     renderPriorityLevel
		--   )
		--   -- After all the children have unmounted, it is now safe to remove the
		--   -- node from the tree.
		--   if currentParentIsContainer then
		--     -- removeChildFromContainer(
		--     --   ((currentParent: any): Container),
		--     --   (fundamentalNode: Instance),
		--     -- )
		--     -- ROBLOX FIXME: type coercion
		--     removeChildFromContainer(currentParent, fundamentalNode)
		--   else
		--     -- removeChild(
		--     --   ((currentParent: any): Instance),
		--     --   (fundamentalNode: Instance),
		--     -- )
		--     -- ROBLOX FIXME: type coercion
		--     removeChild(currentParent, fundamentalNode)
		--   end
		-- elseif
		--   enableSuspenseServerRenderer and
		--   node.tag == DehydratedFragment
		-- then
		--   unimplemented("clearSuspenseBoundary")
		--   -- if enableSuspenseCallback then
		--   --   local hydrationCallbacks = finishedRoot.hydrationCallbacks
		--   --   if hydrationCallbacks ~= nil)
		--   --     local onDeleted = hydrationCallbacks.onDeleted
		--   --     if onDeleted)
		--   --       onDeleted((node.stateNode: SuspenseInstance))
		--   --     end
		--   --   end
		--   -- end

		--   -- -- Delete the dehydrated suspense boundary and all of its content.
		--   -- if currentParentIsContainer)
		--   --   clearSuspenseBoundaryFromContainer(
		--   --     ((currentParent: any): Container),
		--   --     (node.stateNode: SuspenseInstance),
		--   --   )
		--   -- } else {
		--   --   clearSuspenseBoundary(
		--   --     ((currentParent: any): Instance),
		--   --     (node.stateNode: SuspenseInstance),
		--   --   )
		--   -- end
		elseif node.tag == HostPortal then
			if node.child ~= nil then
				-- When we go into a portal, it becomes the parent to remove from.
				-- We will reassign it back when we pop the portal on the way up.
				currentParent = node.stateNode.containerInfo
				currentParentIsContainer = true
				-- Visit children because portals might contain host components.
				node.child.return_ = node
				node = node.child
				continue
			end
		else
			commitUnmount(finishedRoot, node, nearestMountedAncestor, renderPriorityLevel)
			-- Visit children because we may find more host components below.
			if node.child ~= nil then
				node.child.return_ = node
				node = node.child
				continue
			end
		end
		if node == current then
			return
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == current then
				return
			end
			-- ROBLOX FIXME Luau: Luau doesn't understand narrowing by guard above
			node = node.return_ :: Fiber
			if node.tag == HostPortal then
				-- When we go out of the portal, we need to restore the parent.
				-- Since we don't keep a stack of them, we will search for it.
				currentParentIsValid = false
			end
		end
		-- ROBLOX TODO: flowtype makes an impossible leap here, contribute this annotation upstream
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
end

local function commitDeletion(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	-- ROBLOX performance? supportsMutation always true, eliminate cmp on hot path
	-- if supportsMutation then
	-- Recursively delete all host nodes from the parent.
	-- Detach refs and call componentWillUnmount() on the whole subtree.
	unmountHostComponents(
		finishedRoot,
		current,
		nearestMountedAncestor,
		renderPriorityLevel
	)
	-- else
	--   -- Detach refs and call componentWillUnmount() on the whole subtree.
	--   commitNestedUnmounts(
	--     finishedRoot,
	--     current,
	--     nearestMountedAncestor,
	--     renderPriorityLevel
	--   )
	-- end
	local alternate = current.alternate
	detachFiberMutation(current)
	if alternate ~= nil then
		detachFiberMutation(alternate)
	end
end

local function commitWork(current: Fiber | nil, finishedWork: Fiber)
	-- if not supportsMutation then
	--   unimplemented("commitWork: non-mutation branch")
	-- switch (finishedWork.tag)
	--   case FunctionComponent:
	--   case ForwardRef:
	--   case MemoComponent:
	--   case SimpleMemoComponent:
	--   case Block: {
	--     -- Layout effects are destroyed during the mutation phase so that all
	--     -- destroy functions for all fibers are called before any create functions.
	--     -- This prevents sibling component effects from interfering with each other,
	--     -- e.g. a destroy function in one component should never override a ref set
	--     -- by a create function in another component during the same commit.
	--     if
	--       enableProfilerTimer and
	--       enableProfilerCommitHooks and
	--       finishedWork.mode & ProfileMode
	--     )
	--       try {
	--         startLayoutEffectTimer()
	--         commitHookEffectListUnmount(
	--           HookLayout | HookHasEffect,
	--           finishedWork,
	--           finishedWork.return_,
	--         )
	--       } finally {
	--         recordLayoutEffectDuration(finishedWork)
	--       end
	--     } else {
	--       commitHookEffectListUnmount(
	--         HookLayout | HookHasEffect,
	--         finishedWork,
	--         finishedWork.return_,
	--       )
	--     end
	--     return
	--   end
	--   case Profiler: {
	--     return
	--   end
	--   case SuspenseComponent: {
	--     commitSuspenseComponent(finishedWork)
	--     attachSuspenseRetryListeners(finishedWork)
	--     return
	--   end
	--   case SuspenseListComponent: {
	--     attachSuspenseRetryListeners(finishedWork)
	--     return
	--   end
	--   case HostRoot: {
	--     if supportsHydration)
	--       local root: FiberRoot = finishedWork.stateNode
	--       if root.hydrate)
	--         -- We've just hydrated. No need to hydrate again.
	--         root.hydrate = false
	--         commitHydratedContainer(root.containerInfo)
	--       end
	--     end
	--     break
	--   end
	--   case OffscreenComponent:
	--   case LegacyHiddenComponent: {
	--     return
	--   end
	-- end

	-- commitContainer(finishedWork)
	-- return
	-- end

	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == MemoComponent
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		-- Layout effects are destroyed during the mutation phase so that all
		-- destroy functions for all fibers are called before any create functions.
		-- This prevents sibling component effects from interfering with each other,
		-- e.g. a destroy function in one component should never override a ref set
		-- by a create function in another component during the same commit.
		if
			enableProfilerTimer
			and enableProfilerCommitHooks
			and bit32.band(finishedWork.mode, ProfileMode) ~= 0
		then
			-- ROBLOX try
			local ok, result = xpcall(function()
				startLayoutEffectTimer()
				commitHookEffectListUnmount(
					bit32.bor(HookLayout, HookHasEffect),
					finishedWork,
					finishedWork.return_
				)
			end, describeError)
			-- ROBLOX finally
			recordLayoutEffectDuration(finishedWork)
			if not ok then
				error(result)
			end
		else
			commitHookEffectListUnmount(
				bit32.bor(HookLayout, HookHasEffect),
				finishedWork,
				finishedWork.return_
			)
		end
		return
	elseif finishedWork.tag == ClassComponent then
		return
	elseif finishedWork.tag == HostComponent then
		local instance: Instance = finishedWork.stateNode
		if instance ~= nil then
			-- Commit the work prepared earlier.
			local newProps = finishedWork.memoizedProps
			-- For hydration we reuse the update path but we treat the oldProps
			-- as the newProps. The updatePayload will contain the real change in
			-- this case.
			local oldProps
			if current then
				oldProps = current.memoizedProps
			else
				oldProps = newProps
			end
			local type = finishedWork.type
			-- TODO: Type the updateQueue to be specific to host components.
			local updatePayload: nil | UpdatePayload = finishedWork.updateQueue :: any
			finishedWork.updateQueue = nil
			if updatePayload ~= nil then
				commitUpdate(
					instance,
					updatePayload,
					type,
					oldProps,
					newProps,
					finishedWork
				)
			end
		end
		return
	elseif finishedWork.tag == HostText then
		invariant(
			finishedWork.stateNode ~= nil,
			"This should have a text node initialized. This error is likely "
				.. "caused by a bug in React. Please file an issue."
		)
		local textInstance: TextInstance = finishedWork.stateNode
		local newText: string = finishedWork.memoizedProps
		-- For hydration we reuse the update path but we treat the oldProps
		-- as the newProps. The updatePayload will contain the real change in
		-- this case.
		local oldText: string
		if current ~= nil then
			oldText = (current :: Fiber).memoizedProps
			oldText = newText
		end
		commitTextUpdate(textInstance, oldText, newText)
		return
	elseif finishedWork.tag == HostRoot then
		if supportsHydration then
			local root: FiberRoot = finishedWork.stateNode
			if root.hydrate then
				-- We've just hydrated. No need to hydrate again.
				root.hydrate = false
				unimplemented("commitWork: HostRoot: commitHydratedContainer")
				-- commitHydratedContainer(root.containerInfo)
			end
		end
		return
	elseif finishedWork.tag == Profiler then
		return
	elseif finishedWork.tag == SuspenseComponent then
		commitSuspenseComponent(finishedWork)
		attachSuspenseRetryListeners(finishedWork)
		return
	elseif finishedWork.tag == SuspenseListComponent then
		unimplemented("commitWork: SuspenseListComponent")
	-- attachSuspenseRetryListeners(finishedWork)
	-- return
	elseif finishedWork.tag == IncompleteClassComponent then
		return
	-- elseif finishedWork.tag == FundamentalComponent then
	--   unimplemented("commitWork: FundamentalComponent")
	-- if enableFundamentalAPI)
	--   local fundamentalInstance = finishedWork.stateNode
	--   updateFundamentalComponent(fundamentalInstance)
	--   return
	-- end
	-- break
	-- elseif finishedWork.tag == ScopeComponent then
	--   unimplemented("commitWork: ScopeComponent")
	-- if enableScopeAPI)
	--   local scopeInstance = finishedWork.stateNode
	--   prepareScopeUpdate(scopeInstance, finishedWork)
	--   return
	-- end
	-- break
	elseif
		finishedWork.tag == OffscreenComponent
		or finishedWork.tag == LegacyHiddenComponent
	then
		local newState: OffscreenState | nil = finishedWork.memoizedState
		local isHidden = newState ~= nil
		hideOrUnhideAllChildren(finishedWork, isHidden)
		return
	end
	invariant(
		false,
		"This unit of work tag should not have side-effects. This error is "
			.. "likely caused by a bug in React. Please file an issue."
	)
end

function commitSuspenseComponent(finishedWork: Fiber)
	local newState: SuspenseState | nil = finishedWork.memoizedState

	if newState ~= nil then
		markCommitTimeOfFallback()

		if supportsMutation then
			-- Hide the Offscreen component that contains the primary children. TODO:
			-- Ideally, this effect would have been scheduled on the Offscreen fiber
			-- itself. That's how unhiding works: the Offscreen component schedules an
			-- effect on itself. However, in this case, the component didn't complete,
			-- so the fiber was never added to the effect list in the normal path. We
			-- could have appended it to the effect list in the Suspense component's
			-- second pass, but doing it this way is less complicated. This would be
			-- simpler if we got rid of the effect list and traversed the tree, like
			-- we're planning to do.
			local primaryChildParent: Fiber = finishedWork.child :: any
			hideOrUnhideAllChildren(primaryChildParent, true)
		end
	end

	if enableSuspenseCallback and newState ~= nil then
		local suspenseCallback = finishedWork.memoizedProps.suspenseCallback
		if typeof(suspenseCallback) == "function" then
			local wakeables: Set<Wakeable> | nil = finishedWork.updateQueue :: any
			if wakeables ~= nil then
				suspenseCallback(table.clone(wakeables))
			end
		elseif __DEV__ then
			if suspenseCallback ~= nil then
				console.error(
					"Unexpected type for suspenseCallback: %s",
					tostring(suspenseCallback)
				)
			end
		end
	end
end

function commitSuspenseHydrationCallbacks(finishedRoot: FiberRoot, finishedWork: Fiber)
	if not supportsHydration then
		return
	end
	local newState: SuspenseState | nil = finishedWork.memoizedState
	if newState == nil then
		local current = finishedWork.alternate
		if current ~= nil then
			local prevState: SuspenseState | nil = current.memoizedState
			if prevState ~= nil then
				local suspenseInstance = prevState.dehydrated
				if suspenseInstance ~= nil then
					commitHydratedSuspenseInstance(suspenseInstance)
					if enableSuspenseCallback then
						local hydrationCallbacks = finishedRoot.hydrationCallbacks
						if hydrationCallbacks ~= nil then
							local onHydrated = hydrationCallbacks.onHydrated
							if onHydrated then
								onHydrated(suspenseInstance)
							end
						end
					end
				end
			end
		end
	end
end

function attachSuspenseRetryListeners(finishedWork: Fiber)
	-- If this boundary just timed out, then it will have a set of wakeables.
	-- For each wakeable, attach a listener so that when it resolves, React
	-- attempts to re-render the boundary in the primary (pre-timeout) state.
	local wakeables: Set<Wakeable> | nil = finishedWork.updateQueue :: any
	if wakeables ~= nil then
		finishedWork.updateQueue = nil
		local retryCache = finishedWork.stateNode
		if retryCache == nil then
			finishedWork.stateNode = Set.new()
			retryCache = finishedWork.stateNode
		end
		for wakeable, _ in wakeables :: Set<Wakeable> do
			-- Memoize using the boundary fiber to prevent redundant listeners.
			local retry = function()
				return resolveRetryWakeable(finishedWork, wakeable)
			end

			if not retryCache:has(wakeable) then
				if enableSchedulerTracing then
					if wakeable.__reactDoNotTraceInteractions ~= true then
						retry = Schedule_tracing_wrap(retry)
					end
				end
				retryCache:add(wakeable)
				wakeable:andThen(function()
					return retry()
				end, function()
					return retry()
				end)
			end
		end
	end
end

-- This function detects when a Suspense boundary goes from visible to hidden.
-- It returns false if the boundary is already hidden.
-- TODO: Use an effect tag.
function isSuspenseBoundaryBeingHidden(current: Fiber | nil, finishedWork: Fiber): boolean
	if current ~= nil then
		-- ROBLOX TODO: remove typechecks when narrowing works better
		local oldState: SuspenseState | nil = (current :: Fiber).memoizedState
		if oldState == nil or (oldState :: SuspenseState).dehydrated ~= nil then
			local newState: SuspenseState | nil = finishedWork.memoizedState
			return newState ~= nil and (newState :: SuspenseState).dehydrated == nil
		end
	end
	return false
end

function commitResetTextContent(current: Fiber): ()
	if not supportsMutation then
		return
	end
	resetTextContent(current.stateNode)
end

local function commitPassiveUnmount(finishedWork: Fiber): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		if
			enableProfilerTimer
			and enableProfilerCommitHooks
			and bit32.band(finishedWork.mode, ProfileMode) ~= 0
		then
			startPassiveEffectTimer()
			commitHookEffectListUnmount(
				bit32.bor(HookPassive, HookHasEffect),
				finishedWork,
				finishedWork.return_
			)
			recordPassiveEffectDuration(finishedWork)
		else
			commitHookEffectListUnmount(
				bit32.bor(HookPassive, HookHasEffect),
				finishedWork,
				finishedWork.return_
			)
		end
	end
end

local function commitPassiveUnmountInsideDeletedTree(
	current: Fiber,
	nearestMountedAncestor: Fiber | nil
): ()
	if
		current.tag == FunctionComponent
		or current.tag == ForwardRef
		or current.tag == SimpleMemoComponent
		or current.tag == Block
	then
		if
			enableProfilerTimer
			and enableProfilerCommitHooks
			and bit32.band(current.mode, ProfileMode) ~= 0
		then
			startPassiveEffectTimer()
			commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor)
			recordPassiveEffectDuration(current)
		else
			commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor)
		end
	end
end

local function commitPassiveMount(finishedRoot: FiberRoot, finishedWork: Fiber): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		if
			enableProfilerTimer
			and enableProfilerCommitHooks
			and bit32.band(finishedWork.mode, ProfileMode) ~= 0
		then
			startPassiveEffectTimer()
			-- ROBLOX try
			local ok, error_ = xpcall(
				commitHookEffectListMount,
				describeError,
				bit32.bor(HookPassive, HookHasEffect),
				finishedWork
			)
			-- ROBLOX finally
			recordPassiveEffectDuration(finishedWork)
			if not ok then
				error(error_)
			end
		else
			commitHookEffectListMount(bit32.bor(HookPassive, HookHasEffect), finishedWork)
		end
	elseif finishedWork.tag == Profiler then
		commitProfilerPassiveEffect(finishedRoot, finishedWork)
	end
end

function invokeLayoutEffectMountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListMount,
				nil,
				bit32.bor(HookLayout, HookHasEffect),
				fiber
			)
			if hasCaughtError() then
				local mountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, mountError)
			end
			return
		end
	elseif fiber.tag == ClassComponent then
		local instance = fiber.stateNode
		invokeGuardedCallback(nil, instance.componentDidMount, instance)
		if hasCaughtError() then
			local mountError = clearCaughtError()
			captureCommitPhaseError(fiber, fiber.return_, mountError)
		end
		return
	end
end

function invokePassiveEffectMountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListMount,
				nil,
				bit32.bor(HookPassive, HookHasEffect),
				fiber
			)
			if hasCaughtError() then
				local mountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, mountError)
			end
			return
		end
	end
end

function invokeLayoutEffectUnmountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListUnmount,
				nil,
				bit32.bor(HookLayout, HookHasEffect),
				fiber,
				fiber.return_
			)
			if hasCaughtError() then
				local unmountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, unmountError)
			end
			return
		end
	elseif fiber.tag == ClassComponent then
		local instance = fiber.stateNode
		if typeof(instance.componentWillUnmount) == "function" then
			safelyCallComponentWillUnmount(fiber, instance, fiber.return_)
		end
		return
	end
end

function invokePassiveEffectUnmountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListUnmount,
				nil,
				bit32.bor(HookPassive, HookHasEffect),
				fiber,
				fiber.return_
			)
			if hasCaughtError() then
				local unmountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, unmountError)
			end
			return
		end
	end
end

return {
	safelyCallDestroy = safelyCallDestroy,

	commitBeforeMutationLifeCycles = commitBeforeMutationLifeCycles,
	commitResetTextContent = commitResetTextContent,
	commitPlacement = commitPlacement,
	commitDeletion = commitDeletion,
	commitWork = commitWork,
	commitAttachRef = commitAttachRef,
	commitDetachRef = commitDetachRef,
	commitPassiveUnmount = commitPassiveUnmount,
	commitPassiveUnmountInsideDeletedTree = commitPassiveUnmountInsideDeletedTree,
	commitPassiveMount = commitPassiveMount,
	invokeLayoutEffectMountInDEV = invokeLayoutEffectMountInDEV,
	invokeLayoutEffectUnmountInDEV = invokeLayoutEffectUnmountInDEV,
	invokePassiveEffectMountInDEV = invokePassiveEffectMountInDEV,
	invokePassiveEffectUnmountInDEV = invokePassiveEffectUnmountInDEV,
	isSuspenseBoundaryBeingHidden = isSuspenseBoundaryBeingHidden,
	recursivelyCommitLayoutEffects = recursivelyCommitLayoutEffects,
} ]]
cX.Children._277150e7c17e0263da5e22496cacc73c=dd
local de

local df={ClassName="ModuleScript",Children={},Properties={}}
df.Name="ReactFiberCompleteWork.new"
df.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/87c023b1c1b00d6776b7031f6e105913ead355da/packages/react-reconciler/src/ReactFiberCompleteWork.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local OffscreenLane = ReactFiberLane.OffscreenLane
-- local type {
--   ReactFundamentalComponentInstance,
--   ReactScopeInstance,
-- } = require(Packages.Shared).ReactTypes
-- local type {FiberRoot} = require(script.Parent.ReactInternalTypes)
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type Type = ReactFiberHostConfig.Type
type Props = ReactFiberHostConfig.Props
type Container = ReactFiberHostConfig.Container
type ChildSet = ReactFiberHostConfig.ChildSet
-- local type {
--   SuspenseState,
--   SuspenseListRenderState,
-- } = require(script.Parent.ReactFiberSuspenseComponent.new)
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState

local ReactMutableSource = require(script.Parent["ReactMutableSource.new"])
local resetMutableSourceWorkInProgressVersions =
	ReactMutableSource.resetWorkInProgressVersions

-- local {now} = require(script.Parent.SchedulerWithReactIntegration.new)

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local Block = ReactWorkTags.Block
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
type SuspenseListRenderState = ReactFiberSuspenseComponent.SuspenseState

local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local NoMode = ReactTypeOfMode.NoMode
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ProfileMode = ReactTypeOfMode.ProfileMode

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Ref = ReactFiberFlags.Ref
local Update = ReactFiberFlags.Update
local Callback = ReactFiberFlags.Callback
local Passive = ReactFiberFlags.Passive
local Deletion = ReactFiberFlags.Deletion
local NoFlags = ReactFiberFlags.NoFlags
local DidCapture = ReactFiberFlags.DidCapture
local Snapshot = ReactFiberFlags.Snapshot
local MutationMask = ReactFiberFlags.MutationMask
local LayoutMask = ReactFiberFlags.LayoutMask
local PassiveMask = ReactFiberFlags.PassiveMask
local StaticMask = ReactFiberFlags.StaticMask
local PerformedWork = ReactFiberFlags.PerformedWork

local invariant = require(Packages.Shared).invariant

local createInstance = ReactFiberHostConfig.createInstance
local createTextInstance = ReactFiberHostConfig.createTextInstance
local appendInitialChild = ReactFiberHostConfig.appendInitialChild
local finalizeInitialChildren = ReactFiberHostConfig.finalizeInitialChildren
local prepareUpdate = ReactFiberHostConfig.prepareUpdate
local supportsMutation = ReactFiberHostConfig.supportsMutation
local supportsPersistence = ReactFiberHostConfig.supportsPersistence
-- local cloneInstance = ReactFiberHostConfig.cloneInstance
-- local cloneHiddenInstance = ReactFiberHostConfig.cloneHiddenInstance
-- local cloneHiddenTextInstance = ReactFiberHostConfig.cloneHiddenTextInstance
local createContainerChildSet = ReactFiberHostConfig.createContainerChildSet
-- local appendChildToContainerChildSet = ReactFiberHostConfig.appendChildToContainerChildSet
local finalizeContainerChildren = ReactFiberHostConfig.finalizeContainerChildren
-- local getFundamentalComponentInstance = ReactFiberHostConfig.getFundamentalComponentInstance
-- local mountFundamentalComponent = ReactFiberHostConfig.mountFundamentalComponent
-- local cloneFundamentalInstance = ReactFiberHostConfig.cloneFundamentalInstance
-- local shouldUpdateFundamentalComponent = ReactFiberHostConfig.shouldUpdateFundamentalComponent
local preparePortalMount = ReactFiberHostConfig.preparePortalMount
-- local prepareScopeUpdate = ReactFiberHostConfig.prepareScopeUpdate
local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local getRootHostContainer = ReactFiberHostContext.getRootHostContainer
local popHostContext = ReactFiberHostContext.popHostContext
local getHostContext = ReactFiberHostContext.getHostContext
local popHostContainer = ReactFiberHostContext.popHostContainer

local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
local popSuspenseContext = ReactFiberSuspenseContext.popSuspenseContext
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor
local InvisibleParentSuspenseContext =
	ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext
-- local pushSuspenseContext = ReactFiberSuspenseContext.pushSuspenseContext
-- local setShallowSuspenseContext = ReactFiberSuspenseContext.setShallowSuspenseContext
-- local ForceSuspenseFallback = ReactFiberSuspenseContext.ForceSuspenseFallback
-- local setDefaultShallowSuspenseContext = ReactFiberSuspenseContext.setDefaultShallowSuspenseContext

-- local {findFirstSuspended} = require(script.Parent.ReactFiberSuspenseComponent.new)
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local popLegacyContext = ReactFiberContext.popContext
local popTopLevelLegacyContextObject = ReactFiberContext.popTopLevelContextObject
local popProvider = require(script.Parent["ReactFiberNewContext.new"]).popProvider

local ReactFiberHydrationContext =
	require(script.Parent["ReactFiberHydrationContext.new"])
local prepareToHydrateHostSuspenseInstance =
	ReactFiberHydrationContext.prepareToHydrateHostSuspenseInstance
local popHydrationState = ReactFiberHydrationContext.popHydrationState
local resetHydrationState = ReactFiberHydrationContext.resetHydrationState
-- local getIsHydrating = ReactFiberHydrationContext.getIsHydrating
local prepareToHydrateHostInstance =
	ReactFiberHydrationContext.prepareToHydrateHostInstance
local prepareToHydrateHostTextInstance =
	ReactFiberHydrationContext.prepareToHydrateHostTextInstance
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer

local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any

local popRenderLanes = ReactFiberWorkLoop.popRenderLanes
-- ROBLOX deviation: this is a live value in WorkLoop's module state, so it must be accessed directly and not 'cached'
-- local subtreeRenderLanes = ReactFiberWorkLoop.subtreeRenderLanes
local markSpawnedWork = ReactFiberWorkLoop.markSpawnedWork
local renderDidSuspend = ReactFiberWorkLoop.renderDidSuspend
local renderDidSuspendDelayIfPossible = ReactFiberWorkLoop.renderDidSuspendDelayIfPossible
-- local renderHasNotSuspendedYet = ReactFiberWorkLoop.renderHasNotSuspendedYet
-- local getRenderTargetTime = ReactFiberWorkLoop.getRenderTargetTime

-- local {createFundamentalStateInstance} = require(script.Parent.ReactFiberFundamental.new)

-- local OffscreenLane = ReactFiberLane.OffscreenLane
-- local SomeRetryLane = ReactFiberLane.SomeRetryLane
local NoLanes = ReactFiberLane.NoLanes
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
-- local {resetChildFibers} = require(script.Parent.ReactChildFiber.new)
-- local {createScopeInstance} = require(script.Parent.ReactFiberScope.new)
local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])
local transferActualDuration = ReactProfilerTimer.transferActualDuration

local function markUpdate(workInProgress: Fiber)
	-- Tag the fiber with an update effect. This turns a Placement into
	-- a PlacementAndUpdate.
	workInProgress.flags = bit32.bor(workInProgress.flags, Update)
end

local function markRef(workInProgress: Fiber)
	workInProgress.flags = bit32.bor(workInProgress.flags, Ref)
end

-- ROBLOX FIXME: type refinement
-- local function hadNoMutationsEffects(current: nil | Fiber, completedWork: Fiber)
local function hadNoMutationsEffects(current, completedWork: Fiber)
	local didBailout = current ~= nil and current.child == completedWork.child
	if didBailout then
		return true
	end

	local child = completedWork.child
	while child ~= nil do
		if bit32.band(child.flags, MutationMask) ~= NoFlags then
			return false
		end
		if bit32.band(child.subtreeFlags, MutationMask) ~= NoFlags then
			return false
		end
		child = child.sibling
	end
	return true
end

local appendAllChildren
local updateHostContainer
local updateHostComponent
local updateHostText
if supportsMutation then
	-- Mutation mode

	appendAllChildren = function(
		parent: Instance,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		-- We only have the top Fiber that was created but we need recurse down its
		-- children to find all the terminal nodes.
		local node = workInProgress.child
		while node ~= nil do
			if node.tag == HostComponent or node.tag == HostText then
				appendInitialChild(parent, node.stateNode)
			elseif enableFundamentalAPI and node.tag == FundamentalComponent then
				appendInitialChild(parent, node.stateNode.instance)
			elseif node.tag == HostPortal then
			-- If we have a portal child, then we don't want to traverse
			-- down its children. Instead, we'll get insertions from each child in
			-- the portal directly.
			elseif node.child ~= nil then
				node.child.return_ = node
				node = node.child
				continue
			end
			if node == workInProgress then
				return
			end
			while node.sibling == nil do
				if node.return_ == nil or node.return_ == workInProgress then
					return
				end
				node = node.return_
			end
			-- ROBLOX FIXME Luau: Luau doesn't understand loop predicates above results in node.sibling ~= nil
			(node.sibling :: Fiber).return_ = node.return_
			node = node.sibling
		end
	end

	updateHostContainer = function(current: nil | Fiber, workInProgress: Fiber)
		-- Noop
	end
	function updateHostComponent(
		current: Fiber,
		workInProgress: Fiber,
		type: Type,
		newProps: Props,
		rootContainerInstance: Container
	)
		-- If we have an alternate, that means this is an update and we need to
		-- schedule a side-effect to do the updates.
		local oldProps = current.memoizedProps
		if oldProps == newProps then
			-- In mutation mode, this is sufficient for a bailout because
			-- we won't touch this node even if children changed.
			return
		end

		-- If we get updated because one of our children updated, we don't
		-- have newProps so we'll have to reuse them.
		-- TODO: Split the update API as separate for the props vs. children.
		-- Even better would be if children weren't special cased at all tho.
		local instance: Instance = workInProgress.stateNode
		local currentHostContext = getHostContext()
		-- TODO: Experiencing an error where oldProps is nil. Suggests a host
		-- component is hitting the resume path. Figure out why. Possibly
		-- related to `hidden`.
		local updatePayload = prepareUpdate(
			instance,
			type,
			oldProps,
			newProps,
			rootContainerInstance,
			currentHostContext
		)
		-- TODO: Type this specific to this type of component.
		workInProgress.updateQueue = updatePayload
		-- If the update payload indicates that there is a change or if there
		-- is a new ref we mark this as an update. All the work is done in commitWork.
		if updatePayload then
			markUpdate(workInProgress)
		end
	end
	function updateHostText(
		current: Fiber,
		workInProgress: Fiber,
		oldText: string,
		newText: string
	)
		-- If the text differs, mark it as an update. All the work in done in commitWork.
		if oldText ~= newText then
			markUpdate(workInProgress)
		end
	end
elseif supportsPersistence then
	-- Persistent host tree mode
	appendAllChildren = function(
		parent: Instance,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		unimplemented("appendAllChildren")
		--     -- We only have the top Fiber that was created but we need recurse down its
		--     -- children to find all the terminal nodes.
		--     local node = workInProgress.child
		--     while (node ~= nil)
		--       -- eslint-disable-next-line no-labels
		--       branches: if node.tag == HostComponent)
		--         local instance = node.stateNode
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local props = node.memoizedProps
		--           local type = node.type
		--           instance = cloneHiddenInstance(instance, type, props, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if node.tag == HostText)
		--         local instance = node.stateNode
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local text = node.memoizedProps
		--           instance = cloneHiddenTextInstance(instance, text, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if enableFundamentalAPI and node.tag == FundamentalComponent)
		--         local instance = node.stateNode.instance
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local props = node.memoizedProps
		--           local type = node.type
		--           instance = cloneHiddenInstance(instance, type, props, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if node.tag == HostPortal)
		--         -- If we have a portal child, then we don't want to traverse
		--         -- down its children. Instead, we'll get insertions from each child in
		--         -- the portal directly.
		--       } else if node.tag == SuspenseComponent)
		--         if (node.flags & Update) ~= NoFlags)
		--           -- Need to toggle the visibility of the primary children.
		--           local newIsHidden = node.memoizedState ~= nil
		--           if newIsHidden)
		--             local primaryChildParent = node.child
		--             if primaryChildParent ~= nil)
		--               if primaryChildParent.child ~= nil)
		--                 primaryChildParent.child.return = primaryChildParent
		--                 appendAllChildren(
		--                   parent,
		--                   primaryChildParent,
		--                   true,
		--                   newIsHidden,
		--                 )
		--               end
		--               local fallbackChildParent = primaryChildParent.sibling
		--               if fallbackChildParent ~= nil)
		--                 fallbackChildParent.return = node
		--                 node = fallbackChildParent
		--                 continue
		--               end
		--             end
		--           end
		--         end
		--         if node.child ~= nil)
		--           -- Continue traversing like normal
		--           node.child.return = node
		--           node = node.child
		--           continue
		--         end
		--       } else if node.child ~= nil)
		--         node.child.return = node
		--         node = node.child
		--         continue
		--       end
		--       -- $FlowFixMe This is correct but Flow is confused by the labeled break.
		--       node = (node: Fiber)
		--       if node == workInProgress)
		--         return
		--       end
		--       while (node.sibling == nil)
		--         if node.return == nil or node.return == workInProgress)
		--           return
		--         end
		--         node = node.return
		--       end
		--       node.sibling.return = node.return
		--       node = node.sibling
		--     end
	end

	-- An unfortunate fork of appendAllChildren because we have two different parent types.
	local function appendAllChildrenToContainer(
		containerChildSet: ChildSet,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		unimplemented("appendAllChildrenToContainer")
		-- -- We only have the top Fiber that was created but we need recurse down its
		-- -- children to find all the terminal nodes.
		-- local node = workInProgress.child
		-- while node ~= nil do
		--   -- eslint-disable-next-line no-labels
		--   if node.tag == HostComponent then
		--     local instance = node.stateNode
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local props = node.memoizedProps
		--       local type = node.type
		--       instance = cloneHiddenInstance(instance, type, props, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif node.tag == HostText then
		--     local instance = node.stateNode
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local text = node.memoizedProps
		--       instance = cloneHiddenTextInstance(instance, text, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif enableFundamentalAPI and node.tag == FundamentalComponent then
		--     local instance = node.stateNode.instance
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local props = node.memoizedProps
		--       local type = node.type
		--       instance = cloneHiddenInstance(instance, type, props, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif node.tag == HostPortal then
		--     -- If we have a portal child, then we don't want to traverse
		--     -- down its children. Instead, we'll get insertions from each child in
		--     -- the portal directly.
		--   elseif node.tag == SuspenseComponent then
		--     if bit32.band(node.flags, Update) ~= NoFlags then
		--       -- Need to toggle the visibility of the primary children.
		--       local newIsHidden = node.memoizedState ~= nil
		--       if newIsHidden then
		--         local primaryChildParent = node.child
		--         if primaryChildParent ~= nil then
		--           if primaryChildParent.child ~= nil then
		--             primaryChildParent.child.return_ = primaryChildParent
		--             appendAllChildrenToContainer(
		--               containerChildSet,
		--               primaryChildParent,
		--               true,
		--               newIsHidden
		--             )
		--           end
		--           local fallbackChildParent = primaryChildParent.sibling
		--           if fallbackChildParent ~= nil then
		--             fallbackChildParent.return_ = node
		--             node = fallbackChildParent
		--             continue
		--           end
		--         end
		--       end
		--     end
		--     if node.child ~= nil then
		--       -- Continue traversing like normal
		--       node.child.return_ = node
		--       node = node.child
		--       continue
		--     end
		--   elseif node.child ~= nil then
		--     node.child.return_ = node
		--     node = node.child
		--     continue
		--   end
		--   -- $FlowFixMe This is correct but Flow is confused by the labeled break.
		--   -- node = (node: Fiber)
		--   if node == workInProgress then
		--     return
		--   end
		--   while node.sibling == nil do
		--     if node.return_ == nil or node.return_ == workInProgress then
		--       return
		--     end
		--     node = node.return_
		--   end
		--   node.sibling.return_ = node.return_
		--   node = node.sibling
		-- end
	end

	function updateHostContainer(current: nil | Fiber, workInProgress: Fiber)
		local portalOrRoot: {
			containerInfo: Container,
			pendingChildren: ChildSet,
			-- ...
			[any]: any,
		} =
			workInProgress.stateNode
		local childrenUnchanged = hadNoMutationsEffects(current, workInProgress)
		if childrenUnchanged then
		-- No changes, just reuse the existing instance.
		else
			local container = portalOrRoot.containerInfo
			local newChildSet = createContainerChildSet(container)
			-- If children might have changed, we have to add them all to the set.
			appendAllChildrenToContainer(newChildSet, workInProgress, false, false)
			portalOrRoot.pendingChildren = newChildSet
			-- Schedule an update on the container to swap out the container.
			markUpdate(workInProgress)
			finalizeContainerChildren(container, newChildSet)
		end
	end
--   updateHostComponent = function(
--     current: Fiber,
--     workInProgress: Fiber,
--     type: Type,
--     newProps: Props,
--     rootContainerInstance: Container,
--   )
--     local currentInstance = current.stateNode
--     local oldProps = current.memoizedProps
--     -- If there are no effects associated with this node, then none of our children had any updates.
--     -- This guarantees that we can reuse all of them.
--     local childrenUnchanged = workInProgress.firstEffect == nil
--     if childrenUnchanged and oldProps == newProps)
--       -- No changes, just reuse the existing instance.
--       -- Note that this might release a previous clone.
--       workInProgress.stateNode = currentInstance
--       return
--     end
--     local recyclableInstance: Instance = workInProgress.stateNode
--     local currentHostContext = getHostContext()
--     local updatePayload = nil
--     if oldProps ~= newProps)
--       updatePayload = prepareUpdate(
--         recyclableInstance,
--         type,
--         oldProps,
--         newProps,
--         rootContainerInstance,
--         currentHostContext,
--       )
--     end
--     if childrenUnchanged and updatePayload == nil)
--       -- No changes, just reuse the existing instance.
--       -- Note that this might release a previous clone.
--       workInProgress.stateNode = currentInstance
--       return
--     end
--     local newInstance = cloneInstance(
--       currentInstance,
--       updatePayload,
--       type,
--       oldProps,
--       newProps,
--       workInProgress,
--       childrenUnchanged,
--       recyclableInstance,
--     )
--     if
--       finalizeInitialChildren(
--         newInstance,
--         type,
--         newProps,
--         rootContainerInstance,
--         currentHostContext,
--       )
--     )
--       markUpdate(workInProgress)
--     end
--     workInProgress.stateNode = newInstance
--     if childrenUnchanged)
--       -- If there are no other effects in this tree, we need to flag this node as having one.
--       -- Even though we're not going to use it for anything.
--       -- Otherwise parents won't know that there are new children to propagate upwards.
--       markUpdate(workInProgress)
--     else
--       -- If children might have changed, we have to add them all to the set.
--       appendAllChildren(newInstance, workInProgress, false, false)
--     end
--   end
--   updateHostText = function(
--     current: Fiber,
--     workInProgress: Fiber,
--     oldText: string,
--     newText: string,
--   )
--     if oldText ~= newText)
--       -- If the text content differs, we'll create a new text instance for it.
--       local rootContainerInstance = getRootHostContainer()
--       local currentHostContext = getHostContext()
--       workInProgress.stateNode = createTextInstance(
--         newText,
--         rootContainerInstance,
--         currentHostContext,
--         workInProgress,
--       )
--       -- We'll have to mark it as having an effect, even though we won't use the effect for anything.
--       -- This lets the parents know that at least one of their children has changed.
--       markUpdate(workInProgress)
--     else
--       workInProgress.stateNode = current.stateNode
--     end
--   end
else
	-- No host operations
	updateHostContainer = function(current: nil | Fiber, workInProgress: Fiber)
		-- Noop
	end
	--   updateHostComponent = function(
	--     current: Fiber,
	--     workInProgress: Fiber,
	--     type: Type,
	--     newProps: Props,
	--     rootContainerInstance: Container,
	--   )
	--     -- Noop
	--   end
	--   updateHostText = function(
	--     current: Fiber,
	--     workInProgress: Fiber,
	--     oldText: string,
	--     newText: string,
	--   )
	--     -- Noop
	--   end
	-- end

	-- function cutOffTailIfNeeded(
	--   renderState: SuspenseListRenderState,
	--   hasRenderedATailFallback: boolean,
	-- )
	--   if getIsHydrating())
	--     -- If we're hydrating, we should consume as many items as we can
	--     -- so we don't leave any behind.
	--     return
	--   end
	--   switch (renderState.tailMode)
	--     case 'hidden': {
	--       -- Any insertions at the end of the tail list after this point
	--       -- should be invisible. If there are already mounted boundaries
	--       -- anything before them are not considered for collapsing.
	--       -- Therefore we need to go through the whole tail to find if
	--       -- there are any.
	--       local tailNode = renderState.tail
	--       local lastTailNode = nil
	--       while (tailNode ~= nil)
	--         if tailNode.alternate ~= nil)
	--           lastTailNode = tailNode
	--         end
	--         tailNode = tailNode.sibling
	--       end
	--       -- Next we're simply going to delete all insertions after the
	--       -- last rendered item.
	--       if lastTailNode == nil)
	--         -- All remaining items in the tail are insertions.
	--         renderState.tail = nil
	--       else
	--         -- Detach the insertion after the last node that was already
	--         -- inserted.
	--         lastTailNode.sibling = nil
	--       end
	--       break
	--     end
	--     case 'collapsed': {
	--       -- Any insertions at the end of the tail list after this point
	--       -- should be invisible. If there are already mounted boundaries
	--       -- anything before them are not considered for collapsing.
	--       -- Therefore we need to go through the whole tail to find if
	--       -- there are any.
	--       local tailNode = renderState.tail
	--       local lastTailNode = nil
	--       while (tailNode ~= nil)
	--         if tailNode.alternate ~= nil)
	--           lastTailNode = tailNode
	--         end
	--         tailNode = tailNode.sibling
	--       end
	--       -- Next we're simply going to delete all insertions after the
	--       -- last rendered item.
	--       if lastTailNode == nil)
	--         -- All remaining items in the tail are insertions.
	--         if !hasRenderedATailFallback and renderState.tail ~= nil)
	--           -- We suspended during the head. We want to show at least one
	--           -- row at the tail. So we'll keep on and cut off the rest.
	--           renderState.tail.sibling = nil
	--         else
	--           renderState.tail = nil
	--         end
	--       else
	--         -- Detach the insertion after the last node that was already
	--         -- inserted.
	--         lastTailNode.sibling = nil
	--       end
	--       break
	--     end
	--   end
end

local function bubbleProperties(completedWork: Fiber)
	local didBailout = completedWork.alternate ~= nil
		and (completedWork.alternate :: Fiber).child == completedWork.child

	local newChildLanes = NoLanes
	local subtreeFlags = NoFlags

	if not didBailout then
		-- Bubble up the earliest expiration time.
		if
			enableProfilerTimer
			and bit32.band(completedWork.mode, ProfileMode) ~= NoMode
		then
			-- In profiling mode, resetChildExpirationTime is also used to reset
			-- profiler durations.
			local actualDuration = completedWork.actualDuration
			local treeBaseDuration = completedWork.selfBaseDuration

			local child = completedWork.child
			while child ~= nil do
				newChildLanes =
					mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes))

				subtreeFlags = bit32.bor(subtreeFlags, child.subtreeFlags)
				subtreeFlags = bit32.bor(subtreeFlags, child.flags)

				-- When a fiber is cloned, its actualDuration is reset to 0. This value will
				-- only be updated if work is done on the fiber (i.e. it doesn't bailout).
				-- When work is done, it should bubble to the parent's actualDuration. If
				-- the fiber has not been cloned though, (meaning no work was done), then
				-- this value will reflect the amount of time spent working on a previous
				-- render. In that case it should not bubble. We determine whether it was
				-- cloned by comparing the child pointer.
				actualDuration += child.actualDuration

				treeBaseDuration += child.treeBaseDuration
				child = child.sibling
			end

			completedWork.actualDuration = actualDuration
			completedWork.treeBaseDuration = treeBaseDuration
		else
			local child = completedWork.child
			while child ~= nil do
				-- ROBLOX performance: inline mergeLanes
				-- newChildLanes = mergeLanes(
				--   newChildLanes,
				--   mergeLanes(child.lanes, child.childLanes)
				-- )
				newChildLanes =
					bit32.bor(newChildLanes, bit32.bor(child.lanes, child.childLanes))

				subtreeFlags = bit32.bor(subtreeFlags, child.subtreeFlags)
				subtreeFlags = bit32.bor(subtreeFlags, child.flags)

				-- ROBLOX note: this was missed in the "new" version of the file in React 17, but is fixed in React 18
				-- Update the return pointer so the tree is consistent. This is a code
				-- smell because it assumes the commit phase is never concurrent with
				-- the render phase. Will address during refactor to alternate model.
				child.return_ = completedWork

				child = child.sibling
			end
		end

		completedWork.subtreeFlags = bit32.bor(completedWork.subtreeFlags, subtreeFlags)
	else
		-- Bubble up the earliest expiration time.
		if
			enableProfilerTimer
			and bit32.band(completedWork.mode, ProfileMode) ~= NoMode
		then
			-- In profiling mode, resetChildExpirationTime is also used to reset
			-- profiler durations.
			local treeBaseDuration = completedWork.selfBaseDuration

			local child = completedWork.child
			while child ~= nil do
				newChildLanes =
					mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes))

				-- "Static" flags share the lifetime of the fiber/hook they belong to,
				-- so we should bubble those up even during a bailout. All the other
				-- flags have a lifetime only of a single render + commit, so we should
				-- ignore them.
				subtreeFlags =
					bit32.bor(subtreeFlags, bit32.band(child.subtreeFlags, StaticMask))
				subtreeFlags =
					bit32.bor(subtreeFlags, bit32.band(child.flags, StaticMask))

				treeBaseDuration += child.treeBaseDuration
				child = child.sibling
			end

			completedWork.treeBaseDuration = treeBaseDuration
		else
			local child = completedWork.child
			while child ~= nil do
				-- ROBLOX performance: inline mergeLanes
				-- newChildLanes = mergeLanes(
				--   newChildLanes,
				--   mergeLanes(child.lanes, child.childLanes)
				-- )
				newChildLanes =
					bit32.bor(newChildLanes, bit32.bor(child.lanes, child.childLanes))

				-- "Static" flags share the lifetime of the fiber/hook they belong to,
				-- so we should bubble those up even during a bailout. All the other
				-- flags have a lifetime only of a single render + commit, so we should
				-- ignore them.
				subtreeFlags =
					bit32.bor(subtreeFlags, bit32.band(child.subtreeFlags, StaticMask))
				subtreeFlags =
					bit32.bor(subtreeFlags, bit32.band(child.flags, StaticMask))

				-- ROBLOX note: this was missed in the "new" version of the file in React 17, but is fixed in React 18
				-- Update the return pointer so the tree is consistent. This is a code
				-- smell because it assumes the commit phase is never concurrent with
				-- the render phase. Will address during refactor to alternate model.
				child.return_ = completedWork

				child = child.sibling
			end
		end

		completedWork.subtreeFlags = bit32.bor(completedWork.subtreeFlags, subtreeFlags)
	end

	completedWork.childLanes = newChildLanes

	return didBailout
end

-- FIXME (roblox): type refinement
-- local function completeWork(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes
-- ): Fiber | nil
local function completeWork(
	current,
	workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | nil
	local newProps = workInProgress.pendingProps

	if
		workInProgress.tag == IndeterminateComponent
		or workInProgress.tag == LazyComponent
		or workInProgress.tag == SimpleMemoComponent
		or workInProgress.tag == FunctionComponent
		or workInProgress.tag == ForwardRef
		or workInProgress.tag == Fragment
		or workInProgress.tag == Mode
		or workInProgress.tag == ContextConsumer
		or workInProgress.tag == MemoComponent
	then
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == ClassComponent then
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostRoot then
		popHostContainer(workInProgress)
		popTopLevelLegacyContextObject(workInProgress)
		resetMutableSourceWorkInProgressVersions()
		-- ROBLOX FIXME: type coercion
		-- local fiberRoot = (workInProgress.stateNode: FiberRoot)
		local fiberRoot = workInProgress.stateNode
		if fiberRoot.pendingContext then
			fiberRoot.context = fiberRoot.pendingContext
			fiberRoot.pendingContext = nil
		end
		if current == nil or current.child == nil then
			-- If we hydrated, pop so that we can delete any remaining children
			-- that weren't hydrated.
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				-- If we hydrated, then we'll need to schedule an update for
				-- the commit side-effects on the root.
				markUpdate(workInProgress)
			elseif not fiberRoot.hydrate then
				-- Schedule an effect to clear this container at the start of the next commit.
				-- This handles the case of React rendering into a container with previous children.
				-- It's also safe to do for updates too, because current.child would only be nil
				-- if the previous render was nil (so the the container would already be empty).
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end
		updateHostContainer(current, workInProgress)
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostComponent then
		popHostContext(workInProgress)
		local rootContainerInstance = getRootHostContainer()
		local type = workInProgress.type
		if current ~= nil and workInProgress.stateNode ~= nil then
			updateHostComponent(
				current,
				workInProgress,
				type,
				newProps,
				rootContainerInstance
			)

			if current.ref ~= workInProgress.ref then
				markRef(workInProgress)
			end
		else
			if not newProps then
				invariant(
					workInProgress.stateNode ~= nil,
					"We must have new props for new mounts. This error is likely "
						.. "caused by a bug in React. Please file an issue."
				)
				-- This can happen when we abort work.
				bubbleProperties(workInProgress)
				return nil
			end

			local currentHostContext = getHostContext()
			-- TODO: Move createInstance to beginWork and keep it on a context
			-- "stack" as the parent. Then append children as we go in beginWork
			-- or completeWork depending on whether we want to add them top->down or
			-- bottom->up. Top->down is faster in IE11.
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				-- TODO: Move this and createInstance step into the beginPhase
				-- to consolidate.
				if
					prepareToHydrateHostInstance(
						workInProgress,
						rootContainerInstance,
						currentHostContext
					)
				then
					-- If changes to the hydrated node need to be applied at the
					-- commit-phase we mark this as such.
					markUpdate(workInProgress)
				end
			else
				local instance = createInstance(
					type,
					newProps,
					rootContainerInstance,
					currentHostContext,
					workInProgress
				)

				appendAllChildren(instance, workInProgress, false, false)

				workInProgress.stateNode = instance

				-- Certain renderers require commit-time effects for initial mount.
				-- (eg DOM renderer supports auto-focus for certain elements).
				-- Make sure such renderers get scheduled for later work.
				if
					finalizeInitialChildren(
						instance,
						type,
						newProps,
						rootContainerInstance,
						currentHostContext
					)
				then
					markUpdate(workInProgress)
				end
			end

			if workInProgress.ref ~= nil then
				-- If there is a ref on a host node we need to schedule a callback
				markRef(workInProgress)
			end
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostText then
		local newText = newProps
		if current and workInProgress.stateNode ~= nil then
			local oldText = current.memoizedProps
			-- If we have an alternate, that means this is an update and we need
			-- to schedule a side-effect to do the updates.
			updateHostText(current, workInProgress, oldText, newText)
		else
			if typeof(newText) ~= "string" then
				invariant(
					workInProgress.stateNode ~= nil,
					"We must have new props for new mounts. This error is likely "
						.. "caused by a bug in React. Please file an issue."
				)
				-- This can happen when we abort work.
			end
			local rootContainerInstance = getRootHostContainer()
			local currentHostContext = getHostContext()
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				if prepareToHydrateHostTextInstance(workInProgress) then
					markUpdate(workInProgress)
				end
			else
				workInProgress.stateNode = createTextInstance(
					newText,
					rootContainerInstance,
					currentHostContext,
					workInProgress
				)
			end
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == Profiler then
		local didBailout = bubbleProperties(workInProgress)
		if not didBailout then
			-- Use subtreeFlags to determine which commit callbacks should fire.
			-- TODO: Move this logic to the commit phase, since we already check if
			-- a fiber's subtree contains effects. Refactor the commit phase's
			-- depth-first traversal so that we can put work tag-specific logic
			-- before or after committing a subtree's effects.
			local OnRenderFlag = Update
			local OnCommitFlag = Callback
			local OnPostCommitFlag = Passive
			local subtreeFlags = workInProgress.subtreeFlags
			local flags = workInProgress.flags
			local newFlags = flags

			-- Call onRender any time this fiber or its subtree are worked on.
			if
				bit32.band(flags, PerformedWork) ~= NoFlags
				or bit32.band(subtreeFlags, PerformedWork) ~= NoFlags
			then
				newFlags = bit32.bor(newFlags, OnRenderFlag)
			end

			-- Call onCommit only if the subtree contains layout work, or if it
			-- contains deletions, since those might result in unmount work, which
			-- we include in the same measure.
			-- TODO: Can optimize by using a static flag to track whether a tree
			-- contains layout effects, like we do for passive effects.
			if
				bit32.band(flags, bit32.bor(LayoutMask, Deletion)) ~= NoFlags
				or bit32.band(subtreeFlags, bit32.bor(LayoutMask, Deletion))
					~= NoFlags
			then
				newFlags = bit32.bor(newFlags, OnCommitFlag)
			end

			-- Call onPostCommit only if the subtree contains passive work.
			-- Don't have to check for deletions, because Deletion is already
			-- a passive flag.
			if
				bit32.band(flags, PassiveMask) ~= NoFlags
				or bit32.band(subtreeFlags, PassiveMask) ~= NoFlags
			then
				newFlags = bit32.bor(newFlags, OnPostCommitFlag)
			end
			workInProgress.flags = newFlags
		else
			-- This fiber and its subtree bailed out, so don't fire any callbacks.
		end

		return nil
	elseif workInProgress.tag == SuspenseComponent then
		popSuspenseContext(workInProgress)
		local nextState: nil | SuspenseState = workInProgress.memoizedState

		if enableSuspenseServerRenderer then
			-- ROBLOX FIXME: remove :: recast once Luau understands if statement nil check
			if nextState ~= nil and (nextState :: SuspenseState).dehydrated ~= nil then
				if current == nil then
					local wasHydrated = popHydrationState(workInProgress)
					invariant(
						wasHydrated,
						"A dehydrated suspense component was completed without a hydrated node. "
							.. "This is probably a bug in React."
					)
					prepareToHydrateHostSuspenseInstance(workInProgress)
					if enableSchedulerTracing then
						markSpawnedWork(OffscreenLane)
					end
					bubbleProperties(workInProgress)
					if enableProfilerTimer then
						if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
							local isTimedOutSuspense = nextState ~= nil
							if isTimedOutSuspense then
								-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
								local primaryChildFragment = workInProgress.child
								if primaryChildFragment ~= nil then
									-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
									workInProgress.treeBaseDuration = (
										primaryChildFragment.treeBaseDuration :: any
									) :: number
								end
							end
						end
					end
					return nil
				else
					-- We should never have been in a hydration state if we didn't have a current.
					-- However, in some of those paths, we might have reentered a hydration state
					-- and then we might be inside a hydration state. In that case, we'll need to exit out of it.
					resetHydrationState()
					if bit32.band(workInProgress.flags, DidCapture) == NoFlags then
						-- This boundary did not suspend so it's now hydrated and unsuspended.
						workInProgress.memoizedState = nil
					end
					-- If nothing suspended, we need to schedule an effect to mark this boundary
					-- as having hydrated so events know that they're free to be invoked.
					-- It's also a signal to replay events and the suspense callback.
					-- If something suspended, schedule an effect to attach retry listeners.
					-- So we might as well always mark this.
					workInProgress.flags = bit32.bor(workInProgress.flags, Update)
					bubbleProperties(workInProgress)
					if enableProfilerTimer then
						if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
							local isTimedOutSuspense = nextState ~= nil
							if isTimedOutSuspense then
								-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
								local primaryChildFragment = workInProgress.child
								if primaryChildFragment ~= nil then
									-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
									-- ROBLOX deviation: remove recast to silence analyze
									workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration
								end
							end
						end
					end
					return nil
				end
			end
		end

		if bit32.band(workInProgress.flags, DidCapture) ~= NoFlags then
			-- Something suspended. Re-render with the fallback children.
			workInProgress.lanes = renderLanes
			-- Do not reset the effect list.
			if
				enableProfilerTimer
				and bit32.band(workInProgress.mode, ProfileMode) ~= NoMode
			then
				transferActualDuration(workInProgress)
			end
			-- Don't bubble properties in this case.
			return workInProgress
		end

		local nextDidTimeout = nextState ~= nil
		local prevDidTimeout = false
		if current == nil then
			if workInProgress.memoizedProps.fallback ~= nil then
				popHydrationState(workInProgress)
			end
		else
			local prevState: nil | SuspenseState = current.memoizedState
			prevDidTimeout = prevState ~= nil
		end

		if nextDidTimeout and not prevDidTimeout then
			-- If this subtreee is running in blocking mode we can suspend,
			-- otherwise we won't suspend.
			-- TODO: This will still suspend a synchronous tree if anything
			-- in the concurrent tree already suspended during this render.
			-- This is a known bug.
			if bit32.band(workInProgress.mode, BlockingMode) ~= NoMode then
				-- TODO: Move this back to throwException because this is too late
				-- if this is a large tree which is common for initial loads. We
				-- don't know if we should restart a render or not until we get
				-- this marker, and this is too late.
				-- If this render already had a ping or lower pri updates,
				-- and this is the first time we know we're going to suspend we
				-- should be able to immediately restart from within throwException.
				local hasInvisibleChildContext = current == nil
					and workInProgress.memoizedProps.unstable_avoidThisFallback
						~= true
				if
					hasInvisibleChildContext
					or hasSuspenseContext(
						suspenseStackCursor.current,
						InvisibleParentSuspenseContext :: SuspenseContext
					)
				then
					-- If this was in an invisible tree or a new render, then showing
					-- this boundary is ok.
					renderDidSuspend()
				else
					-- Otherwise, we're going to have to hide content so we should
					-- suspend for longer if possible.
					renderDidSuspendDelayIfPossible()
				end
			end
		end

		if supportsPersistence then
			-- TODO: Only schedule updates if not prevDidTimeout.
			if nextDidTimeout then
				-- If this boundary just timed out, schedule an effect to attach a
				-- retry listener to the promise. This flag is also used to hide the
				-- primary children.
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if supportsMutation then
			-- TODO: Only schedule updates if these values are non equal, i.e. it changed.
			if nextDidTimeout or prevDidTimeout then
				-- If this boundary just timed out, schedule an effect to attach a
				-- retry listener to the promise. This flag is also used to hide the
				-- primary children. In mutation mode, we also need the flag to
				-- *unhide* children that were previously hidden, so check if this
				-- is currently timed out, too.
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if
			enableSuspenseCallback
			and workInProgress.updateQueue ~= nil
			and workInProgress.memoizedProps.suspenseCallback ~= nil
		then
			-- Always notify the callback
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
		bubbleProperties(workInProgress)
		if enableProfilerTimer then
			if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
				if nextDidTimeout then
					-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
					local primaryChildFragment = workInProgress.child
					if primaryChildFragment ~= nil then
						-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
						-- ROBLOX deviation: remove recast to silence analyze
						workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration
					end
				end
			end
		end
		return nil
	elseif workInProgress.tag == HostPortal then
		popHostContainer(workInProgress)
		updateHostContainer(current, workInProgress)
		if current == nil then
			preparePortalMount(workInProgress.stateNode.containerInfo)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == ContextProvider then
		-- Pop provider fiber
		popProvider(workInProgress)
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == IncompleteClassComponent then
		-- Same as class component case. I put it down here so that the tags are
		-- sequential to ensure this switch is compiled to a jump table.
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == SuspenseListComponent then
		unimplemented("SuspenseListComponent")
	-- popSuspenseContext(workInProgress)

	-- local renderState: nil | SuspenseListRenderState =
	--   workInProgress.memoizedState

	-- if renderState == nil)
	--   -- We're running in the default, "independent" mode.
	--   -- We don't do anything in this mode.
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end

	-- local didSuspendAlready = (workInProgress.flags & DidCapture) ~= NoFlags

	-- local renderedTail = renderState.rendering
	-- if renderedTail == nil)
	--   -- We just rendered the head.
	--   if !didSuspendAlready)
	--     -- This is the first pass. We need to figure out if anything is still
	--     -- suspended in the rendered set.

	--     -- If new content unsuspended, but there's still some content that
	--     -- didn't. Then we need to do a second pass that forces everything
	--     -- to keep showing their fallbacks.

	--     -- We might be suspended if something in this render pass suspended, or
	--     -- something in the previous committed pass suspended. Otherwise,
	--     -- there's no chance so we can skip the expensive call to
	--     -- findFirstSuspended.
	--     local cannotBeSuspended =
	--       renderHasNotSuspendedYet() and
	--       (current == nil or (current.flags & DidCapture) == NoFlags)
	--     if !cannotBeSuspended)
	--       local row = workInProgress.child
	--       while (row ~= nil)
	--         local suspended = findFirstSuspended(row)
	--         if suspended ~= nil)
	--           didSuspendAlready = true
	--           workInProgress.flags |= DidCapture
	--           cutOffTailIfNeeded(renderState, false)

	--           -- If this is a newly suspended tree, it might not get committed as
	--           -- part of the second pass. In that case nothing will subscribe to
	--           -- its thennables. Instead, we'll transfer its thennables to the
	--           -- SuspenseList so that it can retry if they resolve.
	--           -- There might be multiple of these in the list but since we're
	--           -- going to wait for all of them anyway, it doesn't really matter
	--           -- which ones gets to ping. In theory we could get clever and keep
	--           -- track of how many dependencies remain but it gets tricky because
	--           -- in the meantime, we can add/remove/change items and dependencies.
	--           -- We might bail out of the loop before finding any but that
	--           -- doesn't matter since that means that the other boundaries that
	--           -- we did find already has their listeners attached.
	--           local newThennables = suspended.updateQueue
	--           if newThennables ~= nil)
	--             workInProgress.updateQueue = newThennables
	--             workInProgress.flags |= Update
	--           end

	--           -- Rerender the whole list, but this time, we'll force fallbacks
	--           -- to stay in place.
	--           -- Reset the child fibers to their original state.
	--           workInProgress.subtreeFlags = NoFlags
	--           resetChildFibers(workInProgress, renderLanes)

	--           -- Set up the Suspense Context to force suspense and immediately
	--           -- rerender the children.
	--           pushSuspenseContext(
	--             workInProgress,
	--             setShallowSuspenseContext(
	--               suspenseStackCursor.current,
	--               ForceSuspenseFallback,
	--             ),
	--           )
	--           -- Don't bubble properties in this case.
	--           return workInProgress.child
	--         end
	--         row = row.sibling
	--       end
	--     end

	--     if renderState.tail ~= nil and now() > getRenderTargetTime())
	--       -- We have already passed our CPU deadline but we still have rows
	--       -- left in the tail. We'll just give up further attempts to render
	--       -- the main content and only render fallbacks.
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       cutOffTailIfNeeded(renderState, false)

	--       -- Since nothing actually suspended, there will nothing to ping this
	--       -- to get it started back up to attempt the next item. While in terms
	--       -- of priority this work has the same priority as this current render,
	--       -- it's not part of the same transition once the transition has
	--       -- committed. If it's sync, we still want to yield so that it can be
	--       -- painted. Conceptually, this is really the same as pinging.
	--       -- We can use any RetryLane even if it's the one currently rendering
	--       -- since we're leaving it behind on this node.
	--       workInProgress.lanes = SomeRetryLane
	--       if enableSchedulerTracing)
	--         markSpawnedWork(SomeRetryLane)
	--       end
	--     end
	--   else
	--     cutOffTailIfNeeded(renderState, false)
	--   end
	--   -- Next we're going to render the tail.
	-- else
	--   -- Append the rendered row to the child list.
	--   if !didSuspendAlready)
	--     local suspended = findFirstSuspended(renderedTail)
	--     if suspended ~= nil)
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       -- Ensure we transfer the update queue to the parent so that it doesn't
	--       -- get lost if this row ends up dropped during a second pass.
	--       local newThennables = suspended.updateQueue
	--       if newThennables ~= nil)
	--         workInProgress.updateQueue = newThennables
	--         workInProgress.flags |= Update
	--       end

	--       cutOffTailIfNeeded(renderState, true)
	--       -- This might have been modified.
	--       if
	--         renderState.tail == nil and
	--         renderState.tailMode == 'hidden' and
	--         !renderedTail.alternate and
	--         !getIsHydrating() -- We don't cut it if we're hydrating.
	--       )
	--         -- We're done.
	--         bubbleProperties(workInProgress)
	--         return nil
	--       end
	--     } else if
	--       -- The time it took to render last row is greater than the remaining
	--       -- time we have to render. So rendering one more row would likely
	--       -- exceed it.
	--       now() * 2 - renderState.renderingStartTime >
	--         getRenderTargetTime() and
	--       renderLanes ~= OffscreenLane
	--     )
	--       -- We have now passed our CPU deadline and we'll just give up further
	--       -- attempts to render the main content and only render fallbacks.
	--       -- The assumption is that this is usually faster.
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       cutOffTailIfNeeded(renderState, false)

	--       -- Since nothing actually suspended, there will nothing to ping this
	--       -- to get it started back up to attempt the next item. If we can show
	--       -- them, then they really have the same priority as this render.
	--       -- So we'll pick it back up the very next render pass once we've had
	--       -- an opportunity to yield for paint.
	--       workInProgress.lanes = SomeRetryLane
	--       if enableSchedulerTracing)
	--         markSpawnedWork(SomeRetryLane)
	--       end
	--     end
	--   end
	--   if renderState.isBackwards)
	--     -- The effect list of the backwards tail will have been added
	--     -- to the end. This breaks the guarantee that life-cycles fire in
	--     -- sibling order but that isn't a strong guarantee promised by React.
	--     -- Especially since these might also just pop in during future commits.
	--     -- Append to the beginning of the list.
	--     renderedTail.sibling = workInProgress.child
	--     workInProgress.child = renderedTail
	--   else
	--     local previousSibling = renderState.last
	--     if previousSibling ~= nil)
	--       previousSibling.sibling = renderedTail
	--     else
	--       workInProgress.child = renderedTail
	--     end
	--     renderState.last = renderedTail
	--   end
	-- end

	-- if renderState.tail ~= nil)
	--   -- We still have tail rows to render.
	--   -- Pop a row.
	--   local next = renderState.tail
	--   renderState.rendering = next
	--   renderState.tail = next.sibling
	--   renderState.renderingStartTime = now()
	--   next.sibling = nil

	--   -- Restore the context.
	--   -- TODO: We can probably just avoid popping it instead and only
	--   -- setting it the first time we go from not suspended to suspended.
	--   local suspenseContext = suspenseStackCursor.current
	--   if didSuspendAlready)
	--     suspenseContext = setShallowSuspenseContext(
	--       suspenseContext,
	--       ForceSuspenseFallback,
	--     )
	--   else
	--     suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
	--   end
	--   pushSuspenseContext(workInProgress, suspenseContext)
	--   -- Do a pass over the next row.
	--   -- Don't bubble properties in this case.
	--   return next
	-- end
	-- bubbleProperties(workInProgress)
	-- return nil
	-- end
	elseif workInProgress.tag == FundamentalComponent then
		unimplemented("FundamentalComponent")
	--   if enableFundamentalAPI)
	--   local fundamentalImpl = workInProgress.type.impl
	--   local fundamentalInstance: ReactFundamentalComponentInstance<
	--     any,
	--     any,
	--   > | nil = workInProgress.stateNode

	--   if fundamentalInstance == nil)
	--     local getInitialState = fundamentalImpl.getInitialState
	--     local fundamentalState
	--     if getInitialState ~= undefined)
	--       fundamentalState = getInitialState(newProps)
	--     end
	--     fundamentalInstance = workInProgress.stateNode = createFundamentalStateInstance(
	--       workInProgress,
	--       newProps,
	--       fundamentalImpl,
	--       fundamentalState or {},
	--     )
	--     local instance = ((getFundamentalComponentInstance(
	--       fundamentalInstance,
	--     ): any): Instance)
	--     fundamentalInstance.instance = instance
	--     if fundamentalImpl.reconcileChildren == false)
	--       bubbleProperties(workInProgress)
	--       return nil
	--     end
	--     appendAllChildren(instance, workInProgress, false, false)
	--     mountFundamentalComponent(fundamentalInstance)
	--   else
	--     -- We fire update in commit phase
	--     local prevProps = fundamentalInstance.props
	--     fundamentalInstance.prevProps = prevProps
	--     fundamentalInstance.props = newProps
	--     fundamentalInstance.currentFiber = workInProgress
	--     if supportsPersistence)
	--       local instance = cloneFundamentalInstance(fundamentalInstance)
	--       fundamentalInstance.instance = instance
	--       appendAllChildren(instance, workInProgress, false, false)
	--     end
	--     local shouldUpdate = shouldUpdateFundamentalComponent(
	--       fundamentalInstance,
	--     )
	--     if shouldUpdate)
	--       markUpdate(workInProgress)
	--     end
	--   end
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif workInProgress.tag == ScopeComponent then
		unimplemented("ScopeComponent")
	-- if enableScopeAPI)
	--   if current == nil)
	--     local scopeInstance: ReactScopeInstance = createScopeInstance()
	--     workInProgress.stateNode = scopeInstance
	--     prepareScopeUpdate(scopeInstance, workInProgress)
	--     if workInProgress.ref ~= nil)
	--       markRef(workInProgress)
	--       markUpdate(workInProgress)
	--     end
	--   else
	--     if workInProgress.ref ~= nil)
	--       markUpdate(workInProgress)
	--     end
	--     if current.ref ~= workInProgress.ref)
	--       markRef(workInProgress)
	--     end
	--   end
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif workInProgress.tag == Block then
		unimplemented("Block")
	-- if enableBlocksAPI)
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif
		workInProgress.tag == OffscreenComponent
		or workInProgress.tag == LegacyHiddenComponent
	then
		popRenderLanes(workInProgress)
		local nextState: OffscreenState | nil = workInProgress.memoizedState
		local nextIsHidden = nextState ~= nil

		if current ~= nil then
			local prevState: OffscreenState | nil = current.memoizedState

			local prevIsHidden = prevState ~= nil
			if
				prevIsHidden ~= nextIsHidden
				and newProps.mode ~= "unstable-defer-without-hiding"
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end

		-- Don't bubble properties for hidden children.
		if
			not nextIsHidden
			or includesSomeLane(
				ReactFiberWorkLoop.subtreeRenderLanes,
				OffscreenLane :: Lane
			)
			or bit32.band(workInProgress.mode, ConcurrentMode) == NoMode
		then
			bubbleProperties(workInProgress)
		end

		return nil
	end
	invariant(
		false,
		"Unknown unit of work tag (%s). This error is likely caused by a bug in "
			.. "React. Please file an issue.",
		tostring(workInProgress.tag)
	)
	return nil
end

return {
	completeWork = completeWork,
} ]]
cX.Children._410737c30628dffff0053af7f74a38f6=df
local dg

local dh={ClassName="ModuleScript",Children={},Properties={}}
dh.Name="ReactFiberComponentStack"
dh.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/72d00ab623502983ebd7ac0756cf2787df109811/packages/react-reconciler/src/ReactFiberComponentStack.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Function = (...any) -> ...any
type Error = LuauPolyfill.Error

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local HostComponent = ReactWorkTags.HostComponent
local LazyComponent = ReactWorkTags.LazyComponent
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local ForwardRef = ReactWorkTags.ForwardRef
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local ClassComponent = ReactWorkTags.ClassComponent

local ReactComponentStackFrame = require(Packages.Shared).ReactComponentStackFrame
local describeBuiltInComponentFrame =
	ReactComponentStackFrame.describeBuiltInComponentFrame
local describeFunctionComponentFrame =
	ReactComponentStackFrame.describeFunctionComponentFrame
local describeClassComponentFrame = ReactComponentStackFrame.describeClassComponentFrame

local function describeFiber(fiber: Fiber): string
	-- deviation: untangling some nested ternaries to use more idiomatic if/else
	local owner: nil | Function = nil
	if _G.__DEV__ then
		-- FIXME (roblox): Luau's limited narrowing necessitates this local
		local debugOwner = fiber._debugOwner
		if debugOwner then
			owner = debugOwner.type
		end
	end
	local source = nil
	if _G.__DEV__ then
		source = fiber._debugSource
	end
	if fiber.tag == HostComponent then
		return describeBuiltInComponentFrame(fiber.type, source, owner)
	elseif fiber.tag == LazyComponent then
		return describeBuiltInComponentFrame("Lazy", source, owner)
	elseif fiber.tag == SuspenseComponent then
		return describeBuiltInComponentFrame("Suspense", source, owner)
	elseif fiber.tag == SuspenseListComponent then
		return describeBuiltInComponentFrame("SuspenseList", source, owner)
	elseif
		fiber.tag == FunctionComponent
		or fiber.tag == IndeterminateComponent
		or fiber.tag == SimpleMemoComponent
	then
		return describeFunctionComponentFrame(fiber.type, source, owner)
	elseif fiber.tag == ForwardRef then
		return describeFunctionComponentFrame(fiber.type.render, source, owner)
	elseif fiber.tag == ClassComponent then
		return describeClassComponentFrame(fiber.type, source, owner)
	else
		return ""
	end
end

return {
	getStackByFiberInDevAndProd = function(workInProgress: Fiber?): string
		local ok: boolean, result: Error | string = pcall(function()
			local info = ""
			local node = workInProgress
			repeat
				info ..= describeFiber(node :: Fiber)
				node = (node :: Fiber).return_
			until node == nil
			return info
		end)

		if not ok then
			local message = "\nError generating stack: "
			if
				typeof(result) == "table"
				and (result :: Error).message
				and (result :: Error).stack
			then
				return message
					.. (result :: Error).message
					.. "\n"
					.. tostring((result :: Error).stack)
			end
			return message .. tostring(result)
		end

		return result :: string
	end,
} ]]
cX.Children._e2790d20451dba3943da0470fbb41ce7=dh
local di

local dj={ClassName="ModuleScript",Children={},Properties={}}
dj.Name="ReactFiberContext.new"
dj.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/a724a3b578dce77d427bef313102a4d0e978d9b4/packages/react-reconciler/src/ReactFiberContext.new.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local __DEV__ = _G.__DEV__ :: boolean
local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ =
	_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ :: boolean

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Error = LuauPolyfill.Error

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local isFiberMounted = require(script.Parent.ReactFiberTreeReflection).isFiberMounted
local disableLegacyContext =
	require(Packages.Shared).ReactFeatureFlags.disableLegacyContext
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local getComponentName = require(Packages.Shared).getComponentName
local checkPropTypes = require(Packages.Shared).checkPropTypes

local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

local warnedAboutMissingGetChildContext

if __DEV__ then
	warnedAboutMissingGetChildContext = {}
end

local emptyContextObject = {}
if __DEV__ then
	Object.freeze(emptyContextObject)
end

-- deviation: Common types
type Object = { [any]: any }

-- A cursor to the current merged context object on the stack.
local contextStackCursor: StackCursor<Object> = createCursor(emptyContextObject)
-- A cursor to a boolean indicating whether the context has changed.
local didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false)
-- Keep track of the previous context object that was on the stack.
-- We use this to get access to the parent context after we have already
-- pushed the next context provider, and now need to merge their contexts.
local previousContext: Object = emptyContextObject

-- deviation: Pre-declare function
local isContextProvider

-- deviation: FIXME: `Component: Function` - lock down component type def
local function getUnmaskedContext(
	workInProgress: Fiber,
	Component: any,
	didPushOwnContextIfProvider: boolean
): Object
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	if didPushOwnContextIfProvider and isContextProvider(Component) then
		-- If the fiber is a context provider itself, when we read its context
		-- we may have already pushed its own child context on the stack. A context
		-- provider should not "see" its own child context. Therefore we read the
		-- previous (parent) context instead for a context provider.
		return previousContext
	end
	return contextStackCursor.current
	-- end
end

local function cacheContext(
	workInProgress: Fiber,
	unmaskedContext: Object,
	maskedContext: Object
): ()
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	local instance = workInProgress.stateNode
	instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext
	instance.__reactInternalMemoizedMaskedChildContext = maskedContext
	-- end
end

local function getMaskedContext(workInProgress: Fiber, unmaskedContext: Object): Object
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	local type_ = workInProgress.type
	-- deviation: For function components, we can't support `contextTypes`;
	-- instead, just return unmaskedContext
	if type(type_) == "function" then
		return unmaskedContext
	end

	local contextTypes = type_.contextTypes
	if not contextTypes then
		return emptyContextObject
	end

	-- Avoid recreating masked context unless unmasked context has changed.
	-- Failing to do this will result in unnecessary calls to componentWillReceiveProps.
	-- This may trigger infinite loops if componentWillReceiveProps calls setState.
	local instance = workInProgress.stateNode
	if
		instance
		and instance.__reactInternalMemoizedUnmaskedChildContext == unmaskedContext
	then
		return instance.__reactInternalMemoizedMaskedChildContext
	end

	local context = {}
	for key, _ in contextTypes do
		context[key] = unmaskedContext[key]
	end

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local name = getComponentName(type_) or "Unknown"
		-- ROBLOX deviation: nil as second argument for validateProps compatibility
		checkPropTypes(contextTypes, nil, context, "context", name)
	end

	-- Cache unmasked context so we can avoid recreating masked context unless necessary.
	-- Context is created before the class component is instantiated so check for instance.
	if instance then
		cacheContext(workInProgress, unmaskedContext, context)
	end

	return context
	-- end
end

local function hasContextChanged(): boolean
	if disableLegacyContext then
		return false
	else
		return didPerformWorkStackCursor.current
	end
end

-- deviation: `type: Function` - lock down component type def
function isContextProvider(type_): boolean
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return false
	-- else
	-- ROBLOX deviation: context types only valid for class components
	-- ROBLOX performance: type is already guarded as being a ClassComponent and/or typeof == 'table' in all call sites
	if type(type_) == "function" then
		return false
	end
	local childContextTypes = type_.childContextTypes
	return childContextTypes ~= nil
	-- end
end

local function popContext(fiber: Fiber): ()
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	pop(didPerformWorkStackCursor, fiber)
	pop(contextStackCursor, fiber)
	-- end
end

local function popTopLevelContextObject(fiber: Fiber): ()
	-- ROBLOX performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	pop(didPerformWorkStackCursor, fiber)
	pop(contextStackCursor, fiber)
	-- end
end

local function pushTopLevelContextObject(
	fiber: Fiber,
	context: Object,
	didChange: boolean
): ()
	-- ROBLOX performance: disable always-false cmp in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	if contextStackCursor.current ~= emptyContextObject then
		error(
			Error.new(
				"Unexpected context found on stack. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	push(contextStackCursor, context, fiber)
	push(didPerformWorkStackCursor, didChange, fiber)
	-- end
end

local function processChildContext(
	fiber: Fiber,
	type_: any,
	parentContext: Object
): Object
	-- ROBLOX performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return parentContext
	-- else
	local instance = fiber.stateNode
	local childContextTypes = type_.childContextTypes

	-- TODO (bvaughn) Replace this behavior with an invariant() in the future.
	-- It has only been added in Fiber to match the (unintentional) behavior in Stack.
	if
		instance.getChildContext == nil
		or type(instance.getChildContext) ~= "function"
	then
		if __DEV__ then
			local componentName = getComponentName(type_) or "Unknown"

			if not warnedAboutMissingGetChildContext[componentName] then
				warnedAboutMissingGetChildContext[componentName] = true
				console.error(
					"%s.childContextTypes is specified but there is no getChildContext() method "
						.. "on the instance. You can either define getChildContext() on %s or remove "
						.. "childContextTypes from it.",
					componentName,
					componentName
				)
			end
		end
		return parentContext
	end

	local childContext = instance:getChildContext()
	for contextKey, _ in childContext do
		if childContextTypes[contextKey] == nil then
			local name = getComponentName(type_) or "Unknown"
			error(
				Error.new(
					string.format(
						'%s.getChildContext(): key "%s" is not defined in childContextTypes.',
						name,
						contextKey
					)
				)
			)
		end
	end
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local name = getComponentName(type_) or "Unknown"
		-- ROBLOX deviation: nil as second argument for validateProps compatibility
		checkPropTypes(childContextTypes, nil, childContext, "child context", name)
	end

	return Object.assign({}, parentContext, childContext)
	-- end
end

local function pushContextProvider(workInProgress: Fiber): boolean
	-- ROBLOX performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return false
	-- else
	local instance = workInProgress.stateNode
	-- We push the context as early as possible to ensure stack integrity.
	-- If the instance does not exist yet, we will push nil at first,
	-- and replace it on the stack later when invalidating the context.
	local memoizedMergedChildContext = (
		instance and instance.__reactInternalMemoizedMergedChildContext
	) or emptyContextObject

	-- Remember the parent context so we can merge with it later.
	-- Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
	previousContext = contextStackCursor.current
	push(contextStackCursor, memoizedMergedChildContext, workInProgress)
	push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress)

	return true
	-- end
end

local function invalidateContextProvider(
	workInProgress: Fiber,
	type_: any,
	didChange: boolean
): ()
	-- ROBLOX performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	local instance = workInProgress.stateNode

	if not instance then
		error(
			Error.new(
				"Expected to have an instance by this point. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	if didChange then
		-- Merge parent and own context.
		-- Skip this if we're not updating due to sCU.
		-- This avoids unnecessarily recomputing memoized values.
		local mergedContext = processChildContext(workInProgress, type_, previousContext)
		instance.__reactInternalMemoizedMergedChildContext = mergedContext

		-- Replace the old (or empty) context with the new one.
		-- It is important to unwind the context in the reverse order.
		pop(didPerformWorkStackCursor, workInProgress)
		pop(contextStackCursor, workInProgress)
		-- Now push the new context and mark that it has changed.
		push(contextStackCursor, mergedContext, workInProgress)
		push(didPerformWorkStackCursor, didChange, workInProgress)
	else
		pop(didPerformWorkStackCursor, workInProgress)
		push(didPerformWorkStackCursor, didChange, workInProgress)
	end
	-- end
end

local function findCurrentUnmaskedContext(fiber: Fiber): Object
	-- ROBLOX performance: eliminate always-false in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	-- Currently this is only used with renderSubtreeIntoContainer; not sure if it
	-- makes sense elsewhere
	if fiber.tag ~= ClassComponent or not isFiberMounted(fiber) then
		error(
			Error.new(
				"Expected subtree parent to be a mounted class component. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	-- ROBLOX TODO: Luau analyze can't accommodate the 'repeat until (not) nil' pattern
	local node: any = fiber
	repeat
		if node.tag == HostRoot then
			return node.stateNode.context
		elseif node.tag == ClassComponent then
			local Component = node.type
			-- ROBLOX deviation: inline specialized check for isContextProvider since we know it's a class
			if Component.childContextTypes ~= nil then
				return node.stateNode.__reactInternalMemoizedMergedChildContext
			end
		end

		node = node.return_
	until node == nil

	error(
		Error.new(
			"Found unexpected detached subtree parent. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	)
	-- end
end

return {
	emptyContextObject = emptyContextObject,
	getUnmaskedContext = getUnmaskedContext,
	cacheContext = cacheContext,
	getMaskedContext = getMaskedContext,
	hasContextChanged = hasContextChanged,
	popContext = popContext,
	popTopLevelContextObject = popTopLevelContextObject,
	pushTopLevelContextObject = pushTopLevelContextObject,
	processChildContext = processChildContext,
	isContextProvider = isContextProvider,
	pushContextProvider = pushContextProvider,
	invalidateContextProvider = invalidateContextProvider,
	findCurrentUnmaskedContext = findCurrentUnmaskedContext,
} ]]
cX.Children._689f3a2f07b806f476e9aaf38bedfab4=dj
local dk

local dl={ClassName="ModuleScript",Children={},Properties={}}
dl.Name="ReactFiberDevToolsHook.new"
dl.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberDevToolsHook.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object
local exports = {}

-- ROBLOX deviation: subset copied here from devtools-shared/backend/types, to have stronger enforcement than 'Object' without circular dep
type DevToolsHook = {
	-- ROBLOX TODO: ideally, ReactRenderer type would be importable from this file so we could use it here
	inject: (Object) -> number | nil,
	supportsFiber: boolean,
	isDisabled: boolean,
	--   ...
}

-- ROBLOX deviation: we use callable tables instead of functions sometimes, so typeof() == "function" isn't enough
local function isCallable(value)
	if typeof(value) == "function" then
		return true
	end
	if typeof(value) == "table" then
		local mt = getmetatable(value)
		if mt and rawget(mt, "__call") then
			return true
		end
		if value._isMockFunction then
			return true
		end
	end
	return false
end

local enableProfilerTimer = require(Packages.Shared).ReactFeatureFlags.enableProfilerTimer

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local DidCapture = require(script.Parent.ReactFiberFlags).DidCapture

-- ROBLOX deviation: we'll inject this a different way
-- declare var __REACT_DEVTOOLS_GLOBAL_HOOK__: Object | void

local rendererID = nil
local injectedHook = nil
local hasLoggedError = false

-- ROBLOX deviation: We use a function to handle the hook being changed at runtime
exports.isDevToolsPresent = function()
	return _G.__REACT_DEVTOOLS_GLOBAL_HOOK__ ~= nil
end

exports.injectInternals = function(internals: Object): boolean
	if _G.__REACT_DEVTOOLS_GLOBAL_HOOK__ == nil then
		-- No DevTools
		return false
	end
	local hook: DevToolsHook = _G.__REACT_DEVTOOLS_GLOBAL_HOOK__
	if hook.isDisabled then
		-- This isn't a real property on the hook, but it can be set to opt out
		-- of DevTools integration and associated warnings and logs.
		-- http://github.com/facebook/react/issues/3877
		return true
	end
	if not hook.supportsFiber then
		if _G.__DEV__ then
			console.error(
				"The installed version of React DevTools is too old and will not work "
					.. "with the current version of React. Please update React DevTools. "
					.. "https://reactjs.org/link/react-devtools"
			)
		end
		-- DevTools exists, even though it doesn't support Fiber.
		return true
	end
	local ok, err = pcall(function()
		rendererID = hook.inject(internals)
		-- We have successfully injected, so now it is safe to set up hooks.
		injectedHook = hook
	end)

	if not ok then
		-- Catch all errors because it is unsafe to throw during initialization.
		if _G.__DEV__ then
			console.error("React instrumentation encountered an error: %s.", err)
		end
	end
	-- DevTools exists
	return true
end

exports.onScheduleRoot = function(root: FiberRoot, children: ReactNodeList)
	if _G.__DEV__ then
		if
			injectedHook
			-- ROBLOX deviation: our mocked functions are tables with __call, since they have fields
			and isCallable(injectedHook.onScheduleFiberRoot)
		then
			local ok, err =
				pcall(injectedHook.onScheduleFiberRoot, rendererID, root, children)

			if not ok then
				if _G.__DEV__ and not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

exports.onCommitRoot = function(root: FiberRoot, priorityLevel: ReactPriorityLevel)
	if
		injectedHook
		-- ROBLOX deviation: our mocked functions are tables with __call, since they have fields
		and isCallable(injectedHook.onCommitFiberRoot)
	then
		local ok, err = pcall(function()
			local didError = bit32.band(root.current.flags, DidCapture) == DidCapture
			if enableProfilerTimer then
				injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError)
			else
				injectedHook.onCommitFiberRoot(rendererID, root, nil, didError)
			end
		end)
		if not ok then
			if _G.__DEV__ then
				if not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

exports.onCommitUnmount = function(fiber: Fiber)
	if
		injectedHook
		-- ROBLOX deviation: our mocked functions are tables with __call, since they have fields
		and isCallable(injectedHook.onCommitFiberUnmount)
	then
		local ok, err = pcall(injectedHook.onCommitFiberUnmount, rendererID, fiber)
		if not ok then
			if _G.__DEV__ then
				if not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

return exports ]]
cX.Children._ba91dd66e983627da6dd37468ba2ccc1=dl
local dm

local dn={ClassName="ModuleScript",Children={},Properties={}}
dn.Name="ReactFiberErrorDialog"
dn.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberErrorDialog.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

-- This module is forked in different environments.
-- By default, return `true` to log errors to the console.
-- Forks can return `false` if this isn't desirable.
local exports = {}

exports.showErrorDialog = function(boundary, errorInfo): boolean
	-- ROBLOX TODO: we may replace this with something that sends telemetry LUAFDN-222
	return true
end

return exports ]]
cX.Children._a61a042eecfe7dcd3acfad0ef3c3cd70=dn
local dp

local dq={ClassName="ModuleScript",Children={},Properties={}}
dq.Name="ReactFiberErrorLogger"
dq.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-reconciler/src/ReactFiberErrorLogger.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local setTimeout = LuauPolyfill.setTimeout

local Shared = require(Packages.Shared)
local console = Shared.console
local errorToString = Shared.errorToString

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactCapturedValue = require(script.Parent.ReactCapturedValue)
type CapturedValue<T> = ReactCapturedValue.CapturedValue<T>

local showErrorDialog = require(script.Parent.ReactFiberErrorDialog).showErrorDialog
local ClassComponent = require(script.Parent.ReactWorkTags).ClassComponent
local getComponentName = require(Packages.Shared).getComponentName

local exports = {}

exports.logCapturedError = function(boundary: Fiber, errorInfo: CapturedValue<any>)
	local ok, e = pcall(function()
		local logError = showErrorDialog(boundary, errorInfo)

		-- Allow injected showErrorDialog() to prevent default console.error logging.
		-- This enables renderers like ReactNative to better manage redbox behavior.
		if logError == false then
			-- ROBLOX Luau FIXME: needs void return Luau bugfix
			return nil
		end

		local error_ = errorInfo.value
		if _G.__DEV__ then
			local source = errorInfo.source
			local stack = errorInfo.stack
			local componentStack = stack or ""
			-- Browsers support silencing uncaught errors by calling
			-- `preventDefault()` in window `error` handler.
			-- We record this information as an expando on the error.
			if error_ ~= nil and error_._suppressLogging then
				if boundary.tag == ClassComponent then
					-- The error is recoverable and was silenced.
					-- Ignore it and don't print the stack addendum.
					-- This is handy for testing error boundaries without noise.
					return
				end
				-- The error is fatal. Since the silencing might have
				-- been accidental, we'll surface it anyway.
				-- However, the browser would have silenced the original error
				-- so we'll print it first, and then print the stack addendum.
				console["error"](error_) -- Don't transform to our wrapper
				-- For a more detailed description of this block, see:
				-- https://github.com/facebook/react/pull/13384
			end

			local componentName
			if source ~= nil then
				componentName = getComponentName(source.type)
			else
				componentName = nil
			end

			local componentNameMessage
			if componentName then
				componentNameMessage = "The above error occurred in the <"
					.. tostring(componentName)
					.. "> component:"
			else
				componentNameMessage =
					"The above error occurred in one of your React components:"
			end

			local errorBoundaryMessage
			local errorBoundaryName = getComponentName(boundary.type)
			if errorBoundaryName then
				errorBoundaryMessage = "React will try to recreate this component tree from scratch "
					.. "using the error boundary you provided, "
					.. errorBoundaryName
					.. "."
			else
				errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n"
					.. "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries."
			end
			local combinedMessage = componentNameMessage
				.. "\n"
				.. componentStack
				.. "\n\n"
				.. errorBoundaryMessage

			-- In development, we provide our own message with just the component stack.
			-- We don't include the original error message and JS stack because the browser
			-- has already printed it. Even if the application swallows the error, it is still
			-- displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
			console["error"](combinedMessage) -- Don't transform to our wrapper
		else
			-- In production, we print the error directly.
			-- This will include the message, the JS stack, and anything the browser wants to show.
			-- We pass the error object instead of custom message so that the browser displays the error natively.
			console["error"](inspect(error_)) -- Don't transform to our wrapper
		end

		-- ROBLOX Luau FIXME: needs void return Luau bugfix
		return nil
	end)

	if not ok then
		warn("failed to error with error: " .. inspect(e))
		-- ROBLOX TODO: we may need to think about this more deeply and do something different
		-- This method must not throw, or React internal state will get messed up.
		-- If console.error is overridden, or logCapturedError() shows a dialog that throws,
		-- we want to report this error outside of the normal stack as a last resort.
		-- https://github.com/facebook/react/issues/13188
		setTimeout(function()
			-- ROBLOX FIXME: the top-level Luau VM handler doesn't deal with non-string errors, so massage it until VM support lands
			error(errorToString(e :: any))
		end)
	end
end

return exports ]]
cX.Children._af657014a7f7ebd3d11032c11a1a1adb=dq
local dr

local ds={ClassName="ModuleScript",Children={},Properties={}}
ds.Name="ReactFiberFlags"
ds.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/37cb732c59863297e48f69ac1f6e2ba1aa1886f0/packages/react-reconciler/src/ReactFiberFlags.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

export type Flags = number

local exports = {}

-- Don't change these two values. They're used by React Dev Tools.
exports.NoFlags = --\[\[                      \]\]
	0b000000000000000000
exports.PerformedWork = --\[\[                \]\]
	0b000000000000000001

-- You can change the rest (and add more).
exports.Placement = --\[\[                    \]\]
	0b000000000000000010
exports.Update = --\[\[                       \]\]
	0b000000000000000100
exports.PlacementAndUpdate = --\[\[           \]\]
	0b000000000000000110
exports.Deletion = --\[\[                     \]\]
	0b000000000000001000
exports.ContentReset = --\[\[                 \]\]
	0b000000000000010000
exports.Callback = --\[\[                     \]\]
	0b000000000000100000
exports.DidCapture = --\[\[                   \]\]
	0b000000000001000000
exports.Ref = --\[\[                          \]\]
	0b000000000010000000
exports.Snapshot = --\[\[                     \]\]
	0b000000000100000000
exports.Passive = --\[\[                      \]\]
	0b000000001000000000
-- TODO (effects) Remove this bit once the new reconciler is synced to the old.
exports.PassiveUnmountPendingDev = --\[\[     \]\]
	0b000010000000000000
exports.Hydrating = --\[\[                    \]\]
	0b000000010000000000
exports.HydratingAndUpdate = --\[\[           \]\]
	0b000000010000000100

-- Passive & Update & Callback & Ref & Snapshot
exports.LifecycleEffectMask = --\[\[          \]\]
	0b000000001110100100

-- Union of all host effects
exports.HostEffectMask = --\[\[               \]\]
	0b000000011111111111

-- These are not really side effects, but we still reuse this field.
exports.Incomplete = --\[\[                   \]\]
	0b000000100000000000
exports.ShouldCapture = --\[\[                \]\]
	0b000001000000000000
exports.ForceUpdateForLegacySuspense = --\[\[ \]\]
	0b000100000000000000

-- Static tags describe aspects of a fiber that are not specific to a render,
-- e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
-- This enables us to defer more work in the unmount case,
-- since we can defer traversing the tree during layout to look for Passive effects,
-- and instead rely on the static flag as a signal that there may be cleanup work.
exports.PassiveStatic = --\[\[                \]\]
	0b001000000000000000

-- Union of side effect groupings as pertains to subtreeFlags
exports.BeforeMutationMask = --\[\[           \]\]
	0b000000001100001010
exports.MutationMask = --\[\[                 \]\]
	0b000000010010011110
exports.LayoutMask = --\[\[                   \]\]
	0b000000000010100100
exports.PassiveMask = --\[\[                  \]\]
	0b000000001000001000

-- Union of tags that don't get reset on clones.
-- This allows certain concepts to persist without recalculting them,
-- e.g. whether a subtree contains passive effects or portals.
exports.StaticMask = --\[\[                   \]\]
	0b001000000000000000

-- These flags allow us to traverse to fibers that have effects on mount
-- without traversing the entire tree after every commit for
-- double invoking
exports.MountLayoutDev = --\[\[               \]\]
	0b010000000000000000
exports.MountPassiveDev = --\[\[              \]\]
	0b100000000000000000

return exports ]]
cX.Children._bd7fe010de1258d082f87d3e477f9c4a=ds
local dt

local du={ClassName="ModuleScript",Children={},Properties={}}
du.Name="ReactFiberHooks.new"
du.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/ReactFiberHooks.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. message)
	error("FIXME (roblox): " .. message .. " is unimplemented")
end
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object

-- ROBLOX: use Bindings to implement useRef
local createRef = require(Packages.React).createRef
local createBinding = require(Packages.React).createBinding

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type Dispatcher = ReactInternalTypes.Dispatcher
type HookType = ReactInternalTypes.HookType
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local ReactHookEffectTags = require(script.Parent.ReactHookEffectTags)
type HookFlags = ReactHookEffectTags.HookFlags
type FiberRoot = ReactInternalTypes.FiberRoot
-- ROBLOX TODO: figure out how to expose types through dynamic exports
-- local type {OpaqueIDType} = require(script.Parent.ReactFiberHostConfig)
type OpaqueIDType = any

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableDebugTracing: boolean? = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler: boolean? = ReactFeatureFlags.enableSchedulingProfiler
local enableNewReconciler: boolean? = ReactFeatureFlags.enableNewReconciler
-- local decoupleUpdatePriorityFromScheduler = ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects

-- local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local DebugTracingMode = require(script.Parent.ReactTypeOfMode).DebugTracingMode
local NoLane = ReactFiberLane.NoLane
local NoLanes = ReactFiberLane.NoLanes
-- local InputContinuousLanePriority = ReactFiberLane.InputContinuousLanePriority
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes
local removeLanes = ReactFiberLane.removeLanes
local markRootEntangled = ReactFiberLane.markRootEntangled
local markRootMutableRead = ReactFiberLane.markRootMutableRead
-- local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
-- local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
-- local higherLanePriority = ReactFiberLane.higherLanePriority
-- local DefaultLanePriority = ReactFiberLane.DefaultLanePriority
local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local readContext = ReactFiberNewContext.readContext
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local UpdateEffect = ReactFiberFlags.Update
local PassiveEffect = ReactFiberFlags.Passive
local PassiveStaticEffect = ReactFiberFlags.PassiveStatic
local MountLayoutDevEffect = ReactFiberFlags.MountLayoutDev
local MountPassiveDevEffect = ReactFiberFlags.MountPassiveDev
local HookHasEffect = ReactHookEffectTags.HasEffect
local HookLayout = ReactHookEffectTags.Layout
local HookPassive = ReactHookEffectTags.Passive
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local warnIfNotCurrentlyActingUpdatesInDEV =
	ReactFiberWorkLoop.warnIfNotCurrentlyActingUpdatesInDEV
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local warnIfNotScopedWithMatchingAct = ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct
local requestEventTime = ReactFiberWorkLoop.requestEventTime
local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
local markSkippedUpdateLanes = ReactFiberWorkLoop.markSkippedUpdateLanes
local getWorkInProgressRoot = ReactFiberWorkLoop.getWorkInProgressRoot
local warnIfNotCurrentlyActingEffectsInDEV =
	ReactFiberWorkLoop.warnIfNotCurrentlyActingEffectsInDEV
-- local {
--   getWorkInProgressRoot,
--   requestUpdateLane,
--   requestEventTime,
--   warnIfNotCurrentlyActingEffectsInDEV,
-- } = require(script.Parent.ReactFiberWorkLoop.new)

local invariant = require(Packages.Shared).invariant
local getComponentName = require(Packages.Shared).getComponentName
-- local is = require(Packages.Shared).objectIs
local function is(x: any, y: any)
	return x == y and (x ~= 0 or 1 / x == 1 / y) or x ~= x and y ~= y -- eslint-disable-line no-self-compare
end
local markWorkInProgressReceivedUpdate =
	require(script.Parent["ReactFiberBeginWork.new"]).markWorkInProgressReceivedUpdate :: any
-- local {
--   UserBlockingPriority,
--   NormalPriority,
--   runWithPriority,
--   getCurrentPriorityLevel,
-- } = require(script.Parent.SchedulerWithReactIntegration.new)
local getIsHydrating =
	require(script.Parent["ReactFiberHydrationContext.new"]).getIsHydrating
-- local {
--   makeClientId,
--   makeClientIdInDEV,
--   makeOpaqueHydratingObject,
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local makeClientId = ReactFiberHostConfig.makeClientId
-- local makeOpaqueHydratingObject = ReactFiberHostConfig.makeOpaqueHydratingObject
-- local makeClientIdInDEV = ReactFiberHostConfig.makeClientIdInDEV

local ReactMutableSource = require(script.Parent["ReactMutableSource.new"])
local warnAboutMultipleRenderersDEV = ReactMutableSource.warnAboutMultipleRenderersDEV
local getWorkInProgressVersion = ReactMutableSource.getWorkInProgressVersion
local setWorkInProgressVersion = ReactMutableSource.setWorkInProgressVersion
local markSourceAsDirty = ReactMutableSource.markSourceAsDirty

-- local getIsRendering = require(script.Parent.ReactCurrentFiber).getIsRendering
local logStateUpdateScheduled =
	require(script.Parent.DebugTracing).logStateUpdateScheduled
local markStateUpdateScheduled =
	require(script.Parent.SchedulingProfiler).markStateUpdateScheduled

local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
-- local ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig

-- deviation: common types
type Array<T> = { [number]: T }

type Update<S, A> = {
	lane: Lane,
	action: A,
	eagerReducer: ((S, A) -> S) | nil,
	eagerState: S | nil,
	next: Update<S, A>,
	priority: ReactPriorityLevel?,
}

type UpdateQueue<S, A> = {
	pending: Update<S, A> | nil,
	dispatch: ((A) -> ...any) | nil,
	lastRenderedReducer: ((S, A) -> S) | nil,
	lastRenderedState: S | nil,
}

local didWarnAboutMismatchedHooksForComponent
local _didWarnAboutUseOpaqueIdentifier
if __DEV__ then
	_didWarnAboutUseOpaqueIdentifier = {}
	didWarnAboutMismatchedHooksForComponent = {}
end

export type Hook = {
	memoizedState: any,
	baseState: any,
	baseQueue: Update<any, any> | nil,
	queue: UpdateQueue<any, any> | nil,
	next: Hook?,
}

export type Effect = {
	tag: HookFlags,
	-- ROBLOX TODO: this needs Luau type pack support to express accurately
	create: (() -> (() -> ())) | () -> (),
	destroy: (() -> ())?,
	deps: Array<any> | nil,
	next: Effect,
}

export type FunctionComponentUpdateQueue = {
	lastEffect: Effect?,
}

type BasicStateAction<S> = ((S) -> S) | S

type Dispatch<A> = (A) -> ()

local exports: any = {}

-- These are set right before calling the component.
local renderLanes: Lanes = NoLanes
-- The work-in-progress fiber. I've named it differently to distinguish it from
-- the work-in-progress hook.
local currentlyRenderingFiber: Fiber = nil :: any

-- Hooks are stored as a linked list on the fiber's memoizedState field. The
-- current hook list is the list that belongs to the current fiber. The
-- work-in-progress hook list is a new list that will be added to the
-- work-in-progress fiber.
-- FIXME (roblox): type refinement
-- local currentHook: Hook | nil = nil
local currentHook: any = nil
-- FIXME (roblox): type refinement
-- local workInProgressHook: Hook | nil = nil
local workInProgressHook: any = nil

-- Whether an update was scheduled at any point during the render phase. This
-- does not get reset if we do another render pass; only when we're completely
-- finished evaluating this component. This is an optimization so we know
-- whether we need to clear render phase updates after a throw.
local didScheduleRenderPhaseUpdate: boolean = false
-- Where an update was scheduled only during the current render pass. This
-- gets reset after each attempt.
-- TODO: Maybe there's some way to consolidate this with
-- `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
local didScheduleRenderPhaseUpdateDuringThisPass: boolean = false

local RE_RENDER_LIMIT = 25

-- In DEV, this is the name of the currently executing primitive hook
local currentHookNameInDev: HookType? = nil

-- In DEV, this list ensures that hooks are called in the same order between renders.
-- The list stores the order of hooks used during the initial render (mount).
-- Subsequent renders (updates) reference this list.
local hookTypesDev: Array<HookType> | nil = nil
local hookTypesUpdateIndexDev: number = 0

-- In DEV, this tracks whether currently rendering component needs to ignore
-- the dependencies for Hooks that need them (e.g. useEffect or useMemo).
-- When true, such Hooks will always be "remounted". Only used during hot reload.
-- ROBLOX performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
local ignorePreviousDependencies: boolean = false

-- Deviation: move to top so below function can reference
local HooksDispatcherOnMountInDEV: Dispatcher | nil = nil
local HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | nil = nil
local HooksDispatcherOnUpdateInDEV: Dispatcher | nil = nil
local HooksDispatcherOnRerenderInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | nil = nil

-- ROBLOX deviation: Used to better compare dependency arrays with gaps
local function getHighestIndex(array: Array<any>)
	local highestIndex = 0
	for k, v in array do
		highestIndex = if k > highestIndex then k else highestIndex
	end
	return highestIndex
end

-- ROBLOX deviation: Used to better detect dependency arrays with gaps, to be
-- used in place of Array.isArray
local function isArrayOrSparseArray(deps: any)
	if type(deps) ~= "table" then
		return false
	end
	for k, _v in deps do
		if type(k) ~= "number" then
			return false
		end
	end
	return true
end

local function mountHookTypesDev()
	if __DEV__ then
		local hookName = (currentHookNameInDev :: any) :: HookType

		if hookTypesDev == nil then
			-- ROBLOX FIXME Luau: needs normalization (I think)
			hookTypesDev = ({ hookName } :: any) :: Array<HookType>
		else
			table.insert(hookTypesDev, hookName)
		end
	end
end

function updateHookTypesDev()
	if __DEV__ then
		-- ROBLOX FIXME Luau: needs normalization (I think) to avoid duplicate type declaration
		local hookName: HookType = (currentHookNameInDev :: any) :: HookType

		if hookTypesDev ~= nil then
			hookTypesUpdateIndexDev += 1
			if hookTypesDev[hookTypesUpdateIndexDev] ~= hookName then
				warnOnHookMismatchInDev(hookName)
			end
		end
	end
end

local function checkDepsAreArrayDev(deps: any)
	if __DEV__ then
		if deps ~= nil and not isArrayOrSparseArray(deps) then
			-- Verify deps, but only on mount to avoid extra checks.
			-- It's unlikely their type would change as usually you define them inline.
			console.error(
				"%s received a final argument that is not an array (instead, received `%s`). When "
					.. "specified, the final argument must be an array.",
				currentHookNameInDev,
				type(deps)
			)
		end
	end
end

function warnOnHookMismatchInDev(currentHookName: HookType)
	if __DEV__ then
		-- ROBLOX deviation: getComponentName will return nil in most Hook cases, use same fallback as elsewhere
		local componentName = getComponentName(currentlyRenderingFiber.type)
			or "Component"
		if not didWarnAboutMismatchedHooksForComponent[componentName] then
			didWarnAboutMismatchedHooksForComponent[componentName] = true

			if hookTypesDev ~= nil then
				local table_ = ""

				local secondColumnStart = 30

				for i = 1, hookTypesUpdateIndexDev do
					local oldHookName = (hookTypesDev :: any)[i]
					local newHookName
					if i == hookTypesUpdateIndexDev then
						newHookName = currentHookName
					else
						newHookName = oldHookName
					end

					-- ROBLOX note: upstream lets this be void and string concat coerces it to 'undefined'
					local row = tostring(i) .. ". " .. (oldHookName or "undefined")

					-- Extra space so second column lines up
					-- lol @ IE not supporting String#repeat
					while string.len(row) < secondColumnStart do
						row ..= " "
					end

					row ..= newHookName .. "\n"

					table_ ..= row
				end

				console.error(
					"React has detected a change in the order of Hooks called by %s. "
						.. "This will lead to bugs and errors if not fixed. "
						.. "For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
						.. "   Previous render            Next render\n"
						.. "   ------------------------------------------------------\n"
						.. "%s"
						.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
					componentName,
					table_
				)
			end
		end
	end
end

local function throwInvalidHookError(): ()
	error(
		Error.new(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
	)
end

-- FIXME (roblox): type refinement
-- prevDeps: Array<any>?
local function areHookInputsEqual(nextDeps: Array<any>, prevDeps: Array<any>)
	if __DEV__ then
		if ignorePreviousDependencies then
			-- Only true when this component is being hot reloaded.
			return false
		end
	end

	if prevDeps == nil then
		if __DEV__ then
			-- ROBLOX TODO: no unit tests in upstream for this, we should add some
			console.error(
				"%s received a final argument during this render, but not during "
					.. "the previous render. Even though the final argument is optional, "
					.. "its type cannot change between renders.",
				currentHookNameInDev
			)
		end
		return false
	end

	-- ROBLOX deviation START: calculate lengths with iteration instead of # to
	-- accommodate nil values and disable warning for differing lengths
	local nextDepsLength = getHighestIndex(nextDeps)
	local prevDepsLength = getHighestIndex(prevDeps)

	-- ROBLOX note: In upstream, lengths aren't even compared unless dev mode is
	-- enabled because they _always_ indicate a misuse of dependency arrays. In
	-- luau, since trailing `nil`s effectively change the length of the array,
	-- it's possible to trigger this scenario with a valid use of the dependencies
	-- array (e.g. `{1, 2, 3}` -> `{1, 2, nil}`)
	if nextDepsLength ~= prevDepsLength then
		-- ROBLOX TODO: linting like upstream does would make this warning less
		-- necessary, and would help justify our exclusion of the warning.

		-- https://jira.rbx.com/browse/LUAFDN-1175
		-- if __DEV__ then
		--   console.error(
		--     "The final argument passed to %s changed size between renders. The " ..
		--       "order and size of this array must remain constant.\n\n" ..
		--       "Previous: %s\n" ..
		--       "Incoming: %s",
		--     currentHookNameInDev,
		--     inspect(prevDeps),
		--     inspect(nextDeps)
		--   )
		-- end

		-- Short-circuit here since we know that different lengths means a change in
		-- values, even if it's due to trailing nil values
		return false
	end
	-- ROBLOX deviation END

	local minDependencyCount = math.min(prevDepsLength, nextDepsLength)
	for i = 1, minDependencyCount do
		if is(nextDeps[i], prevDeps[i]) then
			continue
		end
		return false
	end
	return true
end

exports.bailoutHooks = function(current: Fiber, workInProgress: Fiber, lanes: Lanes)
	-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
	workInProgress.updateQueue = current.updateQueue
	if __DEV__ and enableDoubleInvokingEffects then
		workInProgress.flags = bit32.band(
			workInProgress.flags,
			bit32.bnot(
				bit32.bor(
					MountPassiveDevEffect,
					PassiveEffect,
					MountLayoutDevEffect,
					UpdateEffect
				)
			)
		)
	else
		workInProgress.flags = bit32.band(
			workInProgress.flags,
			bit32.bnot(bit32.bor(PassiveEffect, UpdateEffect))
		)
	end
	current.lanes = removeLanes(current.lanes, lanes)
end

local _isUpdatingOpaqueValueInRenderPhase = false
exports.resetHooksAfterThrow = function(): ()
	-- We can assume the previous dispatcher is always this one, since we set it
	-- at the beginning of the render phase and there's no re-entrancy.
	ReactCurrentDispatcher.current = exports.ContextOnlyDispatcher

	if didScheduleRenderPhaseUpdate then
		-- There were render phase updates. These are only valid for this render
		-- phase, which we are now aborting. Remove the updates from the queues so
		-- they do not persist to the next render. Do not remove updates from hooks
		-- that weren't processed.
		--
		-- Only reset the updates from the queue if it has a clone. If it does
		-- not have a clone, that means it wasn't processed, and the updates were
		-- scheduled before we entered the render phase.
		-- FIXME (roblox): Better type refinement
		-- local hook: Hook | nil = currentlyRenderingFiber.memoizedState
		local hook: any = currentlyRenderingFiber.memoizedState
		while hook ~= nil do
			local queue = hook.queue
			if queue ~= nil then
				queue.pending = nil
			end
			hook = hook.next
		end
		didScheduleRenderPhaseUpdate = false
	end

	renderLanes = NoLanes
	currentlyRenderingFiber = nil :: any

	currentHook = nil
	workInProgressHook = nil

	if __DEV__ then
		hookTypesDev = nil
		hookTypesUpdateIndexDev = 0

		currentHookNameInDev = nil

		_isUpdatingOpaqueValueInRenderPhase = false
	end

	didScheduleRenderPhaseUpdateDuringThisPass = false
end

local function mountWorkInProgressHook(): Hook
	local hook: Hook = {
		memoizedState = nil,

		baseState = nil,
		baseQueue = nil,
		queue = nil,

		next = nil,
	}

	if workInProgressHook == nil then
		-- This is the first hook in the list
		currentlyRenderingFiber.memoizedState = hook
		workInProgressHook = hook
	else
		-- Append to the end of the list
		workInProgressHook.next = hook
		workInProgressHook = hook
	end
	return workInProgressHook
end

local function updateWorkInProgressHook(): Hook
	-- This function is used both for updates and for re-renders triggered by a
	-- render phase update. It assumes there is either a current hook we can
	-- clone, or a work-in-progress hook from a previous render pass that we can
	-- use as a base. When we reach the end of the base list, we must switch to
	-- the dispatcher used for mounts.
	-- FIXME (roblox): type refinement
	-- local nextCurrentHook: Hook?
	local nextCurrentHook
	if currentHook == nil then
		local current = currentlyRenderingFiber.alternate
		if current ~= nil then
			nextCurrentHook = current.memoizedState
		else
			nextCurrentHook = nil
		end
	else
		nextCurrentHook = currentHook.next
	end

	-- FIXME (roblox): type refinement
	-- local nextWorkInProgressHook: Hook?
	local nextWorkInProgressHook: Hook
	if workInProgressHook == nil then
		nextWorkInProgressHook = currentlyRenderingFiber.memoizedState
	else
		nextWorkInProgressHook = workInProgressHook.next
	end

	if nextWorkInProgressHook ~= nil then
		-- There's already a work-in-progress. Reuse it.
		workInProgressHook = nextWorkInProgressHook
		nextWorkInProgressHook = workInProgressHook.next

		currentHook = nextCurrentHook
	else
		-- Clone from the current hook.

		-- ROBLOX performance: use React 18 check to avoid function call overhead
		if nextCurrentHook == nil then
			error(Error.new("Rendered more hooks than during the previous render."))
		end

		currentHook = nextCurrentHook

		local newHook: Hook = {
			memoizedState = currentHook.memoizedState,

			baseState = currentHook.baseState,
			baseQueue = currentHook.baseQueue,
			queue = currentHook.queue,

			next = nil,
		}

		if workInProgressHook == nil then
			-- This is the first hook in the list.
			workInProgressHook = newHook
			currentlyRenderingFiber.memoizedState = newHook
		else
			-- Append to the end of the list.
			workInProgressHook.next = newHook
			workInProgressHook = newHook
		end
	end
	return workInProgressHook
end

-- ROBLOX performance: inlined in hot path
-- local function createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue
--   return {
--     lastEffect = nil,
--   }
-- end

function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S
	-- $FlowFixMe: Flow doesn't like mixed types
	if type(action) == "function" then
		return action(state)
	else
		return action
	end
end

function mountReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	local hook = mountWorkInProgressHook()
	local initialState
	if init ~= nil then
		initialState = init(initialArg)
	else
		initialState = (initialArg :: any) :: S
	end
	hook.baseState = initialState
	hook.memoizedState = hook.baseState

	local queue: UpdateQueue<S, A> = {
		pending = nil,
		dispatch = nil,
		lastRenderedReducer = reducer,
		lastRenderedState = initialState :: any,
	}
	hook.queue = queue

	-- deviation: set currentlyRenderingFiber to a local varible so it doesn't change
	-- by call time
	local cRF = currentlyRenderingFiber
	-- ROBLOX FIXME? we pass in action here, but is that what really happens upstream?
	local dispatch: Dispatch<A> = function(action, ...)
		-- ROBLOX Luau FIXME: relies on normalization
		dispatchAction(cRF, queue :: UpdateQueue<any, any>, action, ...)
	end :: any
	queue.dispatch = dispatch :: any
	-- ROBLOX deviation START: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
	-- ROBLOX deviation END: Lua version of useState and useReducer return two items, not list like upstream
end

function updateReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	local hook = updateWorkInProgressHook()
	local queue = hook.queue
	-- ROBLOX deviation: change from invariant to avoid funtion call in hot path
	assert(
		queue ~= nil,
		"Should have a queue. This is likely a bug in React. Please file an issue."
	)

	queue.lastRenderedReducer = reducer

	local current: Hook = currentHook

	-- The last rebase update that is NOT part of the base state.
	local baseQueue = current.baseQueue

	-- The last pending update that hasn't been processed yet.
	local pendingQueue = queue.pending
	if pendingQueue ~= nil then
		-- We have new updates that haven't been processed yet.
		-- We'll add them to the base queue.
		if baseQueue ~= nil then
			-- Merge the pending queue and the base queue.
			local baseFirst = baseQueue.next
			local pendingFirst = pendingQueue.next
			baseQueue.next = pendingFirst
			pendingQueue.next = baseFirst
		end
		-- ROBLOX performance: elimiante cmp in hot path
		-- if __DEV__ then
		--   if current.baseQueue ~= baseQueue then
		--     -- Internal invariant that should never happen, but feasibly could in
		--     -- the future if we implement resuming, or some form of that.
		--     console.error(
		--       'Internal error: Expected work-in-progress queue to be a clone. ' ..
		--         'This is a bug in React.'
		--     )
		--   end
		-- end
		baseQueue = pendingQueue
		current.baseQueue = baseQueue
		queue.pending = nil
	end

	if baseQueue ~= nil then
		-- We have a queue to process.
		local first = baseQueue.next
		local newState = current.baseState

		local newBaseState = nil
		local newBaseQueueFirst = nil
		local newBaseQueueLast = nil
		local update = first
		repeat
			local updateLane = update.lane
			-- ROBLOX performance: inline isSubsetOfLanes for hot path
			-- if not isSubsetOfLanes(renderLanes, updateLane) then
			if bit32.band(renderLanes, updateLane) ~= updateLane then
				-- Priority is insufficient. Skip this update. If this is the first
				-- skipped update, the previous update/state is the new base
				-- update/state.
				local clone: Update<S, A> = {
					lane = updateLane,
					action = update.action,
					eagerReducer = update.eagerReducer,
					eagerState = update.eagerState,
					next = nil :: any,
				}
				if newBaseQueueLast == nil then
					newBaseQueueLast = clone
					newBaseQueueFirst = newBaseQueueLast
					newBaseState = newState
				else
					newBaseQueueLast.next = clone
					newBaseQueueLast = newBaseQueueLast.next
				end
				-- Update the remaining priority in the queue.
				-- TODO: Don't need to accumulate this. Instead, we can remove
				-- renderLanes from the original lanes.
				currentlyRenderingFiber.lanes =
					mergeLanes(currentlyRenderingFiber.lanes, updateLane)
				markSkippedUpdateLanes(updateLane)
			else
				-- This update does have sufficient priority.

				if newBaseQueueLast ~= nil then
					local clone: Update<S, A> = {
						-- This update is going to be committed so we never want uncommit
						-- it. Using NoLane works because 0 is a subset of all bitmasks, so
						-- this will never be skipped by the check above.
						lane = NoLane,
						action = update.action,
						eagerReducer = update.eagerReducer,
						eagerState = update.eagerState,
						next = nil :: any,
					}
					newBaseQueueLast.next = clone
					newBaseQueueLast = newBaseQueueLast.next
				end

				-- Process this update.
				if update.eagerReducer == reducer then
					-- If this update was processed eagerly, and its reducer matches the
					-- current reducer, we can use the eagerly computed state.
					newState = update.eagerState
				else
					local action = update.action
					newState = reducer(newState, action)
				end
			end
			update = update.next
		until update == nil or update == first

		if newBaseQueueLast == nil then
			newBaseState = newState
		else
			newBaseQueueLast.next = newBaseQueueFirst
		end

		-- Mark that the fiber performed work, but only if the new state is
		-- different from the current state.
		if not is(newState, hook.memoizedState) then
			markWorkInProgressReceivedUpdate()
		end

		hook.memoizedState = newState
		hook.baseState = newBaseState
		hook.baseQueue = newBaseQueueLast

		queue.lastRenderedState = newState
	end

	local dispatch: Dispatch<A> = queue.dispatch :: any
	-- deviation: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
end

function rerenderReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	local hook = updateWorkInProgressHook()
	local queue = hook.queue
	-- ROBLOX performance: changed from invariant to avoid function call in hot path
	assert(
		queue ~= nil,
		"Should have a queue. This is likely a bug in React. Please file an issue."
	)

	queue.lastRenderedReducer = reducer

	-- This is a re-render. Apply the new render phase updates to the previous
	-- work-in-progress hook.
	local dispatch: Dispatch<A> = queue.dispatch :: Dispatch<A>
	local lastRenderPhaseUpdate = queue.pending
	local newState = hook.memoizedState
	if lastRenderPhaseUpdate ~= nil then
		-- The queue doesn't persist past this render pass.
		queue.pending = nil

		local firstRenderPhaseUpdate = lastRenderPhaseUpdate.next
		local update = firstRenderPhaseUpdate
		repeat
			-- Process this render phase update. We don't have to check the
			-- priority because it will always be the same as the current
			-- render's.
			local action = update.action
			newState = reducer(newState, action)
			update = update.next
		until update == firstRenderPhaseUpdate

		-- Mark that the fiber performed work, but only if the new state is
		-- different from the current state.
		if not is(newState, hook.memoizedState) then
			markWorkInProgressReceivedUpdate()
		end

		hook.memoizedState = newState
		-- Don't persist the state accumulated from the render phase updates to
		-- the base state unless the queue is empty.
		-- TODO: Not sure if this is the desired semantics, but it's what we
		-- do for gDSFP. I can't remember why.
		if hook.baseQueue == nil then
			hook.baseState = newState
		end

		queue.lastRenderedState = newState
	end
	-- ROBLOX deviation: Lua version returns two values instead of an array
	return newState, dispatch
end

type MutableSourceMemoizedState<Source, Snapshot> = {
	refs: {
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		setSnapshot: (Snapshot) -> (),
	},
	source: MutableSource<any>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
}

function readFromUnsubcribedMutableSource<Source, Snapshot>(
	root: FiberRoot,
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<
		Source,
		Snapshot
	>
): Snapshot
	if __DEV__ then
		warnAboutMultipleRenderersDEV(source)
	end

	local getVersion = source._getVersion
	local version_ = getVersion(source._source)

	-- Is it safe for this component to read from this source during the current render?
	local isSafeToReadFromSource = false

	-- Check the version first.
	-- If this render has already been started with a specific version,
	-- we can use it alone to determine if we can safely read from the source.
	local currentRenderVersion = getWorkInProgressVersion(source)
	if currentRenderVersion ~= nil then
		-- It's safe to read if the store hasn't been mutated since the last time
		-- we read something.
		isSafeToReadFromSource = currentRenderVersion == version_
	else
		-- If there's no version, then this is the first time we've read from the
		-- source during the current render pass, so we need to do a bit more work.
		-- What we need to determine is if there are any hooks that already
		-- subscribed to the source, and if so, whether there are any pending
		-- mutations that haven't been synchronized yet.
		--
		-- If there are no pending mutations, then `root.mutableReadLanes` will be
		-- empty, and we know we can safely read.
		--
		-- If there *are* pending mutations, we may still be able to safely read
		-- if the currently rendering lanes are inclusive of the pending mutation
		-- lanes, since that guarantees that the value we're about to read from
		-- the source is consistent with the values that we read during the most
		-- recent mutation.
		isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes)

		if isSafeToReadFromSource then
			-- If it's safe to read from this source during the current render,
			-- store the version in case other components read from it.
			-- A changed version number will local those components know to throw and restart the render.
			setWorkInProgressVersion(source, version_)
		end
	end

	if isSafeToReadFromSource then
		local snapshot = getSnapshot(source._source)
		if __DEV__ then
			-- ROBLOX deviation: the Snapshot generic isn't constrained upstream, but it as to be for this typeof() to work
			if type(snapshot :: any) == "function" then
				console.error(
					"Mutable source should not return a function as the snapshot value. "
						.. "Functions may close over mutable values and cause tearing."
				)
			end
		end
		return snapshot
	else
		-- This handles the special case of a mutable source being shared between renderers.
		-- In that case, if the source is mutated between the first and second renderer,
		-- The second renderer don't know that it needs to reset the WIP version during unwind,
		-- (because the hook only marks sources as dirty if it's written to their WIP version).
		-- That would cause this tear check to throw again and eventually be visible to the user.
		-- We can avoid this infinite loop by explicitly marking the source as dirty.
		--
		-- This can lead to tearing in the first renderer when it resumes,
		-- but there's nothing we can do about that (short of throwing here and refusing to continue the render).
		markSourceAsDirty(source)

		error(
			Error.new(
				"Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
			)
		)
	end
end

function useMutableSource<Source, Snapshot>(
	hook: Hook,
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<
		Source,
		Snapshot
	>,
	subscribe: MutableSourceSubscribeFn<
		Source,
		Snapshot
	>
): Snapshot
	local root: FiberRoot = getWorkInProgressRoot()
	invariant(
		root ~= nil,
		"Expected a work-in-progress root. This is a bug in React. Please file an issue."
	)

	local getVersion = source._getVersion
	local version_ = getVersion(source._source)

	local dispatcher = ReactCurrentDispatcher.current
	-- ROBLOX deviation: upstream doesn't assert non-nil, but we have to for type soundness
	assert(dispatcher ~= nil, "dispatcher was nil, this is a bug in React")
	-- eslint-disable-next-line prefer-const
	local currentSnapshot, setSnapshot = dispatcher.useState(function()
		return readFromUnsubcribedMutableSource(root, source, getSnapshot)
	end)
	local snapshot = currentSnapshot

	-- Grab a handle to the state hook as well.
	-- We use it to clear the pending update queue if we have a new source.

	-- ROBLOX TODO: recast local stateHook = ((workInProgressHook: any): Hook)
	local stateHook = workInProgressHook

	local memoizedState: MutableSourceMemoizedState<any, any> = hook.memoizedState
	if memoizedState.refs == nil then
		error(tostring(debug.traceback()))
	end
	local refs = memoizedState.refs
	local prevGetSnapshot = refs.getSnapshot
	local prevSource = memoizedState.source
	local prevSubscribe = memoizedState.subscribe

	local fiber = currentlyRenderingFiber

	hook.memoizedState = {
		refs = refs,
		source = source,
		subscribe = subscribe,
	}

	-- Sync the values needed by our subscription handler after each commit.
	dispatcher.useEffect(function()
		refs.getSnapshot = getSnapshot

		-- Normally the dispatch function for a state hook never changes,
		-- but this hook recreates the queue in certain cases  to avoid updates from stale sources.
		-- handleChange() below needs to reference the dispatch function without re-subscribing,
		-- so we use a ref to ensure that it always has the latest version.
		refs.setSnapshot = setSnapshot

		-- Check for a possible change between when we last rendered now.
		local maybeNewVersion = getVersion(source._source)
		if not is(version_, maybeNewVersion) then
			local maybeNewSnapshot = getSnapshot(source._source)
			if __DEV__ then
				-- ROBLOX deviation: the Snapshot generic isn't constrained upstream, but it as to be for this typeof() to work
				if type(maybeNewSnapshot :: any) == "function" then
					console.error(
						"Mutable source should not return a function as the snapshot value. "
							.. "Functions may close over mutable values and cause tearing."
					)
				end
			end

			if not is(snapshot, maybeNewSnapshot) then
				setSnapshot(maybeNewSnapshot)

				local lane = requestUpdateLane(fiber)
				markRootMutableRead(root, lane)
			end
			-- If the source mutated between render and now,
			-- there may be state updates already scheduled from the old source.
			-- Entangle the updates so that they render in the same batch.
			markRootEntangled(root, root.mutableReadLanes)
		end
		-- ROBLOX Luau FIXME: Luau doesn't support mixed arrays
	end, { getSnapshot, source, subscribe } :: Array<any>)

	-- If we got a new source or subscribe function, re-subscribe in a passive effect.
	dispatcher.useEffect(function()
		local handleChange = function()
			local latestGetSnapshot = refs.getSnapshot
			local latestSetSnapshot = refs.setSnapshot

			-- ROBLOX performance? only latestGet..() is throwable. hoist the rest out to eliminate anon func overhead?
			local ok, result = pcall(function()
				latestSetSnapshot(latestGetSnapshot(source._source))

				-- Record a pending mutable source update with the same expiration time.
				local lane = requestUpdateLane(fiber)

				markRootMutableRead(root, lane)
			end)

			if not ok then
				-- A selector might throw after a source mutation.
				-- e.g. it might try to read from a part of the store that no longer exists.
				-- In this case we should still schedule an update with React.
				-- Worst case the selector will throw again and then an error boundary will handle it.
				latestSetSnapshot(function()
					error(result)
				end)
			end
		end

		local unsubscribe = subscribe(source._source, handleChange)
		if __DEV__ then
			if type(unsubscribe) ~= "function" then
				console.error(
					"Mutable source subscribe function must return an unsubscribe function."
				)
			end
		end

		return unsubscribe
		-- ROBLOX Luau FIXME: Luau doesn't support mixed arrays
	end, { source, subscribe } :: Array<any>)

	-- If any of the inputs to useMutableSource change, reading is potentially unsafe.
	--
	-- If either the source or the subscription have changed we can't can't trust the update queue.
	-- Maybe the source changed in a way that the old subscription ignored but the new one depends on.
	--
	-- If the getSnapshot function changed, we also shouldn't rely on the update queue.
	-- It's possible that the underlying source was mutated between the when the last "change" event fired,
	-- and when the current render (with the new getSnapshot function) is processed.
	--
	-- In both cases, we need to throw away pending updates (since they are no longer relevant)
	-- and treat reading from the source as we do in the mount case.
	if
		not is(prevGetSnapshot, getSnapshot)
		or not is(prevSource, source)
		or not is(prevSubscribe, subscribe)
	then
		-- Create a new queue and setState method,
		-- So if there are interleaved updates, they get pushed to the older queue.
		-- When this becomes current, the previous queue and dispatch method will be discarded,
		-- including any interleaving updates that occur.
		local newQueue = {
			pending = nil,
			dispatch = nil,
			lastRenderedReducer = basicStateReducer,
			lastRenderedState = snapshot,
		}

		-- ROBLOX deviation: keep local pointer so if global changes we maintain correct reference.
		local cRF = currentlyRenderingFiber

		setSnapshot = function(...)
			dispatchAction(cRF, newQueue, ...)
		end :: any
		newQueue.dispatch = setSnapshot :: any
		stateHook.queue = newQueue
		stateHook.baseQueue = nil
		snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot)
		stateHook.baseState = snapshot
		stateHook.memoizedState = stateHook.baseState
	end

	return snapshot
end

function mountMutableSource<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<
		Source,
		Snapshot
	>,
	subscribe: MutableSourceSubscribeFn<
		Source,
		Snapshot
	>
): Snapshot
	local hook = mountWorkInProgressHook()
	hook.memoizedState = {
		refs = {
			getSnapshot = getSnapshot,
			setSnapshot = nil,
		},
		source = source,
		subscribe = subscribe,
	}
	return useMutableSource(hook, source, getSnapshot, subscribe)
end

function updateMutableSource<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<
		Source,
		Snapshot
	>,
	subscribe: MutableSourceSubscribeFn<
		Source,
		Snapshot
	>
): Snapshot
	local hook = updateWorkInProgressHook()
	return useMutableSource(hook, source, getSnapshot, subscribe)
end

function mountState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	local hook = mountWorkInProgressHook()
	if type(initialState) == "function" then
		-- $FlowFixMe: Flow doesn't like mixed types
		-- deviation: workaround to silence cli analyze not understanding that we've already verified initialState is a function
		local initialStateAsFunction: () -> S = initialState
		initialState = initialStateAsFunction()
	end
	hook.baseState = initialState
	hook.memoizedState = hook.baseState
	local queue: UpdateQueue<S, BasicStateAction<S>> = {
		pending = nil,
		dispatch = nil,
		lastRenderedReducer = nil, --basicStateReducer,
		lastRenderedState = initialState :: any,
	}
	-- ROBLOX Luau FIXME: work around a toposorting issue in Luau: CLI-48752
	queue.lastRenderedReducer = basicStateReducer
	hook.queue = queue

	-- ROBLOX deviation: set currentlyRenderingFiber to a local varible so it doesn't change by call time
	local cRF = currentlyRenderingFiber
	local dispatch: Dispatch<BasicStateAction<S>> = function(action, ...)
		-- ROBLOX FIXME? we pass in action here, but is that what really happens upstream?
		dispatchAction(cRF, queue :: UpdateQueue<any, any>, action, ...)
	end :: any
	queue.dispatch = dispatch
	-- deviation: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
end

function updateState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	return updateReducer(basicStateReducer, initialState)
end

function rerenderState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	return rerenderReducer(basicStateReducer, initialState)
end

local function pushEffect(tag, create, destroy, deps)
	local effect: Effect = {
		tag = tag,
		create = create,
		destroy = destroy,
		deps = deps,
		-- Circular
		next = nil :: any,
	}
	local componentUpdateQueue: FunctionComponentUpdateQueue =
		currentlyRenderingFiber.updateQueue :: any
	if componentUpdateQueue == nil then
		-- ROBLOX performance: inline simple function in hot path
		-- componentUpdateQueue = createFunctionComponentUpdateQueue()
		componentUpdateQueue = {
			lastEffect = nil,
		}
		currentlyRenderingFiber.updateQueue = componentUpdateQueue
		effect.next = effect
		componentUpdateQueue.lastEffect = effect
	else
		local lastEffect = componentUpdateQueue.lastEffect
		if lastEffect == nil then
			componentUpdateQueue.lastEffect = effect
			effect.next = effect
		else
			local firstEffect = lastEffect.next
			lastEffect.next = effect
			effect.next = firstEffect
			componentUpdateQueue.lastEffect = effect
		end
	end
	return effect
end

-- ROBLOX deviation: Bindings are a feature unique to Roact
function mountBinding<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
	local hook = mountWorkInProgressHook()
	local value, updateValue = createBinding(initialValue)

	-- ROBLOX Luau FIXME: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { value :: any, updateValue :: any }
	return value, updateValue
end

-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function updateBinding<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
	local hook = updateWorkInProgressHook()
	return unpack(hook.memoizedState)
end

-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function mountRef<T>(initialValue: T): { current: T | nil }
	local hook = mountWorkInProgressHook()
	-- ROBLOX DEVIATION: Implement useRef with bindings
	local ref: any = createRef()
	ref.current = initialValue
	-- if (__DEV__) then
	--   Object.seal(ref)
	-- end
	hook.memoizedState = ref
	return ref :: { current: T | nil }
end

-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function updateRef<T>(initialValue: T): { current: T | nil }
	local hook = updateWorkInProgressHook()
	return hook.memoizedState
end

local function mountEffectImpl(fiberFlags, hookFlags, create, deps): ()
	local hook = mountWorkInProgressHook()
	-- deviation: no need to account for undefined
	-- local nextDeps = deps == undefined ? nil : deps
	local nextDeps = deps
	currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags, fiberFlags)

	hook.memoizedState =
		pushEffect(bit32.bor(HookHasEffect, hookFlags), create, nil, nextDeps)
end

-- ROBLOX deviation START: must explicitly mark deps argument as optional/nil-able
function updateEffectImpl(fiberFlags, hookFlags, create, deps: Array<any>?): ()
	-- ROBLOX deviation END
	local hook = updateWorkInProgressHook()
	-- ROBLOX deviation: no need to account for undefined
	-- local nextDeps = deps == undefined ? nil : deps
	local nextDeps = deps
	local destroy

	if currentHook ~= nil then
		local prevEffect = currentHook.memoizedState
		destroy = prevEffect.destroy
		if nextDeps ~= nil then
			local prevDeps = prevEffect.deps
			if areHookInputsEqual(nextDeps, prevDeps) then
				hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps)
				return
			end
		end
	end

	currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags, fiberFlags)

	hook.memoizedState =
		pushEffect(bit32.bor(HookHasEffect, hookFlags), create, destroy, nextDeps)
end

local function mountEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ as well as jest
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
			warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
		end
	end

	if __DEV__ and enableDoubleInvokingEffects then
		mountEffectImpl(
			bit32.bor(MountPassiveDevEffect, PassiveEffect, PassiveStaticEffect),
			HookPassive,
			create,
			deps
		)
	else
		mountEffectImpl(
			bit32.bor(PassiveEffect, PassiveStaticEffect),
			HookPassive,
			create,
			deps
		)
	end
end

local function updateEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ in addition to jest
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
			warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
		end
	end
	updateEffectImpl(PassiveEffect, HookPassive, create, deps)
end

local function mountLayoutEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ and enableDoubleInvokingEffects then
		mountEffectImpl(
			bit32.bor(MountLayoutDevEffect, UpdateEffect),
			HookLayout,
			create,
			deps
		)
	else
		mountEffectImpl(UpdateEffect, HookLayout, create, deps)
	end
end

local function updateLayoutEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	updateEffectImpl(UpdateEffect, HookLayout, create, deps)
end

function imperativeHandleEffect<T>(
	create: () -> T,
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil
	-- ROBLOX deviation: explicit type annotation needed due to mixed return
): nil | () -> ...any
	if ref ~= nil and type(ref) == "function" then
		local refCallback = ref
		local inst = create()
		refCallback(inst)
		return function()
			return refCallback(nil)
		end
	elseif ref ~= nil then
		local refObject = ref :: any
		-- ROBLOX deviation: can't check for key presence because nil is a legitimate value.
		if __DEV__ then
			-- ROBLOX FIXME: This is a clumsy approximation, since we don't have any
			-- explicit way to know that something is a ref object; instead, we check
			-- that it's an empty object with a metatable, which is what Roact refs
			-- look like since they indirect to bindings via their metatable
			local isRefObject = getmetatable(refObject) ~= nil
				and #Object.keys(refObject) == 0
			if not isRefObject then
				console.error(
					"Expected useImperativeHandle() first argument to either be a "
						.. "ref callback or React.createRef() object. Instead received: %s.",
					"an object with keys {"
						.. Array.join(Object.keys(refObject), ", ")
						.. "}"
				)
			end
		end
		local inst = create()
		refObject.current = inst
		return function()
			refObject.current = nil
		end
	-- deviation: explicit return to silence analyze
	else
		return nil
	end
end

function mountImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	if __DEV__ then
		if type(create) ~= "function" then
			console.error(
				"Expected useImperativeHandle() second argument to be a function "
					.. "that creates a handle. Instead received: %s.",
				-- ROBLOX deviation START: nil instead of null
				if create ~= nil then type(create) else "nil"
				-- ROBLOX deviation END
			)
		end
	end
	-- TODO: If deps are provided, should we skip comparing the ref itself?
	local effectDeps = if deps ~= nil then Array.concat(deps, { ref }) else nil

	if __DEV__ and enableDoubleInvokingEffects then
		return mountEffectImpl(
			bit32.bor(MountLayoutDevEffect, UpdateEffect),
			HookLayout,
			function()
				return imperativeHandleEffect(create, ref)
			end,
			effectDeps
		)
	else
		return mountEffectImpl(UpdateEffect, HookLayout, function()
			return imperativeHandleEffect(create, ref)
		end, effectDeps)
	end
end

function updateImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	if __DEV__ then
		if type(create) ~= "function" then
			local errorArg = "nil"
			if create then
				errorArg = type(create)
			end
			console.error(
				"Expected useImperativeHandle() second argument to be a function "
					.. "that creates a handle. Instead received: %s.",
				errorArg
			)
		end
	end

	-- TODO: If deps are provided, should we skip comparing the ref itself?
	-- ROBLOX deviation: ternary turned to explicit if/else
	local effectDeps
	if deps ~= nil then
		effectDeps = table.clone(deps)
		table.insert(effectDeps, ref)
	end

	return updateEffectImpl(UpdateEffect, HookLayout, function()
		return imperativeHandleEffect(create, ref)
	end, effectDeps)
end

function mountDebugValue<T>(value: T, formatterFn: nil | (T) -> any): ()
	-- This hook is normally a no-op.
	-- The react-debug-hooks package injects its own implementation
	-- so that e.g. DevTools can display custom hook values.
end

local updateDebugValue = mountDebugValue

function mountCallback<T>(callback: T, deps: Array<any> | nil): T
	local hook = mountWorkInProgressHook()
	local nextDeps = deps
	-- ROBLOX Luau FIXME: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { callback :: any, nextDeps :: any }
	return callback
end

function updateCallback<T>(callback: T, deps: Array<any> | nil): T
	local hook = updateWorkInProgressHook()
	local nextDeps = deps
	local prevState = hook.memoizedState
	if prevState ~= nil then
		if nextDeps ~= nil then
			-- ROBLOX TODO: Luau false positive when this is `Array<any>?` (E001) Type 'Array<any>?' could not be converted into 'Array<any>'
			local prevDeps: Array<any> = prevState[2]
			if areHookInputsEqual(nextDeps, prevDeps) then
				return prevState[1]
			end
		end
	end
	-- ROBLOX Luau FIXME: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { callback :: any, nextDeps :: any }
	return callback
end

-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
function mountMemo<T...>(nextCreate: () -> T..., deps: Array<any> | nil): ...any
	local hook = mountWorkInProgressHook()

	-- deviation: equivilant to upstream ternary logic
	local nextDeps = deps
	-- ROBLOX DEVIATION: Wrap memoized values in a table and unpack to allow for multiple return values
	local nextValue = { nextCreate() }
	hook.memoizedState = { nextValue :: any, nextDeps }
	return unpack(nextValue)
end

-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
function updateMemo<T...>(nextCreate: () -> T..., deps: Array<any> | nil): ...any
	local hook = updateWorkInProgressHook()
	-- deviation: equivilant to upstream ternary logic
	local nextDeps = deps
	local prevState = hook.memoizedState
	if prevState ~= nil then
		-- Assume these are defined. If they're not, areHookInputsEqual will warn.
		if nextDeps ~= nil then
			local prevDeps: Array<any> = prevState[2]
			if areHookInputsEqual(nextDeps, prevDeps) then
				return unpack(prevState[1])
			end
		end
	end
	-- ROBLOX DEVIATION: Wrap memoized values in a table and unpack to allow for multiple return values
	local nextValue = { nextCreate() }
	hook.memoizedState = { nextValue :: any, nextDeps }
	return unpack(nextValue)
end

-- function mountDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = mountState(value)
--   mountEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function updateDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = updateState(value)
--   updateEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function rerenderDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = rerenderState(value)
--   updateEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function startTransition(setPending, callback)
--   local priorityLevel = getCurrentPriorityLevel()
--   if decoupleUpdatePriorityFromScheduler)
--     local previousLanePriority = getCurrentUpdateLanePriority()
--     setCurrentUpdateLanePriority(
--       higherLanePriority(previousLanePriority, InputContinuousLanePriority),
--     )

--     runWithPriority(
--       priorityLevel < UserBlockingPriority
--         ? UserBlockingPriority
--         : priorityLevel,
--       () => {
--         setPending(true)
--       },
--     )

--     -- TODO: Can remove this. Was only necessary because we used to give
--     -- different behavior to transitions without a config object. Now they are
--     -- all treated the same.
--     setCurrentUpdateLanePriority(DefaultLanePriority)

--     runWithPriority(
--       priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
--       () => {
--         local prevTransition = ReactCurrentBatchConfig.transition
--         ReactCurrentBatchConfig.transition = 1
--         try {
--           setPending(false)
--           callback()
--         } finally {
--           if decoupleUpdatePriorityFromScheduler)
--             setCurrentUpdateLanePriority(previousLanePriority)
--           end
--           ReactCurrentBatchConfig.transition = prevTransition
--         end
--       },
--     )
--   } else {
--     runWithPriority(
--       priorityLevel < UserBlockingPriority
--         ? UserBlockingPriority
--         : priorityLevel,
--       () => {
--         setPending(true)
--       },
--     )

--     runWithPriority(
--       priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
--       () => {
--         local prevTransition = ReactCurrentBatchConfig.transition
--         ReactCurrentBatchConfig.transition = 1
--         try {
--           setPending(false)
--           callback()
--         } finally {
--           ReactCurrentBatchConfig.transition = prevTransition
--         end
--       },
--     )
--   end
-- end

-- function mountTransition(): [(() => void) => void, boolean] {
--   local [isPending, setPending] = mountState(false)
--   -- The `start` method can be stored on a ref, since `setPending`
--   -- never changes.
--   local start = startTransition.bind(null, setPending)
--   mountRef(start)
--   return [start, isPending]
-- end

-- function updateTransition(): [(() => void) => void, boolean] {
--   local [isPending] = updateState(false)
--   local startRef = updateRef()
--   local start: (() => void) => void = (startRef.current: any)
--   return [start, isPending]
-- end

-- function rerenderTransition(): [(() => void) => void, boolean] {
--   local [isPending] = rerenderState(false)
--   local startRef = updateRef()
--   local start: (() => void) => void = (startRef.current: any)
--   return [start, isPending]
-- end

local isUpdatingOpaqueValueInRenderPhase = false
exports.getIsUpdatingOpaqueValueInRenderPhaseInDEV = function(): boolean?
	if __DEV__ then
		return isUpdatingOpaqueValueInRenderPhase
	end
	return nil
end

-- function warnOnOpaqueIdentifierAccessInDEV(fiber)
--   if __DEV__ then
--     -- TODO: Should warn in effects and callbacks, too
--     local name = getComponentName(fiber.type) or 'Unknown'
--     if getIsRendering() and not didWarnAboutUseOpaqueIdentifier[name] then
--       console.error(
--         'The object passed back from useOpaqueIdentifier is meant to be ' ..
--           'passed through to attributes only. Do not read the ' ..
--           'value directly.'
--       )
--       didWarnAboutUseOpaqueIdentifier[name] = true
--     end
--   end
-- end

function mountOpaqueIdentifier()
	local makeId
	if __DEV__ then
		console.warn("!!! unimplemented: warnOnOpaqueIdentifierAccessInDEV")
	-- makeId = makeClientIdInDEV.bind(
	--     nil,
	--     warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber),
	--   )
	else
		makeId = makeClientId
	end

	if getIsHydrating() then
		unimplemented("ReactFiberHooks: getIsHydrating() true")
		return nil
	--   local didUpgrade = false
	--   local fiber = currentlyRenderingFiber
	--   local readValue = function()
	--     if not didUpgrade then
	--       -- Only upgrade once. This works even inside the render phase because
	--       -- the update is added to a shared queue, which outlasts the
	--       -- in-progress render.
	--       didUpgrade = true
	--       if __DEV__ then
	--         isUpdatingOpaqueValueInRenderPhase = true
	--         setId(makeId())
	--         isUpdatingOpaqueValueInRenderPhase = false
	--         warnOnOpaqueIdentifierAccessInDEV(fiber)
	--       else
	--         setId(makeId())
	--       end
	--     end
	--     invariant(
	--       false,
	--       'The object passed back from useOpaqueIdentifier is meant to be ' ..
	--         'passed through to attributes only. Do not read the value directly.'
	--     )
	--   end
	--   local id = makeOpaqueHydratingObject(readValue)

	--   local setId = mountState(id)[1]

	--   if bit32.band(currentlyRenderingFiber.mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
	--     if __DEV__ and enableDoubleInvokingEffects then
	--       currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags,
	--         MountPassiveDevEffect, PassiveEffect, PassiveStaticEffect)
	--     else
	--       currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags,
	-- 				PassiveEffect, PassiveStaticEffect)
	--     end
	--     pushEffect(
	--       bit32.bor(HookHasEffect, HookPassive),
	--       function()
	--         setId(makeId())
	-- 			end,
	--       nil,
	--       nil
	--     )
	--   end
	--   return id
	else
		local id = makeId()
		mountState(id)
		return id
	end
end

function updateOpaqueIdentifier(): OpaqueIDType
	local id, _ = updateState(nil)
	return id
end

function rerenderOpaqueIdentifier(): OpaqueIDType
	local id, _ = rerenderState(nil)
	return id
end

function dispatchAction<S, A>(fiber: Fiber, queue: UpdateQueue<S, A>, action: A, ...): ()
	if __DEV__ then
		local childrenLength = select("#", ...)
		local extraArg
		if childrenLength == 1 then
			extraArg = select(1, ...)
		end
		if type(extraArg) == "function" then
			console.error(
				"State updates from the useState() and useReducer() Hooks don't support the "
					.. "second callback argument. To execute a side effect after "
					.. "rendering, declare it in the component body with useEffect()."
			)
		end
	end

	local eventTime = requestEventTime()
	local lane = requestUpdateLane(fiber)

	local update: Update<S, A> = {
		lane = lane,
		action = action,
		eagerReducer = nil,
		eagerState = nil,
		next = nil :: any,
	}

	-- Append the update to the end of the list.
	local pending = queue.pending
	if pending == nil then
		-- This is the first update. Create a circular list.
		update.next = update
	else
		update.next = pending.next
		pending.next = update
	end
	queue.pending = update

	local alternate = fiber.alternate
	if
		fiber == currentlyRenderingFiber
		or (alternate ~= nil and alternate == currentlyRenderingFiber)
	then
		-- This is a render phase update. Stash it in a lazily-created map of
		-- queue -> linked list of updates. After this render pass, we'll restart
		-- and apply the stashed updates on top of the work-in-progress hook.
		didScheduleRenderPhaseUpdate = true
		didScheduleRenderPhaseUpdateDuringThisPass = true
	else
		if
			fiber.lanes == NoLanes and (alternate == nil or alternate.lanes == NoLanes)
		then
			-- The queue is currently empty, which means we can eagerly compute the
			-- next state before entering the render phase. If the new state is the
			-- same as the current state, we may be able to bail out entirely.
			local lastRenderedReducer = queue.lastRenderedReducer
			if lastRenderedReducer ~= nil then
				local prevDispatcher
				if __DEV__ then
					prevDispatcher = ReactCurrentDispatcher.current
					ReactCurrentDispatcher.current =
						InvalidNestedHooksDispatcherOnUpdateInDEV
				end
				-- ROBLOX try
				local currentState: S = queue.lastRenderedState :: any
				-- ROBLOX performance: only wrap the thing that can throw in a pcall to elimiante anon function creation overhead
				local ok, eagerState = pcall(lastRenderedReducer, currentState, action)
				-- Stash the eagerly computed state, and the reducer used to compute
				-- it, on the update object. If the reducer hasn't changed by the
				-- time we enter the render phase, then the eager state can be used
				-- without calling the reducer again.
				if ok then
					update.eagerReducer = lastRenderedReducer
					update.eagerState = eagerState
				end

				-- ROBLOX finally
				if __DEV__ then
					ReactCurrentDispatcher.current = prevDispatcher
				end

				if is(eagerState, currentState) then
					-- Fast path. We can bail out without scheduling React to re-render.
					-- It's still possible that we'll need to rebase this update later,
					-- if the component re-renders for a different reason and by that
					-- time the reducer has changed.
					return
				end
				-- ROBLOX catch
				if not ok then
					-- Suppress the error. It will throw again in the render phase.
				end
			end
		end
		if __DEV__ then
			-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
			-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ as well as jest
			if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
				warnIfNotScopedWithMatchingAct(fiber)
				warnIfNotCurrentlyActingUpdatesInDEV(fiber)
			end
		end
		scheduleUpdateOnFiber(fiber, lane, eventTime)
	end

	if __DEV__ then
		if enableDebugTracing then
			if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
				local name = getComponentName(fiber.type) or "Unknown"
				logStateUpdateScheduled(name, lane, action)
			end
		end
	end

	if enableSchedulingProfiler then
		markStateUpdateScheduled(fiber, lane)
	end

	return
end

-- deviation: Move these to the top so they're in scope for above functions
local ContextOnlyDispatcher: Dispatcher = {
	readContext = readContext,

	useCallback = throwInvalidHookError :: any,
	useContext = throwInvalidHookError :: any,
	useEffect = throwInvalidHookError :: any,
	useImperativeHandle = throwInvalidHookError :: any,
	useLayoutEffect = throwInvalidHookError :: any,
	useMemo = throwInvalidHookError :: any,
	useReducer = throwInvalidHookError :: any,
	useRef = throwInvalidHookError :: any,
	useBinding = throwInvalidHookError :: any,
	useState = throwInvalidHookError :: any,
	useDebugValue = throwInvalidHookError :: any,
	-- useDeferredValue = throwInvalidHookError,
	-- useTransition = throwInvalidHookError,
	useMutableSource = throwInvalidHookError :: any,
	useOpaqueIdentifier = throwInvalidHookError :: any,

	unstable_isNewReconciler = enableNewReconciler,
}
exports.ContextOnlyDispatcher = ContextOnlyDispatcher

local HooksDispatcherOnMount: Dispatcher = {
	readContext = readContext,

	useCallback = mountCallback,
	useContext = readContext,
	useEffect = mountEffect,
	useImperativeHandle = mountImperativeHandle,
	useLayoutEffect = mountLayoutEffect,
	-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = mountMemo :: any,
	useReducer = mountReducer,
	useRef = mountRef,
	useBinding = mountBinding,
	useState = mountState,
	useDebugValue = mountDebugValue,
	-- useDeferredValue = mountDeferredValue,
	-- useTransition = mountTransition,
	useMutableSource = mountMutableSource,
	useOpaqueIdentifier = mountOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

local HooksDispatcherOnUpdate: Dispatcher = {
	readContext = readContext,

	useCallback = updateCallback,
	useContext = readContext,
	useEffect = updateEffect,
	useImperativeHandle = updateImperativeHandle,
	useLayoutEffect = updateLayoutEffect,
	-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = updateMemo :: any,
	useReducer = updateReducer,
	useRef = updateRef,
	useBinding = updateBinding,
	useState = updateState,
	useDebugValue = updateDebugValue,
	-- useDeferredValue = updateDeferredValue,
	-- useTransition = updateTransition,
	useMutableSource = updateMutableSource,
	useOpaqueIdentifier = updateOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

local HooksDispatcherOnRerender: Dispatcher = {
	readContext = readContext,

	useCallback = updateCallback,
	useContext = readContext,
	useEffect = updateEffect,
	useImperativeHandle = updateImperativeHandle,
	useLayoutEffect = updateLayoutEffect,
	-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = updateMemo :: any,
	useReducer = rerenderReducer,
	useRef = updateRef,
	useBinding = updateBinding,
	useState = rerenderState,
	useDebugValue = updateDebugValue,
	-- useDeferredValue = rerenderDeferredValue,
	-- useTransition = rerenderTransition,
	useMutableSource = updateMutableSource,
	useOpaqueIdentifier = rerenderOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

if __DEV__ then
	local warnInvalidContextAccess = function()
		console.error(
			"Context can only be read while React is rendering. "
				.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
				.. "In function components, you can read it directly in the function body, but not "
				.. "inside Hooks like useReducer() or useMemo()."
		)
	end

	local warnInvalidHookAccess = function()
		console.error(
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. "
				.. "You can only call Hooks at the top level of your React function. "
				.. "For more information, see "
				.. "https://reactjs.org/link/rules-of-hooks"
		)
	end

	HooksDispatcherOnMountInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			mountHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			-- ROBLOX FIXME Luau: TypeError: Type 'boolean' could not be converted into 'T'
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			mountHookTypesDev()
			return mountRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			mountHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of mountState return two items, not list like upstream.
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- ROBLOX deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			mountHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       mountHookTypesDev()
		--       return mountDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       mountHookTypesDev()
		--       return mountTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			mountHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function()
			currentHookNameInDev = "useOpaqueIdentifier"
			mountHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnMountWithHookTypesInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return mountLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return mountRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of mountState return two items, not list like upstream
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of mountState return two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return mountDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return mountTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function()
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnUpdateInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			return updateCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult = pcall(updateReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of updateState returns two items, not list like upstream
			local ok, result, setResult = pcall(updateState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return updateDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return updateTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return updateOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnRerenderInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			local ok, result, setResult =
				pcall(rerenderReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- ROBLOX deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(rerenderState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return rerenderDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return rerenderTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return rerenderOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnMountInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		-- useDeferredValue<T>(value: T): T {
		--   currentHookNameInDev = 'useDeferredValue'
		--   warnInvalidHookAccess()
		--   mountHookTypesDev()
		--   return mountDeferredValue(value)
		-- },
		-- useTransition(): [(() => void) => void, boolean] {
		--   currentHookNameInDev = 'useTransition'
		--   warnInvalidHookAccess()
		--   mountHookTypesDev()
		--   return mountTransition()
		-- },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnUpdateInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult = pcall(updateReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher

			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(updateState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return updateDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return updateTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnRerenderInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--\[\[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      \]\]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(
			reducer: (S, A) -> S,
			initialArg: I,
			init: ((I) -> S)?
		): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult =
				pcall(rerenderReducer, reducer, initialArg, init)
			-- ROBLOX finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- ROBLOX deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- ROBLOX deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(rerenderState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return rerenderDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return rerenderTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<
				Source,
				Snapshot
			>,
			subscribe: MutableSourceSubscribeFn<
				Source,
				Snapshot
			>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return rerenderOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}
end

local function renderWithHooks<Props, SecondArg>(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: (p: Props, arg: SecondArg) -> any,
	props: Props,
	secondArg: SecondArg,
	nextRenderLanes: Lanes
): any
	renderLanes = nextRenderLanes
	currentlyRenderingFiber = workInProgress

	if __DEV__ then
		hookTypesDev = if current ~= nil
			then (current._debugHookTypes :: any) :: Array<HookType>
			else nil
		-- ROBLOX deviation START: index variable offset by one for Lua
		hookTypesUpdateIndexDev = 0
		-- ROBLOX deviation END
		-- Used for hot reloading:
		-- ROBLOX performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
		-- ignorePreviousDependencies =
		--   current ~= nil and current.type ~= workInProgress.type
	end

	workInProgress.memoizedState = nil
	-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
	workInProgress.updateQueue = nil
	workInProgress.lanes = NoLanes

	-- The following should have already been reset
	-- currentHook = nil
	-- workInProgressHook = nil

	-- didScheduleRenderPhaseUpdate = false

	-- TODO Warn if no hooks are used at all during mount, then some are used during update.
	-- Currently we will identify the update render as a mount because memoizedState == nil.
	-- This is tricky because it's valid for certain types of components (e.g. React.lazy)

	-- Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
	-- Non-stateful hooks (e.g. context) don't get added to memoizedState,
	-- so memoizedState would be nil during updates and mounts.
	if __DEV__ then
		if current ~= nil and current.memoizedState ~= nil then
			ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV
		elseif hookTypesDev ~= nil then
			-- This dispatcher handles an edge case where a component is updating,
			-- but no stateful hooks have been used.
			-- We want to match the production code behavior (which will use HooksDispatcherOnMount),
			-- but with the extra DEV validation to ensure hooks ordering hasn't changed.
			-- This dispatcher does that.
			ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV
		else
			ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV
		end
	else
		ReactCurrentDispatcher.current = (current == nil or current.memoizedState == nil)
				and HooksDispatcherOnMount
			or HooksDispatcherOnUpdate
	end

	local children = Component(props, secondArg)

	-- Check if there was a render phase update
	if didScheduleRenderPhaseUpdateDuringThisPass then
		-- Keep rendering in a loop for as long as render phase updates continue to
		-- be scheduled. Use a counter to prevent infinite loops.
		local numberOfReRenders: number = 0
		repeat
			didScheduleRenderPhaseUpdateDuringThisPass = false
			-- ROBLOX performance: use React 18 approach to avoid invariant in hot path
			if numberOfReRenders >= RE_RENDER_LIMIT then
				error(
					Error.new(
						"Too many re-renders. React limits the number of renders to prevent "
							.. "an infinite loop."
					)
				)
			end

			numberOfReRenders += 1
			-- ROBLOX performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
			-- if __DEV__ then
			-- Even when hot reloading, allow dependencies to stabilize
			-- after first render to prevent infinite render phase updates.
			-- ignorePreviousDependencies = false
			-- end

			-- Start over from the beginning of the list
			currentHook = nil
			workInProgressHook = nil

			-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
			workInProgress.updateQueue = nil

			if __DEV__ then
				-- Also validate hook order for cascading updates.
				hookTypesUpdateIndexDev = 0
			end

			ReactCurrentDispatcher.current = __DEV__ and HooksDispatcherOnRerenderInDEV
				or HooksDispatcherOnRerender

			children = Component(props, secondArg)
		until not didScheduleRenderPhaseUpdateDuringThisPass
	end

	-- We can assume the previous dispatcher is always this one, since we set it
	-- at the beginning of the render phase and there's no re-entrancy.
	ReactCurrentDispatcher.current = ContextOnlyDispatcher

	if __DEV__ then
		workInProgress._debugHookTypes = hookTypesDev
	end

	-- This check uses currentHook so that it works the same in DEV and prod bundles.
	-- hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
	local didRenderTooFewHooks = currentHook ~= nil and currentHook.next ~= nil

	renderLanes = NoLanes
	currentlyRenderingFiber = nil :: any

	currentHook = nil
	workInProgressHook = nil

	if __DEV__ then
		currentHookNameInDev = nil
		hookTypesDev = nil
		hookTypesUpdateIndexDev = 0
	end

	didScheduleRenderPhaseUpdate = false

	-- ROBLOX performance: use React 18 approach that avoid invariant in hot paths
	if didRenderTooFewHooks then
		error(
			Error.new(
				"Rendered fewer hooks than expected. This may be caused by an accidental "
					.. "early return statement."
			)
		)
	end

	return children
end
exports.renderWithHooks = renderWithHooks

return exports ]]
cX.Children._5417917487ef82fa0f38a782772cdc93=du
local dv

local dw={ClassName="ModuleScript",Children={},Properties={}}
dw.Name="ReactFiberHostConfig"
dw.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/9ac42dd074c42b66ecc0334b75200b1d2989f892/packages/react-reconciler/src/ReactFiberHostConfig.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[ eslint-disable react-internal/invariant-args \]\]

-- ROBLOX FIXME: Cannot carry types over via the module overriding that's in use
-- here; this is a particularly tricky case of cross-dependency type definitions
-- Use a common set of typedefs across ReactTestHostConfig and ReactRobloxHostTypes
type Object = { [string]: any }

export type Instance = Object
export type HostInstance = Instance
export type TextInstance = Instance
export type Container = Object
export type HostContext = Object
export type HydratableInstance = Instance | SuspenseInstance
export type SuspenseInstance = Object
export type PublicInstance = HostInstance

export type Type = string
export type Props = Object
export type ChildSet = {} -- void, unused
export type RendererInspectionConfig = Object

-- if _G.__NO_LOADMODULE__ then
local exports: { [string]: any } = {}
return exports
-- end

-- -- We expect that our Rollup, Jest, and Flow configurations
-- -- always shim this module with the corresponding host config
-- -- (either provided by a renderer, or a generic shim for npm).
-- --
-- -- We should never resolve to this file, but it exists to make
-- -- sure that if we *do* accidentally break the configuration,
-- -- the failure isn't silent.

-- -- deviation: FIXME (roblox): is there a way to configure luau to account for this module
-- -- being shimmed?
-- error('This module must be shimmed by a specific renderer.') ]]
cX.Children._5c5671ce4caf5100686023a552a143f0=dw
local dx

local dy={ClassName="ModuleScript",Children={},Properties={}}
dy.Name="ReactFiberHostContext.new"
dy.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberHostContext.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

-- local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Container = ReactFiberHostConfig.Container
type HostContext = ReactFiberHostConfig.HostContext

-- local invariant = require(Packages.Shared).invariant

local getChildHostContext = ReactFiberHostConfig.getChildHostContext
local getRootHostContext = ReactFiberHostConfig.getRootHostContext
local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

-- FIXME (roblox): The upstream code here should be guaranteeing that the type
-- is always this exact object, but I think ours will match against any empty
-- table
-- declare class NoContextT {}
type NoContextT = {}
local NO_CONTEXT: NoContextT = {}

local contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(NO_CONTEXT)
local contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(NO_CONTEXT)
local rootInstanceStackCursor: StackCursor<Container | NoContextT> =
	createCursor(NO_CONTEXT)

function requiredContext<Value>(c: Value | NoContextT): Value
	-- ROBLOX performance: eliminate expensive optional cmp in hot path
	-- invariant(
	--   c ~= NO_CONTEXT,
	--   "Expected host context to exist. This error is likely caused by a bug " ..
	--     "in React. Please file an issue."
	-- )
	return c :: any
end

function getRootHostContainer(): Container
	-- ROBLOX performance: inline requiredContext impl for hot path
	-- local rootInstance = requiredContext(rootInstanceStackCursor.current)
	-- return rootInstance
	return rootInstanceStackCursor.current
end

function pushHostContainer(fiber: Fiber, nextRootInstance: Container)
	-- Push current root instance onto the stack
	-- This allows us to reset root when portals are popped.
	push(rootInstanceStackCursor, nextRootInstance, fiber)
	-- Track the context and the Fiber that provided it.
	-- This enables us to pop only Fibers that provide unique contexts.
	push(contextFiberStackCursor, fiber, fiber)

	-- Finally, we need to push the host context to the stack.
	-- However, we can't just call getRootHostContext() and push it because
	-- we'd have a different number of entries on the stack depending on
	-- whether getRootHostContext() throws somewhere in renderer code or not.
	-- So we push an empty value first. This lets us safely unwind on errors.
	push(contextStackCursor, NO_CONTEXT, fiber)
	local nextRootContext = getRootHostContext(nextRootInstance)
	-- Now that we know this function doesn't throw, replace it.
	pop(contextStackCursor, fiber)
	push(contextStackCursor, nextRootContext, fiber)
end

function popHostContainer(fiber: Fiber)
	pop(contextStackCursor, fiber)
	pop(contextFiberStackCursor, fiber)
	pop(rootInstanceStackCursor, fiber)
end

function getHostContext(): HostContext
	-- ROBLOX performance: inline requiredContext impl for hot path
	-- local context = requiredContext(contextStackCursor.current)
	-- return context
	return contextStackCursor.current
end

function pushHostContext(fiber: Fiber)
	local rootInstance: Container = requiredContext(rootInstanceStackCursor.current)
	local context: HostContext = requiredContext(contextStackCursor.current)
	local nextContext = getChildHostContext(context, fiber.type, rootInstance)

	-- Don't push this Fiber's context unless it's unique.
	if context == nextContext then
		return
	end

	-- Track the context and the Fiber that provided it.
	-- This enables us to pop only Fibers that provide unique contexts.
	push(contextFiberStackCursor, fiber, fiber)
	push(contextStackCursor, nextContext, fiber)
end

function popHostContext(fiber: Fiber)
	-- Do not pop unless this Fiber provided the current context.
	-- pushHostContext() only pushes Fibers that provide unique contexts.
	if contextFiberStackCursor.current ~= fiber then
		return
	end

	pop(contextStackCursor, fiber)
	pop(contextFiberStackCursor, fiber)
end

return {
	getHostContext = getHostContext,
	getRootHostContainer = getRootHostContainer,
	popHostContainer = popHostContainer,
	popHostContext = popHostContext,
	pushHostContainer = pushHostContainer,
	pushHostContext = pushHostContext,
} ]]
cX.Children._711e805962e495c33b53381473e2d81a=dy
local dz

local dA={ClassName="ModuleScript",Children={},Properties={}}
dA.Name="ReactFiberHotReloading.new"
dA.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/6edaf6f764f23043f0cd1c2da355b42f641afd8b/packages/react-reconciler/src/ReactFiberHotReloading.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local ReactElementType = require(Packages.Shared)
-- ROBLOX deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactElementType.ReactElement<any, any>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
-- local type {FiberRoot} = require(script.Parent.ReactInternalTypes)
-- local type {Instance} = require(script.Parent.ReactFiberHostConfig)
-- local type {ReactNodeList} = require(Packages.Shared).ReactTypes

-- local {
-- 	flushSync,
-- 	scheduleUpdateOnFiber,
-- 	flushPassiveEffects,
-- } = require(script.Parent.ReactFiberWorkLoop.new)
-- local {updateContainer} = require(script.Parent.ReactFiberReconciler.new)
-- local {emptyContextObject} = require(script.Parent.ReactFiberContext.new)
-- local {SyncLane, NoTimestamp} = require(script.Parent.ReactFiberLane)
-- local {
-- 	ClassComponent,
-- 	FunctionComponent,
-- 	ForwardRef,
-- 	HostComponent,
-- 	HostPortal,
-- 	HostRoot,
-- 	MemoComponent,
-- 	SimpleMemoComponent,
-- } = require(script.Parent.ReactWorkTags)
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
-- 	REACT_MEMO_TYPE,
-- 	REACT_LAZY_TYPE,

export type Family = {
	current: any,
}

-- export type RefreshUpdate = {|
-- 	staleFamilies: Set<Family>,
-- 	updatedFamilies: Set<Family>,
-- |}

-- Resolves type to a family.
type RefreshHandler = (any) -> (Family?)

-- -- Used by React Refresh runtime through DevTools Global Hook.
-- export type SetRefreshHandler = (handler: RefreshHandler | nil) => void
-- export type ScheduleRefresh = (root: FiberRoot, update: RefreshUpdate) => void
-- export type ScheduleRoot = (root: FiberRoot, element: ReactNodeList) => void
-- export type FindHostInstancesForRefresh = (
-- 	root: FiberRoot,
-- 	families: Array<Family>,
-- ) => Set<Instance>

-- FIXME (roblox): restore type 'resolveFamily: RefreshHandler?' when type
-- refinement in Luau works better
local resolveFamily = nil
-- $FlowFixMe Flow gets confused by a WeakSet feature check below.
-- ROBLOX deviation: Using table instead of WeakSet
local failedBoundaries: { [number]: Fiber } | nil = nil

local exports = {}

-- export local setRefreshHandler = (handler: RefreshHandler | nil): void => {
-- 	if _G.__DEV__)
-- 		resolveFamily = handler
-- 	end
-- end

local function resolveFunctionForHotReloading(type: any): any
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return type
		end
		local family = resolveFamily(type)
		if family == nil then
			return type
		end
		-- Use the latest known implementation.
		return family.current
	else
		return type
	end
end
exports.resolveFunctionForHotReloading = resolveFunctionForHotReloading

local function resolveClassForHotReloading(type: any): any
	-- No implementation differences.
	return resolveFunctionForHotReloading(type)
end
exports.resolveClassForHotReloading = resolveClassForHotReloading

local function resolveForwardRefForHotReloading(type: any): any
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return type
		end
		local family = resolveFamily(type)
		if family == nil then
			-- Check if we're dealing with a real forwardRef. Don't want to crash early.
			if type ~= nil and typeof(type.render) == "function" then
				-- ForwardRef is special because its resolved .type is an object,
				-- but it's possible that we only have its inner render function in the map.
				-- If that inner render function is different, we'll build a new forwardRef type.
				local currentRender = resolveFunctionForHotReloading(type.render)
				if type.render ~= currentRender then
					local syntheticType = {
						["$$typeof"] = REACT_FORWARD_REF_TYPE,
						render = currentRender,
						-- ROBLOX deviation: Luau needs table initializers to be complete
						displayName = nil,
					}
					if type.displayName ~= nil then
						syntheticType.displayName = type.displayName
					end
					return syntheticType
				end
			end
			return type
		end
		-- Use the latest known implementation.
		return family.current
	else
		return type
	end
end
exports.resolveForwardRefForHotReloading = resolveForwardRefForHotReloading

exports.isCompatibleFamilyForHotReloading =
	function(fiber: Fiber, element: ReactElement): boolean
		warn("isCompatibleFamilyForHotReloading is stubbed (returns false)")
		return false
		-- if _G.__DEV__ then
		-- 	if resolveFamily == nil then
		-- 		-- Hot reloading is disabled.
		-- 		return false
		-- 	end

		-- 	local prevType = fiber.elementType
		-- 	local nextType = element.type

		-- 	-- If we got here, we know types aren't == equal.
		-- 	local needsCompareFamilies = false

		-- 	local $$typeofNextType =
		-- 		typeof nextType == 'table’' and nextType ~= nil
		-- 			? nextType.$$typeof
		-- 			: nil

		-- 	switch (fiber.tag)
		-- 		case ClassComponent: {
		-- 			if typeof nextType == 'function')
		-- 				needsCompareFamilies = true
		-- 			end
		-- 			break
		-- 		end
		-- 		case FunctionComponent: {
		-- 			if typeof nextType == 'function')
		-- 				needsCompareFamilies = true
		-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
		-- 				-- We don't know the inner type yet.
		-- 				-- We're going to assume that the lazy inner type is stable,
		-- 				-- and so it is sufficient to avoid reconciling it away.
		-- 				-- We're not going to unwrap or actually use the new lazy type.
		-- 				needsCompareFamilies = true
		-- 			end
		-- 			break
		-- 		end
		-- 		case ForwardRef: {
		-- 			if $$typeofNextType == REACT_FORWARD_REF_TYPE)
		-- 				needsCompareFamilies = true
		-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
		-- 				needsCompareFamilies = true
		-- 			end
		-- 			break
		-- 		end
		-- 		case MemoComponent:
		-- 		case SimpleMemoComponent: {
		-- 			if $$typeofNextType == REACT_MEMO_TYPE)
		-- 				-- TODO: if it was but can no longer be simple,
		-- 				-- we shouldn't set this.
		-- 				needsCompareFamilies = true
		-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
		-- 				needsCompareFamilies = true
		-- 			end
		-- 			break
		-- 		end
		-- 		default:
		-- 			return false
		-- 	end

		-- 	-- Check if both types have a family and it's the same one.
		-- 	if needsCompareFamilies)
		-- 		-- Note: memo() and forwardRef() we'll compare outer rather than inner type.
		-- 		-- This means both of them need to be registered to preserve state.
		-- 		-- If we unwrapped and compared the inner types for wrappers instead,
		-- 		-- then we would risk falsely saying two separate memo(Foo)
		-- 		-- calls are equivalent because they wrap the same Foo function.
		-- 		local prevFamily = resolveFamily(prevType)
		-- 		if prevFamily ~= undefined and prevFamily == resolveFamily(nextType))
		-- 			return true
		-- 		end
		-- 	end
		-- 	return false
		-- } else {
		-- 	return false
		-- end
	end

exports.markFailedErrorBoundaryForHotReloading = function(fiber: Fiber)
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return
		end
		-- if typeof(WeakSet) ~= 'function' then
		-- 	return
		-- end
		-- ROBLOX deviation: {} in place of WeakSet
		if failedBoundaries == nil then
			failedBoundaries = {}
		end
		-- ROBLOX FIXME: remove :: once Luau understands nil check
		table.insert(failedBoundaries :: { [number]: Fiber }, fiber)
	end
end

-- export local scheduleRefresh: ScheduleRefresh = (
-- 	root: FiberRoot,
-- 	update: RefreshUpdate,
-- ): void => {
-- 	if _G.__DEV__)
-- 		if resolveFamily == nil)
-- 			-- Hot reloading is disabled.
-- 			return
-- 		end
-- 		local {staleFamilies, updatedFamilies} = update
-- 		flushPassiveEffects()
-- 		flushSync(() => {
-- 			scheduleFibersWithFamiliesRecursively(
-- 				root.current,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		})
-- 	end
-- end

-- export local scheduleRoot: ScheduleRoot = (
-- 	root: FiberRoot,
-- 	element: ReactNodeList,
-- ): void => {
-- 	if _G.__DEV__)
-- 		if root.context ~= emptyContextObject)
-- 			-- Super edge case: root has a legacy _renderSubtree context
-- 			-- but we don't know the parentComponent so we can't pass it.
-- 			-- Just ignore. We'll delete this with _renderSubtree code path later.
-- 			return
-- 		end
-- 		flushPassiveEffects()
-- 		flushSync(() => {
-- 			updateContainer(element, root, nil, nil)
-- 		})
-- 	end
-- end

-- function scheduleFibersWithFamiliesRecursively(
-- 	fiber: Fiber,
-- 	updatedFamilies: Set<Family>,
-- 	staleFamilies: Set<Family>,
-- )
-- 	if _G.__DEV__)
-- 		local {alternate, child, sibling, tag, type} = fiber

-- 		local candidateType = nil
-- 		switch (tag)
-- 			case FunctionComponent:
-- 			case SimpleMemoComponent:
-- 			case ClassComponent:
-- 				candidateType = type
-- 				break
-- 			case ForwardRef:
-- 				candidateType = type.render
-- 				break
-- 			default:
-- 				break
-- 		end

-- 		if resolveFamily == nil)
-- 			throw new Error('Expected resolveFamily to be set during hot reload.')
-- 		end

-- 		local needsRender = false
-- 		local needsRemount = false
-- 		if candidateType ~= nil)
-- 			local family = resolveFamily(candidateType)
-- 			if family ~= undefined)
-- 				if staleFamilies.has(family))
-- 					needsRemount = true
-- 				} else if updatedFamilies.has(family))
-- 					if tag == ClassComponent)
-- 						needsRemount = true
-- 					} else {
-- 						needsRender = true
-- 					end
-- 				end
-- 			end
-- 		end
-- 		if failedBoundaries ~= nil)
-- 			if
-- 				failedBoundaries.has(fiber) or
-- 				(alternate ~= nil and failedBoundaries.has(alternate))
-- 			)
-- 				needsRemount = true
-- 			end
-- 		end

-- 		if needsRemount)
-- 			fiber._debugNeedsRemount = true
-- 		end
-- 		if needsRemount or needsRender)
-- 			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
-- 		end
-- 		if child ~= nil and !needsRemount)
-- 			scheduleFibersWithFamiliesRecursively(
-- 				child,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		end
-- 		if sibling ~= nil)
-- 			scheduleFibersWithFamiliesRecursively(
-- 				sibling,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		end
-- 	end
-- end

-- export local findHostInstancesForRefresh: FindHostInstancesForRefresh = (
-- 	root: FiberRoot,
-- 	families: Array<Family>,
-- ): Set<Instance> => {
-- 	if _G.__DEV__)
-- 		local hostInstances = new Set()
-- 		local types = new Set(families.map(family => family.current))
-- 		findHostInstancesForMatchingFibersRecursively(
-- 			root.current,
-- 			types,
-- 			hostInstances,
-- 		)
-- 		return hostInstances
-- 	} else {
-- 		throw new Error(
-- 			'Did not expect findHostInstancesForRefresh to be called in production.',
-- 		)
-- 	end
-- end

-- function findHostInstancesForMatchingFibersRecursively(
-- 	fiber: Fiber,
-- 	types: Set<any>,
-- 	hostInstances: Set<Instance>,
-- )
-- 	if _G.__DEV__)
-- 		local {child, sibling, tag, type} = fiber

-- 		local candidateType = nil
-- 		switch (tag)
-- 			case FunctionComponent:
-- 			case SimpleMemoComponent:
-- 			case ClassComponent:
-- 				candidateType = type
-- 				break
-- 			case ForwardRef:
-- 				candidateType = type.render
-- 				break
-- 			default:
-- 				break
-- 		end

-- 		local didMatch = false
-- 		if candidateType ~= nil)
-- 			if types.has(candidateType))
-- 				didMatch = true
-- 			end
-- 		end

-- 		if didMatch)
-- 			-- We have a match. This only drills down to the closest host components.
-- 			-- There's no need to search deeper because for the purpose of giving
-- 			-- visual feedback, "flashing" outermost parent rectangles is sufficient.
-- 			findHostInstancesForFiberShallowly(fiber, hostInstances)
-- 		} else {
-- 			-- If there's no match, maybe there will be one further down in the child tree.
-- 			if child ~= nil)
-- 				findHostInstancesForMatchingFibersRecursively(
-- 					child,
-- 					types,
-- 					hostInstances,
-- 				)
-- 			end
-- 		end

-- 		if sibling ~= nil)
-- 			findHostInstancesForMatchingFibersRecursively(
-- 				sibling,
-- 				types,
-- 				hostInstances,
-- 			)
-- 		end
-- 	end
-- end

-- function findHostInstancesForFiberShallowly(
-- 	fiber: Fiber,
-- 	hostInstances: Set<Instance>,
-- ): void {
-- 	if _G.__DEV__)
-- 		local foundHostInstances = findChildHostInstancesForFiberShallowly(
-- 			fiber,
-- 			hostInstances,
-- 		)
-- 		if foundHostInstances)
-- 			return
-- 		end
-- 		-- If we didn't find any host children, fallback to closest host parent.
-- 		local node = fiber
-- 		while (true)
-- 			switch (node.tag)
-- 				case HostComponent:
-- 					hostInstances.add(node.stateNode)
-- 					return
-- 				case HostPortal:
-- 					hostInstances.add(node.stateNode.containerInfo)
-- 					return
-- 				case HostRoot:
-- 					hostInstances.add(node.stateNode.containerInfo)
-- 					return
-- 			end
-- 			if node.return == nil)
-- 				throw new Error('Expected to reach root first.')
-- 			end
-- 			node = node.return
-- 		end
-- 	end
-- end

-- function findChildHostInstancesForFiberShallowly(
-- 	fiber: Fiber,
-- 	hostInstances: Set<Instance>,
-- ): boolean {
-- 	if _G.__DEV__)
-- 		local node: Fiber = fiber
-- 		local foundHostInstances = false
-- 		while (true)
-- 			if node.tag == HostComponent)
-- 				-- We got a match.
-- 				foundHostInstances = true
-- 				hostInstances.add(node.stateNode)
-- 				-- There may still be more, so keep searching.
-- 			} else if node.child ~= nil)
-- 				node.child.return = node
-- 				node = node.child
-- 				continue
-- 			end
-- 			if node == fiber)
-- 				return foundHostInstances
-- 			end
-- 			while (node.sibling == nil)
-- 				if node.return == nil or node.return == fiber)
-- 					return foundHostInstances
-- 				end
-- 				node = node.return
-- 			end
-- 			node.sibling.return = node.return
-- 			node = node.sibling
-- 		end
-- 	end
-- 	return false
-- end

return exports ]]
cX.Children._4633a3d8ecd1df28cf42cdb56342ef0d=dA
local dB

local dC={ClassName="ModuleScript",Children={},Properties={}}
dC.Name="ReactFiberHydrationContext.new"
dC.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberHydrationContext.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. message)
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type TextInstance = ReactFiberHostConfig.TextInstance
type HydratableInstance = ReactFiberHostConfig.HydratableInstance
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
type Container = ReactFiberHostConfig.Container
type HostContext = ReactFiberHostConfig.HostContext

local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
-- local Deletion = ReactFiberFlags.Deletion

local invariant = require(Packages.Shared).invariant

local ReactFiber = require(script.Parent["ReactFiber.new"])
-- local createFiberFromHostInstanceForDeletion = ReactFiber.createFiberFromHostInstanceForDeletion
local createFiberFromDehydratedFragment = ReactFiber.createFiberFromDehydratedFragment

local supportsHydration = ReactFiberHostConfig.supportsHydration
local getNextHydratableSibling = ReactFiberHostConfig.getNextHydratableSibling
local getFirstHydratableChild = ReactFiberHostConfig.getFirstHydratableChild
local canHydrateInstance = ReactFiberHostConfig.canHydrateInstance
local canHydrateTextInstance = ReactFiberHostConfig.canHydrateTextInstance
local canHydrateSuspenseInstance = ReactFiberHostConfig.canHydrateSuspenseInstance
local hydrateInstance = ReactFiberHostConfig.hydrateInstance
local hydrateTextInstance = ReactFiberHostConfig.hydrateTextInstance
local hydrateSuspenseInstance = ReactFiberHostConfig.hydrateSuspenseInstance
local getNextHydratableInstanceAfterSuspenseInstance =
	ReactFiberHostConfig.getNextHydratableInstanceAfterSuspenseInstance
local didNotMatchHydratedContainerTextInstance =
	ReactFiberHostConfig.didNotMatchHydratedContainerTextInstance
local didNotMatchHydratedTextInstance =
	ReactFiberHostConfig.didNotMatchHydratedTextInstance
local shouldSetTextContent = ReactFiberHostConfig.shouldSetTextContent

-- local {
--   didNotHydrateContainerInstance,
--   didNotHydrateInstance,
--   didNotFindHydratableContainerInstance,
--   didNotFindHydratableContainerTextInstance,
--   didNotFindHydratableContainerSuspenseInstance,
--   didNotFindHydratableInstance,
--   didNotFindHydratableTextInstance,
--   didNotFindHydratableSuspenseInstance,
-- } = require(Packages../ReactFiberHostConfig'
local enableSuspenseServerRenderer =
	require(Packages.Shared).ReactFeatureFlags.enableSuspenseServerRenderer
local OffscreenLane = require(script.Parent.ReactFiberLane).OffscreenLane

-- The deepest Fiber on the stack involved in a hydration context.
-- This may have been an insertion or a hydration.
local hydrationParentFiber: Fiber? = nil
local nextHydratableInstance: nil | HydratableInstance = nil
local isHydrating: boolean = false

function warnIfHydrating()
	if _G.__DEV__ then
		if isHydrating then
			console.error(
				"We should not be hydrating here. This is a bug in React. Please file a bug."
			)
		end
	end
end

function enterHydrationState(fiber: Fiber): boolean
	if not supportsHydration then
		return false
	end

	local parentInstance = fiber.stateNode.containerInfo
	nextHydratableInstance = getFirstHydratableChild(parentInstance)
	hydrationParentFiber = fiber
	isHydrating = true
	return true
end

function reenterHydrationStateFromDehydratedSuspenseInstance(
	fiber: Fiber,
	suspenseInstance: SuspenseInstance
): boolean
	if not supportsHydration then
		return false
	end

	nextHydratableInstance = getNextHydratableSibling(suspenseInstance)
	popToNextHostParent(fiber)
	isHydrating = true
	return true
end

function deleteHydratableInstance(returnFiber: Fiber?, instance: HydratableInstance)
	unimplemented("deleteHydratableInstance")
	-- if _G.__DEV__ then
	--   switch (returnFiber.tag)
	--     case HostRoot:
	--       didNotHydrateContainerInstance(
	--         returnFiber.stateNode.containerInfo,
	--         instance,
	--       )
	--       break
	--     case HostComponent:
	--       didNotHydrateInstance(
	--         returnFiber.type,
	--         returnFiber.memoizedProps,
	--         returnFiber.stateNode,
	--         instance,
	--       )
	--       break
	-- 		end
	-- 	end

	-- local childToDelete = createFiberFromHostInstanceForDeletion()
	-- childToDelete.stateNode = instance
	-- childToDelete.return = returnFiber

	-- local deletions = returnFiber.deletions
	-- if deletions == nil)
	--   returnFiber.deletions = [childToDelete]
	--   -- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
	--   returnFiber.flags |= Deletion
	-- } else {
	--   deletions.push(childToDelete)
	-- }
end

function insertNonHydratedInstance(returnFiber: Fiber?, fiber: Fiber)
	unimplemented("insertNonHydratedInstance")
	fiber.flags = bit32.bor(bit32.band(fiber.flags, bit32.bnot(Hydrating)), Placement)
	if _G.__DEV__ then
		-- switch (returnFiber.tag)
		--   case HostRoot: {
		--     local parentContainer = returnFiber.stateNode.containerInfo
		--     switch (fiber.tag)
		--       case HostComponent:
		--         local type = fiber.type
		--         local props = fiber.pendingProps
		--         didNotFindHydratableContainerInstance(parentContainer, type, props)
		--         break
		--       case HostText:
		--         local text = fiber.pendingProps
		--         didNotFindHydratableContainerTextInstance(parentContainer, text)
		--         break
		--       case SuspenseComponent:
		--         didNotFindHydratableContainerSuspenseInstance(parentContainer)
		--         break
		--     }
		--     break
		--   }
		--   case HostComponent: {
		--     local parentType = returnFiber.type
		--     local parentProps = returnFiber.memoizedProps
		--     local parentInstance = returnFiber.stateNode
		--     switch (fiber.tag)
		--       case HostComponent:
		--         local type = fiber.type
		--         local props = fiber.pendingProps
		--         didNotFindHydratableInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--           type,
		--           props,
		--         )
		--         break
		--       case HostText:
		--         local text = fiber.pendingProps
		--         didNotFindHydratableTextInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--           text,
		--         )
		--         break
		--       case SuspenseComponent:
		--         didNotFindHydratableSuspenseInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--         )
		--         break
		--     }
		--     break
		--   }
		--   default:
		--     return
		-- end
	end
end

function tryHydrate(fiber, nextInstance)
	if fiber.tag == HostComponent then
		local type_ = fiber.type
		local props = fiber.pendingProps
		local instance = canHydrateInstance(nextInstance, type_, props)
		if instance ~= nil then
			fiber.stateNode = instance
			return true
		end
		return false
	elseif fiber.tag == HostText then
		local text = fiber.pendingProps
		local textInstance = canHydrateTextInstance(nextInstance, text)
		if textInstance ~= nil then
			fiber.stateNode = textInstance
			return true
		end
		return false
	elseif fiber.tag == SuspenseComponent then
		if enableSuspenseServerRenderer then
			local suspenseInstance: nil | SuspenseInstance =
				canHydrateSuspenseInstance(nextInstance)
			if suspenseInstance ~= nil then
				local suspenseState: SuspenseState = {
					dehydrated = suspenseInstance,
					retryLane = OffscreenLane,
				}
				fiber.memoizedState = suspenseState
				-- Store the dehydrated fragment as a child fiber.
				-- This simplifies the code for getHostSibling and deleting nodes,
				-- since it doesn't have to consider all Suspense boundaries and
				-- check if they're dehydrated ones or not.
				local dehydratedFragment =
					createFiberFromDehydratedFragment(suspenseInstance)
				dehydratedFragment.return_ = fiber
				fiber.child = dehydratedFragment
				return true
			end
		end
		return false
	else
		return false
	end
end

function tryToClaimNextHydratableInstance(fiber: Fiber)
	if not isHydrating then
		return
	end
	local nextInstance = nextHydratableInstance
	if not nextInstance then
		-- Nothing to hydrate. Make it an insertion.
		insertNonHydratedInstance(hydrationParentFiber, fiber)
		isHydrating = false
		hydrationParentFiber = fiber
		return
	end
	-- ROBLOX FIXME Luau: Luau doesn't narrow based on the guard above
	local firstAttemptedInstance = nextInstance :: HydratableInstance
	if not tryHydrate(fiber, nextInstance) then
		-- If we can't hydrate this instance let's try the next one.
		-- We use this as a heuristic. It's based on intuition and not data so it
		-- might be flawed or unnecessary.
		nextInstance = getNextHydratableSibling(firstAttemptedInstance)
		if not nextInstance or not tryHydrate(fiber, nextInstance) then
			-- Nothing to hydrate. Make it an insertion.
			insertNonHydratedInstance(hydrationParentFiber, fiber)
			isHydrating = false
			hydrationParentFiber = fiber
			return
		end
		-- We matched the next one, we'll now assume that the first one was
		-- superfluous and we'll delete it. Since we can't eagerly delete it
		-- we'll have to schedule a deletion. To do that, this node needs a dummy
		-- fiber associated with it.
		deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance)
	end
	hydrationParentFiber = fiber
	nextHydratableInstance = getFirstHydratableChild(nextInstance)
end

function prepareToHydrateHostInstance(
	fiber: Fiber,
	rootContainerInstance: Container,
	hostContext: HostContext
): boolean
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local instance: Instance = fiber.stateNode
	local updatePayload = hydrateInstance(
		instance,
		fiber.type,
		fiber.memoizedProps,
		rootContainerInstance,
		hostContext,
		fiber
	)
	-- TODO: Type this specific to this type of component.
	fiber.updateQueue = updatePayload
	-- If the update payload indicates that there is a change or if there
	-- is a new ref we mark this as an update.
	if updatePayload ~= nil then
		return true
	end
	return false
end

function prepareToHydrateHostTextInstance(fiber: Fiber): boolean
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostTextInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local textInstance: TextInstance = fiber.stateNode
	local textContent: string = fiber.memoizedProps
	local shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber)
	if _G.__DEV__ then
		if shouldUpdate then
			-- We assume that prepareToHydrateHostTextInstance is called in a context where the
			-- hydration parent is the parent host component of this host text.
			local returnFiber = hydrationParentFiber
			if returnFiber ~= nil then
				if returnFiber.tag == HostRoot then
					local parentContainer = returnFiber.stateNode.containerInfo
					didNotMatchHydratedContainerTextInstance(
						parentContainer,
						textInstance,
						textContent
					)
				elseif returnFiber.tag == HostComponent then
					local parentType = returnFiber.type
					local parentProps = returnFiber.memoizedProps
					local parentInstance = returnFiber.stateNode
					didNotMatchHydratedTextInstance(
						parentType,
						parentProps,
						parentInstance,
						textInstance,
						textContent
					)
				end
			end
		end
	end
	return shouldUpdate
end

function prepareToHydrateHostSuspenseInstance(fiber: Fiber)
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostSuspenseInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local suspenseState: SuspenseState = fiber.memoizedState
	local suspenseInstance: nil | SuspenseInstance
	if suspenseState ~= nil then
		suspenseInstance = suspenseState.dehydrated
	else
		suspenseInstance = nil
	end

	invariant(
		suspenseInstance,
		"Expected to have a hydrated suspense instance. "
			.. "This error is likely caused by a bug in React. Please file an issue."
	)
	hydrateSuspenseInstance(suspenseInstance, fiber)
end

function skipPastDehydratedSuspenseInstance(fiber: Fiber): nil | HydratableInstance
	if not supportsHydration then
		invariant(
			false,
			"Expected skipPastDehydratedSuspenseInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end
	local suspenseState: SuspenseState = fiber.memoizedState
	local suspenseInstance: nil | SuspenseInstance
	if suspenseState ~= nil then
		suspenseInstance = suspenseState.dehydrated
	else
		suspenseInstance = nil
	end
	invariant(
		suspenseInstance,
		"Expected to have a hydrated suspense instance. "
			.. "This error is likely caused by a bug in React. Please file an issue."
	)
	return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)
end

function popToNextHostParent(fiber: Fiber)
	local parent = fiber.return_
	while
		parent ~= nil
		and parent.tag ~= HostComponent
		and parent.tag ~= HostRoot
		and parent.tag ~= SuspenseComponent
	do
		parent = parent.return_
	end
	hydrationParentFiber = parent
end

function popHydrationState(fiber: Fiber): boolean
	if not supportsHydration then
		return false
	end
	if fiber ~= hydrationParentFiber then
		-- We're deeper than the current hydration context, inside an inserted
		-- tree.
		return false
	end
	if not isHydrating then
		-- If we're not currently hydrating but we're in a hydration context, then
		-- we were an insertion and now need to pop up reenter hydration of our
		-- siblings.
		popToNextHostParent(fiber)
		isHydrating = true
		return false
	end

	local type_ = fiber.type

	-- If we have any remaining hydratable nodes, we need to delete them now.
	-- We only do this deeper than head and body since they tend to have random
	-- other nodes in them. We also ignore components with pure text content in
	-- side of them.
	-- TODO: Better heuristic.
	if
		fiber.tag ~= HostComponent
		or (
			type_ ~= "head"
			and type_ ~= "body"
			and not shouldSetTextContent(type_, fiber.memoizedProps)
		)
	then
		local nextInstance = nextHydratableInstance
		while nextInstance do
			deleteHydratableInstance(fiber, nextInstance)
			nextInstance = getNextHydratableSibling(nextInstance)
		end
	end

	popToNextHostParent(fiber)
	if fiber.tag == SuspenseComponent then
		nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber)
	else
		if hydrationParentFiber then
			nextHydratableInstance = getNextHydratableSibling(fiber.stateNode)
		else
			nextHydratableInstance = nil
		end
	end
	return true
end

function resetHydrationState()
	if not supportsHydration then
		return
	end

	hydrationParentFiber = nil
	nextHydratableInstance = nil
	isHydrating = false
end

function getIsHydrating(): boolean
	return isHydrating
end

return {
	warnIfHydrating = warnIfHydrating,
	enterHydrationState = enterHydrationState,
	getIsHydrating = getIsHydrating,
	reenterHydrationStateFromDehydratedSuspenseInstance = reenterHydrationStateFromDehydratedSuspenseInstance,
	resetHydrationState = resetHydrationState,
	tryToClaimNextHydratableInstance = tryToClaimNextHydratableInstance,
	prepareToHydrateHostInstance = prepareToHydrateHostInstance,
	prepareToHydrateHostTextInstance = prepareToHydrateHostTextInstance,
	prepareToHydrateHostSuspenseInstance = prepareToHydrateHostSuspenseInstance,
	popHydrationState = popHydrationState,
} ]]
cX.Children._0de089bb5bfc7f97e9c52e6cae1beb5f=dC
local dD

local dE={ClassName="ModuleScript",Children={},Properties={}}
dE.Name="ReactFiberLane"
dE.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/6f62abb58ae46d9c88525635f1790487285666e6/packages/react-reconciler/src/ReactFiberLane.js
--!strict
--\[\[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local Packages = script.Parent.Parent
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local console = require(Packages.Shared).console

local ReactFiberSchedulerPriorities =
	require(script.Parent["ReactFiberSchedulerPriorities.roblox"])

-- deviation: Instead of defining these here, and and re-exporting in
-- `ReactInternalTypes`, we depend on and re-export them here to avoid cyclical
-- require issues
export type LanePriority = ReactInternalTypes.LanePriority
export type Lane = ReactInternalTypes.Lane
export type Lanes = ReactInternalTypes.Lanes
export type LaneMap<T> = ReactInternalTypes.LaneMap<T>

local invariant = require(Packages.Shared).invariant

local ImmediateSchedulerPriority = ReactFiberSchedulerPriorities.ImmediatePriority
local UserBlockingSchedulerPriority = ReactFiberSchedulerPriorities.UserBlockingPriority
local NormalSchedulerPriority = ReactFiberSchedulerPriorities.NormalPriority
local LowSchedulerPriority = ReactFiberSchedulerPriorities.LowPriority
local IdleSchedulerPriority = ReactFiberSchedulerPriorities.IdlePriority
local NoSchedulerPriority = ReactFiberSchedulerPriorities.NoPriority

local exports = {}

local SyncLanePriority: LanePriority = 15
exports.SyncLanePriority = SyncLanePriority
local SyncBatchedLanePriority: LanePriority = 14
exports.SyncBatchedLanePriority = SyncBatchedLanePriority

local InputDiscreteHydrationLanePriority: LanePriority = 13
local InputDiscreteLanePriority: LanePriority = 12
exports.InputDiscreteLanePriority = InputDiscreteLanePriority

local InputContinuousHydrationLanePriority: LanePriority = 11
local InputContinuousLanePriority: LanePriority = 10
exports.InputContinuousLanePriority = InputContinuousLanePriority

local DefaultHydrationLanePriority: LanePriority = 9
local DefaultLanePriority: LanePriority = 8
exports.DefaultLanePriority = DefaultLanePriority

local TransitionHydrationPriority: LanePriority = 7
local TransitionPriority: LanePriority = 6
exports.TransitionPriority = TransitionPriority

local RetryLanePriority: LanePriority = 5

local SelectiveHydrationLanePriority: LanePriority = 4

local IdleHydrationLanePriority: LanePriority = 3
local IdleLanePriority: LanePriority = 2

local OffscreenLanePriority: LanePriority = 1

local NoLanePriority: LanePriority = 0
exports.NoLanePriority = NoLanePriority

-- ROBLOX performance: only use was for loop that was manually unrolled
-- local TotalLanes = 31

local NoLanes: Lanes = --\[\[                             \]\]
	0b0000000000000000000000000000000
exports.NoLanes = NoLanes
local NoLane: Lane = --\[\[                               \]\]
	0b0000000000000000000000000000000
exports.NoLane = NoLane

local SyncLane: Lane = --\[\[                             \]\]
	0b0000000000000000000000000000001
exports.SyncLane = SyncLane
local SyncBatchedLane: Lanes = --\[\[                     \]\]
	0b0000000000000000000000000000010
exports.SyncBatchedLane = SyncBatchedLane

local InputDiscreteHydrationLane: Lane = --\[\[           \]\]
	0b0000000000000000000000000000100
exports.InputDiscreteHydrationLane = InputDiscreteHydrationLane
local InputDiscreteLanes: Lanes = --\[\[                  \]\]
	0b0000000000000000000000000011000

local InputContinuousHydrationLane: Lane = --\[\[         \]\]
	0b0000000000000000000000000100000
local InputContinuousLanes: Lanes = --\[\[                \]\]
	0b0000000000000000000000011000000

local DefaultHydrationLane: Lane = --\[\[                 \]\]
	0b0000000000000000000000100000000
exports.DefaultHydrationLane = DefaultHydrationLane
local DefaultLanes: Lanes = --\[\[                        \]\]
	0b0000000000000000000111000000000
exports.DefaultLanes = DefaultLanes

local TransitionHydrationLane: Lane = --\[\[              \]\]
	0b0000000000000000001000000000000
local TransitionLanes: Lanes = --\[\[                     \]\]
	0b0000000001111111110000000000000

local RetryLanes: Lanes = --\[\[                          \]\]
	0b0000011110000000000000000000000
-- ROBLOX deviation: we expose this symbol from the module for ReactUpdateQueue.roblox tests, we don't re-export outside the package
exports.RetryLanes = RetryLanes
local SomeRetryLane: Lanes = --\[\[                       \]\]
	0b0000010000000000000000000000000
exports.SomeRetryLane = SomeRetryLane

local SelectiveHydrationLane: Lane = --\[\[               \]\]
	0b0000100000000000000000000000000
exports.SelectiveHydrationLane = SelectiveHydrationLane

local NonIdleLanes = --\[\[                               \]\]
	0b0000111111111111111111111111111

local IdleHydrationLane: Lane = --\[\[                    \]\]
	0b0001000000000000000000000000000
exports.IdleHydrationLane = IdleHydrationLane
local IdleLanes: Lanes = --\[\[                           \]\]
	0b0110000000000000000000000000000

local OffscreenLane: Lane = --\[\[                        \]\]
	0b1000000000000000000000000000000
exports.OffscreenLane = OffscreenLane

local NoTimestamp = -1
exports.NoTimestamp = NoTimestamp

local currentUpdateLanePriority: LanePriority = exports.NoLanePriority

exports.getCurrentUpdateLanePriority = function(): LanePriority
	return currentUpdateLanePriority
end

exports.setCurrentUpdateLanePriority = function(newLanePriority: LanePriority)
	currentUpdateLanePriority = newLanePriority
end

-- // "Registers" used to "return" multiple values
-- // Used by getHighestPriorityLanes and getNextLanes:
local return_highestLanePriority: LanePriority = exports.DefaultLanePriority

local function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes
	if bit32.band(SyncLane, lanes) ~= NoLanes then
		return_highestLanePriority = SyncLanePriority
		return SyncLane
	end
	if bit32.band(SyncBatchedLane, lanes) ~= NoLanes then
		return_highestLanePriority = SyncBatchedLanePriority
		return SyncBatchedLane
	end
	if bit32.band(InputDiscreteHydrationLane, lanes) ~= NoLanes then
		return_highestLanePriority = InputDiscreteHydrationLanePriority
		return InputDiscreteHydrationLane
	end
	local inputDiscreteLanes = bit32.band(InputDiscreteLanes, lanes)
	if inputDiscreteLanes ~= NoLanes then
		return_highestLanePriority = InputDiscreteLanePriority
		return inputDiscreteLanes
	end
	if bit32.band(lanes, InputContinuousHydrationLane) ~= NoLanes then
		return_highestLanePriority = InputContinuousHydrationLanePriority
		return InputContinuousHydrationLane
	end
	local inputContinuousLanes = bit32.band(InputContinuousLanes, lanes)
	if inputContinuousLanes ~= NoLanes then
		return_highestLanePriority = InputContinuousLanePriority
		return inputContinuousLanes
	end
	if bit32.band(lanes, DefaultHydrationLane) ~= NoLanes then
		return_highestLanePriority = DefaultHydrationLanePriority
		return DefaultHydrationLane
	end
	local defaultLanes = bit32.band(DefaultLanes, lanes)
	if defaultLanes ~= NoLanes then
		return_highestLanePriority = DefaultLanePriority
		return defaultLanes
	end
	if bit32.band(lanes, TransitionHydrationLane) ~= NoLanes then
		return_highestLanePriority = TransitionHydrationPriority
		return TransitionHydrationLane
	end
	local transitionLanes = bit32.band(TransitionLanes, lanes)
	if transitionLanes ~= NoLanes then
		return_highestLanePriority = TransitionPriority
		return transitionLanes
	end
	local retryLanes = bit32.band(RetryLanes, lanes)
	if retryLanes ~= NoLanes then
		return_highestLanePriority = RetryLanePriority
		return retryLanes
	end
	if bit32.band(lanes, SelectiveHydrationLane) ~= 0 then
		return_highestLanePriority = SelectiveHydrationLanePriority
		return SelectiveHydrationLane
	end
	if bit32.band(lanes, IdleHydrationLane) ~= NoLanes then
		return_highestLanePriority = IdleHydrationLanePriority
		return IdleHydrationLane
	end
	local idleLanes = bit32.band(IdleLanes, lanes)
	if idleLanes ~= NoLanes then
		return_highestLanePriority = IdleLanePriority
		return idleLanes
	end
	if bit32.band(OffscreenLane, lanes) ~= NoLanes then
		return_highestLanePriority = OffscreenLanePriority
		return OffscreenLane
	end
	if _G.__DEV__ then
		console.error("Should have found matching lanes. This is a bug in React.")
	end
	-- // This shouldn't be reachable, but as a fallback, return the entire bitmask.
	return_highestLanePriority = DefaultLanePriority
	return lanes
end

local function schedulerPriorityToLanePriority(
	schedulerPriorityLevel: ReactPriorityLevel
): LanePriority
	if schedulerPriorityLevel == ImmediateSchedulerPriority then
		return SyncLanePriority
	elseif schedulerPriorityLevel == UserBlockingSchedulerPriority then
		return InputContinuousLanePriority
	elseif
		schedulerPriorityLevel == NormalSchedulerPriority
		or schedulerPriorityLevel == LowSchedulerPriority
	then
		-- // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
		return DefaultLanePriority
	elseif schedulerPriorityLevel == IdleSchedulerPriority then
		return IdleLanePriority
	else
		return NoLanePriority
	end
end
exports.schedulerPriorityToLanePriority = schedulerPriorityToLanePriority

local function lanePriorityToSchedulerPriority(
	lanePriority: LanePriority
): ReactPriorityLevel
	if lanePriority == SyncLanePriority or lanePriority == SyncBatchedLanePriority then
		return ImmediateSchedulerPriority
	elseif
		lanePriority == InputDiscreteHydrationLanePriority
		or lanePriority == InputDiscreteLanePriority
		or lanePriority == InputContinuousHydrationLanePriority
		or lanePriority == InputContinuousLanePriority
	then
		return UserBlockingSchedulerPriority
	elseif
		lanePriority == DefaultHydrationLanePriority
		or lanePriority == DefaultLanePriority
		or lanePriority == TransitionHydrationPriority
		or lanePriority == TransitionPriority
		or lanePriority == SelectiveHydrationLanePriority
		or lanePriority == RetryLanePriority
	then
		return NormalSchedulerPriority
	elseif
		lanePriority == IdleHydrationLanePriority
		or lanePriority == IdleLanePriority
		or lanePriority == OffscreenLanePriority
	then
		return IdleSchedulerPriority
	elseif lanePriority == NoLanePriority then
		return NoSchedulerPriority
	else
		invariant(
			false,
			"Invalid update priority: %s. This is a bug in React.",
			lanePriority
		)
		-- deviation: luau doesn't know that invariant throws, so we error
		error("unreachable")
	end
end
exports.lanePriorityToSchedulerPriority = lanePriorityToSchedulerPriority

-- deviation: pre-declare pickArbitraryLaneIndex to keep ordering
local pickArbitraryLaneIndex, getLowestPriorityLane, getEqualOrHigherPriorityLanes

local function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes
	-- // Early bailout if there's no pending work left.
	local pendingLanes = root.pendingLanes
	if pendingLanes == NoLanes then
		return_highestLanePriority = NoLanePriority
		return NoLanes
	end

	local nextLanes = NoLanes
	local nextLanePriority = NoLanePriority

	local expiredLanes = root.expiredLanes
	local suspendedLanes = root.suspendedLanes
	local pingedLanes = root.pingedLanes

	-- // Check if any work has expired.
	if expiredLanes ~= NoLanes then
		nextLanes = expiredLanes
		return_highestLanePriority = SyncLanePriority
		nextLanePriority = SyncLanePriority
	else
		-- // Do not work on any idle work until all the non-idle work has finished,
		-- // even if the work is suspended.
		local nonIdlePendingLanes = bit32.band(pendingLanes, NonIdleLanes)
		if nonIdlePendingLanes ~= NoLanes then
			local nonIdleUnblockedLanes =
				bit32.band(nonIdlePendingLanes, bit32.bnot(suspendedLanes))
			if nonIdleUnblockedLanes ~= NoLanes then
				nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes)
				nextLanePriority = return_highestLanePriority
			else
				local nonIdlePingedLanes = bit32.band(nonIdlePendingLanes, pingedLanes)
				if nonIdlePingedLanes ~= NoLanes then
					nextLanes = getHighestPriorityLanes(nonIdlePingedLanes)
					nextLanePriority = return_highestLanePriority
				end
			end
		else
			-- // The only remaining work is Idle.
			local unblockedLanes = bit32.band(pendingLanes, bit32.bnot(suspendedLanes))
			if unblockedLanes ~= NoLanes then
				nextLanes = getHighestPriorityLanes(unblockedLanes)
				nextLanePriority = return_highestLanePriority
			else
				if pingedLanes ~= NoLanes then
					nextLanes = getHighestPriorityLanes(pingedLanes)
					nextLanePriority = return_highestLanePriority
				end
			end
		end
	end

	if nextLanes == NoLanes then
		-- // This should only be reachable if we're suspended
		-- // TODO: Consider warning in this path if a fallback timer is not scheduled.
		return NoLanes
	end

	-- // If there are higher priority lanes, we'll include them even if they
	-- // are suspended.
	-- ROBLOX performance: inline getEqualOrHigherPriorityLanes to avoid function call overhead in hot path
	-- nextLanes = bit32.band(pendingLanes, getEqualOrHigherPriorityLanes(nextLanes))
	nextLanes =
		bit32.band(pendingLanes, bit32.lshift(getLowestPriorityLane(nextLanes), 1) - 1)

	-- // If we're already in the middle of a render, switching lanes will interrupt
	-- // it and we'll lose our progress. We should only do this if the new lanes are
	-- // higher priority.
	if
		wipLanes ~= NoLanes
		and wipLanes ~= nextLanes
		-- // If we already suspended with a delay, then interrupting is fine. Don't
		-- // bother waiting until the root is complocale.
		and bit32.band(wipLanes, suspendedLanes) == NoLanes
	then
		getHighestPriorityLanes(wipLanes)
		local wipLanePriority = return_highestLanePriority
		if nextLanePriority <= wipLanePriority then
			return wipLanes
		else
			return_highestLanePriority = nextLanePriority
		end
	end

	-- // Check for entangled lanes and add them to the batch.
	-- //
	-- // A lane is said to be entangled with another when it's not allowed to render
	-- // in a batch that does not also include the other lane. Typically we do this
	-- // when multiple updates have the same source, and we only want to respond to
	-- // the most recent event from that source.
	-- //
	-- // Note that we apply entanglements *after* checking for partial work above.
	-- // This means that if a lane is entangled during an interleaved event while
	-- // it's already rendering, we won't interrupt it. This is intentional, since
	-- // entanglement is usually "best effort": we'll try our best to render the
	-- // lanes in the same batch, but it's not worth throwing out partially
	-- // complocaled work in order to do it.
	-- //
	-- // For those exceptions where entanglement is semantically important, like
	-- // useMutableSource, we should ensure that there is no partial work at the
	-- // time we apply the entanglement.
	local entangledLanes = root.entangledLanes
	if entangledLanes ~= NoLanes then
		local entanglements = root.entanglements
		local lanes = bit32.band(nextLanes, entangledLanes)
		while lanes > 0 do
			local index = pickArbitraryLaneIndex(lanes)
			local lane = bit32.lshift(1, index)

			nextLanes = bit32.bor(nextLanes, entanglements[index])

			lanes = bit32.band(lanes, bit32.bnot(lane))
		end
	end

	return nextLanes
end
exports.getNextLanes = getNextLanes

local function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number
	local eventTimes = root.eventTimes

	local mostRecentEventTime = NoTimestamp
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		local eventTime = eventTimes[index]
		if eventTime > mostRecentEventTime then
			mostRecentEventTime = eventTime
		end

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end

	return mostRecentEventTime
end
exports.getMostRecentEventTime = getMostRecentEventTime

local function computeExpirationTime(lane: Lane, currentTime: number)
	-- // TODO: Expiration heuristic is constant per lane, so could use a map.
	getHighestPriorityLanes(lane)
	local priority = return_highestLanePriority
	if priority >= InputContinuousLanePriority then
		-- // User interactions should expire slightly more quickly.
		-- //
		-- // NOTE: This is set to the corresponding constant as in Scheduler.js. When
		-- // we made it larger, a product metric in www regressed, suggesting there's
		-- // a user interaction that's being starved by a series of synchronous
		-- // updates. If that theory is correct, the proper solution is to fix the
		-- // starvation. However, this scenario supports the idea that expiration
		-- // times are an important safeguard when starvation does happen.
		-- //
		-- // Also note that, in the case of user input specifically, this will soon no
		-- // longer be an issue because we plan to make user input synchronous by
		-- // default (until you enter `startTransition`, of course.)
		-- //
		-- // If weren't planning to make these updates synchronous soon anyway, I
		-- // would probably make this number a configurable parameter.
		return currentTime + 250
	elseif priority >= TransitionPriority then
		return currentTime + 5000
	else
		-- // Anything idle priority or lower should never expire.
		return NoTimestamp
	end
end
exports.computeExpirationTime = computeExpirationTime

local function markStarvedLanesAsExpired(root: FiberRoot, currentTime: number)
	-- // TODO: This gets called every time we yield. We can optimize by storing
	-- // the earliest expiration time on the root. Then use that to quickly bail out
	-- // of this function.

	local pendingLanes = root.pendingLanes
	local suspendedLanes = root.suspendedLanes
	local pingedLanes = root.pingedLanes
	local expirationTimes = root.expirationTimes

	-- // Iterate through the pending lanes and check if we've reached their
	-- // expiration time. If so, we'll assume the update is being starved and mark
	-- // it as expired to force it to finish.
	local lanes = pendingLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		local expirationTime = expirationTimes[index]
		if expirationTime == NoTimestamp then
			-- // Found a pending lane with no expiration time. If it's not suspended, or
			-- // if it's pinged, assume it's CPU-bound. Compute a new expiration time
			-- // using the current time.
			if
				bit32.band(lane, suspendedLanes) == NoLanes
				or bit32.band(lane, pingedLanes) ~= NoLanes
			then
				-- // Assumes timestamps are monotonically increasing.
				expirationTimes[index] = computeExpirationTime(lane, currentTime)
			end
		elseif expirationTime <= currentTime then
			-- // This lane expired
			root.expiredLanes = bit32.bor(root.expiredLanes, lane)
		end

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markStarvedLanesAsExpired = markStarvedLanesAsExpired

-- // This returns the highest priority pending lanes regardless of whether they
-- // are suspended.
local function getHighestPriorityPendingLanes(root: FiberRoot)
	return getHighestPriorityLanes(root.pendingLanes)
end
exports.getHighestPriorityPendingLanes = getHighestPriorityPendingLanes

local function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes
	local everythingButOffscreen =
		bit32.band(root.pendingLanes, bit32.bnot(OffscreenLane))
	if everythingButOffscreen ~= NoLanes then
		return everythingButOffscreen
	end
	if bit32.band(everythingButOffscreen, OffscreenLane) ~= 0 then
		return OffscreenLane
	end
	return NoLanes
end
exports.getLanesToRetrySynchronouslyOnError = getLanesToRetrySynchronouslyOnError

local function returnNextLanesPriority()
	return return_highestLanePriority
end
exports.returnNextLanesPriority = returnNextLanesPriority

local function includesNonIdleWork(lanes: Lanes)
	return bit32.band(lanes, NonIdleLanes) ~= NoLanes
end
exports.includesNonIdleWork = includesNonIdleWork

local function includesOnlyRetries(lanes: Lanes)
	return bit32.band(lanes, RetryLanes) == lanes
end
exports.includesOnlyRetries = includesOnlyRetries

local function includesOnlyTransitions(lanes: Lanes)
	return bit32.band(lanes, TransitionLanes) == lanes
end
exports.includesOnlyTransitions = includesOnlyTransitions

-- deviation: pre-declare pickArbitraryLane to keep ordering
local pickArbitraryLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be a pure function, so that it always returns the same lane for given inputs.
local function findUpdateLane(lanePriority: LanePriority, wipLanes: Lanes): Lane
	if lanePriority == NoLanePriority then
		-- break
	elseif lanePriority == SyncLanePriority then
		return SyncLane
	elseif lanePriority == SyncBatchedLanePriority then
		return SyncBatchedLane
	elseif lanePriority == InputDiscreteLanePriority then
		local lane =
			pickArbitraryLane(bit32.band(InputDiscreteLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // Shift to the next priority level
			return findUpdateLane(InputContinuousLanePriority, wipLanes)
		end
		return lane
	elseif lanePriority == InputContinuousLanePriority then
		local lane =
			pickArbitraryLane(bit32.band(InputContinuousLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // Shift to the next priority level
			return findUpdateLane(DefaultLanePriority, wipLanes)
		end
		return lane
	elseif lanePriority == DefaultLanePriority then
		local lane = pickArbitraryLane(bit32.band(DefaultLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // If all the default lanes are already being worked on, look for a
			-- // lane in the transition range.
			lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(wipLanes)))
			if lane == NoLane then
				-- // All the transition lanes are taken, too. This should be very
				-- // rare, but as a last resort, pick a default lane. This will have
				-- // the effect of interrupting the current work-in-progress render.
				lane = pickArbitraryLane(DefaultLanes)
			end
		end
		return lane
	elseif
		lanePriority == TransitionPriority -- // Should be handled by findTransitionLane instead
		or lanePriority == RetryLanePriority -- // Should be handled by findRetryLane instead
	then
		-- break
	elseif lanePriority == IdleLanePriority then
		local lane = pickArbitraryLane(bit32.band(IdleLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			lane = pickArbitraryLane(IdleLanes)
		end
		return lane
	else
		-- // The remaining priorities are not valid for updates
	end
	invariant(false, "Invalid update priority: %s. This is a bug in React.", lanePriority)
	-- deviation: luau doesn't know that invariant throws, so we error
	error("unreachable")
end
exports.findUpdateLane = findUpdateLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be pure function, so that it always returns the same lane for given inputs.
local function findTransitionLane(wipLanes: Lanes, pendingLanes: Lanes): Lane
	-- // First look for lanes that are completely unclaimed, i.e. have no
	-- // pending work.
	local lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(pendingLanes)))
	if lane == NoLane then
		-- // If all lanes have pending work, look for a lane that isn't currently
		-- // being worked on.
		lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // If everything is being worked on, pick any lane. This has the
			-- // effect of interrupting the current work-in-progress.
			lane = pickArbitraryLane(TransitionLanes)
		end
	end
	return lane
end
exports.findTransitionLane = findTransitionLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be pure function, so that it always returns the same lane for given inputs.
local function findRetryLane(wipLanes: Lanes): Lane
	-- // This is a fork of `findUpdateLane` designed specifically for Suspense
	-- // "retries" — a special update that attempts to flip a Suspense boundary
	-- // from its placeholder state to its primary/resolved state.
	local lane = pickArbitraryLane(bit32.band(RetryLanes, bit32.bnot(wipLanes)))
	if lane == NoLane then
		lane = pickArbitraryLane(RetryLanes)
	end
	return lane
end
exports.findRetryLane = findRetryLane

local function getHighestPriorityLane(lanes: Lanes)
	return bit32.band(lanes, -lanes)
end

function getLowestPriorityLane(lanes: Lanes): Lane
	-- // This finds the most significant non-zero bit.
	local index = 31 - bit32.countlz(lanes)
	if index < 0 then
		return NoLanes
	else
		return bit32.lshift(1, index)
	end
end

function getEqualOrHigherPriorityLanes(lanes: Lanes | Lane): Lanes
	return bit32.lshift(getLowestPriorityLane(lanes), 1) - 1
end

function pickArbitraryLane(lanes: Lanes): Lane
	-- // This wrapper function gets inlined. Only exists so to communicate that it
	-- // doesn't matter which bit is selected; you can pick any bit without
	-- // affecting the algorithms where its used. Here I'm using
	-- // getHighestPriorityLane because it requires the fewest operations.
	return getHighestPriorityLane(lanes)
end
exports.pickArbitraryLane = pickArbitraryLane

function pickArbitraryLaneIndex(lanes: Lanes)
	return 31 - bit32.countlz(lanes)
end

-- ROBLOX performance: all uses have been inlined
-- local function laneToIndex(lane: Lane)
-- 	return pickArbitraryLaneIndex(lane)
-- end

local function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane)
	return bit32.band(a, b) ~= NoLanes
end
exports.includesSomeLane = includesSomeLane

local function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane)
	return bit32.band(set, subset) == subset
end
exports.isSubsetOfLanes = isSubsetOfLanes

local function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes
	return bit32.bor(a, b)
end
exports.mergeLanes = mergeLanes

local function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes
	return bit32.band(set, bit32.bnot(subset))
end
exports.removeLanes = removeLanes

-- // Seems redundant, but it changes the type from a single lane (used for
-- // updates) to a group of lanes (used for flushing work).
local function laneToLanes(lane: Lane): Lanes
	return lane
end
exports.laneToLanes = laneToLanes

local function higherPriorityLane(a: Lane, b: Lane)
	-- // This works because the bit ranges decrease in priority as you go left.
	if a ~= NoLane and b ~= NoLane then
		if a < b then
			return a
		end
		return b
	else
		if a ~= NoLane then
			return a
		end
		return b
	end
end
exports.higherPriorityLane = higherPriorityLane

local function higherLanePriority(a: LanePriority, b: LanePriority): LanePriority
	if a ~= NoLanePriority and a > b then
		return a
	else
		return b
	end
end
exports.higherLanePriority = higherLanePriority

-- deviation: luau does not support generic functions yet
-- local function createLaneMap<T>(initial: T): LaneMap<T>
local function createLaneMap(initial): LaneMap<any>
	-- // Intentionally pushing one by one.
	-- // https://v8.dev/blog/elements-kinds#avoid-creating-holes
	-- ROBLOX performance: manually unroll this loop so the table creation is a one-shot
	--for i = 0, TotalLanes do
	local laneMap = {
		[0] = initial,
		[1] = initial,
		[2] = initial,
		[3] = initial,
		[4] = initial,
		[5] = initial,
		[6] = initial,
		[7] = initial,
		[8] = initial,
		[9] = initial,
		[10] = initial,
		[11] = initial,
		[12] = initial,
		[13] = initial,
		[14] = initial,
		[15] = initial,
		[16] = initial,
		[17] = initial,
		[18] = initial,
		[19] = initial,
		[20] = initial,
		[21] = initial,
		[22] = initial,
		[23] = initial,
		[24] = initial,
		[25] = initial,
		[26] = initial,
		[27] = initial,
		[28] = initial,
		[29] = initial,
		[30] = initial,
		[31] = initial,
		-- ROBLOX TODO: must be updated when TotalLanes is updated!
	}
	return laneMap
end
exports.createLaneMap = createLaneMap

local function markRootUpdated(root: FiberRoot, updateLane: Lane, eventTime: number)
	root.pendingLanes = bit32.bor(root.pendingLanes, updateLane)

	-- // TODO: Theoretically, any update to any lane can unblock any other lane. But
	-- // it's not practical to try every single possible combination. We need a
	-- // heuristic to decide which lanes to attempt to render, and in which batches.
	-- // For now, we use the same heuristic as in the old ExpirationTimes model:
	-- // retry any lane at equal or lower priority, but don't try updates at higher
	-- // priority without also including the lower priority updates. This works well
	-- // when considering updates across different priority levels, but isn't
	-- // sufficient for updates within the same priority, since we want to treat
	-- // those updates as parallel.

	-- // Unsuspend any update at equal or lower priority.
	local higherPriorityLanes = updateLane - 1 -- // Turns 0b1000 into 0b0111

	root.suspendedLanes = bit32.band(root.suspendedLanes, higherPriorityLanes)
	root.pingedLanes = bit32.band(root.pingedLanes, higherPriorityLanes)

	local eventTimes = root.eventTimes
	-- ROBLOX performance: inline laneToIndex in hot path
	-- local index = laneToIndex(updateLane)
	local index = 31 - bit32.countlz(updateLane)
	-- // We can always overwrite an existing timestamp because we prefer the most
	-- // recent event, and we assume time is monotonically increasing.
	eventTimes[index] = eventTime
end
exports.markRootUpdated = markRootUpdated

local function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes)
	root.suspendedLanes = bit32.bor(root.suspendedLanes, suspendedLanes)
	root.pingedLanes = bit32.band(root.pingedLanes, bit32.bnot(suspendedLanes))

	-- // The suspended lanes are no longer CPU-bound. Clear their expiration times.
	local expirationTimes = root.expirationTimes
	local lanes = suspendedLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		expirationTimes[index] = NoTimestamp

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootSuspended = markRootSuspended

local function markRootPinged(root: FiberRoot, pingedLanes: Lanes, eventTime: number)
	root.pingedLanes =
		bit32.bor(root.pingedLanes, bit32.band(root.suspendedLanes, pingedLanes))
end
exports.markRootPinged = markRootPinged

local function markRootExpired(root: FiberRoot, expiredLanes: Lanes)
	root.expiredLanes =
		bit32.bor(root.expiredLanes, bit32.band(expiredLanes, root.pendingLanes))
end
exports.markRootExpired = markRootExpired

local function markDiscreteUpdatesExpired(root: FiberRoot)
	root.expiredLanes =
		bit32.bor(root.expiredLanes, bit32.band(InputDiscreteLanes, root.pendingLanes))
end
exports.markDiscreteUpdatesExpired = markDiscreteUpdatesExpired

local function hasDiscreteLanes(lanes: Lanes)
	return bit32.band(lanes, InputDiscreteLanes) ~= NoLanes
end
exports.hasDiscreteLanes = hasDiscreteLanes

local function markRootMutableRead(root: FiberRoot, updateLane: Lane)
	root.mutableReadLanes =
		bit32.bor(root.mutableReadLanes, bit32.band(updateLane, root.pendingLanes))
end
exports.markRootMutableRead = markRootMutableRead

local function markRootFinished(root: FiberRoot, remainingLanes: Lanes)
	local noLongerPendingLanes = bit32.band(root.pendingLanes, bit32.bnot(remainingLanes))

	root.pendingLanes = remainingLanes

	-- // Let's try everything again
	root.suspendedLanes = 0
	root.pingedLanes = 0

	root.expiredLanes = bit32.band(root.expiredLanes, remainingLanes)
	root.mutableReadLanes = bit32.band(root.mutableReadLanes, remainingLanes)

	root.entangledLanes = bit32.band(root.entangledLanes, remainingLanes)

	local entanglements = root.entanglements
	local eventTimes = root.eventTimes
	local expirationTimes = root.expirationTimes

	-- // Clear the lanes that no longer have pending work
	local lanes = noLongerPendingLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		entanglements[index] = NoLanes
		eventTimes[index] = NoTimestamp
		expirationTimes[index] = NoTimestamp

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootFinished = markRootFinished

local function markRootEntangled(root: FiberRoot, entangledLanes: Lanes)
	root.entangledLanes = bit32.bor(root.entangledLanes, entangledLanes)

	local entanglements = root.entanglements
	local lanes = entangledLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		entanglements[index] = bit32.bor(entanglements[index], entangledLanes)

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootEntangled = markRootEntangled

local function getBumpedLaneForHydration(root: FiberRoot, renderLanes: Lanes): Lane
	getHighestPriorityLanes(renderLanes)
	local highestLanePriority = return_highestLanePriority

	local lane

	if
		highestLanePriority == SyncLanePriority
		or highestLanePriority == SyncBatchedLanePriority
	then
		lane = NoLane
	elseif
		highestLanePriority == InputDiscreteHydrationLanePriority
		or highestLanePriority == InputDiscreteLanePriority
	then
		lane = InputDiscreteHydrationLane
	elseif
		highestLanePriority == InputContinuousHydrationLanePriority
		or highestLanePriority == InputContinuousLanePriority
	then
		lane = InputContinuousHydrationLane
	elseif
		highestLanePriority == DefaultHydrationLanePriority
		or highestLanePriority == DefaultLanePriority
	then
		lane = DefaultHydrationLane
	elseif
		highestLanePriority == TransitionHydrationPriority
		or highestLanePriority == TransitionPriority
	then
		lane = TransitionHydrationLane
	elseif highestLanePriority == RetryLanePriority then
		-- // Shouldn't be reachable under normal circumstances, so there's no
		-- // dedicated lane for retry priority. Use the one for long transitions.
		lane = TransitionHydrationLane
	elseif highestLanePriority == SelectiveHydrationLanePriority then
		lane = SelectiveHydrationLane
	elseif
		highestLanePriority == IdleHydrationLanePriority
		or highestLanePriority == IdleLanePriority
	then
		lane = IdleHydrationLane
	elseif
		highestLanePriority == OffscreenLanePriority
		or highestLanePriority == NoLanePriority
	then
		lane = NoLane
	else
		invariant(false, "Invalid lane: %s. This is a bug in React.", tostring(lane))
	end

	-- // Check if the lane we chose is suspended. If so, that indicates that we
	-- // already attempted and failed to hydrate at that level. Also check if we're
	-- // already rendering that lane, which is rare but could happen.
	if bit32.band(lane, bit32.bor(root.suspendedLanes, renderLanes)) ~= NoLane then
		-- // Give up trying to hydrate and fall back to client render.
		return NoLane
	end

	return lane
end
exports.getBumpedLaneForHydration = getBumpedLaneForHydration

return exports ]]
cX.Children._42fa8f47378d605342103b3c997d34fa=dE
local dF

local dG={ClassName="ModuleScript",Children={},Properties={}}
dG.Name="ReactFiberLazyComponent.new"
dG.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberLazyComponent.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

type Object = { [any]: any }

local function resolveDefaultProps(Component: any, baseProps: Object): Object
	-- ROBLOX deviation: check if type is table before checking defaultProps to prevent non-table index
	if Component and typeof(Component) == "table" and Component.defaultProps then
		-- Resolve default props. Taken from ReactElement
		-- ROBLOX FIXME Luau: hard cast to object until we can model this better in Luau. avoids Expected type table, got 'Object & any & any & { [any]: any }' instead
		local props = table.clone(baseProps) :: Object
		local defaultProps = Component.defaultProps
		for propName, _ in defaultProps do
			if props[propName] == nil then
				props[propName] = defaultProps[propName]
			end
		end
		return props
	end
	return baseProps
end

return {
	resolveDefaultProps = resolveDefaultProps,
} ]]
cX.Children._12c3cc7bbdef35f4ec21e0fea3c06277=dG
local dH

local dI={ClassName="ModuleScript",Children={},Properties={}}
dI.Name="ReactFiberNewContext.new"
dI.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/1eaafc9ade46ba708b2361b324dd907d019e3939/packages/react-reconciler/src/ReactFiberNewContext.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number
local Error = LuauPolyfill.Error

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
type ReactContext<T> = ReactTypes.ReactContext<T>
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type ContextDependency<T> = ReactInternalTypes.ContextDependency<T>

local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type SharedQueue<T> = ReactUpdateQueue.SharedQueue<T>

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local isPrimaryRenderer = ReactFiberHostConfig.isPrimaryRenderer
local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop
local MAX_SIGNED_31_BIT_INT = require(script.Parent.MaxInts).MAX_SIGNED_31_BIT_INT
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ContextProvider = ReactWorkTags.ContextProvider
local ClassComponent = ReactWorkTags.ClassComponent
-- local DehydratedFragment = ReactWorkTags.DehydratedFragment
local NoLanes = ReactFiberLane.NoLanes
local NoTimestamp = ReactFiberLane.NoTimestamp
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane

local is = require(Packages.Shared).objectIs
local createUpdate = ReactUpdateQueue.createUpdate
local ForceUpdate = ReactUpdateQueue.ForceUpdate
-- deviation: passed in as an arg to eliminate cycle
-- local markWorkInProgressReceivedUpdate = require(script.Parent["ReactFiberBeginWork.new"]).markWorkInProgressReceivedUpdate
-- local enableSuspenseServerRenderer = require(Packages.Shared).ReactFeatureFlags.enableSuspenseServerRenderer

local exports = {}

local valueCursor: StackCursor<any> = createCursor(nil)

local rendererSigil
if _G.__DEV__ then
	-- Use this to detect multiple renderers using the same context
	rendererSigil = {}
end

local currentlyRenderingFiber: Fiber | nil = nil
local lastContextDependency: ContextDependency<any> | nil = nil
local lastContextWithAllBitsObserved: ReactContext<any> | nil = nil

local isDisallowedContextReadInDEV: boolean = false

exports.resetContextDependencies = function(): ()
	-- This is called right before React yields execution, to ensure `readContext`
	-- cannot be called outside the render phase.
	currentlyRenderingFiber = nil
	lastContextDependency = nil
	lastContextWithAllBitsObserved = nil
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = false
	end
end

exports.enterDisallowedContextReadInDEV = function(): ()
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = true
	end
end

exports.exitDisallowedContextReadInDEV = function(): ()
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = false
	end
end

exports.pushProvider = function<T>(providerFiber: Fiber, nextValue: T): ()
	local context: ReactContext<T> = providerFiber.type._context

	if isPrimaryRenderer then
		push(valueCursor, context._currentValue, providerFiber)

		context._currentValue = nextValue
		if _G.__DEV__ then
			if
				context._currentRenderer ~= nil
				and context._currentRenderer ~= rendererSigil
			then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same context provider. This is currently unsupported."
				)
			end
			context._currentRenderer = rendererSigil
		end
	else
		push(valueCursor, context._currentValue2, providerFiber)

		context._currentValue2 = nextValue
		if _G.__DEV__ then
			if
				context._currentRenderer2 ~= nil
				and context._currentRenderer2 ~= rendererSigil
			then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same context provider. This is currently unsupported."
				)
			end
			context._currentRenderer2 = rendererSigil
		end
	end
end

exports.popProvider = function(providerFiber: Fiber)
	local currentValue = valueCursor.current

	pop(valueCursor, providerFiber)

	local context: ReactContext<any> = providerFiber.type._context
	if isPrimaryRenderer then
		context._currentValue = currentValue
	else
		context._currentValue2 = currentValue
	end
end

exports.calculateChangedBits =
	function<T>(context: ReactContext<T>, newValue: T, oldValue: T)
		if is(oldValue, newValue) then
			-- No change
			return 0
		else
			-- deviation: unravel ternary that's unsafe to translate
			local changedBits = MAX_SIGNED_31_BIT_INT
			if typeof(context._calculateChangedBits) == "function" then
				changedBits = context._calculateChangedBits(oldValue, newValue)
			end

			-- ROBLOX performance: eliminate nice-to-have compare in hot path that's removed in React 18
			-- if _G.__DEV__ then
			--   if bit32.band(changedBits, MAX_SIGNED_31_BIT_INT) ~= changedBits then
			--     console.error(
			--       "calculateChangedBits: Expected the return value to be a " ..
			--         "31-bit integer. Instead received: %s",
			--       changedBits
			--     )
			--   end
			-- end
			-- deviation: JS does a bitwise OR with 0 presumably to floor the value and
			-- coerce to an int; we just use math.floor
			return math.floor(changedBits)
		end
	end

exports.scheduleWorkOnParentPath = function(parent: Fiber | nil, renderLanes: Lanes)
	-- Update the child lanes of all the ancestors, including the alternates.
	local node = parent
	while node ~= nil do
		local alternate = node.alternate
		if not isSubsetOfLanes(node.childLanes, renderLanes) then
			node.childLanes = mergeLanes(node.childLanes, renderLanes)
			if alternate ~= nil then
				alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes)
			end
		elseif
			alternate ~= nil and not isSubsetOfLanes(alternate.childLanes, renderLanes)
		then
			alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes)
		else
			-- Neither alternate was updated, which means the rest of the
			-- ancestor path already has sufficient priority.
			break
		end
		node = node.return_
	end
end

exports.propagateContextChange = function<T>(
	workInProgress: Fiber,
	context: ReactContext<T>,
	changedBits: number,
	renderLanes: Lanes
): ()
	local fiber = workInProgress.child
	if fiber ~= nil then
		-- Set the return pointer of the child to the work-in-progress fiber.
		fiber.return_ = workInProgress
	end
	while fiber ~= nil do
		local nextFiber

		-- Visit this fiber.
		local list = fiber.dependencies
		if list ~= nil then
			nextFiber = fiber.child

			local dependency = list.firstContext
			while dependency ~= nil do
				-- Check if the context matches.
				if
					dependency.context == context
					-- ROBLOX performance: unstable observedBits is removed in React 18
					and bit32.band(dependency.observedBits, changedBits) ~= 0
				then
					-- Match! Schedule an update on this fiber.

					if fiber.tag == ClassComponent then
						-- Schedule a force update on the work-in-progress.
						local update =
							createUpdate(NoTimestamp, pickArbitraryLane(renderLanes))
						update.tag = ForceUpdate
						-- TODO: Because we don't have a work-in-progress, this will add the
						-- update to the current fiber, too, which means it will persist even if
						-- this render is thrown away. Since it's a race condition, not sure it's
						-- worth fixing.

						-- Inlined `enqueueUpdate` to remove interleaved update check
						local updateQueue = fiber.updateQueue
						if updateQueue == nil then
						-- Only occurs if the fiber has been unmounted.
						else
							local sharedQueue: SharedQueue<any> = (updateQueue :: any).shared
							local pending = sharedQueue.pending
							if pending == nil then
								-- This is the first update. Create a circular list.
								update.next = update
							else
								update.next = pending.next
								pending.next = update
							end
							sharedQueue.pending = update
						end
					end

					-- ROBLOX performance: inline mergeLanes(fiber.lanes, renderLanes)
					fiber.lanes = bit32.bor(fiber.lanes, renderLanes)
					local alternate = fiber.alternate
					if alternate ~= nil then
						-- ROBLOX performance: inline mergeLanes(alternate.lanes, renderLanes)
						alternate.lanes = bit32.bor(alternate.lanes, renderLanes)
					end
					exports.scheduleWorkOnParentPath(fiber.return_, renderLanes)

					-- Mark the updated lanes on the list, too.
					-- ROBLOX performance: inline mergeLanes(list.lanes, renderLanes)
					list.lanes = bit32.bor(list.lanes, renderLanes)

					-- Since we already found a match, we can stop traversing the
					-- dependency list.
					break
				end
				dependency = dependency.next
			end
		elseif fiber.tag == ContextProvider then
			-- Don't scan deeper if this is a matching provider
			if fiber.type == workInProgress.type then
				nextFiber = nil
			else
				nextFiber = fiber.child
			end
		-- ROBLOX performance: eliminate always-false compare in tab switching hot path
		-- elseif
		--   enableSuspenseServerRenderer and
		--   fiber.tag == DehydratedFragment
		-- then
		--   -- If a dehydrated suspense boundary is in this subtree, we don't know
		--   -- if it will have any context consumers in it. The best we can do is
		--   -- mark it as having updates.
		--   local parentSuspense = fiber.return_
		--   if parentSuspense == nil then
		--     error("We just came from a parent so we must have had a parent. This is a bug in React.")
		--   end
		--   parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes)
		--   local alternate = parentSuspense.alternate
		--   if alternate ~= nil then
		--     alternate.lanes = mergeLanes(alternate.lanes, renderLanes)
		--   end
		--   -- This is intentionally passing this fiber as the parent
		--   -- because we want to schedule this fiber as having work
		--   -- on its children. We'll use the childLanes on
		--   -- this fiber to indicate that a context has changed.
		--   exports.scheduleWorkOnParentPath(parentSuspense, renderLanes)
		--   nextFiber = fiber.sibling
		else
			-- Traverse down.
			nextFiber = fiber.child
		end

		if nextFiber ~= nil then
			-- Set the return pointer of the child to the work-in-progress fiber.
			nextFiber.return_ = fiber
		else
			-- No child. Traverse to next sibling.
			nextFiber = fiber
			while nextFiber ~= nil do
				if nextFiber == workInProgress then
					-- We're back to the root of this subtree. Exit.
					nextFiber = nil
					break
				end
				local sibling = nextFiber.sibling
				if sibling ~= nil then
					-- Set the return pointer of the sibling to the work-in-progress fiber.
					sibling.return_ = nextFiber.return_
					nextFiber = sibling
					break
				end
				-- No more siblings. Traverse up.
				nextFiber = nextFiber.return_
			end
		end
		fiber = nextFiber
	end
end

-- deviation: third argument added to eliminate cycle
exports.prepareToReadContext = function(
	workInProgress: Fiber,
	renderLanes: Lanes,
	markWorkInProgressReceivedUpdate: () -> ()
): ()
	currentlyRenderingFiber = workInProgress
	lastContextDependency = nil
	lastContextWithAllBitsObserved = nil

	local dependencies = workInProgress.dependencies
	if dependencies ~= nil then
		local firstContext = dependencies.firstContext
		if firstContext ~= nil then
			if includesSomeLane(dependencies.lanes, renderLanes) then
				-- Context list has a pending update. Mark that this fiber performed work.
				markWorkInProgressReceivedUpdate()
			end
			-- Reset the work-in-progress list
			dependencies.firstContext = nil
		end
	end
end

exports.readContext =
	function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
		if _G.__DEV__ then
			-- This warning would fire if you read context inside a Hook like useMemo.
			-- Unlike the class check below, it's not enforced in production for perf.
			if isDisallowedContextReadInDEV then
				console.error(
					"Context can only be read while React is rendering. "
						.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
						.. "In function components, you can read it directly in the function body, but not "
						.. "inside Hooks like useReducer() or useMemo()."
				)
			end
		end

		if lastContextWithAllBitsObserved == context then
		-- Nothing to do. We already observe everything in this context.
		elseif observedBits == false or observedBits == 0 then
		-- Do not observe any updates.
		else
			local resolvedObservedBits -- Avoid deopting on observable arguments or heterogeneous types.
			if
				typeof(observedBits) ~= "number"
				or observedBits == Number.MAX_SAFE_INTEGER
			then
				-- Observe all updates.
				-- lastContextWithAllBitsObserved = ((context: any): ReactContext<mixed>)
				lastContextWithAllBitsObserved = context
				resolvedObservedBits = Number.MAX_SAFE_INTEGER
			else
				resolvedObservedBits = observedBits
			end

			local contextItem = {
				-- context: ((context: any): ReactContext<mixed>),
				context = context,
				observedBits = resolvedObservedBits,
				next = nil,
			}

			if lastContextDependency == nil then
				if currentlyRenderingFiber == nil then
					error(
						Error.new(
							"Context can only be read while React is rendering. "
								.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
								.. "In function components, you can read it directly in the function body, but not "
								.. "inside Hooks like useReducer() or useMemo()."
						)
					)
				end

				-- This is the first dependency for this component. Create a new list.
				lastContextDependency = contextItem;
				(currentlyRenderingFiber :: Fiber).dependencies = {
					lanes = NoLanes,
					firstContext = contextItem,
					responders = nil,
				}
			else
				-- Append a new context item.
				(lastContextDependency :: any).next = contextItem
				lastContextDependency = contextItem
			end
		end
		return if isPrimaryRenderer then context._currentValue else context._currentValue2
	end

return exports ]]
cX.Children._6c47e0e0abf3198855bdc0e3c2e98a54=dI
local dJ

local dK={ClassName="ModuleScript",Children={},Properties={}}
dK.Name="ReactFiberOffscreenComponent"
dK.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberOffscreenComponent.js
--!strict
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local ReactFiberLanes = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLanes.Lanes

export type OffscreenProps = {
	-- TODO: Pick an API before exposing the Offscreen type. I've chosen an enum
	-- for now, since we might have multiple variants. For example, hiding the
	-- content without changing the layout.
	--
	-- Default mode is visible. Kind of a weird default for a component
	-- called "Offscreen." Possible alt: <Visibility />?
	mode: string | nil,
	children: ReactNodeList,
}

-- We use the existence of the state object as an indicator that the component
-- is hidden.
export type OffscreenState = {
	-- TODO: This doesn't do anything, yet. It's always NoLanes. But eventually it
	-- will represent the pending work that must be included in the render in
	-- order to unhide the component.
	baseLanes: Lanes,
}

return {} ]]
cX.Children._1d6ed3a0de038ed37280ae9a6d4536aa=dK
local dL

local dM={ClassName="ModuleScript",Children={},Properties={}}
dM.Name="ReactFiberReconciler"
dM.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/faa697f4f9afe9f1c98e315b2a9e70f5a74a7a74/packages/react-reconciler/src/ReactFiberReconciler.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

-- deviation: old version of reconciler not ported
return require(script.Parent["ReactFiberReconciler.new"]) ]]
cX.Children._577bcdfbea1c8712e98bd2c682c20265=dM
local dN

local dO={ClassName="ModuleScript",Children={},Properties={}}
dO.Name="ReactFiberReconciler.new"
dO.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/50d9451f320a9aaf94304209193562cc385567d8/packages/react-reconciler/src/ReactFiberReconciler.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local flowtypes = require(Packages.Shared)
type React_Component<Props, State> = flowtypes.React_Component<Props, State>
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Function = (...any) -> ...any

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

type Object = { [string]: any }
type Array<T> = { [number]: T }

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type SuspenseHydrationCallbacks = ReactInternalTypes.SuspenseHydrationCallbacks
type FiberRoot = ReactInternalTypes.FiberRoot

local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type TextInstance = ReactFiberHostConfig.TextInstance
type Container = ReactFiberHostConfig.Container
type PublicInstance = ReactFiberHostConfig.PublicInstance
type RendererInspectionConfig = ReactFiberHostConfig.RendererInspectionConfig

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
type LanePriority = ReactFiberLane.LanePriority
local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactFiberTreeReflection = require(script.Parent.ReactFiberTreeReflection)
local findCurrentHostFiber = ReactFiberTreeReflection.findCurrentHostFiber
local findCurrentHostFiberWithNoPortals =
	ReactFiberTreeReflection.findCurrentHostFiberWithNoPortals
local getInstance = require(Packages.Shared).ReactInstanceMap.get
local HostComponent = ReactWorkTags.HostComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local getComponentName = require(Packages.Shared).getComponentName
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local enableSchedulingProfiler =
	require(Packages.Shared).ReactFeatureFlags.enableSchedulingProfiler
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local getPublicInstance = require(script.Parent.ReactFiberHostConfig).getPublicInstance
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local findCurrentUnmaskedContext = ReactFiberContext.findCurrentUnmaskedContext
local processChildContext = ReactFiberContext.processChildContext
local emptyContextObject = ReactFiberContext.emptyContextObject
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local ReactFiberRoot = require(script.Parent["ReactFiberRoot.new"])
local createFiberRoot = ReactFiberRoot.createFiberRoot
local ReactFiberDevToolsHook = require(script.Parent["ReactFiberDevToolsHook.new"])
local injectInternals = ReactFiberDevToolsHook.injectInternals
local onScheduleRoot = ReactFiberDevToolsHook.onScheduleRoot
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local requestEventTime = ReactFiberWorkLoop.requestEventTime
local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local flushRoot = ReactFiberWorkLoop.flushRoot
local batchedEventUpdates = ReactFiberWorkLoop.batchedEventUpdates
local batchedUpdates = ReactFiberWorkLoop.batchedUpdates
local unbatchedUpdates = ReactFiberWorkLoop.unbatchedUpdates
local flushSync = ReactFiberWorkLoop.flushSync
local flushControlled = ReactFiberWorkLoop.flushControlled
local deferredUpdates = ReactFiberWorkLoop.deferredUpdates
local discreteUpdates = ReactFiberWorkLoop.discreteUpdates
local flushDiscreteUpdates = ReactFiberWorkLoop.flushDiscreteUpdates
local flushPassiveEffects = ReactFiberWorkLoop.flushPassiveEffects
local warnIfNotScopedWithMatchingAct = ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct
local warnIfUnmockedScheduler = ReactFiberWorkLoop.warnIfUnmockedScheduler
local IsThisRendererActing = ReactFiberWorkLoop.IsThisRendererActing
local act = ReactFiberWorkLoop.act :: (() -> ()) -> ()
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local createUpdate = ReactUpdateQueue.createUpdate
local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local ReactCurrentFiberIsRendering = ReactCurrentFiber.isRendering
-- deviation: this property would be captured as values instead of bound
-- local ReactCurrentFiber.current = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local StrictMode = ReactTypeOfMode.StrictMode
local SyncLane = ReactFiberLane.SyncLane
local InputDiscreteHydrationLane = ReactFiberLane.InputDiscreteHydrationLane
local SelectiveHydrationLane = ReactFiberLane.SelectiveHydrationLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local getHighestPriorityPendingLanes = ReactFiberLane.getHighestPriorityPendingLanes
local higherPriorityLane = ReactFiberLane.higherPriorityLane
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
-- local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
-- local scheduleRefresh = ReactFiberHotReloading.scheduleRefresh
-- local scheduleRoot = ReactFiberHotReloading.scheduleRoot
-- local setRefreshHandler = ReactFiberHotReloading.setRefreshHandler
-- local findHostInstancesForRefresh = ReactFiberHotReloading.findHostInstancesForRefresh
local markRenderScheduled = require(script.Parent.SchedulingProfiler).markRenderScheduled

local exports = {}

-- ROBLOX deviation: explicitly export internal type definitions used by the noop and test renderers
exports.ReactRootTags = ReactRootTags
-- ROBLOX deviation: explicitly export internal type definitions used by the test renderer
exports.ReactWorkTags = ReactWorkTags

-- ROBLOX deviation: explicitly export internal type definitions used by the dev tools
exports.ReactTypeOfMode = ReactTypeOfMode
exports.ReactFiberFlags = ReactFiberFlags
exports.getNearestMountedFiber = ReactFiberTreeReflection.getNearestMountedFiber
exports.findCurrentFiberUsingSlowPath =
	ReactFiberTreeReflection.findCurrentFiberUsingSlowPath

-- exports.registerMutableSourceForHydration = require(script.Parent["ReactMutableSource.new"]).registerMutableSourceForHydration
exports.createPortal = require(script.Parent.ReactPortal).createPortal
-- local ReactTestSelectors = require(script.Parent.ReactTestSelectors)
-- exports.createComponentSelector = ReactTestSelectors.createComponentSelector
-- ROBLOX FIXME: Should we deviate and fix this typo?
-- exports.createHasPsuedoClassSelector = ReactTestSelectors.createHasPsuedoClassSelector
-- exports.createRoleSelector = ReactTestSelectors.createRoleSelector
-- exports.createTestNameSelector = ReactTestSelectors.createTestNameSelector
-- exports.createTextSelector = ReactTestSelectors.createTextSelector
-- exports.getFindAllNodesFailureDescription = ReactTestSelectors.getFindAllNodesFailureDescription
-- exports.findAllNodes = ReactTestSelectors.findAllNodes
-- exports.findBoundingRects = ReactTestSelectors.findBoundingRects
-- exports.focusWithin = ReactTestSelectors.focusWithin
-- exports.observeVisibleRects = ReactTestSelectors.observeVisibleRects

type OpaqueRoot = FiberRoot

-- 0 is PROD, 1 is DEV.
-- Might add PROFILE later.
type BundleType = number

type DevToolsConfig = {
	bundleType: BundleType,
	version: string,
	rendererPackageName: string,
	-- Note: this actually *does* depend on Fiber internal fields.
	-- Used by "inspect clicked DOM element" in React DevTools.
	findFiberByHostInstance: ((Instance | TextInstance) -> Fiber)?,
	rendererConfig: RendererInspectionConfig?,
}

local didWarnAboutNestedUpdates
local didWarnAboutFindNodeInStrictMode

if __DEV__ then
	didWarnAboutNestedUpdates = false
	didWarnAboutFindNodeInStrictMode = {}
end

local function getContextForSubtree(parentComponent: any?): Object
	if not parentComponent then
		return emptyContextObject
	end

	local fiber = getInstance(parentComponent)
	local parentContext = findCurrentUnmaskedContext(fiber)

	if fiber.tag == ClassComponent then
		local Component = fiber.type
		if isLegacyContextProvider(Component) then
			return processChildContext(fiber, Component, parentContext)
		end
	end

	return parentContext
end

local function findHostInstance(component: Object): PublicInstance | nil
	local fiber = getInstance(component)
	if fiber == nil then
		if typeof(component.render) == "function" then
			invariant(false, "Unable to find node on an unmounted component.")
		else
			invariant(
				false,
				"Argument appears to not be a ReactComponent. Keys: %s",
				-- ROBLOX deviation: explicitly coerce the array of strings into a string
				table.concat(Object.keys(component))
			)
		end
	end
	local hostFiber = findCurrentHostFiber(fiber)
	if hostFiber == nil then
		return nil
	end
	return hostFiber.stateNode
end

local function findHostInstanceWithWarning(
	component: Object,
	methodName: string
): PublicInstance | nil
	if __DEV__ then
		local fiber = getInstance(component)
		if fiber == nil then
			if typeof(component.render) == "function" then
				invariant(false, "Unable to find node on an unmounted component.")
			else
				invariant(
					false,
					"Argument appears to not be a ReactComponent. Keys: %s",
					-- ROBLOX deviation: explicitly convert array into string
					table.concat(Object.keys(component))
				)
			end
		end
		local hostFiber = findCurrentHostFiber(fiber)
		if hostFiber == nil then
			return nil
		end
		if bit32.band(hostFiber.mode, StrictMode) ~= 0 then
			local componentName = getComponentName(fiber.type) or "Component"
			if not didWarnAboutFindNodeInStrictMode[componentName] then
				didWarnAboutFindNodeInStrictMode[componentName] = true

				local previousFiber = ReactCurrentFiber.current
				local ok, result = xpcall(function()
					setCurrentDebugFiberInDEV(hostFiber)
					if bit32.band(fiber.mode, StrictMode) ~= 0 then
						console.error(
							"%s is deprecated in StrictMode. "
								.. "%s was passed an instance of %s which is inside StrictMode. "
								.. "Instead, add a ref directly to the element you want to reference. "
								.. "Learn more about using refs safely here: "
								.. "https://reactjs.org/link/strict-mode-find-node",
							methodName,
							methodName,
							componentName
						)
					else
						console.error(
							"%s is deprecated in StrictMode. "
								.. "%s was passed an instance of %s which renders StrictMode children. "
								.. "Instead, add a ref directly to the element you want to reference. "
								.. "Learn more about using refs safely here: "
								.. "https://reactjs.org/link/strict-mode-find-node",
							methodName,
							methodName,
							componentName
						)
					end
				end, describeError)

				-- Ideally this should reset to previous but this shouldn't be called in
				-- render and there's another warning for that anyway.
				if previousFiber then
					setCurrentDebugFiberInDEV(previousFiber)
				else
					resetCurrentDebugFiberInDEV()
				end

				if not ok then
					error(result)
				end
			end
		end
		return hostFiber.stateNode
	end
	return findHostInstance(component)
end

exports.createContainer = function(
	containerInfo: Container,
	tag: RootTag,
	hydrate: boolean,
	hydrationCallbacks: nil | SuspenseHydrationCallbacks
): OpaqueRoot
	return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)
end

exports.updateContainer = function(
	element: ReactNodeList,
	container: OpaqueRoot,
	parentComponent,
	callback: Function?
): Lane
	if __DEV__ then
		onScheduleRoot(container, element)
	end
	local current = container.current
	local eventTime = requestEventTime()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ (no jest global)
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if _G.__TESTEZ_RUNNING_TEST__ then
			warnIfUnmockedScheduler(current)
			warnIfNotScopedWithMatchingAct(current)
		end
	end
	local lane = requestUpdateLane(current)

	if enableSchedulingProfiler then
		markRenderScheduled(lane)
	end

	local context = getContextForSubtree(parentComponent)
	if container.context == nil then
		container.context = context
	else
		container.pendingContext = context
	end

	if __DEV__ then
		if
			ReactCurrentFiberIsRendering
			and ReactCurrentFiber.current ~= nil
			and not didWarnAboutNestedUpdates
		then
			didWarnAboutNestedUpdates = true
			console.error(
				"Render methods should be a pure function of props and state; "
					.. "triggering nested component updates from render is not allowed. "
					.. "If necessary, trigger nested updates in componentDidUpdate.\n\n"
					.. "Check the render method of %s.",
				getComponentName((ReactCurrentFiber.current :: any).type) or "Unknown"
			)
		end
	end

	local update = createUpdate(eventTime, lane)
	-- deviation: We need to set element to a placeholder so that it gets
	-- removed from previous state when merging tables
	if element == nil then
		element = Object.None
	end
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	update.payload = {
		element = element,
	}

	-- deviation: no undefined, so not needed
	-- callback = callback == undefined ? nil : callback
	if callback ~= nil then
		if __DEV__ then
			if typeof(callback) ~= "function" then
				console.error(
					"render(...): Expected the last optional `callback` argument to be a "
						.. "function. Instead received: %s.",
					tostring(callback)
				)
			end
		end
		update.callback = callback
	end

	enqueueUpdate(current, update)
	scheduleUpdateOnFiber(current, lane, eventTime)

	return lane
end

-- FIXME: WIP
exports.batchedEventUpdates = batchedEventUpdates
exports.batchedUpdates = batchedUpdates
exports.unbatchedUpdates = unbatchedUpdates
exports.deferredUpdates = deferredUpdates
exports.discreteUpdates = discreteUpdates
exports.flushDiscreteUpdates = flushDiscreteUpdates
exports.flushControlled = flushControlled
exports.flushSync = flushSync
exports.flushPassiveEffects = flushPassiveEffects
exports.IsThisRendererActing = IsThisRendererActing
exports.act = act

exports.getPublicRootInstance =
	function(container: OpaqueRoot): React_Component<any, any> | PublicInstance | nil
		local containerFiber = container.current
		if not containerFiber.child then
			return nil
		end
		if containerFiber.child.tag == HostComponent then
			return getPublicInstance(containerFiber.child.stateNode)
		else
			return containerFiber.child.stateNode
		end
	end

-- deviation: Declare function ahead of use
local markRetryLaneIfNotHydrated

exports.attemptSynchronousHydration = function(fiber: Fiber)
	if fiber.tag == HostRoot then
		local root: FiberRoot = fiber.stateNode
		if root.hydrate then
			-- Flush the first scheduled "update".
			local lanes = getHighestPriorityPendingLanes(root)
			flushRoot(root, lanes)
		end
	elseif fiber.tag == SuspenseComponent then
		local eventTime = requestEventTime()
		flushSync(function()
			return scheduleUpdateOnFiber(fiber, SyncLane, eventTime)
		end)
		-- If we're still blocked after this, we need to increase
		-- the priority of any promises resolving within this
		-- boundary so that they next attempt also has higher pri.
		local retryLane = InputDiscreteHydrationLane
		markRetryLaneIfNotHydrated(fiber, retryLane)
	end
end

local function markRetryLaneImpl(fiber: Fiber, retryLane: Lane)
	local suspenseState: SuspenseState? = fiber.memoizedState
	if suspenseState then
		if suspenseState ~= nil and suspenseState.dehydrated ~= nil then
			suspenseState.retryLane =
				higherPriorityLane(suspenseState.retryLane, retryLane)
		end
	end
end

-- Increases the priority of thennables when they resolve within this boundary.
markRetryLaneIfNotHydrated = function(fiber: Fiber, retryLane: Lane)
	markRetryLaneImpl(fiber, retryLane)
	-- ROBLOX TODO: grab local for this since Luau can't deal with nested type narrowing
	local alternate = fiber.alternate
	if alternate then
		markRetryLaneImpl(alternate, retryLane)
	end
end

exports.attemptUserBlockingHydration = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority and they should not suspend on I/O,
		-- since you have to wrap anything that might suspend in
		-- Suspense.
		return
	end
	local eventTime = requestEventTime()
	local lane = InputDiscreteHydrationLane
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.attemptContinuousHydration = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority and they should not suspend on I/O,
		-- since you have to wrap anything that might suspend in
		-- Suspense.
		return
	end
	local eventTime = requestEventTime()
	local lane = SelectiveHydrationLane
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.attemptHydrationAtCurrentPriority = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority other than synchronously flush it.
		return
	end
	local eventTime = requestEventTime()
	local lane = requestUpdateLane(fiber)
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.runWithPriority = function<T>(priority: LanePriority, fn: () -> T): T
	local previousPriority = getCurrentUpdateLanePriority()
	-- ROBLOX performance: hoist non-throwable out of try{} to eliminate anon function
	setCurrentUpdateLanePriority(priority)
	local ok, result = xpcall(fn, describeError)
	setCurrentUpdateLanePriority(previousPriority)
	if not ok then
		error(result)
	end
	return result
end

exports.getCurrentUpdateLanePriority = getCurrentUpdateLanePriority

exports.findHostInstance = findHostInstance

exports.findHostInstanceWithWarning = findHostInstanceWithWarning

exports.findHostInstanceWithNoPortals = function(fiber: Fiber): PublicInstance?
	local hostFiber = findCurrentHostFiberWithNoPortals(fiber)
	if hostFiber == nil then
		return nil
	end
	if hostFiber.tag == FundamentalComponent then
		return hostFiber.stateNode.instance
	end
	return hostFiber.stateNode
end

local function shouldSuspendImpl(fiber)
	return false
end

exports.shouldSuspend = function(fiber: Fiber): boolean
	return shouldSuspendImpl(fiber)
end

local overrideHookState = nil
local overrideHookStateDeletePath = nil
local overrideHookStateRenamePath = nil
local overrideProps = nil
local overridePropsDeletePath = nil
local overridePropsRenamePath = nil
local scheduleUpdate = nil
local setSuspenseHandler = nil

if __DEV__ then
	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithDeleteImpl(
		obj: Object,
		path: Array<string | number>,
		index: number
	)
		local key = path[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		if index + 1 == #path then
			if Array.isArray(updated) then
				-- Narrow type
				local updatedIndex: number = key
				Array.splice(updated, updatedIndex, 1)
			else
				updated[key] = nil
			end
			return updated
		end
		-- $FlowFixMe number or string is fine here
		updated[key] = copyWithDeleteImpl(obj[key], path, index + 1)
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithDelete(
		obj: Object,
		path: Array<string | number>
	): Object | Array<any>
		return copyWithDeleteImpl(obj, path, 0)
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithRenameImpl(
		obj: Object,
		oldPath: Array<string | number>,
		newPath: Array<string | number>,
		index: number
	)
		local oldKey = oldPath[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		if index + 1 == #oldPath then
			local newKey = newPath[index]
			-- $FlowFixMe number or string is fine here
			updated[newKey] = updated[oldKey]
			if Array.isArray(updated) then
				Array.splice(updated, oldKey, 1)
			else
				updated[oldKey] = nil
			end
		else
			-- $FlowFixMe number or string is fine here
			updated[oldKey] = copyWithRenameImpl(
				-- $FlowFixMe number or string is fine here
				obj[oldKey],
				oldPath,
				newPath,
				index + 1
			)
		end
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithRename(
		obj: Object,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	): Object | Array<any> | nil
		if #oldPath ~= #newPath then
			console.warn("copyWithRename() expects paths of the same length")
			return nil
		else
			for i = 1, #newPath do
				if oldPath[i] ~= newPath[i] then
					console.warn(
						"copyWithRename() expects paths to be the same except for the deepest key"
					)
					return nil
				end
			end
		end
		return copyWithRenameImpl(obj, oldPath, newPath, 0)
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithSetImpl(
		obj: Object,
		path: Array<string | number>,
		index: number,
		value: any
	)
		if index >= (#path + 1) then
			return value
		end
		local key = path[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		-- $FlowFixMe number or string is fine here
		updated[key] = copyWithSetImpl(obj[key], path, index + 2, value)
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithSet(
		obj: Object,
		path: Array<string | number>,
		value: any
	): Object | Array<any>
		return copyWithSetImpl(obj, path, 1, value)
	end

	local function findHook(fiber: Fiber, id: number)
		-- For now, the "id" of stateful hooks is just the stateful hook index.
		-- This may change in the future with e.g. nested hooks.
		local currentHook = fiber.memoizedState
		while currentHook ~= nil and id > 1 do
			currentHook = currentHook.next
			id -= 1
		end
		return currentHook
	end

	-- Support DevTools editable values for useState and useReducer.
	overrideHookState =
		function(fiber: Fiber, id: number, path: Array<string | number>, value: any)
			local hook = findHook(fiber, id)
			if hook ~= nil then
				local newState = copyWithSet(hook.memoizedState, path, value)
				hook.memoizedState = newState
				hook.baseState = newState

				-- We aren't actually adding an update to the queue,
				-- because there is no update we can add for useReducer hooks that won't trigger an error.
				-- (There's no appropriate action type for DevTools overrides.)
				-- As a result though, React will see the scheduled update as a noop and bailout.
				-- Shallow cloning props works as a workaround for now to bypass the bailout check.
				fiber.memoizedProps = table.clone(fiber.memoizedProps)

				scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
			end
		end
	overrideHookStateDeletePath =
		function(fiber: Fiber, id: number, path: Array<string | number>)
			local hook = findHook(fiber, id)
			if hook ~= nil then
				local newState = copyWithDelete(hook.memoizedState, path)
				hook.memoizedState = newState
				hook.baseState = newState

				-- We aren't actually adding an update to the queue,
				-- because there is no update we can add for useReducer hooks that won't trigger an error.
				-- (There's no appropriate action type for DevTools overrides.)
				-- As a result though, React will see the scheduled update as a noop and bailout.
				-- Shallow cloning props works as a workaround for now to bypass the bailout check.
				fiber.memoizedProps = table.clone(fiber.memoizedProps)

				scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
			end
		end
	overrideHookStateRenamePath = function(
		fiber: Fiber,
		id: number,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	)
		local hook = findHook(fiber, id)
		if hook ~= nil then
			local newState = copyWithRename(hook.memoizedState, oldPath, newPath)
			hook.memoizedState = newState
			hook.baseState = newState

			-- We aren't actually adding an update to the queue,
			-- because there is no update we can add for useReducer hooks that won't trigger an error.
			-- (There's no appropriate action type for DevTools overrides.)
			-- As a result though, React will see the scheduled update as a noop and bailout.
			-- Shallow cloning props works as a workaround for now to bypass the bailout check.
			fiber.memoizedProps = table.clone(fiber.memoizedProps)

			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
		end
	end

	-- Support DevTools props for function components, forwardRef, memo, host components, etc.
	overrideProps = function(fiber: Fiber, path: Array<string | number>, value: any)
		fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value)
		-- ROBLOX TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end
	overridePropsDeletePath = function(fiber: Fiber, path: Array<string | number>)
		fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path)
		-- ROBLOX TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end
	overridePropsRenamePath = function(
		fiber: Fiber,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	)
		fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath)
		-- ROBLOX TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end

	scheduleUpdate = function(fiber: Fiber)
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end

	setSuspenseHandler = function(newShouldSuspendImpl: (Fiber) -> (boolean))
		shouldSuspendImpl = newShouldSuspendImpl
	end
end

function findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | nil
	local hostFiber = findCurrentHostFiber(fiber)
	if hostFiber == nil then
		return nil
	end
	return hostFiber.stateNode
end

function emptyFindFiberByHostInstance(instance: Instance | TextInstance): Fiber | nil
	return nil
end

function getCurrentFiberForDevTools()
	return ReactCurrentFiber.current
end

exports.injectIntoDevTools = function(devToolsConfig: DevToolsConfig): boolean
	local findFiberByHostInstance = devToolsConfig.findFiberByHostInstance
	local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
	local getCurrentFiber = nil
	if __DEV__ then
		getCurrentFiber = getCurrentFiberForDevTools
	end
	return injectInternals({
		bundleType = devToolsConfig.bundleType,
		version = devToolsConfig.version,
		rendererPackageName = devToolsConfig.rendererPackageName,
		rendererConfig = devToolsConfig.rendererConfig,
		overrideHookState = overrideHookState,
		overrideHookStateDeletePath = overrideHookStateDeletePath,
		overrideHookStateRenamePath = overrideHookStateRenamePath,
		overrideProps = overrideProps,
		overridePropsDeletePath = overridePropsDeletePath,
		overridePropsRenamePath = overridePropsRenamePath,
		setSuspenseHandler = setSuspenseHandler,
		scheduleUpdate = scheduleUpdate,
		currentDispatcherRef = ReactCurrentDispatcher,
		findHostInstanceByFiber = findHostInstanceByFiber,
		findFiberByHostInstance = findFiberByHostInstance or emptyFindFiberByHostInstance,
		-- FIXME: WIP
		-- React Refresh
		-- findHostInstancesForRefresh = __DEV__ and findHostInstancesForRefresh or nil,
		-- scheduleRefresh = __DEV__ and scheduleRefresh or nil,
		-- scheduleRoot = __DEV__ and scheduleRoot or nil,
		-- setRefreshHandler = __DEV__ and setRefreshHandler or nil,
		-- Enables DevTools to append owner stacks to error messages in DEV mode.
		getCurrentFiber = getCurrentFiber,
	})
end

return exports ]]
cX.Children._1d617d5e8451792b104ce20e4f01d52e=dO
local dP

local dQ={ClassName="ModuleScript",Children={},Properties={}}
dQ.Name="ReactFiberRoot.new"
dQ.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/96ac799eace5d989de3b4f80e6414e94a08ff77a/packages/react-reconciler/src/ReactFiberRoot.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
local Map = LuauPolyfill.Map

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type SuspenseHydrationCallbacks = ReactInternalTypes.SuspenseHydrationCallbacks
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local noTimeout = ReactFiberHostConfig.noTimeout
local supportsHydration = ReactFiberHostConfig.supportsHydration
local ReactFiber = require(script.Parent["ReactFiber.new"])
local createHostRootFiber = ReactFiber.createHostRootFiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
local NoLanes = ReactFiberLane.NoLanes
local NoLanePriority = ReactFiberLane.NoLanePriority
local NoTimestamp = ReactFiberLane.NoTimestamp
local createLaneMap = ReactFiberLane.createLaneMap
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
-- ROBLOX deviation: import from tracing from Scheduler export to avoid direct file access
local Scheduler = require(Packages.Scheduler).tracing
local unstable_getThreadID = Scheduler.unstable_getThreadID
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local LegacyRoot = ReactRootTags.LegacyRoot
local BlockingRoot = ReactRootTags.BlockingRoot
local ConcurrentRoot = ReactRootTags.ConcurrentRoot

local exports = {}

local function FiberRootNode(containerInfo, tag, hydrate)
	-- ROBLOX performance: See if this kind of object init is faster in Luau
	local rootNode = {
		tag = tag,
		containerInfo = containerInfo,
		pendingChildren = nil,
		-- ROBLOX TODO: this isn't typesafe upstream
		current = (nil :: any) :: Fiber,
		pingCache = nil,
		finishedWork = nil,
		timeoutHandle = noTimeout,
		context = nil,
		pendingContext = nil,
		hydrate = hydrate,
		callbackNode = nil,
		callbackPriority = NoLanePriority,
		eventTimes = createLaneMap(NoLanes),
		expirationTimes = createLaneMap(NoTimestamp),

		pendingLanes = NoLanes,
		suspendedLanes = NoLanes,
		pingedLanes = NoLanes,
		expiredLanes = NoLanes,
		mutableReadLanes = NoLanes,
		finishedLanes = NoLanes,

		entangledLanes = NoLanes,
		entanglements = createLaneMap(NoLanes),
	}

	if supportsHydration then
		rootNode.mutableSourceEagerHydrationData = nil
	end

	if enableSchedulerTracing then
		rootNode.interactionThreadID = unstable_getThreadID()
		rootNode.memoizedInteractions = Set.new()
		rootNode.pendingInteractionMap = Map.new()
	end
	if enableSuspenseCallback then
		rootNode.hydrationCallbacks = nil
	end

	if _G.__DEV__ then
		if tag == BlockingRoot then
			rootNode._debugRootType = "createBlockingRoot()"
		elseif tag == ConcurrentRoot then
			rootNode._debugRootType = "createRoot()"
		elseif tag == LegacyRoot then
			rootNode._debugRootType = "createLegacyRoot()"
		end
	end

	return rootNode
end

exports.createFiberRoot = function(
	containerInfo: any,
	tag: RootTag,
	hydrate: boolean,
	hydrationCallbacks: SuspenseHydrationCallbacks?
): FiberRoot
	local root: FiberRoot = FiberRootNode(containerInfo, tag, hydrate)
	if enableSuspenseCallback then
		root.hydrationCallbacks = hydrationCallbacks
	end

	-- Cyclic construction. This cheats the type system right now because
	-- stateNode is any.
	local uninitializedFiber = createHostRootFiber(tag)
	root.current = uninitializedFiber
	uninitializedFiber.stateNode = root

	initializeUpdateQueue(uninitializedFiber)

	return root
end

return exports ]]
cX.Children._f2dff71254a2fc66709251604b6f5f24=dQ
local dR

local dS={ClassName="ModuleScript",Children={},Properties={}}
dS.Name="ReactFiberSchedulerPriorities.roblox"
dS.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/d17086c7c813402a550d15a2f56dc43f1dbd1735/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js
--\[\[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

-- deviation: Type definition and values extracted from
-- SchedulerWithReactIntegration.new. This helps avoid a cyclic dependency that
-- can occur between SchedulerWithReactIntegration.new, ReactFiberLanes, and
-- various files that depend upon them

export type ReactPriorityLevel = number

local exports: { [string]: ReactPriorityLevel } = {
	-- // Except for NoPriority, these correspond to Scheduler priorities. We use
	-- // ascending numbers so we can compare them like numbers. They start at 90 to
	-- // avoid clashing with Scheduler's priorities.
	ImmediatePriority = 99,
	UserBlockingPriority = 98,
	NormalPriority = 97,
	LowPriority = 96,
	IdlePriority = 95,
	-- // NoPriority is the absence of priority. Also React-only.
	NoPriority = 90,
}

return exports ]]
cX.Children._f12863ed1d1bfe74e40cb7cdf5fc9608=dS
local dT

local dU={ClassName="ModuleScript",Children={},Properties={}}
dU.Name="ReactFiberStack.new"
dU.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberStack.new.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

type Array<T> = { [number]: T }
-- deviation: use this table when pushing nil values
type null = {}
local NULL: null = {}

export type StackCursor<T> = { current: T }

local valueStack: Array<any> = {}

local fiberStack: Array<Fiber | null>

if _G.__DEV__ then
	fiberStack = {}
end

local index = 0

local function createCursor<T>(defaultValue: T): StackCursor<T>
	return {
		current = defaultValue,
	}
end

local function isEmpty(): boolean
	return index == 0
end

local function pop<T>(cursor: StackCursor<T>, fiber: Fiber): ()
	if index < 1 then
		if _G.__DEV__ then
			console.error("Unexpected pop.")
		end
		return
	end

	if _G.__DEV__ then
		-- ROBLOX TODO: workaround for Luau analysis bug
		if fiber ~= fiberStack[index] :: Fiber then
			console.error("Unexpected Fiber popped.")
		end
	end

	local value = valueStack[index]
	if value == NULL then
		-- ROBLOX TODO: this is a sort of incorrect typing in upstream
		cursor.current = nil :: any
	else
		cursor.current = value
	end

	valueStack[index] = nil

	if _G.__DEV__ then
		fiberStack[index] = nil
	end

	index -= 1
end

local function push<T>(cursor: StackCursor<T>, value: T, fiber: Fiber): ()
	index += 1

	local stackValue = cursor.current
	if stackValue == nil then
		valueStack[index] = NULL
	else
		valueStack[index] = stackValue
	end

	if _G.__DEV__ then
		fiberStack[index] = fiber
	end

	cursor.current = value
end

local function checkThatStackIsEmpty()
	if _G.__DEV__ then
		if index ~= 0 then
			console.error("Expected an empty stack. Something was not reset properly.")
		end
	end
end

local function resetStackAfterFatalErrorInDev()
	if _G.__DEV__ then
		index = 0
		-- ROBLOX deviation: Original js simply sets `length`
		table.clear(valueStack)
		table.clear(fiberStack)
	end
end

return {
	createCursor = createCursor,
	isEmpty = isEmpty,
	pop = pop,
	push = push,
	-- DEV only:
	checkThatStackIsEmpty = checkThatStackIsEmpty,
	resetStackAfterFatalErrorInDev = resetStackAfterFatalErrorInDev,
} ]]
cX.Children._85db494f3dae6ebdf32d68198c0e211f=dU
local dV

local dW={ClassName="ModuleScript",Children={},Properties={}}
dW.Name="ReactFiberSuspenseComponent.new"
dW.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberSuspenseComponent.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type Wakeable = ReactTypes.Wakeable

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local DidCapture = ReactFiberFlags.DidCapture
local isSuspenseInstancePending = ReactFiberHostConfig.isSuspenseInstancePending
local isSuspenseInstanceFallback = ReactFiberHostConfig.isSuspenseInstanceFallback

-- deviation: Common types
type Set<T> = { [T]: boolean }

export type SuspenseProps = {
	children: ReactNodeList?,
	fallback: ReactNodeList?,

	-- TODO: Add "unstable_" prefix?
	suspenseCallback: (Set<Wakeable>?) -> any,

	unstable_expectedLoadTime: number?,
}

-- A nil SuspenseState represents an unsuspended normal Suspense boundary.
-- A non-null SuspenseState means that it is blocked for one reason or another.
-- - A non-null dehydrated field means it's blocked pending hydration.
--   - A non-null dehydrated field can use isSuspenseInstancePending or
--     isSuspenseInstanceFallback to query the reason for being dehydrated.
-- - A nil dehydrated field means it's blocked by something suspending and
--   we're currently showing a fallback instead.
export type SuspenseState = {
	-- If this boundary is still dehydrated, we store the SuspenseInstance
	-- here to indicate that it is dehydrated (flag) and for quick access
	-- to check things like isSuspenseInstancePending.
	dehydrated: SuspenseInstance?,
	-- Represents the lane we should attempt to hydrate a dehydrated boundary at.
	-- OffscreenLane is the default for dehydrated boundaries.
	-- NoLane is the default for normal boundaries, which turns into "normal" pri.
	retryLane: Lane,
}

-- deviation: Can't use literals for types
-- export type SuspenseListTailMode = 'collapsed' | 'hidden' | void
export type SuspenseListTailMode = string?

export type SuspenseListRenderState = {
	isBackwards: boolean,
	-- The currently rendering tail row.
	rendering: Fiber?,
	-- The absolute time when we started rendering the most recent tail row.
	renderingStartTime: number,
	-- The last of the already rendered children.
	last: Fiber?,
	-- Remaining rows on the tail of the list.
	tail: Fiber?,
	-- Tail insertions setting.
	tailMode: SuspenseListTailMode,
}

local exports = {}

exports.shouldCaptureSuspense =
	function(workInProgress: Fiber, hasInvisibleParent: boolean): boolean
		-- If it was the primary children that just suspended, capture and render the
		-- fallback. Otherwise, don't capture and bubble to the next boundary.
		local nextState: SuspenseState? = workInProgress.memoizedState
		if nextState then
			if nextState.dehydrated ~= nil then
				-- A dehydrated boundary always captures.
				return true
			end
			return false
		end
		local props = workInProgress.memoizedProps
		-- In order to capture, the Suspense component must have a fallback prop.
		if props.fallback == nil then
			return false
		end
		-- Regular boundaries always capture.
		if props.unstable_avoidThisFallback ~= true then
			return true
		end
		-- If it's a boundary we should avoid, then we prefer to bubble up to the
		-- parent boundary if it is currently invisible.
		if hasInvisibleParent then
			return false
		end
		-- If the parent is not able to handle it, we must handle it.
		return true
	end

exports.findFirstSuspended = function(row: Fiber): Fiber?
	local node = row
	while node ~= nil do
		if node.tag == SuspenseComponent then
			local state: SuspenseState? = node.memoizedState
			if state then
				local dehydrated: SuspenseInstance? = state.dehydrated
				if
					dehydrated == nil
					or isSuspenseInstancePending(dehydrated)
					or isSuspenseInstanceFallback(dehydrated)
				then
					return node
				end
			end
		elseif
			node.tag == SuspenseListComponent
			-- revealOrder undefined can't be trusted because it don't
			-- keep track of whether it suspended or not.
			and node.memoizedProps.revealOrder ~= nil
		then
			local didSuspend = bit32.band(node.flags, DidCapture) ~= NoFlags
			if didSuspend then
				return node
			end
		elseif node.child ~= nil then
			node.child.return_ = node
			node = node.child
			continue
		end
		if node == row then
			return nil
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == row then
				return nil
			end
			-- ROBLOX FIXME Luau: Luau narrowing doesn't understand this loop until nil pattern
			node = node.return_ :: Fiber
		end
		-- ROBLOX FIXME Luau: Luau narrowing doesn't understand this loop until nil pattern
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
	return nil
end

return exports ]]
cX.Children._a1fa44f28899eab9f4bfdcf3615ee797=dW
local dX

local dY={ClassName="ModuleScript",Children={},Properties={}}
dY.Name="ReactFiberSuspenseContext.new"
dY.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberSuspenseContext.new.js
--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberSuspenseContext.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

export type SuspenseContext = number
export type SubtreeSuspenseContext = SuspenseContext
export type ShallowSuspenseContext = SuspenseContext

local exports = {}

local DefaultSuspenseContext: SuspenseContext = 0b00

-- // The Suspense Context is split into two parts. The lower bits is
-- // inherited deeply down the subtree. The upper bits only affect
-- // this immediate suspense boundary and gets reset each new
-- // boundary or suspense list.
local SubtreeSuspenseContextMask: SuspenseContext = 0b01

-- // Subtree Flags:

-- // InvisibleParentSuspenseContext indicates that one of our parent Suspense
-- // boundaries is not currently showing visible main content.
-- // Either because it is already showing a fallback or is not mounted at all.
-- // We can use this to determine if it is desirable to trigger a fallback at
-- // the parent. If not, then we might need to trigger undesirable boundaries
-- // and/or suspend the commit to avoid hiding the parent content.
local InvisibleParentSuspenseContext: SubtreeSuspenseContext = 0b01
exports.InvisibleParentSuspenseContext = InvisibleParentSuspenseContext

-- // Shallow Flags:

-- // ForceSuspenseFallback can be used by SuspenseList to force newly added
-- // items into their fallback state during one of the render passes.
local ForceSuspenseFallback: ShallowSuspenseContext = 0b10
exports.ForceSuspenseFallback = ForceSuspenseFallback

local suspenseStackCursor: StackCursor<SuspenseContext> =
	createCursor(DefaultSuspenseContext)
exports.suspenseStackCursor = suspenseStackCursor

function exports.hasSuspenseContext(
	parentContext: SuspenseContext,
	flag: SuspenseContext
): boolean
	return bit32.band(parentContext, flag) ~= 0
end

function exports.setDefaultShallowSuspenseContext(
	parentContext: SuspenseContext
): SuspenseContext
	return bit32.band(parentContext, SubtreeSuspenseContextMask)
end

function exports.setShallowSuspenseContext(
	parentContext: SuspenseContext,
	shallowContext: ShallowSuspenseContext
): SuspenseContext
	return bit32.bor(
		bit32.band(parentContext, SubtreeSuspenseContextMask),
		shallowContext
	)
end

function exports.addSubtreeSuspenseContext(
	parentContext: SuspenseContext,
	subtreeContext: SubtreeSuspenseContext
): SuspenseContext
	return bit32.bor(parentContext, subtreeContext)
end

function exports.pushSuspenseContext(fiber: Fiber, newContext: SuspenseContext)
	push(suspenseStackCursor, newContext, fiber)
end

function exports.popSuspenseContext(fiber: Fiber)
	pop(suspenseStackCursor, fiber)
end

return exports ]]
cX.Children._92f42ca2bec3e75ffaf9f0ed919ac21c=dY
local dZ

local d_={ClassName="ModuleScript",Children={},Properties={}}
d_.Name="ReactFiberThrow.new"
d_.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberThrow.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
type Error = LuauPolyfill.Error
type Map<K, V> = { [K]: V }
type Object = { [string]: any }
type Set<T> = { [T]: boolean }

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local ReactCapturedValue = require(script.Parent.ReactCapturedValue)
type CapturedValue<T> = ReactCapturedValue.CapturedValue<T>
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type Update<T> = ReactInternalTypes.Update<T>

local ReactTypes = require(Packages.Shared)
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>
type Thenable<T> = ReactTypes.Thenable<T>
type Wakeable = ReactTypes.Wakeable

local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext

local getComponentName = require(Packages.Shared).getComponentName

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local DidCapture = ReactFiberFlags.DidCapture
local Incomplete = ReactFiberFlags.Incomplete
local NoFlags = ReactFiberFlags.NoFlags
local ShouldCapture = ReactFiberFlags.ShouldCapture
local LifecycleEffectMask = ReactFiberFlags.LifecycleEffectMask
local ForceUpdateForLegacySuspense = ReactFiberFlags.ForceUpdateForLegacySuspense
local shouldCaptureSuspense =
	require(script.Parent["ReactFiberSuspenseComponent.new"]).shouldCaptureSuspense
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local NoMode = ReactTypeOfMode.NoMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local createCapturedValue = require(script.Parent.ReactCapturedValue).createCapturedValue

local enqueueCapturedUpdate = ReactUpdateQueue.enqueueCapturedUpdate
local createUpdate = ReactUpdateQueue.createUpdate
local CaptureUpdate = ReactUpdateQueue.CaptureUpdate
local ForceUpdate = ReactUpdateQueue.ForceUpdate
local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local markFailedErrorBoundaryForHotReloading = require(
	script.Parent["ReactFiberHotReloading.new"]
).markFailedErrorBoundaryForHotReloading

local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
local InvisibleParentSuspenseContext =
	ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor

-- ROBLOX FIXME: these will incur a dependency cycle
-- onUncaughtError would be very easy to extract out, or to transplant into this file
local ReactFiberWorkLoop
local markLegacyErrorBoundaryAsFailedRef, isAlreadyFailedLegacyErrorBoundaryRef, pingSuspendedRootRef

-- ROBLOX deviation: lazy initialize ReactFiberWorkLoop to prevent cyclic module dependency
local markLegacyErrorBoundaryAsFailed = function(...)
	if not markLegacyErrorBoundaryAsFailedRef then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
		markLegacyErrorBoundaryAsFailedRef =
			ReactFiberWorkLoop.markLegacyErrorBoundaryAsFailed
	end
	return markLegacyErrorBoundaryAsFailedRef(...)
end
-- local {
--   renderDidError,
--   onUncaughtError,
--   markLegacyErrorBoundaryAsFailed,
--   isAlreadyFailedLegacyErrorBoundary,
--   pingSuspendedRoot,
-- } = require(Packages../ReactFiberWorkLoop.new'
local pingSuspendedRoot = function(...)
	if ReactFiberWorkLoop == nil then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	end
	pingSuspendedRootRef = ReactFiberWorkLoop.pingSuspendedRoot
	return pingSuspendedRootRef(...)
end
local isAlreadyFailedLegacyErrorBoundary = function(...)
	if ReactFiberWorkLoop == nil then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	end
	isAlreadyFailedLegacyErrorBoundaryRef =
		ReactFiberWorkLoop.isAlreadyFailedLegacyErrorBoundary
	return isAlreadyFailedLegacyErrorBoundaryRef(...)
end

local logCapturedError = require(script.Parent.ReactFiberErrorLogger).logCapturedError
local logComponentSuspended = require(script.Parent.DebugTracing).logComponentSuspended
local markComponentSuspended =
	require(script.Parent.SchedulingProfiler).markComponentSuspended

local SyncLane = ReactFiberLane.SyncLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane

-- local PossiblyWeakMap = typeof WeakMap == 'function' ? WeakMap : Map

function createRootErrorUpdate(
	fiber: Fiber,
	errorInfo: CapturedValue<Error>,
	lane: Lane,
	-- ROBLOX deviation: parameterize method to avoid circular dependency
	onUncaughtError
): Update<any>
	local update = createUpdate(NoTimestamp, lane)
	-- Unmount the root by rendering nil.
	update.tag = CaptureUpdate
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	update.payload = { element = Object.None }
	local _error = errorInfo.value
	update.callback = function()
		if onUncaughtError ~= nil then
			onUncaughtError(_error)
		end
		logCapturedError(fiber, errorInfo)
	end
	return update
end

function createClassErrorUpdate(
	fiber: Fiber,
	errorInfo: CapturedValue<Error>,
	lane: Lane
): Update<any>
	local update = createUpdate(NoTimestamp, lane)
	update.tag = CaptureUpdate
	local getDerivedStateFromError = (fiber.type :: React_Component<any, any>).getDerivedStateFromError
	if typeof(getDerivedStateFromError) == "function" then
		local error_ = errorInfo.value
		update.payload = function()
			logCapturedError(fiber, errorInfo)
			return getDerivedStateFromError(error_)
		end
	end

	local inst = fiber.stateNode
	if inst ~= nil and typeof(inst.componentDidCatch) == "function" then
		update.callback = function()
			if _G.__DEV__ then
				markFailedErrorBoundaryForHotReloading(fiber)
			end
			if typeof(getDerivedStateFromError) ~= "function" then
				-- To preserve the preexisting retry behavior of error boundaries,
				-- we keep track of which ones already failed during this batch.
				-- This gets reset before we yield back to the browser.
				-- TODO: Warn in strict mode if getDerivedStateFromError is
				-- not defined.
				-- ROBLOX FIXME: used to be `this` upstream, needs verification by ReactIncremental unwinding test
				markLegacyErrorBoundaryAsFailed(inst)

				-- Only log here if componentDidCatch is the only error boundary method defined
				logCapturedError(fiber, errorInfo)
			end
			local error_ = errorInfo.value
			local stack = errorInfo.stack
			-- ROBLOX FIXME: used to be `this` upstream, needs verification by ReactIncremental unwinding test
			inst:componentDidCatch(error_, {
				componentStack = stack or "",
			})
			if _G.__DEV__ then
				if typeof(getDerivedStateFromError) ~= "function" then
					-- If componentDidCatch is the only error boundary method defined,
					-- then it needs to call setState to recover from errors.
					-- If no state update is scheduled then the boundary will swallow the error.
					if not includesSomeLane(fiber.lanes, SyncLane) then
						console.error(
							"%s: Error boundaries should implement getDerivedStateFromError(). "
								.. "In that method, return a state update to display an error message or fallback UI.",
							getComponentName(fiber.type) or "Unknown"
						)
					end
				end
			end
		end
	elseif _G.__DEV__ then
		update.callback = function()
			markFailedErrorBoundaryForHotReloading(fiber)
		end
	end
	return update
end

local function attachPingListener(root: FiberRoot, wakeable: Wakeable, lanes: Lanes)
	-- Attach a listener to the promise to "ping" the root and retry. But only if
	-- one does not already exist for the lanes we're currently rendering (which
	-- acts like a "thread ID" here).
	local pingCache: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)> | nil =
		root.pingCache
	local threadIDs
	if pingCache == nil then
		-- ROBLOX deviation: use table in place of WeakMap
		-- ROBLOX performance: slight re-ordering so we initialize the table in one shot
		threadIDs = {} :: Set<any>
		root.pingCache = {
			[wakeable] = threadIDs,
		} :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>
		pingCache = root.pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>
	else
		threadIDs = (
			pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>
		)[wakeable] :: Set<any>
		if threadIDs == nil then
			threadIDs = {} :: Set<any>;
			(pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>)[wakeable] =
				threadIDs
		end
	end
	if not threadIDs[lanes] then
		-- Memoize using the thread ID to prevent redundant listeners.
		threadIDs[lanes] = true
		local ping = function()
			return pingSuspendedRoot(root, wakeable, lanes)
		end
		wakeable:andThen(ping, ping)
	end
end

function throwException(
	root: FiberRoot,
	returnFiber: Fiber,
	sourceFiber: Fiber,
	value: any,
	rootRenderLanes: Lanes,
	onUncaughtError,
	renderDidError
)
	-- The source fiber did not complete.
	sourceFiber.flags = bit32.bor(sourceFiber.flags, Incomplete)

	if
		value ~= nil
		and typeof(value) == "table"
		and typeof(value.andThen) == "function"
	then
		-- This is a wakeable.
		local wakeable: Wakeable = value

		if _G.__DEV__ then
			if enableDebugTracing then
				if bit32.band(sourceFiber.mode, DebugTracingMode) ~= 0 then
					local name = getComponentName(sourceFiber.type) or "Unknown"
					logComponentSuspended(name, wakeable)
				end
			end
		end

		if enableSchedulingProfiler then
			markComponentSuspended(sourceFiber, wakeable)
		end

		if bit32.band(sourceFiber.mode, BlockingMode) == NoMode then
			-- Reset the memoizedState to what it was before we attempted
			-- to render it.
			local currentSource = sourceFiber.alternate
			if currentSource then
				-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
				sourceFiber.updateQueue = currentSource.updateQueue
				sourceFiber.memoizedState = currentSource.memoizedState
				sourceFiber.lanes = currentSource.lanes
			else
				-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
				sourceFiber.updateQueue = nil
				sourceFiber.memoizedState = nil
			end
		end

		local hasInvisibleParentBoundary = hasSuspenseContext(
			suspenseStackCursor.current,
			InvisibleParentSuspenseContext :: SuspenseContext
		)

		-- Schedule the nearest Suspense to re-render the timed out view.
		local workInProgress = returnFiber
		repeat
			if
				workInProgress.tag == SuspenseComponent
				and shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)
			then
				-- Found the nearest boundary.

				-- Stash the promise on the boundary fiber. If the boundary times out, we'll
				-- attach another listener to flip the boundary back to its normal state.
				local wakeables: Set<Wakeable> = workInProgress.updateQueue
				if wakeables == nil then
					local updateQueue = {
						[wakeable] = true,
					}
					-- ROBLOX performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
					workInProgress.updateQueue = updateQueue
				else
					wakeables[wakeable] = true
				end

				-- If the boundary is outside of blocking mode, we should *not*
				-- suspend the commit. Pretend as if the suspended component rendered
				-- nil and keep rendering. In the commit phase, we'll schedule a
				-- subsequent synchronous update to re-render the Suspense.
				--
				-- Note: It doesn't matter whether the component that suspended was
				-- inside a blocking mode tree. If the Suspense is outside of it, we
				-- should *not* suspend the commit.
				if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
					workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
					sourceFiber.flags =
						bit32.bor(sourceFiber.flags, ForceUpdateForLegacySuspense)

					-- We're going to commit this fiber even though it didn't complete.
					-- But we shouldn't call any lifecycle methods or callbacks. Remove
					-- all lifecycle effect tags.
					sourceFiber.flags = bit32.band(
						sourceFiber.flags,
						bit32.bnot(bit32.bor(LifecycleEffectMask, Incomplete))
					)

					if sourceFiber.tag == ClassComponent then
						local currentSourceFiber = sourceFiber.alternate
						if currentSourceFiber == nil then
							-- This is a new mount. Change the tag so it's not mistaken for a
							-- completed class component. For example, we should not call
							-- componentWillUnmount if it is deleted.
							sourceFiber.tag = IncompleteClassComponent
						else
							-- When we try rendering again, we should not reuse the current fiber,
							-- since it's known to be in an inconsistent state. Use a force update to
							-- prevent a bail out.
							local update = createUpdate(NoTimestamp, SyncLane)
							update.tag = ForceUpdate
							enqueueUpdate(sourceFiber, update)
						end
					end

					-- The source fiber did not complete. Mark it with Sync priority to
					-- indicate that it still has pending work.
					sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane)

					-- Exit without suspending.
					return
				end

				-- Confirmed that the boundary is in a concurrent mode tree. Continue
				-- with the normal suspend path.
				--
				-- After this we'll use a set of heuristics to determine whether this
				-- render pass will run to completion or restart or "suspend" the commit.
				-- The actual logic for this is spread out in different places.
				--
				-- This first principle is that if we're going to suspend when we complete
				-- a root, then we should also restart if we get an update or ping that
				-- might unsuspend it, and vice versa. The only reason to suspend is
				-- because you think you might want to restart before committing. However,
				-- it doesn't make sense to restart only while in the period we're suspended.
				--
				-- Restarting too aggressively is also not good because it starves out any
				-- intermediate loading state. So we use heuristics to determine when.

				-- Suspense Heuristics
				--
				-- If nothing threw a Promise or all the same fallbacks are already showing,
				-- then don't suspend/restart.
				--
				-- If this is an initial render of a new tree of Suspense boundaries and
				-- those trigger a fallback, then don't suspend/restart. We want to ensure
				-- that we can show the initial loading state as quickly as possible.
				--
				-- If we hit a "Delayed" case, such as when we'd switch from content back into
				-- a fallback, then we should always suspend/restart. Transitions apply
				-- to this case. If none is defined, JND is used instead.
				--
				-- If we're already showing a fallback and it gets "retried", allowing us to show
				-- another level, but there's still an inner boundary that would show a fallback,
				-- then we suspend/restart for 500ms since the last time we showed a fallback
				-- anywhere in the tree. This effectively throttles progressive loading into a
				-- consistent train of commits. This also gives us an opportunity to restart to
				-- get to the completed state slightly earlier.
				--
				-- If there's ambiguity due to batching it's resolved in preference of:
				-- 1) "delayed", 2) "initial render", 3) "retry".
				--
				-- We want to ensure that a "busy" state doesn't get force committed. We want to
				-- ensure that new initial loading states can commit as soon as possible.

				attachPingListener(root, wakeable, rootRenderLanes)

				workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
				workInProgress.lanes = rootRenderLanes

				return
			end
			-- This boundary already captured during this render. Continue to the next
			-- boundary.
			workInProgress = workInProgress.return_ :: Fiber -- ROBLOX TODO: Luau narrowing doesn't understand this loop until nil pattern
		until workInProgress == nil

		-- No boundary was found. Fallthrough to error mode.
		-- TODO: Use invariant so the message is stripped in prod?
		value = (getComponentName(sourceFiber.type) or "A React component")
			.. " suspended while rendering, but no fallback UI was specified.\n"
			.. "\n"
			.. "Add a <Suspense fallback=...> component higher in the tree to "
			.. "provide a loading indicator or placeholder to display."
	end

	-- We didn't find a boundary that could handle this type of exception. Start
	-- over and traverse parent path again, this time treating the exception
	-- as an error.
	renderDidError()

	value = createCapturedValue(value, sourceFiber)
	local workInProgress = returnFiber
	repeat
		if workInProgress.tag == HostRoot then
			local errorInfo = value
			workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
			local lane = pickArbitraryLane(rootRenderLanes)
			workInProgress.lanes = mergeLanes(workInProgress.lanes, lane)
			-- ROBLOX deviation: parameterize method onUncaughtError to avoid circular dependency
			local update =
				createRootErrorUpdate(workInProgress, errorInfo, lane, onUncaughtError)
			enqueueCapturedUpdate(workInProgress, update)
			return
		elseif workInProgress.tag == ClassComponent then
			-- Capture and retry
			local errorInfo = value
			local ctor = workInProgress.type
			local instance = workInProgress.stateNode
			if
				bit32.band(workInProgress.flags, DidCapture) == NoFlags
				and (
					typeof(ctor.getDerivedStateFromError) == "function"
					or (
						instance ~= nil
						and typeof(instance.componentDidCatch) == "function"
						and not isAlreadyFailedLegacyErrorBoundary(instance)
					)
				)
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
				local lane = pickArbitraryLane(rootRenderLanes)
				workInProgress.lanes = mergeLanes(workInProgress.lanes, lane)
				-- Schedule the error boundary to re-render using updated state
				local update = createClassErrorUpdate(workInProgress, errorInfo, lane)
				enqueueCapturedUpdate(workInProgress, update)
				return
			end
		end
		workInProgress = workInProgress.return_ :: Fiber -- ROBLOX TODO: Luau narrowing doesn't understand this loop until nil pattern
	until workInProgress == nil
end

return {
	throwException = throwException,
	createRootErrorUpdate = createRootErrorUpdate,
	createClassErrorUpdate = createClassErrorUpdate,
} ]]
cX.Children._30ae798505095a72357acebedbc30f21=d_
local d0

local d1={ClassName="ModuleScript",Children={},Properties={}}
d1.Name="ReactFiberTransition"
d1.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/ddd1faa1972b614dfbfae205f2aa4a6c0b39a759/packages/react-reconciler/src/ReactFiberTransition.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals

local ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig

return {
	NoTransition = 0,
	requestCurrentTransition = function(): number
		return ReactCurrentBatchConfig.transition
	end,
} ]]
cX.Children._990a864f1332a806868a7fce18643e51=d1
local d2

local d3={ClassName="ModuleScript",Children={},Properties={}}
d3.Name="ReactFiberTreeReflection"
d3.Properties.Source=[[ --!nonstrict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberTreeReflection.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Container = ReactFiberHostConfig.Container
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local invariant = require(Packages.Shared).invariant

local getInstance = require(Packages.Shared).ReactInstanceMap.get
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local getComponentName = require(Packages.Shared).getComponentName
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostComponent = ReactWorkTags.HostComponent
local HostRoot = ReactWorkTags.HostRoot
local HostPortal = ReactWorkTags.HostPortal
local HostText = ReactWorkTags.HostText
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
local enableFundamentalAPI =
	require(Packages.Shared).ReactFeatureFlags.enableFundamentalAPI

local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner

local exports = {}

local function getNearestMountedFiber(fiber: Fiber): Fiber?
	local node = fiber
	-- ROBLOX FIXME Luau: Luau should infer this annotation
	local nearestMounted: Fiber | nil = fiber
	if not fiber.alternate then
		-- If there is no alternate, this might be a new tree that isn't inserted
		-- yet. If it is, then it will have a pending insertion effect on it.
		local nextNode = node
		repeat
			node = nextNode
			if bit32.band(node.flags, bit32.bor(Placement, Hydrating)) ~= NoFlags then
				-- This is an insertion or in-progress hydration. The nearest possible
				-- mounted fiber is the parent but we need to continue to figure out
				-- if that one is still mounted.
				nearestMounted = node.return_
			end
			nextNode = node.return_
		until not nextNode
	else
		while node.return_ do
			node = node.return_
		end
	end
	if node.tag == HostRoot then
		-- TODO: Check if this was a nested HostRoot when used with
		-- renderContainerIntoSubtree.
		return nearestMounted
	end
	-- If we didn't hit the root, that means that we're in an disconnected tree
	-- that has been unmounted.
	return nil
end
exports.getNearestMountedFiber = getNearestMountedFiber

exports.getSuspenseInstanceFromFiber = function(fiber: Fiber): SuspenseInstance?
	if fiber.tag == SuspenseComponent then
		local suspenseState: SuspenseState? = fiber.memoizedState
		if suspenseState == nil then
			local current = fiber.alternate
			if current ~= nil then
				suspenseState = current.memoizedState
			end
		end
		if suspenseState then
			return suspenseState.dehydrated
		end
	end
	return nil
end

exports.getContainerFromFiber = function(fiber: Fiber): Container?
	return if fiber.tag == HostRoot then fiber.stateNode.containerInfo else nil
end

exports.isFiberMounted = function(fiber: Fiber): boolean
	return getNearestMountedFiber(fiber) == fiber
end

-- ROBLOX TODO: Missing React$ internal flow types
-- exports.isMounted = function(component: React$Component<any, any>): boolean
exports.isMounted = function(component): boolean
	if _G.__DEV__ then
		local owner: any = ReactCurrentOwner.current
		if owner ~= nil and owner.tag == ClassComponent then
			local ownerFiber: Fiber = owner
			local instance = ownerFiber.stateNode
			if not instance._warnedAboutRefsInRender then
				console.error(
					"%s is accessing isMounted inside its render() function. "
						.. "render() should be a pure function of props and state. It should "
						.. "never access something that requires stale data from the previous "
						.. "render, such as refs. Move this logic to componentDidMount and "
						.. "componentDidUpdate instead.",
					getComponentName(ownerFiber.type) or "A component"
				)
			end
			instance._warnedAboutRefsInRender = true
		end
	end

	local fiber: Fiber? = getInstance(component)
	if not fiber then
		return false
	else
		-- ROBLOX FIXME: remove any cast once Luau understands if-statement nil check
		local fiberNonNil: any = fiber
		return getNearestMountedFiber(fiberNonNil) == fiber
	end
end

local function assertIsMounted(fiber)
	invariant(
		getNearestMountedFiber(fiber) == fiber,
		"Unable to find node on an unmounted component."
	)
end

local function findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber?
	local alternate = fiber.alternate
	if not alternate then
		-- If there is no alternate, then we only need to check if it is mounted.
		local nearestMounted = getNearestMountedFiber(fiber)
		invariant(nearestMounted ~= nil, "Unable to find node on an unmounted component.")
		if nearestMounted ~= fiber then
			return nil
		end
		return fiber
	end
	-- If we have two possible branches, we'll walk backwards up to the root
	-- to see what path the root points to. On the way we may hit one of the
	-- special cases and we'll deal with them.
	local a: Fiber = fiber
	local b: Fiber = alternate
	while true do
		local parentA = a.return_
		if parentA == nil then
			-- We're at the root.
			break
		end
		local parentB = parentA.alternate
		if parentB == nil then
			-- There is no alternate. This is an unusual case. Currently, it only
			-- happens when a Suspense component is hidden. An extra fragment fiber
			-- is inserted in between the Suspense fiber and its children. Skip
			-- over this extra fragment fiber and proceed to the next parent.
			local nextParent = parentA.return_
			if nextParent ~= nil then
				a = nextParent
				b = nextParent
				continue
			end
			-- If there's no parent, we're at the root.
			break
		end

		-- If both copies of the parent fiber point to the same child, we can
		-- assume that the child is current. This happens when we bailout on low
		-- priority: the bailed out fiber's child reuses the current child.
		if parentA.child == parentB.child then
			local child = parentA.child
			while child do
				if child == a then
					-- We've determined that A is the current branch.
					assertIsMounted(parentA)
					return fiber
				end
				if child == b then
					-- We've determined that B is the current branch.
					assertIsMounted(parentA)
					return alternate
				end
				child = child.sibling
			end
			-- We should never have an alternate for any mounting node. So the only
			-- way this could possibly happen is if this was unmounted, if at all.
			invariant(false, "Unable to find node on an unmounted component.")
		end

		if a.return_ ~= b.return_ then
			-- The return pointer of A and the return pointer of B point to different
			-- fibers. We assume that return pointers never criss-cross, so A must
			-- belong to the child set of A.return, and B must belong to the child
			-- set of B.return.
			a = parentA
			b = parentB
		else
			-- The return pointers point to the same fiber. We'll have to use the
			-- default, slow path: scan the child sets of each parent alternate to see
			-- which child belongs to which set.
			--
			-- Search parent A's child set
			local didFindChild = false
			local child = parentA.child
			while child do
				if child == a then
					didFindChild = true
					a = parentA
					b = parentB
					break
				end
				if child == b then
					didFindChild = true
					b = parentA
					a = parentB
					break
				end
				child = child.sibling
			end
			if not didFindChild then
				-- Search parent B's child set
				child = parentB.child
				while child do
					if child == a then
						didFindChild = true
						a = parentB
						b = parentA
						break
					end
					if child == b then
						didFindChild = true
						b = parentB
						a = parentA
						break
					end
					child = child.sibling
				end
				invariant(
					didFindChild,
					"Child was not found in either parent set. This indicates a bug "
						.. "in React related to the return pointer. Please file an issue."
				)
			end
		end

		invariant(
			a.alternate == b,
			"Return fibers should always be each others' alternates. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end
	-- If the root is not a host container, we're in a disconnected tree. I.e.
	-- unmounted.
	invariant(a.tag == HostRoot, "Unable to find node on an unmounted component.")
	if a.stateNode.current == a then
		-- We've determined that A is the current branch.
		return fiber
	end
	-- Otherwise B has to be current branch.
	return alternate
end
exports.findCurrentFiberUsingSlowPath = findCurrentFiberUsingSlowPath

exports.findCurrentHostFiber = function(parent: Fiber): Fiber?
	local currentParent = findCurrentFiberUsingSlowPath(parent)
	if not currentParent then
		return nil
	end

	-- Next we'll drill down this component to find the first HostComponent/Text.
	-- ROBLOX FIXME Luau: Luau doesn't narrow based on above branch
	local node: Fiber = currentParent :: Fiber
	while true do
		local child = node.child
		if node.tag == HostComponent or node.tag == HostText then
			return node
		elseif child then
			child.return_ = node
			node = child
			continue
		end
		if node == currentParent then
			return nil
		end
		local return_ = node.return_
		local sibling = node.sibling
		while not sibling do
			if not return_ or return_ == currentParent then
				return nil
			end
			-- ROBLOX FIXME Luau: Luau doesn't narrow based on above branch
			node = return_ :: Fiber
		end
		-- ROBLOX FIXME Luau: Luau doesn't narrow based on above branch
		(sibling :: Fiber).return_ = return_ :: Fiber
		node = sibling :: Fiber
	end
	-- Flow needs the return nil here, but ESLint complains about it.
	-- eslint-disable-next-line no-unreachable
	return nil
end

exports.findCurrentHostFiberWithNoPortals = function(parent: Fiber): Fiber?
	local currentParent = findCurrentFiberUsingSlowPath(parent)
	if not currentParent then
		return nil
	end

	-- Next we'll drill down this component to find the first HostComponent/Text.
	local node: Fiber = currentParent :: Fiber
	while true do
		local child = node.child
		if
			node.tag == HostComponent
			or node.tag == HostText
			or (enableFundamentalAPI and node.tag == FundamentalComponent)
		then
			return node
		elseif child and node.tag ~= HostPortal then
			child.return_ = node
			node = child
			continue
		end
		if node == currentParent then
			return nil
		end
		local return_ = node.return_
		local sibling = node.sibling
		while not sibling do
			if not return_ or return_ == currentParent then
				return nil
			end
			-- ROBLOX FIXME Luau: Luau doesn't narrow based on above branch
			node = return_ :: Fiber
		end
		-- ROBLOX FIXME Luau: Luau doesn't narrow based on above branch
		(sibling :: Fiber).return_ = return_ :: Fiber
		node = sibling :: Fiber
	end
	-- Flow needs the return nil here, but ESLint complains about it.
	-- eslint-disable-next-line no-unreachable
	return nil
end

exports.isFiberSuspenseAndTimedOut = function(fiber: Fiber): boolean
	local memoizedState = fiber.memoizedState
	return fiber.tag == SuspenseComponent
		and memoizedState ~= nil
		and memoizedState.dehydrated == nil
end

exports.doesFiberContain = function(parentFiber: Fiber, childFiber: Fiber): boolean
	local node = childFiber
	local parentFiberAlternate = parentFiber.alternate
	while node ~= nil do
		if node == parentFiber or node == parentFiberAlternate then
			return true
		end
		-- ROBLOX FIXME Luau: Luau doesn't understand loop until not nil pattern
		node = node.return_ :: Fiber
	end
	return false
end

return exports ]]
cX.Children._94673b580e8de4bd6c416009e66fb113=d3
local d4

local d5={ClassName="ModuleScript",Children={},Properties={}}
d5.Name="ReactFiberUnwindWork.new"
d5.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberUnwindWork.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local resetMutableSourceWorkInProgressVersions =
	require(script.Parent["ReactMutableSource.new"]).resetWorkInProgressVersions
local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- local {ReactFiberFlags.DidCapture, ReactFiberFlags.NoFlags, ReactFiberFlags.ShouldCapture} = require(script.Parent.ReactFiberFlags)
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer

local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local popHostContainer = ReactFiberHostContext.popHostContainer
local popHostContext = ReactFiberHostContext.popHostContext
local popSuspenseContext =
	require(script.Parent["ReactFiberSuspenseContext.new"]).popSuspenseContext
local resetHydrationState =
	require(script.Parent["ReactFiberHydrationContext.new"]).resetHydrationState
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local popLegacyContext = ReactFiberContext.popContext
local popTopLevelLegacyContextObject = ReactFiberContext.popTopLevelContextObject
local popProvider = require(script.Parent["ReactFiberNewContext.new"]).popProvider
-- ROBLOX FIXME: this causes a circular require
local popRenderLanesRef
local popRenderLanes = function(...)
	if not popRenderLanesRef then
		popRenderLanesRef =
			require(script.Parent["ReactFiberWorkLoop.new"]).popRenderLanes
	end
	return popRenderLanesRef(...)
end
local transferActualDuration =
	require(script.Parent["ReactProfilerTimer.new"]).transferActualDuration

local invariant = require(Packages.Shared).invariant

local function unwindWork(workInProgress: Fiber, renderLanes: Lanes): Fiber?
	if workInProgress.tag == ReactWorkTags.ClassComponent then
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		local flags = workInProgress.flags
		if bit32.band(flags, ReactFiberFlags.ShouldCapture) ~= 0 then
			workInProgress.flags = bit32.bor(
				bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)),
				ReactFiberFlags.DidCapture
			)
			if
				enableProfilerTimer
				and bit32.band(workInProgress.mode, ReactTypeOfMode.ProfileMode)
					~= ReactTypeOfMode.NoMode
			then
				transferActualDuration(workInProgress)
			end
			return workInProgress
		end
		return nil
	elseif workInProgress.tag == ReactWorkTags.HostRoot then
		popHostContainer(workInProgress)
		popTopLevelLegacyContextObject(workInProgress)
		resetMutableSourceWorkInProgressVersions()
		local flags = workInProgress.flags
		invariant(
			bit32.band(flags, ReactFiberFlags.DidCapture) == ReactFiberFlags.NoFlags,
			"The root failed to unmount after an error. This is likely a bug in "
				.. "React. Please file an issue."
		)
		workInProgress.flags = bit32.bor(
			bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)),
			ReactFiberFlags.DidCapture
		)
		return workInProgress
	elseif workInProgress.tag == ReactWorkTags.HostComponent then
		-- TODO: popHydrationState
		popHostContext(workInProgress)
		return nil
	elseif workInProgress.tag == ReactWorkTags.SuspenseComponent then
		popSuspenseContext(workInProgress)
		if enableSuspenseServerRenderer then
			local suspenseState = workInProgress.memoizedState
			if suspenseState ~= nil and suspenseState.dehydrated ~= nil then
				invariant(
					workInProgress.alternate ~= nil,
					"Threw in newly mounted dehydrated component. This is likely a bug in "
						.. "React. Please file an issue."
				)
				resetHydrationState()
			end
		end
		local flags = workInProgress.flags
		if bit32.band(flags, ReactFiberFlags.ShouldCapture) ~= 0 then
			workInProgress.flags = bit32.bor(
				bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)),
				ReactFiberFlags.DidCapture
			)
			-- Captured a suspense effect. Re-render the boundary.
			if
				enableProfilerTimer
				and (
					bit32.band(workInProgress.mode, ReactTypeOfMode.ProfileMode)
					~= ReactTypeOfMode.NoMode
				)
			then
				transferActualDuration(workInProgress)
			end
			return workInProgress
		end
		return nil
	elseif workInProgress.tag == ReactWorkTags.SuspenseListComponent then
		popSuspenseContext(workInProgress)
		-- SuspenseList doesn't actually catch anything. It should've been
		-- caught by a nested boundary. If not, it should bubble through.
		return nil
	elseif workInProgress.tag == ReactWorkTags.HostPortal then
		popHostContainer(workInProgress)
		return nil
	elseif workInProgress.tag == ReactWorkTags.ContextProvider then
		popProvider(workInProgress)
		return nil
	elseif
		workInProgress.tag == ReactWorkTags.OffscreenComponent
		or workInProgress.tag == ReactWorkTags.LegacyHiddenComponent
	then
		popRenderLanes(workInProgress)
		return nil
	else
		return nil
	end
end

function unwindInterruptedWork(interruptedWork: Fiber)
	if interruptedWork.tag == ReactWorkTags.ClassComponent then
		-- ROBLOX deviation: Lua doesn't support properties on functions
		local childContextTypes
		if typeof(interruptedWork.type) == "table" then
			childContextTypes = interruptedWork.type.childContextTypes
		end
		if childContextTypes ~= nil then
			popLegacyContext(interruptedWork)
		end
	elseif interruptedWork.tag == ReactWorkTags.HostRoot then
		popHostContainer(interruptedWork)
		popTopLevelLegacyContextObject(interruptedWork)
		resetMutableSourceWorkInProgressVersions()
	elseif interruptedWork.tag == ReactWorkTags.HostComponent then
		popHostContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.HostPortal then
		popHostContainer(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.SuspenseComponent then
		popSuspenseContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.SuspenseListComponent then
		popSuspenseContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.ContextProvider then
		popProvider(interruptedWork)
	elseif
		interruptedWork.tag == ReactWorkTags.OffscreenComponent
		or interruptedWork.tag == ReactWorkTags.LegacyHiddenComponent
	then
		popRenderLanes(interruptedWork)
		return
	else -- default
		return
	end
end

return {
	unwindWork = unwindWork,
	unwindInterruptedWork = unwindInterruptedWork,
} ]]
cX.Children._8c92e6f087277f5f22344c739d2dd5d4=d5
local d6

local d7={ClassName="ModuleScript",Children={},Properties={}}
d7.Name="ReactFiberWorkInProgress"
d7.Properties.Source=[[ --!strict
-- ROBLOX deviation: this is an extraction of a single state field
-- (and associated mutation/getters) from ReactFiberWorkLooop.new
-- which allows us to break dependency cycles involving that module
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberWorkLoop.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local ReactFiberLane = require(script.Parent.ReactFiberLane)
local _workInProgressRootSkippedLanes: Lanes = ReactFiberLane.NoLanes
local mergeLanes = ReactFiberLane.mergeLanes
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane

local exports = {}

-- ROBLOX TODO: turn this into newindex property accessor
exports.workInProgressRootSkippedLanes = function(value: Lanes?): Lanes
	if value == nil then
		return _workInProgressRootSkippedLanes
	end

	-- ROBLOX FIXME Luau: Luau should narrow based on guard above
	_workInProgressRootSkippedLanes = value :: Lanes
	return _workInProgressRootSkippedLanes
end

exports.markSkippedUpdateLanes = function(lane: Lane | Lanes): ()
	_workInProgressRootSkippedLanes = mergeLanes(lane, _workInProgressRootSkippedLanes)
end

return exports ]]
cX.Children._16d9f6f65c8f3c841a8dba2cd6f4a303=d7
local d8

local d9={ClassName="ModuleScript",Children={},Properties={}}
d9.Name="ReactFiberWorkLoop.new"
d9.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberWorkLoop.new.js
--!nonstrict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local __DEV__ = _G.__DEV__
local __YOLO__ = _G.__YOLO__

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
type Set<T> = LuauPolyfill.Set<T>
type Array<T> = LuauPolyfill.Array<T>

local exports: any = {}

local ReactTypes = require(Packages.Shared)
type Thenable<T> = ReactTypes.Thenable<T>
type Wakeable = ReactTypes.Wakeable

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
-- The scheduler is imported here *only* to detect whether it's been mocked
local Scheduler = require(Packages.Scheduler)
-- ROBLOX deviation: we import from top-level Scheduler exports to avoid direct file access

type Interaction = Scheduler.Interaction

local ReactFiberSuspenseComponent =
	require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- deviation: Use some properties directly instead of localizing to avoid 200 limit
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local replayFailedUnitOfWorkWithInvokeGuardedCallback = ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback
-- local warnAboutUnmockedScheduler = ReactFeatureFlags.warnAboutUnmockedScheduler
-- local deferRenderPhaseUpdateToNextBatch = ReactFeatureFlags.ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
-- local decoupleUpdatePriorityFromScheduler = ReactFeatureFlags.ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local skipUnmountedBoundaries = ReactFeatureFlags.skipUnmountedBoundaries
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects
local ReactShared = require(Packages.Shared)
-- ROBLOX deviation: we pull in Dispatcher type because we need it for our lazy loading deviations to typecheck
type Dispatcher = ReactShared.Dispatcher
local describeError = require(Packages.Shared).describeError
local ReactSharedInternals = ReactShared.ReactSharedInternals
local invariant = ReactShared.invariant

local SchedulerWithReactIntegration =
	require(script.Parent["SchedulerWithReactIntegration.new"])
local scheduleCallback = SchedulerWithReactIntegration.scheduleCallback
local cancelCallback = SchedulerWithReactIntegration.cancelCallback
local getCurrentPriorityLevel = SchedulerWithReactIntegration.getCurrentPriorityLevel
local runWithPriority = SchedulerWithReactIntegration.runWithPriority
local shouldYield = SchedulerWithReactIntegration.shouldYield
local requestPaint = SchedulerWithReactIntegration.requestPaint
local now = SchedulerWithReactIntegration.now
local NoSchedulerPriority = SchedulerWithReactIntegration.NoPriority
local ImmediateSchedulerPriority = SchedulerWithReactIntegration.ImmediatePriority
local UserBlockingSchedulerPriority = SchedulerWithReactIntegration.UserBlockingPriority
local NormalSchedulerPriority = SchedulerWithReactIntegration.NormalPriority
local flushSyncCallbackQueue = SchedulerWithReactIntegration.flushSyncCallbackQueue
local scheduleSyncCallback = SchedulerWithReactIntegration.scheduleSyncCallback
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local {
--   DebugTracing.logCommitStarted,
--   DebugTracing.logCommitStopped,
--   DebugTracing.logLayoutEffectsStarted,
--   DebugTracing.logLayoutEffectsStopped,
--   logPassiveEffectsStarted,
--   DebugTracing.logPassiveEffectsStopped,
--   DebugTracing.logRenderStarted,
--   DebugTracing.logRenderStopped,
local DebugTracing = require(script.Parent.DebugTracing)
-- local {
--   SchedulingProfiler.markCommitStarted,
--   SchedulingProfiler.markCommitStopped,
--   SchedulingProfiler.markLayoutEffectsStarted,
--   SchedulingProfiler.markLayoutEffectsStopped,
--   SchedulingProfiler.markPassiveEffectsStarted,
--   SchedulingProfiler.markPassiveEffectsStopped,
--   SchedulingProfiler.markRenderStarted,
--   SchedulingProfiler.markRenderYielded,
--   SchedulingProfiler.markRenderStopped,
local SchedulingProfiler = require(script.Parent.SchedulingProfiler)

local SchedulerTracing = require(Packages.Scheduler).tracing
local __interactionsRef, __subscriberRef =
	SchedulerTracing.__interactionsRef, SchedulerTracing.__subscriberRef

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local prepareForCommit = ReactFiberHostConfig.prepareForCommit
-- local resetAfterCommit = ReactFiberHostConfig.resetAfterCommit
-- local scheduleTimeout = ReactFiberHostConfig.scheduleTimeout
-- local cancelTimeout = ReactFiberHostConfig.cancelTimeout
-- local noTimeout = ReactFiberHostConfig.noTimeout
-- local warnsIfNotActing = ReactFiberHostConfig.warnsIfNotActing
-- local beforeActiveInstanceBlur = ReactFiberHostConfig.beforeActiveInstanceBlur
-- local afterActiveInstanceBlur = ReactFiberHostConfig.afterActiveInstanceBlur
-- local clearContainer = ReactFiberHostConfig.clearContainer

local ReactFiber = require(script.Parent["ReactFiber.new"])
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local createWorkInProgress = ReactFiber.createWorkInProgress
-- local assignFiberPropertiesInDEV = ReactFiber.assignFiberPropertiesInDEV
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local NoMode = ReactTypeOfMode.NoMode
-- local StrictMode = ReactTypeOfMode.StrictMode
-- local ProfileMode = ReactTypeOfMode.ProfileMode
-- local BlockingMode = ReactTypeOfMode.BlockingMode
-- local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local HostRoot = ReactWorkTags.HostRoot
-- local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
-- local ClassComponent = ReactWorkTags.ClassComponent
-- local SuspenseComponent = ReactWorkTags.SuspenseComponent
-- local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
-- local FunctionComponent = ReactWorkTags.FunctionComponent
-- local ForwardRef = ReactWorkTags.ForwardRef
-- local MemoComponent = ReactWorkTags.MemoComponent
-- local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LegacyRoot = require(script.Parent.ReactRootTags).LegacyRoot
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
type Flags = ReactFiberFlags.Flags
-- ROBLOX deviation: Use properties directly instead of localizing to avoid 200 limit
-- local NoFlags = ReactFiberFlags.NoFlags
-- local Placement = ReactFiberFlags.Placement
-- local Incomplete = ReactFiberFlags.Incomplete
-- local HostEffectMask = ReactFiberFlags.HostEffectMask
-- local Hydrating = ReactFiberFlags.Hydrating
-- local BeforeMutationMask = ReactFiberFlags.BeforeMutationMask
-- local MutationMask = ReactFiberFlags.MutationMask
-- local LayoutMask = ReactFiberFlags.LayoutMask
-- local PassiveMask = ReactFiberFlags.PassiveMask
-- local NoLane = ReactFiberLane.NoLane
local SyncLane = ReactFiberLane.SyncLane
local SyncBatchedLane = ReactFiberLane.SyncBatchedLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local findUpdateLane = ReactFiberLane.findUpdateLane
local findTransitionLane = ReactFiberLane.findTransitionLane
local findRetryLane = ReactFiberLane.findRetryLane
local includesSomeLane = ReactFiberLane.includesSomeLane
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes
local removeLanes = ReactFiberLane.removeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane
local hasDiscreteLanes = ReactFiberLane.hasDiscreteLanes
local includesNonIdleWork = ReactFiberLane.includesNonIdleWork
local includesOnlyRetries = ReactFiberLane.includesOnlyRetries
local includesOnlyTransitions = ReactFiberLane.includesOnlyTransitions
local getNextLanes = ReactFiberLane.getNextLanes
local returnNextLanesPriority = ReactFiberLane.returnNextLanesPriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local markStarvedLanesAsExpired = ReactFiberLane.markStarvedLanesAsExpired
local getLanesToRetrySynchronouslyOnError =
	ReactFiberLane.getLanesToRetrySynchronouslyOnError
local getMostRecentEventTime = ReactFiberLane.getMostRecentEventTime
local markRootUpdated = ReactFiberLane.markRootUpdated
local markRootSuspended_dontCallThisOneDirectly = ReactFiberLane.markRootSuspended
local markRootPinged = ReactFiberLane.markRootPinged
local markRootExpired = ReactFiberLane.markRootExpired
local markDiscreteUpdatesExpired = ReactFiberLane.markDiscreteUpdatesExpired
local markRootFinished = ReactFiberLane.markRootFinished
local schedulerPriorityToLanePriority = ReactFiberLane.schedulerPriorityToLanePriority
local lanePriorityToSchedulerPriority = ReactFiberLane.lanePriorityToSchedulerPriority
local ReactFiberTransition = require(script.Parent.ReactFiberTransition)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local requestCurrentTransition = ReactFiberTransition.requestCurrentTransition
-- local NoTransition = ReactFiberTransition.NoTransition

local ReactFiberUnwindWork = require(script.Parent["ReactFiberUnwindWork.new"]) :: any
local unwindWork = ReactFiberUnwindWork.unwindWork
local unwindInterruptedWork = ReactFiberUnwindWork.unwindInterruptedWork
local ReactFiberThrow = require(script.Parent["ReactFiberThrow.new"]) :: any
local throwException = ReactFiberThrow.throwException
local createRootErrorUpdate = ReactFiberThrow.createRootErrorUpdate
local createClassErrorUpdate = ReactFiberThrow.createClassErrorUpdate
local ReactFiberCommitWork = require(script.Parent["ReactFiberCommitWork.new"])
local commitBeforeMutationEffectOnFiber =
	ReactFiberCommitWork.commitBeforeMutationLifeCycles
local commitPlacement = ReactFiberCommitWork.commitPlacement
local commitWork = ReactFiberCommitWork.commitWork
local commitDeletion = ReactFiberCommitWork.commitDeletion
local commitPassiveUnmountOnFiber = ReactFiberCommitWork.commitPassiveUnmount
local commitPassiveUnmountInsideDeletedTreeOnFiber =
	ReactFiberCommitWork.commitPassiveUnmountInsideDeletedTree
local commitPassiveMountOnFiber = ReactFiberCommitWork.commitPassiveMount
local commitDetachRef = ReactFiberCommitWork.commitDetachRef
-- local commitAttachRef = ReactFiberCommitWork.commitAttachRef
-- local commitResetTextContent = ReactFiberCommitWork.commitResetTextContent
-- local isSuspenseBoundaryBeingHidden = ReactFiberCommitWork.isSuspenseBoundaryBeingHidden
local invokeLayoutEffectMountInDEV = ReactFiberCommitWork.invokeLayoutEffectMountInDEV
local invokePassiveEffectMountInDEV = ReactFiberCommitWork.invokePassiveEffectMountInDEV
local invokeLayoutEffectUnmountInDEV = ReactFiberCommitWork.invokeLayoutEffectUnmountInDEV
local invokePassiveEffectUnmountInDEV =
	ReactFiberCommitWork.invokePassiveEffectUnmountInDEV
local recursivelyCommitLayoutEffects = ReactFiberCommitWork.recursivelyCommitLayoutEffects

local Promise = require(Packages.Promise)

local enqueueUpdate = require(script.Parent["ReactUpdateQueue.new"]).enqueueUpdate

local resetContextDependencies =
	require(script.Parent["ReactFiberNewContext.new"]).resetContextDependencies

-- ROBLOX deviation: Pre-declare function
local ensureRootIsScheduled

-- deviation: lazy init for functions from ReactFiberHooks, put in table b/c local var limit
local lazyInitRefs = {
	resetHooksAfterThrowRef = (nil :: any) :: (...any) -> ...any,
	ContextOnlyDispatcherRef = (nil :: any) :: Dispatcher,
	getIsUpdatingOpaqueValueInRenderPhaseInDEVRef = (nil :: any) :: (...any) -> ...any,
	originalBeginWorkRef = (nil :: any) :: (...any) -> ...any,
	completeWorkRef = (nil :: any) :: (...any) -> ...any,
}

-- ROBLOX deviation: lazy initialize beginwork to break cyclic dependencies
local originalBeginWork =
	function(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
		if not lazyInitRefs.originalBeginWorkRef then
			lazyInitRefs.originalBeginWorkRef =
				require(script.Parent["ReactFiberBeginWork.new"]).beginWork
		end
		return lazyInitRefs.originalBeginWorkRef(current, workInProgress, renderLanes)
	end

local completeWork =
	function(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
		if not lazyInitRefs.completeWorkRef then
			lazyInitRefs.completeWorkRef =
				require(script.Parent["ReactFiberCompleteWork.new"]).completeWork
		end
		return (lazyInitRefs.completeWorkRef :: any)(current, workInProgress, renderLanes)
	end

local ReactFiberHooks
-- ROBLOX deviation: lazy init for functions from ReactFiberHooks
local function initReactFiberHooks()
	ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
	lazyInitRefs.resetHooksAfterThrowRef = ReactFiberHooks.resetHooksAfterThrow
	lazyInitRefs.ContextOnlyDispatcherRef = ReactFiberHooks.ContextOnlyDispatcher
	lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef =
		ReactFiberHooks.getIsUpdatingOpaqueValueInRenderPhaseInDEV
end

-- ROBLOX deviation: lazy init for resetHooksAfterThrow from ReactFiberHooks
local resetHooksAfterThrow = function(): ()
	if not lazyInitRefs.resetHooksAfterThrowRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.resetHooksAfterThrowRef()
end

-- ROBLOX deviation: lazy init for ContextOnlyDispatcher from ReactFiberHooks
local ContextOnlyDispatcher = function(): Dispatcher
	if not lazyInitRefs.ContextOnlyDispatcherRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.ContextOnlyDispatcherRef
end

-- ROBLOX deviation: lazy init for getIsUpdatingOpaqueValueInRenderPhaseInDEV from ReactFiberHooks
local getIsUpdatingOpaqueValueInRenderPhaseInDEV = function(): boolean?
	if not lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef()
end

local createCapturedValue = require(script.Parent.ReactCapturedValue).createCapturedValue
local pushToStack = ReactFiberStack.push
local popFromStack = ReactFiberStack.pop
local createCursor = ReactFiberStack.createCursor

local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])

-- DEV stuff
local getComponentName = require(Packages.Shared).getComponentName
local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
-- deviation: these two properties would be captured as values instead of bound
-- local ReactCurrentDebugFiberIsRenderingInDEV = ReactCurrentFiber.isRendering
local ReactCurrentFiberCurrent = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local ReactErrorUtils = require(Packages.Shared).ReactErrorUtils
local invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback
local hasCaughtError = ReactErrorUtils.hasCaughtError
local clearCaughtError = ReactErrorUtils.clearCaughtError
local onCommitRootDevTools =
	require(script.Parent["ReactFiberDevToolsHook.new"]).onCommitRoot
local onCommitRootTestSelector = require(script.Parent.ReactTestSelectors).onCommitRoot

-- Used by `act`
local enqueueTask = require(Packages.Shared).enqueueTask
local doesFiberContain = require(script.Parent.ReactFiberTreeReflection).doesFiberContain

local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner
local IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing
local captureCommitPhaseErrorOnRoot, flushPassiveMountEffects

-- local ceil = math.ceil

-- ROBLOX deviation: Pre-declare functions
local mod: { [string]: any } = {}

type ExecutionContext = number

local NoContext = --\[\[                    \]\]
	0b0000000
local BatchedContext = --\[\[               \]\]
	0b0000001
local EventContext = --\[\[                 \]\]
	0b0000010
local DiscreteEventContext = --\[\[         \]\]
	0b0000100
local LegacyUnbatchedContext = --\[\[       \]\]
	0b0001000
local RenderContext = --\[\[                \]\]
	0b0010000
local CommitContext = --\[\[                \]\]
	0b0100000
local RetryAfterError = --\[\[              \]\]
	0b1000000

exports.NoContext = NoContext
exports.RetryAfterError = RetryAfterError

-- ROBLOX deviation: Luau doesn't yet support literal types
-- type RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5
type RootExitStatus = number
-- ROBLOX deviation: Define constants in a table instead of locals to avoid 200 limit
local RootExitStatus: { [string]: RootExitStatus } = {
	Incomplete = 0,
	FatalErrored = 1,
	Errored = 2,
	Suspended = 3,
	SuspendedWithDelay = 4,
	Completed = 5,
}

-- Describes where we are in the React execution stack
local executionContext: ExecutionContext = NoContext
-- The root we're working on
local workInProgressRoot: FiberRoot? = nil
-- The fiber we're working on
local workInProgress: Fiber? = nil
-- The lanes we're rendering
local workInProgressRootRenderLanes: Lanes = ReactFiberLane.NoLanes

-- Stack that allows components to change the render lanes for its subtree
-- This is a superset of the lanes we started working on at the root. The only
-- case where it's different from `workInProgressRootRenderLanes` is when we
-- enter a subtree that is hidden and needs to be unhidden: Suspense and
-- Offscreen component.
--
-- Most things in the work loop should deal with workInProgressRootRenderLanes.
-- Most things in begin/complete phases should deal with exports.subtreeRenderLanes.
exports.subtreeRenderLanes = ReactFiberLane.NoLanes
local subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(ReactFiberLane.NoLanes)

-- Whether to root completed, errored, suspended, etc.
local workInProgressRootExitStatus: RootExitStatus = RootExitStatus.Incomplete
-- A fatal error, if one is thrown
local workInProgressRootFatalError: any = nil
-- "Included" lanes refer to lanes that were worked on during this render. It's
-- slightly different than `renderLanes` because `renderLanes` can change as you
-- enter and exit an Offscreen tree. This value is the combination of all render
-- lanes for the entire render phase.
local workInProgressRootIncludedLanes: Lanes = ReactFiberLane.NoLanes
-- The work left over by components that were visited during this render. Only
-- includes unprocessed updates, not work in bailed out children.
local ReactFiberWorkInProgress = require(script.Parent.ReactFiberWorkInProgress)
local workInProgressRootSkippedLanes: (value: Lanes?) -> Lanes =
	ReactFiberWorkInProgress.workInProgressRootSkippedLanes --: Lanes = ReactFiberLane.NoLanes
-- Lanes that were updated (in an interleaved event) during this render.
local workInProgressRootUpdatedLanes: Lanes = ReactFiberLane.NoLanes
-- Lanes that were pinged (in an interleaved event) during this render.
local workInProgressRootPingedLanes: Lanes = ReactFiberLane.NoLanes

local mostRecentlyUpdatedRoot: FiberRoot | nil = nil

-- The most recent time we committed a fallback. This lets us ensure a train
-- model where we don't commit new loading states in too quick succession.
local globalMostRecentFallbackTime: number = 0
local FALLBACK_THROTTLE_MS: number = 500

-- The absolute time for when we should start giving up on rendering
-- more and prefer CPU suspense heuristics instead.
local workInProgressRootRenderTargetTime: number = math.huge
-- How long a render is supposed to take before we start following CPU
-- suspense heuristics and opt out of rendering more content.
local RENDER_TIMEOUT_MS = 500

-- Used to avoid traversing the return path to find the nearest Profiler ancestor during commit.
local nearestProfilerOnStack: Fiber | nil = nil

local function resetRenderTimer()
	workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS
end

exports.getRenderTargetTime = function(): number
	return workInProgressRootRenderTargetTime
end

local hasUncaughtError = false
local firstUncaughtError = nil
local legacyErrorBoundariesThatAlreadyFailed: Set<any> | nil = nil

local rootDoesHavePassiveEffects: boolean = false
local rootWithPendingPassiveEffects: FiberRoot? = nil
local pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority
local pendingPassiveEffectsLanes: Lanes = ReactFiberLane.NoLanes

local rootsWithPendingDiscreteUpdates: Set<ReactInternalTypes.FiberRoot> | nil = nil

-- Use these to prevent an infinite loop of nested updates
local NESTED_UPDATE_LIMIT = 50
local nestedUpdateCount: number = 0
local rootWithNestedUpdates: FiberRoot | nil = nil

local NESTED_PASSIVE_UPDATE_LIMIT = 50
local nestedPassiveUpdateCount: number = 0

-- Marks the need to reschedule pending interactions at these lanes
-- during the commit phase. This enables them to be traced across components
-- that spawn new work during render. E.g. hidden boundaries, suspended SSR
-- hydration or SuspenseList.
-- TODO: Can use a bitmask instead of an array
local spawnedWorkDuringRender: nil | Array<Lane | Lanes> = nil

-- If two updates are scheduled within the same event, we should treat their
-- event times as simultaneous, even if the actual clock time has advanced
-- between the first and second call.
local currentEventTime: number = NoTimestamp
local currentEventWipLanes: Lanes = ReactFiberLane.NoLanes
local currentEventPendingLanes: Lanes = ReactFiberLane.NoLanes

local focusedInstanceHandle: nil | Fiber = nil
local shouldFireAfterActiveInstanceBlur: boolean = false

exports.getWorkInProgressRoot = function(): FiberRoot?
	return workInProgressRoot
end

exports.requestEventTime = function()
	if
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext))
		~= NoContext
	then
		-- We're inside React, so it's fine to read the actual time.
		return now()
	end
	-- We're not inside React, so we may be in the middle of a browser event.
	if currentEventTime ~= NoTimestamp then
		-- Use the same start time for all updates until we enter React again.
		return currentEventTime
	end
	-- This is the first update since React yielded. Compute a new start time.
	currentEventTime = now()
	return currentEventTime
end

-- exports.getCurrentTime()
--   return now()
-- end

exports.requestUpdateLane = function(fiber: Fiber): Lane
	-- Special cases
	local mode = fiber.mode
	if bit32.band(mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
		return SyncLane :: Lane
	elseif bit32.band(mode, ReactTypeOfMode.ConcurrentMode) == ReactTypeOfMode.NoMode then
		return if getCurrentPriorityLevel() == ImmediateSchedulerPriority
			then SyncLane :: Lane
			else SyncBatchedLane :: Lane
	elseif
		not ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
		and bit32.band(executionContext, RenderContext) ~= NoContext
		and workInProgressRootRenderLanes ~= ReactFiberLane.NoLanes
	then
		-- This is a render phase update. These are not officially supported. The
		-- old behavior is to give this the same "thread" (expiration time) as
		-- whatever is currently rendering. So if you call `setState` on a component
		-- that happens later in the same render, it will flush. Ideally, we want to
		-- remove the special case and treat them as if they came from an
		-- interleaved event. Regardless, this pattern is not officially supported.
		-- This behavior is only a fallback. The flag only exists until we can roll
		-- out the setState warning, since existing code might accidentally rely on
		-- the current behavior.
		return pickArbitraryLane(workInProgressRootRenderLanes)
	end

	-- The algorithm for assigning an update to a lane should be stable for all
	-- updates at the same priority within the same event. To do this, the inputs
	-- to the algorithm must be the same. For example, we use the `renderLanes`
	-- to avoid choosing a lane that is already in the middle of rendering.
	--
	-- However, the "included" lanes could be mutated in between updates in the
	-- same event, like if you perform an update inside `flushSync`. Or any other
	-- code path that might call `prepareFreshStack`.
	--
	-- The trick we use is to cache the first of each of these inputs within an
	-- event. Then reset the cached values once we can be sure the event is over.
	-- Our heuristic for that is whenever we enter a concurrent work loop.
	--
	-- We'll do the same for `currentEventPendingLanes` below.
	if currentEventWipLanes == ReactFiberLane.NoLanes then
		currentEventWipLanes = workInProgressRootIncludedLanes
	end

	local isTransition = ReactFiberTransition.requestCurrentTransition()
		~= ReactFiberTransition.NoTransition
	if isTransition then
		if currentEventPendingLanes ~= ReactFiberLane.NoLanes then
			if mostRecentlyUpdatedRoot ~= nil then
				currentEventPendingLanes = mostRecentlyUpdatedRoot.pendingLanes
			else
				currentEventPendingLanes = ReactFiberLane.NoLanes
			end
		end
		return findTransitionLane(currentEventWipLanes, currentEventPendingLanes)
	end

	-- TODO: Remove this dependency on the Scheduler priority.
	-- To do that, we're replacing it with an update lane priority.
	local schedulerPriority = getCurrentPriorityLevel()

	-- The old behavior was using the priority level of the Scheduler.
	-- This couples React to the Scheduler internals, so we're replacing it
	-- with the currentUpdateLanePriority above. As an example of how this
	-- could be problematic, if we're not inside `Scheduler.runWithPriority`,
	-- then we'll get the priority of the current running Scheduler task,
	-- which is probably not what we want.
	local lane
	if
		-- TODO: Temporary. We're removing the concept of discrete updates.
		bit32.band(executionContext, DiscreteEventContext) ~= NoContext
		and schedulerPriority == UserBlockingSchedulerPriority
	then
		lane =
			findUpdateLane(ReactFiberLane.InputDiscreteLanePriority, currentEventWipLanes)
	else
		local schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority)

		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			-- In the new strategy, we will track the current update lane priority
			-- inside React and use that priority to select a lane for this update.
			-- For now, we're just logging when they're different so we can assess.
			local currentUpdateLanePriority = getCurrentUpdateLanePriority()

			if
				schedulerLanePriority ~= currentUpdateLanePriority
				and currentUpdateLanePriority ~= ReactFiberLane.NoLanePriority
			then
				if __DEV__ then
					console.error(
						"Expected current scheduler lane priority %s to match current update lane priority %s",
						tostring(schedulerLanePriority),
						tostring(currentUpdateLanePriority)
					)
				end
			end
		end

		lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes)
	end

	return lane
end

function requestRetryLane(fiber: Fiber): Lane
	-- This is a fork of `requestUpdateLane` designed specifically for Suspense
	-- "retries" — a special update that attempts to flip a Suspense boundary
	-- from its placeholder state to its primary/resolved state.

	-- Special cases
	local mode = fiber.mode
	if bit32.band(mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
		return SyncLane :: Lane
	elseif bit32.band(mode, ReactTypeOfMode.ConcurrentMode) == ReactTypeOfMode.NoMode then
		return if getCurrentPriorityLevel() == ImmediateSchedulerPriority
			then SyncLane :: Lane
			else SyncBatchedLane :: Lane
	end

	-- See `requestUpdateLane` for explanation of `currentEventWipLanes`
	if currentEventWipLanes == ReactFiberLane.NoLanes then
		currentEventWipLanes = workInProgressRootIncludedLanes
	end
	return findRetryLane(currentEventWipLanes)
end

exports.scheduleUpdateOnFiber = function(
	fiber: Fiber,
	lane: Lane,
	eventTime: number
): FiberRoot | nil
	mod.checkForNestedUpdates()

	local root = mod.markUpdateLaneFromFiberToRoot(fiber, lane)
	if root == nil then
		return nil
	end

	-- Mark that the root has a pending update.
	markRootUpdated(root, lane, eventTime)

	if root == workInProgressRoot then
		-- Received an update to a tree that's in the middle of rendering. Mark
		-- that there was an interleaved update work on this root. Unless the
		-- `ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
		-- phase update. In that case, we don't treat render phase updates as if
		-- they were interleaved, for backwards compat reasons.
		mod.warnAboutRenderPhaseUpdatesInDEV(fiber)

		if
			ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
			or bit32.band(executionContext, RenderContext) == NoContext
		then
			workInProgressRootUpdatedLanes =
				mergeLanes(workInProgressRootUpdatedLanes, lane)
		end
		if workInProgressRootExitStatus == RootExitStatus.SuspendedWithDelay then
			-- The root already suspended with a delay, which means this render
			-- definitely won't finish. Since we have a new update, let's mark it as
			-- suspended now, right before marking the incoming update. This has the
			-- effect of interrupting the current render and switching to the update.
			-- TODO: Make sure this doesn't override pings that happen while we've
			-- already started rendering.
			mod.markRootSuspended(root, workInProgressRootRenderLanes)
		end
	end

	-- TODO: requestUpdateLanePriority also reads the priority. Pass the
	-- priority as an argument to that function and this one.
	local priorityLevel = getCurrentPriorityLevel()

	if lane == SyncLane then
		if
			-- Check if we're inside unbatchedUpdates
			bit32.band(executionContext, LegacyUnbatchedContext) ~= NoContext
			-- Check if we're not already rendering
			and bit32.band(executionContext, bit32.bor(RenderContext, CommitContext))
				== NoContext
		then
			-- Register pending interactions on the root to avoid losing traced interaction data.
			mod.schedulePendingInteractions(root, lane)

			-- This is a legacy edge case. The initial mount of a ReactDOM.render-ed
			-- root inside of batchedUpdates should be synchronous, but layout updates
			-- should be deferred until the end of the batch.
			mod.performSyncWorkOnRoot(root)
		else
			ensureRootIsScheduled(root, eventTime)
			mod.schedulePendingInteractions(root, lane)
			if executionContext == NoContext then
				-- Flush the synchronous work now, unless we're already working or inside
				-- a batch. This is intentionally inside scheduleUpdateOnFiber instead of
				-- scheduleCallbackForFiber to preserve the ability to schedule a callback
				-- without immediately flushing it. We only do this for user-initiated
				-- updates, to preserve historical behavior of legacy mode.
				resetRenderTimer()
				flushSyncCallbackQueue()
			end
		end
	else
		-- Schedule a discrete update but only if it's not Sync.
		if
			bit32.band(executionContext, DiscreteEventContext) ~= NoContext
			-- Only updates at user-blocking priority or greater are considered
			-- discrete, even inside a discrete event.
			and (
				priorityLevel == UserBlockingSchedulerPriority
				or priorityLevel == ImmediateSchedulerPriority
			)
		then
			-- This is the result of a discrete event. Track the lowest priority
			-- discrete update per root so we can flush them early, if needed.
			if rootsWithPendingDiscreteUpdates == nil then
				rootsWithPendingDiscreteUpdates = Set.new({ root })
			else
				rootsWithPendingDiscreteUpdates:add(root)
			end
		end
		-- Schedule other updates after in case the callback is sync.
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, lane)
	end

	-- We use this when assigning a lane for a transition inside
	-- `requestUpdateLane`. We assume it's the same as the root being updated,
	-- since in the common case of a single root app it probably is. If it's not
	-- the same root, then it's not a huge deal, we just might batch more stuff
	-- together more than necessary.
	mostRecentlyUpdatedRoot = root
	return root
end

-- This is split into a separate function so we can mark a fiber with pending
-- work without treating it as a typical update that originates from an event
-- e.g. retrying a Suspense boundary isn't an update, but it does schedule work
-- on a fiber.
mod.markUpdateLaneFromFiberToRoot = function(sourceFiber: Fiber, lane: Lane): FiberRoot?
	-- Update the source fiber's lanes
	sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane)
	local alternate = sourceFiber.alternate
	if alternate ~= nil then
		alternate.lanes = mergeLanes(alternate.lanes, lane)
	end
	if __DEV__ then
		if
			alternate == nil
			and bit32.band(
					sourceFiber.flags,
					bit32.bor(ReactFiberFlags.Placement, ReactFiberFlags.Hydrating)
				)
				~= ReactFiberFlags.NoFlags
		then
			mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
		end
	end
	-- Walk the parent path to the root and update the child expiration time.
	local node = sourceFiber
	local parent = sourceFiber.return_
	while parent ~= nil do
		parent.childLanes = mergeLanes(parent.childLanes, lane)
		alternate = parent.alternate
		if alternate ~= nil then
			alternate.childLanes = mergeLanes(alternate.childLanes, lane)
		else
			if __DEV__ then
				if
					bit32.band(
						parent.flags,
						bit32.bor(ReactFiberFlags.Placement, ReactFiberFlags.Hydrating)
					) ~= ReactFiberFlags.NoFlags
				then
					mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
				end
			end
		end
		node = parent
		parent = parent.return_
	end
	if node.tag == ReactWorkTags.HostRoot then
		local root: FiberRoot = node.stateNode
		return root
	else
		return nil
	end
end

-- Use this function to schedule a task for a root. There's only one task per
-- root; if a task was already scheduled, we'll check to make sure the priority
-- of the existing task is the same as the priority of the next level that the
-- root has work on. This function is called on every update, and right before
-- exiting a task.
ensureRootIsScheduled = function(root: FiberRoot, currentTime: number)
	local existingCallbackNode = root.callbackNode

	-- Check if any lanes are being starved by other work. If so, mark them as
	-- expired so we know to work on those next.
	markStarvedLanesAsExpired(root, currentTime)

	-- Determine the next lanes to work on, and their priority.
	local lanes
	if root == workInProgressRoot then
		lanes = workInProgressRootRenderLanes
	else
		lanes = ReactFiberLane.NoLanes
	end
	local nextLanes = getNextLanes(root, lanes)
	-- This returns the priority level computed during the `getNextLanes` call.
	local newCallbackPriority = returnNextLanesPriority()

	if nextLanes == ReactFiberLane.NoLanes then
		-- Special case: There's nothing to work on.
		if existingCallbackNode ~= nil then
			cancelCallback(existingCallbackNode)
			root.callbackNode = nil
			root.callbackPriority = ReactFiberLane.NoLanePriority
		end
		return
	end

	-- Check if there's an existing task. We may be able to reuse it.
	if existingCallbackNode ~= nil then
		local existingCallbackPriority = root.callbackPriority
		if existingCallbackPriority == newCallbackPriority then
			-- The priority hasn't changed. We can reuse the existing task. Exit.
			return
		end
		-- The priority changed. Cancel the existing callback. We'll schedule a new
		-- one below.
		cancelCallback(existingCallbackNode)
	end

	-- Schedule a new callback.
	local newCallbackNode
	if newCallbackPriority == ReactFiberLane.SyncLanePriority then
		-- Special case: Sync React callbacks are scheduled on a special
		-- internal queue
		newCallbackNode = scheduleSyncCallback(function()
			return mod.performSyncWorkOnRoot(root)
		end)
	elseif newCallbackPriority == ReactFiberLane.SyncBatchedLanePriority then
		newCallbackNode = scheduleCallback(ImmediateSchedulerPriority, function()
			return mod.performSyncWorkOnRoot(root)
		end)
	else
		local schedulerPriorityLevel =
			lanePriorityToSchedulerPriority(newCallbackPriority)
		newCallbackNode = scheduleCallback(schedulerPriorityLevel, function()
			return mod.performConcurrentWorkOnRoot(root)
		end)
	end

	root.callbackPriority = newCallbackPriority
	root.callbackNode = newCallbackNode
end

-- This is the entry point for every concurrent task, i.e. anything that
-- goes through Scheduler.
-- ROBLOX Luau FIXME: Luau needs explicit annotation with nil-able returns
mod.performConcurrentWorkOnRoot = function(root): (() -> ...any) | nil
	-- Since we know we're in a React event, we can clear the current
	-- event time. The next update will compute a new event time.
	currentEventTime = NoTimestamp
	currentEventWipLanes = ReactFiberLane.NoLanes
	currentEventPendingLanes = ReactFiberLane.NoLanes

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	-- Flush any pending passive effects before deciding which lanes to work on,
	-- in case they schedule additional work.
	local originalCallbackNode = root.callbackNode
	local didFlushPassiveEffects = exports.flushPassiveEffects()
	if didFlushPassiveEffects then
		-- Something in the passive effect phase may have canceled the current task.
		-- Check if the task node for this root was changed.
		if root.callbackNode ~= originalCallbackNode then
			-- The current task was canceled. Exit. We don't need to call
			-- `ensureRootIsScheduled` because the check above implies either that
			-- there's a new task, or that there's no remaining work on this root.
			return nil
		else
			-- Current task was not canceled. Continue.
		end
	end

	-- Determine the next expiration time to work on, using the fields stored
	-- on the root.
	local lanes = getNextLanes(
		root,
		if root == workInProgressRoot
			then workInProgressRootRenderLanes
			else ReactFiberLane.NoLanes
	)
	if lanes == ReactFiberLane.NoLanes then
		-- Defensive coding. This is never expected to happen.
		return nil
	end

	local exitStatus = mod.renderRootConcurrent(root, lanes)

	if
		includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)
	then
		-- The render included lanes that were updated during the render phase.
		-- For example, when unhiding a hidden tree, we include all the lanes
		-- that were previously skipped when the tree was hidden. That set of
		-- lanes is a superset of the lanes we started rendering with.
		--
		-- So we'll throw out the current work and restart.
		mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
	elseif exitStatus ~= RootExitStatus.Incomplete then
		if exitStatus == RootExitStatus.Errored then
			executionContext = bit32.bor(executionContext, RetryAfterError)

			-- If an error occurred during hydration,
			-- discard server response and fall back to client side render.
			if root.hydrate then
				root.hydrate = false
				ReactFiberHostConfig.clearContainer(root.containerInfo)
			end

			-- If something threw an error, try rendering one more time. We'll render
			-- synchronously to block concurrent data mutations, and we'll includes
			-- all pending updates are included. If it still fails after the second
			-- attempt, we'll give up and commit the resulting tree.
			lanes = getLanesToRetrySynchronouslyOnError(root)
			if lanes ~= ReactFiberLane.NoLanes then
				exitStatus = mod.renderRootSync(root, lanes)
			end
		end

		if exitStatus == RootExitStatus.FatalErrored then
			local fatalError = workInProgressRootFatalError
			mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
			mod.markRootSuspended(root, lanes)
			ensureRootIsScheduled(root, now())
			error(fatalError)
		end

		-- We now have a consistent tree. The next step is either to commit it,
		-- or, if something suspended, wait to commit it after a timeout.
		local finishedWork: Fiber = root.current.alternate :: any
		root.finishedWork = finishedWork
		root.finishedLanes = lanes
		mod.finishConcurrentRender(root, exitStatus, lanes)
	end

	ensureRootIsScheduled(root, now())
	if root.callbackNode == originalCallbackNode then
		-- The task node scheduled for this root is the same one that's
		-- currently executed. Need to return a continuation.
		return function()
			return mod.performConcurrentWorkOnRoot(root)
		end
	end
	-- ROBLOX Luau FIXME: Luau shouldn't error on nil-able returns
	return nil :: any
end

-- we track the 'depth' of the act() calls with this counter,
-- so we can tell if any async act() calls try to run in parallel.
local actingUpdatesScopeDepth = 0
local didWarnAboutUsingActInProd = false

function shouldForceFlushFallbacksInDEV()
	-- Never force flush in production. This function should get stripped out.
	return __DEV__ and actingUpdatesScopeDepth > 0
end

mod.finishConcurrentRender = function(root, exitStatus, lanes)
	if
		exitStatus == RootExitStatus.Incomplete
		or exitStatus == RootExitStatus.FatalErrored
	then
		invariant(false, "Root did not complete. This is a bug in React.")
	-- Flow knows about invariant, so it complains if I add a break
	-- if I do. eslint-disable-next-line no-fallthrough
	-- statement, but eslint doesn't know about invariant, so it complains
	elseif exitStatus == RootExitStatus.Errored then
		-- We should have already attempted to retry this tree. If we reached
		-- this point, it errored again. Commit it.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.Suspended then
		mod.markRootSuspended(root, lanes)

		-- We have an acceptable loading state. We need to figure out if we
		-- should immediately commit it or wait a bit.
		if
			includesOnlyRetries(lanes)
			-- do not delay if we're inside an act() scope
			and not shouldForceFlushFallbacksInDEV()
		then
			-- This render only included retries, no updates. Throttle committing
			-- retries so that we don't show too many loading states too quickly.
			local msUntilTimeout = globalMostRecentFallbackTime
				+ FALLBACK_THROTTLE_MS
				- now()
			-- Don't bother with a very short suspense time.
			if msUntilTimeout > 10 then
				local nextLanes = getNextLanes(root, ReactFiberLane.NoLanes)
				if nextLanes ~= ReactFiberLane.NoLanes then
					-- There's additional work on this root.
					return
				end
				local suspendedLanes = root.suspendedLanes
				if not isSubsetOfLanes(suspendedLanes, lanes) then
					-- We should prefer to render the fallback of at the last
					-- suspended level. Ping the last suspended level to try
					-- rendering it again.
					-- FIXME: What if the suspended lanes are Idle? Should not restart.
					local eventTime = exports.requestEventTime()
					markRootPinged(root, suspendedLanes, eventTime)
					return
				end

				-- The render is suspended, it hasn't timed out, and there's no
				-- lower priority work to do. Instead of committing the fallback
				-- immediately, wait for more data to arrive.
				root.timeoutHandle = ReactFiberHostConfig.scheduleTimeout(function()
					return mod.commitRoot(root)
				end, msUntilTimeout)
				return
			end
		end
		-- The work expired. Commit immediately.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.SuspendedWithDelay then
		mod.markRootSuspended(root, lanes)

		if includesOnlyTransitions(lanes) then
			-- This is a transition, so we should exit without committing a
			-- placeholder and without scheduling a timeout. Delay indefinitely
			-- until we receive more data.
			return
		end

		if not shouldForceFlushFallbacksInDEV() then
			-- This is not a transition, but we did trigger an avoided state.
			-- Schedule a placeholder to display after a short delay, using the Just
			-- Noticeable Difference.
			-- TODO: Is the JND optimization worth the added complexity? If this is
			-- the only reason we track the event time, then probably not.
			-- Consider removing.

			local mostRecentEventTime = getMostRecentEventTime(root, lanes)
			local eventTimeMs = mostRecentEventTime
			local timeElapsedMs = now() - eventTimeMs
			local msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs

			-- Don't bother with a very short suspense time.
			if msUntilTimeout > 10 then
				-- Instead of committing the fallback immediately, wait for more data
				-- to arrive.
				root.timeoutHandle = ReactFiberHostConfig.scheduleTimeout(function()
					return mod.commitRoot(root)
				end, msUntilTimeout)
				return
			end
		end
		-- Commit the placeholder.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.Completed then
		-- The work completed. Ready to commit.
		mod.commitRoot(root)
	else
		invariant(false, "Unknown root exit status.")
	end
end

mod.markRootSuspended = function(root, suspendedLanes)
	-- When suspending, we should always exclude lanes that were pinged or (more
	-- rarely, since we try to avoid it) updated during the render phase.
	-- TODO: Lol maybe there's a better way to factor this besides this
	-- obnoxiously named function :)
	suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes)
	suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes)
	markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes)
end

-- This is the entry point for synchronous tasks that don't go
-- through Scheduler
mod.performSyncWorkOnRoot = function(root)
	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	exports.flushPassiveEffects()

	local lanes
	local exitStatus
	if
		root == workInProgressRoot
		and includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)
	then
		-- There's a partial tree, and at least one of its lanes has expired. Finish
		-- rendering it before rendering the rest of the expired work.
		lanes = workInProgressRootRenderLanes
		exitStatus = mod.renderRootSync(root, lanes)
		if
			includesSomeLane(
				workInProgressRootIncludedLanes,
				workInProgressRootUpdatedLanes
			)
		then
			-- The render included lanes that were updated during the render phase.
			-- For example, when unhiding a hidden tree, we include all the lanes
			-- that were previously skipped when the tree was hidden. That set of
			-- lanes is a superset of the lanes we started rendering with.
			--
			-- Note that this only happens when part of the tree is rendered
			-- concurrently. If the whole tree is rendered synchronously, then there
			-- are no interleaved events.
			lanes = getNextLanes(root, lanes)
			exitStatus = mod.renderRootSync(root, lanes)
		end
	else
		lanes = getNextLanes(root, ReactFiberLane.NoLanes)
		exitStatus = mod.renderRootSync(root, lanes)
	end

	if root.tag ~= LegacyRoot and exitStatus == RootExitStatus.Errored then
		executionContext = bit32.bor(executionContext, RetryAfterError)

		-- If an error occurred during hydration,
		-- discard server response and fall back to client side render.
		if root.hydrate then
			root.hydrate = false
			ReactFiberHostConfig.clearContainer(root.containerInfo)
		end

		-- If something threw an error, try rendering one more time. We'll render
		-- synchronously to block concurrent data mutations, and we'll includes
		-- all pending updates are included. If it still fails after the second
		-- attempt, we'll give up and commit the resulting tree.
		lanes = getLanesToRetrySynchronouslyOnError(root)
		if lanes ~= ReactFiberLane.NoLanes then
			exitStatus = mod.renderRootSync(root, lanes)
		end
	end

	if exitStatus == RootExitStatus.FatalErrored then
		local fatalError = workInProgressRootFatalError
		mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
		mod.markRootSuspended(root, lanes)
		ensureRootIsScheduled(root, now())
		error(fatalError)
	end

	-- We now have a consistent tree. Because this is a sync render, we
	-- will commit it even if something suspended.
	local finishedWork: Fiber = root.current.alternate :: any
	root.finishedWork = finishedWork
	root.finishedLanes = lanes
	mod.commitRoot(root)

	-- Before exiting, make sure there's a callback scheduled for the next
	-- pending level.
	ensureRootIsScheduled(root, now())

	return nil
end

exports.flushRoot = function(root: FiberRoot, lanes: Lanes)
	markRootExpired(root, lanes)
	ensureRootIsScheduled(root, now())
	if
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext))
		== NoContext
	then
		resetRenderTimer()
		flushSyncCallbackQueue()
	end
end

exports.getExecutionContext = function(): ExecutionContext
	return executionContext
end

exports.flushDiscreteUpdates = function()
	-- TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
	-- However, `act` uses `batchedUpdates`, so there's no way to distinguish
	-- those two cases. Need to fix this before exposing flushDiscreteUpdates
	-- as a public API.
	if
		bit32.band(
			executionContext,
			bit32.bor(BatchedContext, RenderContext, CommitContext)
		) ~= NoContext
	then
		if __DEV__ then
			if bit32.band(executionContext, RenderContext) ~= NoContext then
				console.error(
					"unstable_flushDiscreteUpdates: Cannot flush updates when React is "
						.. "already rendering."
				)
			end
		end
		-- We're already rendering, so we can't synchronously flush pending work.s
		-- This is probably a nested event dispatch triggered by a lifecycle/effect,
		-- like `el.focus()`. Exit.
		return
	end
	mod.flushPendingDiscreteUpdates()
	-- If the discrete updates scheduled passive effects, flush them now so that
	-- they fire before the next serial event.
	exports.flushPassiveEffects()
end

exports.deferredUpdates = function<A>(fn: () -> A): A
	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()
		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			-- ROBLOX performance: hoist non-throwable out of try{} to eliminate anon function
			setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority)
			ok, result =
				xpcall(runWithPriority, describeError, NormalSchedulerPriority, fn)
		else
			ok = true
			setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority)
			result = runWithPriority(NormalSchedulerPriority, fn)
		end

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)

		if ok then
			return result
		else
			error(result)
		end
	else
		return runWithPriority(NormalSchedulerPriority, fn)
	end
end

mod.flushPendingDiscreteUpdates = function()
	if rootsWithPendingDiscreteUpdates ~= nil then
		-- For each root with pending discrete updates, schedule a callback to
		-- immediately flush them.
		local roots = rootsWithPendingDiscreteUpdates
		rootsWithPendingDiscreteUpdates = nil
		roots:forEach(function(root)
			markDiscreteUpdatesExpired(root)
			ensureRootIsScheduled(root, now())
		end)
	end
	-- Now flush the immediate queue.
	flushSyncCallbackQueue()
end

exports.batchedUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, BatchedContext)

	-- ROBLOX deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.batchedEventUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, EventContext)

	-- ROBLOX deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.discreteUpdates =
	function<A, B, C, D, R>(fn: (A, B, C, D) -> R, a: A, b: B, c: C, d: D): R
		local prevExecutionContext = executionContext
		executionContext = bit32.bor(executionContext, DiscreteEventContext)

		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			local previousLanePriority = getCurrentUpdateLanePriority()
			-- ROBLOX performance: extract non-throwable fn call out of try{} so we can remove an anon function
			setCurrentUpdateLanePriority(ReactFiberLane.InputDiscreteLanePriority)
			local ok, result = xpcall(
				runWithPriority,
				describeError,
				UserBlockingSchedulerPriority,
				function()
					return fn(a, b, c, d)
				end
			)

			-- finally
			setCurrentUpdateLanePriority(previousLanePriority)
			executionContext = prevExecutionContext
			if executionContext == NoContext then
				-- Flush the immediate callbacks that were scheduled during this batch
				resetRenderTimer()
				flushSyncCallbackQueue()
			end

			if ok then
				return result
			else
				error(result)
			end
		else
			local ok, result = xpcall(
				runWithPriority,
				describeError,
				UserBlockingSchedulerPriority,
				function()
					return fn(a, b, c, d)
				end
			)

			-- finally
			executionContext = prevExecutionContext
			if executionContext == NoContext then
				-- Flush the immediate callbacks that were scheduled during this batch
				resetRenderTimer()
				flushSyncCallbackQueue()
			end

			if ok then
				return result
			else
				error(result)
			end
		end
	end

exports.unbatchedUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.band(executionContext, bit32.bnot(BatchedContext))
	executionContext = bit32.bor(executionContext, LegacyUnbatchedContext)
	-- ROBLOX deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.flushSync = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	if
		(bit32.band(prevExecutionContext, bit32.bor(RenderContext, CommitContext)))
		~= NoContext
	then
		if __DEV__ then
			console.error(
				"flushSync was called from inside a lifecycle method. React cannot "
					.. "flush when React is already rendering. Consider moving this call to "
					.. "a scheduler task or micro task."
			)
		end
		return fn(a)
	end
	executionContext = bit32.bor(executionContext, BatchedContext)

	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()

		-- ROBLOX performance: extract non-throwable call out of try{} to eliminate an anon function
		setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			if fn then
				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediateSchedulerPriority,
					function()
						return fn(a)
					end
				)
			else
				ok = true
				-- ROBLOX note: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		else
			ok = true
			setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
			if fn then
				result = runWithPriority(ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				-- ROBLOX note: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		end

		-- ROBLOX finally
		setCurrentUpdateLanePriority(previousLanePriority)
		executionContext = prevExecutionContext
		-- Flush the immediate callbacks that were scheduled during this batch.
		-- Note that this will happen even if batchedUpdates is higher up
		-- the stack.
		flushSyncCallbackQueue()

		if not ok then
			error(result)
		end
		return result
	else
		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			if fn then
				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediateSchedulerPriority,
					function()
						return fn(a)
					end
				)
			else
				ok = true
				-- ROBLOX note: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		else
			ok = true
			if fn then
				result = runWithPriority(ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				-- ROBLOX note: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		end
		-- ROBLOX: finally
		executionContext = prevExecutionContext
		-- Flush the immediate callbacks that were scheduled during this batch.
		-- Note that this will happen even if batchedUpdates is higher up
		-- the stack.
		flushSyncCallbackQueue()
		if not ok then
			error(result)
		end
		return result
	end
end

exports.flushControlled = function(fn: () -> any)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, BatchedContext)
	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()
		-- ROBLOX performance: extract non-throwable call out of try{} to eliminate an anon function
		setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		local ok, result =
			xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, fn)

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)

		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if not ok then
			error(result)
		end
	else
		local ok, result =
			xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, fn)
		-- finally
		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if not ok then
			error(result)
		end
	end
end

exports.pushRenderLanes = function(fiber: Fiber, lanes: Lanes)
	pushToStack(subtreeRenderLanesCursor, exports.subtreeRenderLanes, fiber)
	exports.subtreeRenderLanes = mergeLanes(exports.subtreeRenderLanes, lanes)
	workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes)
end

exports.popRenderLanes = function(fiber: Fiber)
	exports.subtreeRenderLanes = subtreeRenderLanesCursor.current
	popFromStack(subtreeRenderLanesCursor, fiber)
end

mod.prepareFreshStack = function(root: FiberRoot, lanes: Lanes)
	root.finishedWork = nil
	root.finishedLanes = ReactFiberLane.NoLanes

	local timeoutHandle = root.timeoutHandle
	if timeoutHandle ~= ReactFiberHostConfig.noTimeout then
		-- The root previous suspended and scheduled a timeout to commit a fallback
		-- state. Now that we have additional work, cancel the timeout.
		root.timeoutHandle = ReactFiberHostConfig.noTimeout
		-- $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
		ReactFiberHostConfig.cancelTimeout(timeoutHandle)
	end

	if workInProgress ~= nil then
		local interruptedWork = workInProgress.return_
		while interruptedWork ~= nil do
			unwindInterruptedWork(interruptedWork)
			interruptedWork = interruptedWork.return_
		end
	end
	workInProgressRoot = root
	workInProgress = ReactFiber.createWorkInProgress(root.current, nil)
	workInProgressRootRenderLanes = lanes
	exports.subtreeRenderLanes = lanes
	workInProgressRootIncludedLanes = lanes
	workInProgressRootExitStatus = RootExitStatus.Incomplete
	workInProgressRootFatalError = nil
	workInProgressRootSkippedLanes(ReactFiberLane.NoLanes)
	workInProgressRootUpdatedLanes = ReactFiberLane.NoLanes
	workInProgressRootPingedLanes = ReactFiberLane.NoLanes

	if ReactFeatureFlags.enableSchedulerTracing then
		spawnedWorkDuringRender = nil
	end

	if __DEV__ then
		ReactStrictModeWarnings.discardPendingWarnings()
	end
end

mod.handleError = function(root, thrownValue): ()
	while true do
		local erroredWork = workInProgress
		-- ROBLOX FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
		local ok, yetAnotherThrownValue = pcall(function()
			-- Reset module-level state that was set during the render phase.
			resetContextDependencies()
			resetHooksAfterThrow()
			resetCurrentDebugFiberInDEV()
			-- TODO: I found and added this missing line while investigating a
			-- separate issue. Write a regression test using string refs.
			ReactCurrentOwner.current = nil

			if erroredWork == nil or erroredWork.return_ == nil then
				-- Expected to be working on a non-root fiber. This is a fatal error
				-- because there's no ancestor that can handle it; the root is
				-- supposed to capture all errors that weren't caught by an error
				-- boundary.
				workInProgressRootExitStatus = RootExitStatus.FatalErrored
				workInProgressRootFatalError = thrownValue
				-- Set `workInProgress` to nil. This represents advancing to the next
				-- sibling, or the parent if there are no siblings. But since the root
				-- has no siblings nor a parent, we set it to nil. Usually this is
				-- handled by `completeUnitOfWork` or `unwindWork`, but since we're
				-- intentionally not calling those, we need set it here.
				-- TODO: Consider calling `unwindWork` to pop the contexts.
				workInProgress = nil
				-- ROBLOX FIXME: THIS IS A BUG, WE SHOULD BAIL ON THE OUTER FUNCTION -- NOT THE PCALL!
				return
			end

			-- ROBLOX Luau FIXME: Luau doesn't narrow based on the erroredWork == nil then return above
			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band(
						(erroredWork :: Fiber).mode,
						ReactTypeOfMode.ProfileMode
					)
					~= 0
			then
				-- Record the time spent rendering before an error was thrown. This
				-- avoids inaccurate Profiler durations in the case of a
				-- suspended render.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(
					erroredWork :: Fiber,
					true
				)
			end

			-- ROBLOX deviation, we pass in onUncaughtError and renderDidError here since throwException can't call them due to a require cycle
			throwException(
				root,
				(erroredWork :: Fiber).return_,
				erroredWork :: Fiber,
				thrownValue,
				workInProgressRootRenderLanes,
				exports.onUncaughtError,
				exports.renderDidError
			)
			mod.completeUnitOfWork(erroredWork)
		end)
		if not ok then
			-- Something in the return path also threw.
			thrownValue = yetAnotherThrownValue
			if workInProgress == erroredWork and erroredWork ~= nil then
				-- If this boundary has already errored, then we had trouble processing
				-- the error. Bubble it to the next boundary.
				erroredWork = erroredWork.return_
				workInProgress = erroredWork
			else
				erroredWork = workInProgress
			end
			continue
		end
		-- Return to the normal work loop.
		return
	end
end

mod.pushDispatcher = function()
	local prevDispatcher = ReactCurrentDispatcher.current

	-- ROBLOX deviation: lazy init of ContextOnlyDispatcher wrapped in a function
	ReactCurrentDispatcher.current = ContextOnlyDispatcher()
	if prevDispatcher == nil then
		-- The React isomorphic package does not include a default dispatcher.
		-- Instead the first renderer will lazily attach one, in order to give
		-- nicer error messages.

		-- ROBLOX deviation: lazy init of ContextOnlyDispatcher wrapped in a function
		return ContextOnlyDispatcher()
	else
		return prevDispatcher
	end
end

mod.popDispatcher = function(prevDispatcher)
	ReactCurrentDispatcher.current = prevDispatcher
end

mod.pushInteractions = function(root)
	if ReactFeatureFlags.enableSchedulerTracing then
		local prevInteractions: Set<Interaction>? = __interactionsRef.current
		__interactionsRef.current = root.memoizedInteractions
		return prevInteractions
	end
	return nil
end

mod.popInteractions = function(prevInteractions)
	if ReactFeatureFlags.enableSchedulerTracing then
		__interactionsRef.current = prevInteractions
	end
end

exports.markCommitTimeOfFallback = function(): ()
	globalMostRecentFallbackTime = now()
end

exports.markSkippedUpdateLanes = function(lane: Lane | Lanes): ()
	ReactFiberWorkInProgress.markSkippedUpdateLanes(lane)
end

exports.renderDidSuspend = function(): ()
	if workInProgressRootExitStatus == RootExitStatus.Incomplete then
		workInProgressRootExitStatus = RootExitStatus.Suspended
	end
end

exports.renderDidSuspendDelayIfPossible = function(): ()
	if
		workInProgressRootExitStatus == RootExitStatus.Incomplete
		or workInProgressRootExitStatus == RootExitStatus.Suspended
	then
		workInProgressRootExitStatus = RootExitStatus.SuspendedWithDelay
	end

	-- Check if there are updates that we skipped tree that might have unblocked
	-- this render.
	if
		workInProgressRoot ~= nil
		and (
			includesNonIdleWork(workInProgressRootSkippedLanes())
			or includesNonIdleWork(workInProgressRootUpdatedLanes)
		)
	then
		-- Mark the current render as suspended so that we switch to working on
		-- the updates that were skipped. Usually we only suspend at the end of
		-- the render phase.
		-- TODO: We should probably always mark the root as suspended immediately
		-- (inside this function), since by suspending at the end of the render
		-- phase introduces a potential mistake where we suspend lanes that were
		-- pinged or updated while we were rendering.
		mod.markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes)
	end
end

exports.renderDidError = function()
	if workInProgressRootExitStatus ~= RootExitStatus.Completed then
		workInProgressRootExitStatus = RootExitStatus.Errored
	end
end

-- Called during render to determine if anything has suspended.
-- Returns false if we're not sure.
exports.renderHasNotSuspendedYet = function(): boolean
	-- If something errored or completed, we can't really be sure,
	-- so those are false.
	return workInProgressRootExitStatus == RootExitStatus.Incomplete
end

mod.renderRootSync = function(root: FiberRoot, lanes: Lanes)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, RenderContext)
	local prevDispatcher = mod.pushDispatcher()

	-- If the root or lanes have changed, throw out the existing stack
	-- and prepare a fresh one. Otherwise we'll continue where we left off.
	if workInProgressRoot ~= root or workInProgressRootRenderLanes ~= lanes then
		mod.prepareFreshStack(root, lanes)
		mod.startWorkOnPendingInteractions(root, lanes)
	end

	local prevInteractions = mod.pushInteractions(root)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStarted(lanes)
	end

	while true do
		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, thrownValue
		if not __YOLO__ then
			ok, thrownValue = xpcall(mod.workLoopSync, describeError)
		else
			ok = true
			mod.workLoopSync()
		end

		if not ok then
			mod.handleError(root, thrownValue)
		else
			break
		end
	end
	resetContextDependencies()
	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
	end

	executionContext = prevExecutionContext
	mod.popDispatcher(prevDispatcher)

	if workInProgress ~= nil then
		-- This is a sync render, so we should have finished the whole tree.
		invariant(
			false,
			"Cannot commit an incomplete root. This error is likely caused by a "
				.. "bug in React. Please file an issue."
		)
	end

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStopped()
	end

	-- Set this to nil to indicate there's no in-progress render.
	workInProgressRoot = nil
	workInProgressRootRenderLanes = ReactFiberLane.NoLanes

	return workInProgressRootExitStatus
end

-- The work loop is an extremely hot path. Tell Closure not to inline it.
--\[\[* @noinline \]\]
mod.workLoopSync = function()
	-- Already timed out, so perform work without checking if we need to yield.
	while workInProgress ~= nil do
		mod.performUnitOfWork(workInProgress)
	end
end

mod.renderRootConcurrent = function(root: FiberRoot, lanes: Lanes)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, RenderContext)
	local prevDispatcher = mod.pushDispatcher()

	-- If the root or lanes have changed, throw out the existing stack
	-- and prepare a fresh one. Otherwise we'll continue where we left off.
	if workInProgressRoot ~= root or workInProgressRootRenderLanes ~= lanes then
		resetRenderTimer()
		mod.prepareFreshStack(root, lanes)
		mod.startWorkOnPendingInteractions(root, lanes)
	end

	local prevInteractions = mod.pushInteractions(root)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStarted(lanes)
	end

	while true do
		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, thrownValue
		if not __YOLO__ then
			-- ROBLOX deviation: when converting `try` to `pcall`, we can't use break inside it
			ok, thrownValue = xpcall(mod.workLoopConcurrent, describeError)
			if ok then
				thrownValue = "break"
			end
		else
			ok = true
			thrownValue = "break"
			mod.workLoopConcurrent()
		end

		if thrownValue == "break" then
			break
		end
		if not ok then
			mod.handleError(root, thrownValue)
		end
	end
	resetContextDependencies()
	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
	end

	mod.popDispatcher(prevDispatcher)
	executionContext = prevExecutionContext

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStopped()
		end
	end

	-- Check if the tree has completed.
	if workInProgress ~= nil then
		-- Still work remaining.
		if enableSchedulingProfiler then
			SchedulingProfiler.markRenderYielded()
		end
		return RootExitStatus.Incomplete
	else
		-- Completed the tree.
		if enableSchedulingProfiler then
			SchedulingProfiler.markRenderStopped()
		end

		-- Set this to nil to indicate there's no in-progress render.
		workInProgressRoot = nil
		workInProgressRootRenderLanes = ReactFiberLane.NoLanes

		-- Return the final exit status.
		return workInProgressRootExitStatus
	end
end

--\[\[* @noinline \]\]
mod.workLoopConcurrent = function()
	-- Perform work until Scheduler asks us to yield
	while workInProgress ~= nil and not shouldYield() do
		mod.performUnitOfWork(workInProgress)
	end
end

mod.performUnitOfWork = function(unitOfWork: Fiber): ()
	-- The current, flushed, state of this fiber is the alternate. Ideally
	-- nothing should rely on this, but relying on it here means that we don't
	-- need an additional field on the work in progress.
	local current = unitOfWork.alternate
	setCurrentDebugFiberInDEV(unitOfWork)

	local next_
	if
		ReactFeatureFlags.enableProfilerTimer
		and bit32.band(unitOfWork.mode, ReactTypeOfMode.ProfileMode)
			~= ReactTypeOfMode.NoMode
	then
		ReactProfilerTimer.startProfilerTimer(unitOfWork)
		next_ = mod.beginWork(current, unitOfWork, exports.subtreeRenderLanes)
		ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true)
	else
		next_ = mod.beginWork(current, unitOfWork, exports.subtreeRenderLanes)
	end

	resetCurrentDebugFiberInDEV()
	unitOfWork.memoizedProps = unitOfWork.pendingProps
	if next_ == nil then
		-- If this doesn't spawn new work, complete the current work.
		mod.completeUnitOfWork(unitOfWork)
	else
		workInProgress = next_
	end

	ReactCurrentOwner.current = nil
end

mod.completeUnitOfWork = function(unitOfWork: Fiber)
	-- Attempt to complete the current unit of work, then move to the next
	-- sibling. If there are no more siblings, return to the parent fiber.
	local completedWork = unitOfWork
	repeat
		-- The current, flushed, state of this fiber is the alternate. Ideally
		-- nothing should rely on this, but relying on it here means that we don't
		-- need an additional field on the work in progress.
		local current = completedWork.alternate
		local returnFiber = completedWork.return_

		-- Check if the work completed or if something threw.
		if
			bit32.band(completedWork.flags, ReactFiberFlags.Incomplete)
			== ReactFiberFlags.NoFlags
		then
			setCurrentDebugFiberInDEV(completedWork)
			local next_
			if
				not ReactFeatureFlags.enableProfilerTimer
				or bit32.band(completedWork.mode, ReactTypeOfMode.ProfileMode)
					== ReactTypeOfMode.NoMode
			then
				next_ = completeWork(current, completedWork, exports.subtreeRenderLanes)
			else
				ReactProfilerTimer.startProfilerTimer(completedWork)
				next_ = completeWork(current, completedWork, exports.subtreeRenderLanes)
				-- Update render duration assuming we didn't error.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(
					completedWork,
					false
				)
			end
			resetCurrentDebugFiberInDEV()

			if next_ ~= nil then
				-- Completing this fiber spawned new work. Work on that next.
				workInProgress = next_
				return
			end
		else
			-- This fiber did not complete because something threw. Pop values off
			-- the stack without entering the complete phase. If this is a boundary,
			-- capture values if possible.
			local next_ = unwindWork(completedWork, exports.subtreeRenderLanes)

			-- Because this fiber did not complete, don't reset its expiration time.

			if next_ ~= nil then
				-- If completing this work spawned new work, do that next. We'll come
				-- back here again.
				-- Since we're restarting, remove anything that is not a host effect
				-- from the effect tag.
				next_.flags = bit32.band(next_.flags, ReactFiberFlags.HostEffectMask)
				workInProgress = next_
				return
			end

			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band(completedWork.mode, ReactTypeOfMode.ProfileMode)
					~= ReactTypeOfMode.NoMode
			then
				-- Record the render duration for the fiber that errored.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(
					completedWork,
					false
				)

				-- Include the time spent working on failed children before continuing.
				-- ROBLOX TODO: actualDuration is nil-able and only populated with enableProfilerTimer. contribute default value upstream.
				local actualDuration = completedWork.actualDuration or 0
				local child = completedWork.child
				while child ~= nil do
					actualDuration += child.actualDuration or 0
					child = child.sibling
				end
				completedWork.actualDuration = actualDuration
			end

			if returnFiber ~= nil then
				-- Mark the parent fiber as incomplete
				returnFiber.flags =
					bit32.bor(returnFiber.flags, ReactFiberFlags.Incomplete)
				returnFiber.subtreeFlags = ReactFiberFlags.NoFlags
				returnFiber.deletions = nil
			end
		end

		local siblingFiber = completedWork.sibling
		if siblingFiber ~= nil then
			-- If there is more work to do in this returnFiber, do that next.
			workInProgress = siblingFiber
			return
		end
		-- Otherwise, return to the parent
		-- ROBLOX Luau FIXME: Luau doesn't understand that completedWork is only nil-able at this point in the control flow
		completedWork = returnFiber :: any
		-- Update the next thing we're working on in case something throws.
		workInProgress = completedWork
	until completedWork == nil

	-- We've reached the root.
	if workInProgressRootExitStatus == RootExitStatus.Incomplete then
		workInProgressRootExitStatus = RootExitStatus.Completed
	end
end

mod.commitRoot = function(root)
	local renderPriorityLevel = getCurrentPriorityLevel()
	runWithPriority(ImmediateSchedulerPriority, function()
		return mod.commitRootImpl(root, renderPriorityLevel)
	end)
	return nil
end

-- ROBLOX Luau FIXME: Luau doesn't infer root as FiberRoot via the callgraph from ensureRootIsScheduled(root: FiberRoot)
mod.commitRootImpl = function(root: FiberRoot, renderPriorityLevel)
	repeat
		-- `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
		-- means `flushPassiveEffects` will sometimes result in additional
		-- passive effects. So we need to keep flushing in a loop until there are
		-- no more pending effects.
		-- TODO: Might be better if `flushPassiveEffects` did not automatically
		-- flush synchronous work at the end, to avoid factoring hazards like this.
		exports.flushPassiveEffects()
	until rootWithPendingPassiveEffects == nil
	flushRenderPhaseStrictModeWarningsInDEV()

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	-- ROBLOX Luau FIXME: Luau doesn't narrow finishedWork based on the nil guard below
	local finishedWork = root.finishedWork :: Fiber
	local lanes = root.finishedLanes

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logCommitStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markCommitStarted(lanes)
	end

	if finishedWork == nil then
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logCommitStopped()
			end
		end

		if enableSchedulingProfiler then
			SchedulingProfiler.markCommitStopped()
		end

		return nil
	end
	root.finishedWork = nil
	root.finishedLanes = ReactFiberLane.NoLanes

	invariant(
		finishedWork ~= root.current,
		"Cannot commit the same tree as before. This error is likely caused by "
			.. "a bug in React. Please file an issue."
	)

	-- commitRoot never returns a continuation; it always finishes synchronously.
	-- So we can clear these now to allow a new callback to be scheduled.
	root.callbackNode = nil

	-- Update the first and last pending times on this root. The new first
	-- pending time is whatever is left on the root fiber.
	local remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes)
	markRootFinished(root, remainingLanes)

	-- Clear already finished discrete updates in case that a later call of
	-- `flushDiscreteUpdates` starts a useless render pass which may cancels
	-- a scheduled timeout.
	if rootsWithPendingDiscreteUpdates ~= nil then
		if
			not hasDiscreteLanes(remainingLanes)
			and rootsWithPendingDiscreteUpdates:has(root)
		then
			rootsWithPendingDiscreteUpdates:delete(root)
		end
	end

	if root == workInProgressRoot then
		-- We can reset these now that they are finished.
		workInProgressRoot = nil
		workInProgress = nil
		workInProgressRootRenderLanes = ReactFiberLane.NoLanes
	else
		-- This indicates that the last root we worked on is not the same one that
		-- we're committing now. This most commonly happens when a suspended root
		-- times out.
	end

	-- Check if there are any effects in the whole tree.
	-- TODO: This is left over from the effect list implementation, where we had
	-- to check for the existence of `firstEffect` to satsify Flow. I think the
	-- only other reason this optimization exists is because it affects profiling.
	-- Reconsider whether this is necessary.
	local subtreeHasEffects = bit32.band(
		finishedWork.subtreeFlags,
		bit32.bor(
			ReactFiberFlags.BeforeMutationMask,
			ReactFiberFlags.MutationMask,
			ReactFiberFlags.LayoutMask,
			ReactFiberFlags.PassiveMask
		)
	) ~= ReactFiberFlags.NoFlags
	local rootHasEffect = bit32.band(
		finishedWork.flags,
		bit32.bor(
			ReactFiberFlags.BeforeMutationMask,
			ReactFiberFlags.MutationMask,
			ReactFiberFlags.LayoutMask,
			ReactFiberFlags.PassiveMask
		)
	) ~= ReactFiberFlags.NoFlags

	if subtreeHasEffects or rootHasEffect then
		local previousLanePriority
		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			previousLanePriority = getCurrentUpdateLanePriority()
			setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		end

		local prevExecutionContext = executionContext
		executionContext = bit32.bor(executionContext, CommitContext)
		local prevInteractions = mod.pushInteractions(root)

		-- Reset this to nil before calling lifecycles
		ReactCurrentOwner.current = nil

		-- The commit phase is broken into several sub-phases. We do a separate pass
		-- of the effect list for each phase: all mutation effects come before all
		-- layout effects, and so on.

		-- The first phase a "before mutation" phase. We use this phase to read the
		-- state of the host tree right before we mutate it. This is where
		-- getSnapshotBeforeUpdate is called.
		focusedInstanceHandle = ReactFiberHostConfig.prepareForCommit(root.containerInfo)
		shouldFireAfterActiveInstanceBlur = false

		mod.commitBeforeMutationEffects(finishedWork)

		-- We no longer need to track the active instance fiber
		focusedInstanceHandle = nil

		if ReactFeatureFlags.enableProfilerTimer then
			-- Mark the current commit time to be shared by all Profilers in this
			-- batch. This enables them to be grouped later.
			ReactProfilerTimer.recordCommitTime()
		end

		-- The next phase is the mutation phase, where we mutate the host tree.
		mod.commitMutationEffects(finishedWork, root, renderPriorityLevel)

		if shouldFireAfterActiveInstanceBlur then
			ReactFiberHostConfig.afterActiveInstanceBlur()
		end
		ReactFiberHostConfig.resetAfterCommit(root.containerInfo)

		-- The work-in-progress tree is now the current tree. This must come after
		-- the mutation phase, so that the previous tree is still current during
		-- componentWillUnmount, but before the layout phase, so that the finished
		-- work is current during componentDidMount/Update.
		root.current = finishedWork

		-- The next phase is the layout phase, where we call effects that read
		-- the host tree after it's been mutated. The idiomatic use case for this is
		-- layout, but class component lifecycles also fire here for legacy reasons.
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logLayoutEffectsStarted(lanes)
			end
		end
		if enableSchedulingProfiler then
			SchedulingProfiler.markLayoutEffectsStarted(lanes)
		end

		if __DEV__ then
			setCurrentDebugFiberInDEV(finishedWork)
			invokeGuardedCallback(
				nil,
				recursivelyCommitLayoutEffects,
				nil,
				finishedWork,
				root,
				-- ROBLOX deviation: pass in this function to avoid dependency cycle
				exports.captureCommitPhaseError,
				exports.schedulePassiveEffectCallback
			)
			if hasCaughtError() then
				local err = clearCaughtError()
				captureCommitPhaseErrorOnRoot(finishedWork, finishedWork, err)
			end
			resetCurrentDebugFiberInDEV()
		else
			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok, result
			if not __YOLO__ then
				-- ROBLOX deviation: pass in captureCommitPhaseError and schedulePassiveEffectCallback to avoid dependency cycle
				ok, result = xpcall(
					recursivelyCommitLayoutEffects,
					describeError,
					finishedWork,
					root,
					exports.captureCommitPhaseError,
					exports.schedulePassiveEffectCallback
				)
			else
				ok = true
				recursivelyCommitLayoutEffects(
					finishedWork,
					root,
					exports.captureCommitPhaseError,
					exports.schedulePassiveEffectCallback
				)
			end

			if not ok then
				captureCommitPhaseErrorOnRoot(finishedWork, finishedWork, result)
			end
		end

		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logLayoutEffectsStopped()
			end
		end
		if enableSchedulingProfiler then
			SchedulingProfiler.markLayoutEffectsStopped()
		end

		-- If there are pending passive effects, schedule a callback to process them.
		if
			bit32.band(finishedWork.subtreeFlags, ReactFiberFlags.PassiveMask)
				~= ReactFiberFlags.NoFlags
			or bit32.band(finishedWork.flags, ReactFiberFlags.PassiveMask)
				~= ReactFiberFlags.NoFlags
		then
			if not rootDoesHavePassiveEffects then
				rootDoesHavePassiveEffects = true
				scheduleCallback(NormalSchedulerPriority, function()
					exports.flushPassiveEffects()
					return nil
				end)
			end
		end

		-- Tell Scheduler to yield at the end of the frame, so the browser has an
		-- opportunity to paint.
		requestPaint()

		if ReactFeatureFlags.enableSchedulerTracing then
			mod.popInteractions(prevInteractions)
		end
		executionContext = prevExecutionContext

		if
			ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
			and previousLanePriority ~= nil
		then
			-- Reset the priority to the previous non-sync value.
			setCurrentUpdateLanePriority(previousLanePriority)
		end
	else
		-- No effects.
		root.current = finishedWork
		-- Measure these anyway so the flamegraph explicitly shows that there were
		-- no effects.
		-- TODO: Maybe there's a better way to report this.
		if ReactFeatureFlags.enableProfilerTimer then
			ReactProfilerTimer.recordCommitTime()
		end
	end

	local rootDidHavePassiveEffects = rootDoesHavePassiveEffects

	if rootDoesHavePassiveEffects then
		-- This commit has passive effects. Stash a reference to them. But don't
		-- schedule a callback until after flushing layout work.
		rootDoesHavePassiveEffects = false
		rootWithPendingPassiveEffects = root
		pendingPassiveEffectsLanes = lanes
		pendingPassiveEffectsRenderPriority = renderPriorityLevel
	end

	-- Read this again, since an effect might have updated it
	remainingLanes = root.pendingLanes

	-- Check if there's remaining work on this root
	if remainingLanes ~= ReactFiberLane.NoLanes then
		if ReactFeatureFlags.enableSchedulerTracing then
			if spawnedWorkDuringRender ~= nil then
				local expirationTimes = spawnedWorkDuringRender
				spawnedWorkDuringRender = nil
				for i = 1, #expirationTimes do
					scheduleInteractions(
						root,
						expirationTimes[i],
						root.memoizedInteractions
					)
				end
			end
			mod.schedulePendingInteractions(root, remainingLanes)
		end
	else
		-- If there's no remaining work, we can clear the set of already failed
		-- error boundaries.
		legacyErrorBoundariesThatAlreadyFailed = nil
	end

	if __DEV__ and enableDoubleInvokingEffects then
		if not rootDidHavePassiveEffects then
			commitDoubleInvokeEffectsInDEV(root.current, false)
		end
	end

	if ReactFeatureFlags.enableSchedulerTracing then
		if not rootDidHavePassiveEffects then
			-- If there are no passive effects, then we can complete the pending interactions.
			-- Otherwise, we'll wait until after the passive effects are flushed.
			-- Wait to do this until after remaining work has been scheduled,
			-- so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
			mod.finishPendingInteractions(root, lanes)
		end
	end

	if remainingLanes == SyncLane then
		-- Count the number of times the root synchronously re-renders without
		-- finishing. If there are too many, it indicates an infinite update loop.
		if root == rootWithNestedUpdates then
			nestedUpdateCount += 1
		else
			nestedUpdateCount = 0
			rootWithNestedUpdates = root
		end
	else
		nestedUpdateCount = 0
	end

	onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel)

	if __DEV__ then
		onCommitRootTestSelector()
	end

	-- Always call this before exiting `commitRoot`, to ensure that any
	-- additional work on this root is scheduled.
	ensureRootIsScheduled(root, now())

	if hasUncaughtError then
		hasUncaughtError = false
		local error_ = firstUncaughtError
		firstUncaughtError = nil
		-- ROBLOX FIXME: we lose the original stack trace when we re-throw this way
		error(error_)
	end

	if bit32.band(executionContext, LegacyUnbatchedContext) ~= NoContext then
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logCommitStopped()
			end
		end

		if enableSchedulingProfiler then
			SchedulingProfiler.markCommitStopped()
		end

		-- This is a legacy edge case. We just committed the initial mount of
		-- a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
		-- synchronously, but layout updates should be deferred until the end
		-- of the batch.
		return nil
	end

	-- If layout work was scheduled, flush it now.
	flushSyncCallbackQueue()

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logCommitStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markCommitStopped()
	end

	return nil
end

mod.commitBeforeMutationEffects = function(firstChild: Fiber)
	local fiber = firstChild
	while fiber ~= nil do
		if fiber.deletions ~= nil then
			mod.commitBeforeMutationEffectsDeletions(fiber.deletions)
		end

		if fiber.child ~= nil then
			local primarySubtreeFlags =
				bit32.band(fiber.subtreeFlags, ReactFiberFlags.BeforeMutationMask)
			if primarySubtreeFlags ~= ReactFiberFlags.NoFlags then
				mod.commitBeforeMutationEffects(fiber.child)
			end
		end

		if __DEV__ then
			setCurrentDebugFiberInDEV(fiber)
			invokeGuardedCallback(nil, mod.commitBeforeMutationEffectsImpl, nil, fiber)
			if hasCaughtError() then
				local error_ = clearCaughtError()
				exports.captureCommitPhaseError(fiber, fiber.return_, error_)
			end
			resetCurrentDebugFiberInDEV()
		else
			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok, error_
			if not __YOLO__ then
				ok, error_ =
					xpcall(mod.commitBeforeMutationEffectsImpl, describeError, fiber)
			else
				ok = true
				mod.commitBeforeMutationEffectsImpl(fiber)
			end

			if not ok then
				exports.captureCommitPhaseError(fiber, fiber.return_, error_)
			end
		end
		-- ROBLOX Luau FIXME: Luau doesn't narrow correctly for the while ~= nil pattern
		fiber = fiber.sibling :: Fiber
	end
end

mod.commitBeforeMutationEffectsImpl = function(fiber: Fiber)
	local current = fiber.alternate
	local flags = fiber.flags

	if not shouldFireAfterActiveInstanceBlur and focusedInstanceHandle ~= nil then
		-- Check to see if the focused element was inside of a hidden (Suspense) subtree.
		-- TODO: Move this out of the hot path using a dedicated effect tag.
		if
			fiber.tag == ReactWorkTags.SuspenseComponent
			and ReactFiberCommitWork.isSuspenseBoundaryBeingHidden(current, fiber)
			and doesFiberContain(fiber, focusedInstanceHandle)
		then
			shouldFireAfterActiveInstanceBlur = true
			ReactFiberHostConfig.beforeActiveInstanceBlur()
		end
	end

	if bit32.band(flags, ReactFiberFlags.Snapshot) ~= ReactFiberFlags.NoFlags then
		setCurrentDebugFiberInDEV(fiber)
		commitBeforeMutationEffectOnFiber(current, fiber)
		resetCurrentDebugFiberInDEV()
	end

	if bit32.band(flags, ReactFiberFlags.Passive) ~= ReactFiberFlags.NoFlags then
		-- If there are passive effects, schedule a callback to flush at
		-- the earliest opportunity.
		if not rootDoesHavePassiveEffects then
			rootDoesHavePassiveEffects = true
			scheduleCallback(NormalSchedulerPriority, function()
				exports.flushPassiveEffects()
				return nil
			end)
		end
	end
end

mod.commitBeforeMutationEffectsDeletions = function(deletions: Array<Fiber>)
	for i = 1, #deletions do
		local fiber = deletions[i]

		-- TODO (effects) It would be nice to avoid calling doesFiberContain()
		-- Maybe we can repurpose one of the subtreeFlags positions for this instead?
		-- Use it to store which part of the tree the focused instance is in?
		-- This assumes we can safely determine that instance during the "render" phase.
		if doesFiberContain(fiber, (focusedInstanceHandle :: any) :: Fiber) then
			shouldFireAfterActiveInstanceBlur = true
			ReactFiberHostConfig.beforeActiveInstanceBlur()
		end
	end
end

mod.commitMutationEffects =
	function(firstChild: Fiber, root: FiberRoot, renderPriorityLevel: ReactPriorityLevel)
		local fiber = firstChild
		while fiber ~= nil do
			local deletions = fiber.deletions
			if deletions ~= nil then
				-- ROBLOX performance: React 18 inlines commitMutationEffectsDeletions, pulling that in based on tab switching hot path
				for _, childToDelete in deletions do
					-- ROBLOX FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
					local ok, error_ = xpcall(
						commitDeletion,
						describeError,
						root,
						childToDelete,
						fiber,
						renderPriorityLevel
					)
					if not ok then
						exports.captureCommitPhaseError(childToDelete, fiber, error_)
					end
				end
			end

			if fiber.child ~= nil then
				local mutationFlags =
					bit32.band(fiber.subtreeFlags, ReactFiberFlags.MutationMask)
				if mutationFlags ~= ReactFiberFlags.NoFlags then
					mod.commitMutationEffects(fiber.child, root, renderPriorityLevel)
				end
			end

			if __DEV__ then
				setCurrentDebugFiberInDEV(fiber)
				invokeGuardedCallback(
					nil,
					mod.commitMutationEffectsImpl,
					nil,
					fiber,
					root,
					renderPriorityLevel
				)
				if hasCaughtError() then
					local error_ = clearCaughtError()
					exports.captureCommitPhaseError(fiber, fiber.return_, error_)
				end
				resetCurrentDebugFiberInDEV()
			else
				-- ROBLOX deviation: YOLO flag for disabling pcall
				local ok, result
				if not __YOLO__ then
					ok, result = xpcall(
						mod.commitMutationEffectsImpl,
						describeError,
						fiber,
						root,
						renderPriorityLevel
					)
				else
					ok = true
					mod.commitMutationEffectsImpl(fiber, root, renderPriorityLevel)
				end
				if not ok then
					exports.captureCommitPhaseError(fiber, fiber.return_, result)
				end
			end
			-- ROBLOX Luau FIXME: Luau doesn't understand the while ~= nil construct
			fiber = fiber.sibling :: Fiber
		end
	end

mod.commitMutationEffectsImpl =
	function(fiber: Fiber, root: FiberRoot, renderPriorityLevel)
		local flags = fiber.flags
		-- ROBLOX performance: avoid always-false compare for Roblox renderer in hot path
		-- if bit32.band(flags, ReactFiberFlags.ContentReset) ~= 0 then
		--   unimplemented("commitResetTextContent")
		-- commitResetTextContent(fiber)
		-- end

		if bit32.band(flags, ReactFiberFlags.Ref) ~= 0 then
			local current = fiber.alternate
			if current ~= nil then
				commitDetachRef(current)
			end
			-- ROBLOX performance: avoid always-false compare for Roblox renderer in hot path
			-- if ReactFeatureFlags.enableScopeAPI then
			--   -- TODO: This is a temporary solution that allowed us to transition away from React Flare on www.
			--   if fiber.tag == ReactWorkTags.ScopeComponent then
			--     commitAttachRef(fiber)
			--   end
			-- end
		end

		-- The following switch statement is only concerned about placement,
		-- updates, and deletions. To avoid needing to add a case for every possible
		-- bitmap value, we remove the secondary effects from the effect tag and
		-- switch on that value.
		local primaryFlags = bit32.band(
			flags,
			bit32.bor(
				ReactFiberFlags.Placement,
				ReactFiberFlags.Update,
				ReactFiberFlags.Hydrating
			)
		)
		if primaryFlags == ReactFiberFlags.Placement then
			commitPlacement(fiber)
			-- Clear the "placement" from effect tag so that we know that this is
			-- inserted, before any life-cycles like componentDidMount gets called.
			-- TODO: findDOMNode doesn't rely on this any more but isMounted does
			-- and isMounted is deprecated anyway so we should be able to kill this.
			fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Placement))
		elseif primaryFlags == ReactFiberFlags.PlacementAndUpdate then
			-- Placement
			commitPlacement(fiber)
			-- Clear the "placement" from effect tag so that we know that this is
			-- inserted, before any life-cycles like componentDidMount gets called.
			fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Placement))

			-- Update
			local current = fiber.alternate
			commitWork(current, fiber)
		-- ROBLOX performance: avoid always-false compare for Roblox renderer in hot path
		-- elseif primaryFlags == ReactFiberFlags.Hydrating then
		--   fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Hydrating))
		-- elseif primaryFlags == ReactFiberFlags.HydratingAndUpdate then
		--   fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Hydrating))
		--   -- Update
		--   local current = fiber.alternate
		--   commitWork(current, fiber)
		elseif primaryFlags == ReactFiberFlags.Update then
			local current = fiber.alternate
			commitWork(current, fiber)
		end
	end

mod.commitMutationEffectsDeletions =
	function(deletions: Array<Fiber>, fiber: Fiber, root: FiberRoot, renderPriorityLevel)
		-- ROBLOX performance: align to React 18, which ditches the __DEV__ branch and use of invokeGuardedCallback
		for _, childToDelete in deletions do
			-- ROBLOX FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
			local ok, error_ = xpcall(
				commitDeletion,
				describeError,
				root,
				childToDelete,
				fiber,
				renderPriorityLevel
			)
			if not ok then
				exports.captureCommitPhaseError(childToDelete, fiber, error_)
			end
		end
	end

exports.schedulePassiveEffectCallback = function()
	if not rootDoesHavePassiveEffects then
		rootDoesHavePassiveEffects = true
		scheduleCallback(NormalSchedulerPriority, function()
			exports.flushPassiveEffects()
			return nil
		end)
	end
end

-- deviation: Pre-declare functions
local flushPassiveEffectsImpl
exports.flushPassiveEffects = function(): boolean
	-- Returns whether passive effects were flushed.
	if pendingPassiveEffectsRenderPriority ~= NoSchedulerPriority then
		local priorityLevel = if pendingPassiveEffectsRenderPriority
				> NormalSchedulerPriority
			then NormalSchedulerPriority
			else pendingPassiveEffectsRenderPriority
		pendingPassiveEffectsRenderPriority = NoSchedulerPriority
		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			local previousLanePriority = getCurrentUpdateLanePriority()

			-- ROBLOX performance: extract non-throwable function from try{} to remove need for anon function
			setCurrentUpdateLanePriority(schedulerPriorityToLanePriority(priorityLevel))
			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok, result
			if not __YOLO__ then
				ok, result = xpcall(
					runWithPriority,
					describeError,
					priorityLevel,
					flushPassiveEffectsImpl
				)
			else
				ok = true
				setCurrentUpdateLanePriority(
					schedulerPriorityToLanePriority(priorityLevel)
				)
				result = runWithPriority(priorityLevel, flushPassiveEffectsImpl)
			end

			-- finally
			setCurrentUpdateLanePriority(previousLanePriority)

			if not ok then
				error(result)
			end
			return result
		else
			return runWithPriority(priorityLevel, flushPassiveEffectsImpl)
		end
	end
	return false
end

flushPassiveMountEffects = function(root, firstChild: Fiber): ()
	local fiber = firstChild
	while fiber ~= nil do
		local prevProfilerOnStack = nil
		if
			ReactFeatureFlags.enableProfilerTimer
			and ReactFeatureFlags.enableProfilerCommitHooks
		then
			if fiber.tag == ReactWorkTags.Profiler then
				prevProfilerOnStack = nearestProfilerOnStack
				nearestProfilerOnStack = fiber
			end
		end

		local primarySubtreeFlags =
			bit32.band(fiber.subtreeFlags, ReactFiberFlags.PassiveMask)

		if fiber.child ~= nil and primarySubtreeFlags ~= ReactFiberFlags.NoFlags then
			flushPassiveMountEffects(root, fiber.child)
		end

		if
			bit32.band(fiber.flags, ReactFiberFlags.Passive) ~= ReactFiberFlags.NoFlags
		then
			if __DEV__ then
				setCurrentDebugFiberInDEV(fiber)
				invokeGuardedCallback(nil, commitPassiveMountOnFiber, nil, root, fiber)
				if hasCaughtError() then
					local error_ = clearCaughtError()
					exports.captureCommitPhaseError(fiber, fiber.return_, error_)
				end
				resetCurrentDebugFiberInDEV()
			else
				-- ROBLOX deviation: YOLO flag for disabling pcall
				local ok, error_
				if not __YOLO__ then
					ok, error_ =
						xpcall(commitPassiveMountOnFiber, describeError, root, fiber)
				else
					ok = true
					commitPassiveMountOnFiber(root, fiber)
				end

				if not ok then
					exports.captureCommitPhaseError(fiber, fiber.return_, error_)
				end
			end
		end

		if
			ReactFeatureFlags.enableProfilerTimer
			and ReactFeatureFlags.enableProfilerCommitHooks
		then
			if fiber.tag == ReactWorkTags.Profiler then
				-- Bubble times to the next nearest ancestor Profiler.
				-- After we process that Profiler, we'll bubble further up.
				if prevProfilerOnStack ~= nil then
					prevProfilerOnStack.stateNode.passiveEffectDuration += fiber.stateNode.passiveEffectDuration
				end

				nearestProfilerOnStack = prevProfilerOnStack
			end
		end

		-- ROBLOX Luau FIXME: Luau doesn't understand the loop ~= nil construct
		fiber = fiber.sibling :: Fiber
	end
end

local function flushPassiveUnmountEffects(firstChild: Fiber): ()
	local fiber = firstChild
	while fiber ~= nil do
		local deletions = fiber.deletions
		if deletions ~= nil then
			for i = 1, #deletions do
				local fiberToDelete = deletions[i]
				mod.flushPassiveUnmountEffectsInsideOfDeletedTree(fiberToDelete, fiber)

				-- Now that passive effects have been processed, it's safe to detach lingering pointers.
				mod.detachFiberAfterEffects(fiberToDelete)
			end
		end

		local child = fiber.child
		if child ~= nil then
			-- If any children have passive effects then traverse the subtree.
			-- Note that this requires checking subtreeFlags of the current Fiber,
			-- rather than the subtreeFlags/effectsTag of the first child,
			-- since that would not cover passive effects in siblings.
			local passiveFlags =
				bit32.band(fiber.subtreeFlags, ReactFiberFlags.PassiveMask)
			if passiveFlags ~= ReactFiberFlags.NoFlags then
				flushPassiveUnmountEffects(child)
			end
		end

		local primaryFlags = bit32.band(fiber.flags, ReactFiberFlags.Passive)
		if primaryFlags ~= ReactFiberFlags.NoFlags then
			setCurrentDebugFiberInDEV(fiber)
			commitPassiveUnmountOnFiber(fiber)
			resetCurrentDebugFiberInDEV()
		end

		-- ROBLOX FIXME Luau: Luau doesn't understand the loop ~= nil construct
		fiber = fiber.sibling :: Fiber
	end
end

mod.flushPassiveUnmountEffectsInsideOfDeletedTree =
	function(fiberToDelete: Fiber, nearestMountedAncestor: Fiber)
		if
			bit32.band(fiberToDelete.subtreeFlags, ReactFiberFlags.PassiveStatic)
			~= ReactFiberFlags.NoFlags
		then
			-- If any children have passive effects then traverse the subtree.
			-- Note that this requires checking subtreeFlags of the current Fiber,
			-- rather than the subtreeFlags/effectsTag of the first child,
			-- since that would not cover passive effects in siblings.
			local child = fiberToDelete.child
			while child ~= nil do
				mod.flushPassiveUnmountEffectsInsideOfDeletedTree(
					child,
					nearestMountedAncestor
				)
				child = child.sibling
			end
		end

		if
			bit32.band(fiberToDelete.flags, ReactFiberFlags.PassiveStatic)
			~= ReactFiberFlags.NoFlags
		then
			setCurrentDebugFiberInDEV(fiberToDelete)
			commitPassiveUnmountInsideDeletedTreeOnFiber(
				fiberToDelete,
				nearestMountedAncestor
			)
			resetCurrentDebugFiberInDEV()
		end
	end

flushPassiveEffectsImpl = function()
	if rootWithPendingPassiveEffects == nil then
		return false
	end

	-- ROBLOX Luau FIXME: Luau doesn't narrow to non-nil with the guard above
	local root = rootWithPendingPassiveEffects :: FiberRoot
	local lanes = pendingPassiveEffectsLanes
	rootWithPendingPassiveEffects = nil
	pendingPassiveEffectsLanes = ReactFiberLane.NoLanes

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Cannot flush passive effects while already rendering."
	)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logPassiveEffectsStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markPassiveEffectsStarted(lanes)
	end

	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, CommitContext)
	local prevInteractions = mod.pushInteractions(root)

	-- It's important that ALL pending passive effect destroy functions are called
	-- before ANY passive effect create functions are called.
	-- Otherwise effects in sibling components might interfere with each other.
	-- e.g. a destroy function in one component may unintentionally override a ref
	-- value set by a create function in another component.
	-- Layout effects have the same constraint.
	flushPassiveUnmountEffects(root.current)
	flushPassiveMountEffects(root, root.current)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logPassiveEffectsStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markPassiveEffectsStopped()
	end

	if __DEV__ and enableDoubleInvokingEffects then
		commitDoubleInvokeEffectsInDEV(root.current, true)
	end

	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
		mod.finishPendingInteractions(root, lanes)
	end

	executionContext = prevExecutionContext

	flushSyncCallbackQueue()

	-- If additional passive effects were scheduled, increment a counter. If this
	-- exceeds the limit, we'll fire a warning.
	if rootWithPendingPassiveEffects == nil then
		nestedPassiveUpdateCount = 0
	else
		nestedPassiveUpdateCount = nestedPassiveUpdateCount + 1
	end

	return true
end

exports.isAlreadyFailedLegacyErrorBoundary = function(instance): boolean
	return
		legacyErrorBoundariesThatAlreadyFailed ~= nil
			and legacyErrorBoundariesThatAlreadyFailed:has(instance)
end

exports.markLegacyErrorBoundaryAsFailed = function(instance)
	if legacyErrorBoundariesThatAlreadyFailed == nil then
		legacyErrorBoundariesThatAlreadyFailed = Set.new({ instance })
	else
		legacyErrorBoundariesThatAlreadyFailed:add(instance)
	end
end

-- ROBLOX TODO: this function and the related fields should be extracted/relocated to break a cycle
local function prepareToThrowUncaughtError(error_)
	if not hasUncaughtError then
		hasUncaughtError = true
		firstUncaughtError = error_
	end
end
exports.onUncaughtError = prepareToThrowUncaughtError

captureCommitPhaseErrorOnRoot = function(rootFiber: Fiber, sourceFiber: Fiber, error_)
	local errorInfo = createCapturedValue(error_, sourceFiber)
	-- ROBLOX deviation: parameterize method onUncaughtError to avoid circular dependency
	local update =
		createRootErrorUpdate(rootFiber, errorInfo, SyncLane, exports.onUncaughtError)
	enqueueUpdate(rootFiber, update)
	local eventTime = exports.requestEventTime()
	local root = mod.markUpdateLaneFromFiberToRoot(rootFiber, SyncLane)
	if root ~= nil then
		markRootUpdated(root, SyncLane, eventTime)
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, SyncLane)
	end
end

-- exports.captureCommitPhaseError(
--   sourceFiber: Fiber,
--   nearestMountedAncestor: Fiber | nil,
--   error: mixed
-- )
exports.captureCommitPhaseError =
	function(sourceFiber: Fiber, nearestMountedAncestor, error_)
		if sourceFiber.tag == ReactWorkTags.HostRoot then
			-- Error was thrown at the root. There is no parent, so the root
			-- itself should capture it.
			captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error_)
			return
		end

		local fiber = nil
		if skipUnmountedBoundaries then
			fiber = nearestMountedAncestor
		else
			fiber = sourceFiber.return_
		end

		while fiber ~= nil do
			if fiber.tag == ReactWorkTags.HostRoot then
				captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error_)
				return
			else
				if fiber.tag == ReactWorkTags.ClassComponent then
					local ctor = fiber.type
					local instance = fiber.stateNode
					if
						typeof(ctor.getDerivedStateFromError) == "function"
						or (
							typeof(instance.componentDidCatch) == "function"
							and not exports.isAlreadyFailedLegacyErrorBoundary(instance)
						)
					then
						local errorInfo = createCapturedValue(error_, sourceFiber)
						local update = createClassErrorUpdate(fiber, errorInfo, SyncLane)
						enqueueUpdate(fiber, update)
						local eventTime = exports.requestEventTime()
						local root = mod.markUpdateLaneFromFiberToRoot(fiber, SyncLane)
						if root ~= nil then
							markRootUpdated(root, SyncLane, eventTime)
							ensureRootIsScheduled(root, eventTime)
							mod.schedulePendingInteractions(root, SyncLane)
						end
						return
					end
				end
				fiber = fiber.return_
			end
		end
	end

exports.pingSuspendedRoot =
	function(root: FiberRoot, wakeable: Wakeable, pingedLanes: Lanes)
		local pingCache = root.pingCache
		if pingCache ~= nil then
			-- The wakeable resolved, so we no longer need to memoize, because it will
			-- never be thrown again.
			pingCache[wakeable] = nil
		end

		local eventTime = exports.requestEventTime()
		markRootPinged(root, pingedLanes, eventTime)

		if
			workInProgressRoot == root
			and isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)
		then
			-- Received a ping at the same priority level at which we're currently
			-- rendering. We might want to restart this render. This should mirror
			-- the logic of whether or not a root suspends once it completes.

			-- TODO: If we're rendering sync either due to Sync, Batched or expired,
			-- we should probably never restart.

			-- If we're suspended with delay, or if it's a retry, we'll always suspend
			-- so we can always restart.
			if
				workInProgressRootExitStatus == RootExitStatus.SuspendedWithDelay
				or workInProgressRootExitStatus == RootExitStatus.Suspended
					and includesOnlyRetries(workInProgressRootRenderLanes)
					and now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS
			then
				-- Restart from the root.
				mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
			else
				-- Even though we can't restart right now, we might get an
				-- opportunity later. So we mark this render as having a ping.
				workInProgressRootPingedLanes =
					mergeLanes(workInProgressRootPingedLanes, pingedLanes)
			end
		end

		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, pingedLanes)
	end

function retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane)
	-- The boundary fiber (a Suspense component or SuspenseList component)
	-- previously was rendered in its fallback state. One of the promises that
	-- suspended it has resolved, which means at least part of the tree was
	-- likely unblocked. Try rendering again, at a new expiration time.
	if retryLane == ReactFiberLane.NoLane then
		retryLane = requestRetryLane(boundaryFiber)
	end
	-- TODO: Special case idle priority?
	local eventTime = exports.requestEventTime()
	local root = mod.markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane)
	if root ~= nil then
		markRootUpdated(root, retryLane, eventTime)
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, retryLane)
	end
end

-- exports.retryDehydratedSuspenseBoundary(boundaryFiber: Fiber)
--   local suspenseState: nil | SuspenseState = boundaryFiber.memoizedState
--   local retryLane = NoLane
--   if suspenseState ~= nil)
--     retryLane = suspenseState.retryLane
--   end
--   retryTimedOutBoundary(boundaryFiber, retryLane)
-- end

exports.resolveRetryWakeable = function(boundaryFiber: Fiber, wakeable: Wakeable)
	local retryLane = ReactFiberLane.NoLane -- Default
	local retryCache -- : WeakSet<Wakeable> | Set<Wakeable> | nil
	-- ROBLOX performance: avoid always-false comapare
	-- if ReactFeatureFlags.enableSuspenseServerRenderer then
	--   if boundaryFiber.tag == ReactWorkTags.SuspenseComponent then
	--       retryCache = boundaryFiber.stateNode
	--       local suspenseState: nil | SuspenseState = boundaryFiber.memoizedState
	--       if suspenseState ~= nil then
	--         -- ROBLOX TODO: Remove Luau narrowing workaround
	--         retryLane = (suspenseState :: SuspenseState).retryLane
	--       end
	--     elseif boundaryFiber.tag == ReactWorkTags.SuspenseListComponent then
	--       retryCache = boundaryFiber.stateNode
	--     else
	--       invariant(
	--         false,
	--         'Pinged unknown suspense boundary type. ' ..
	--           'This is probably a bug in React.'
	--       )
	--   end
	-- else
	retryCache = boundaryFiber.stateNode
	-- end

	if retryCache ~= nil then
		-- The wakeable resolved, so we no longer need to memoize, because it will
		-- never be thrown again.
		retryCache:delete(wakeable)
	end

	retryTimedOutBoundary(boundaryFiber, retryLane)
end

-- Computes the next Just Noticeable Difference (JND) boundary.
-- The theory is that a person can't tell the difference between small differences in time.
-- Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
-- difference in the experience. However, waiting for longer might mean that we can avoid
-- showing an intermediate loading state. The longer we have already waited, the harder it
-- is to tell small differences in time. Therefore, the longer we've already waited,
-- the longer we can wait additionally. At some point we have to give up though.
-- We pick a train model where the next boundary commits at a consistent schedule.
-- These particular numbers are vague estimates. We expect to adjust them based on research.
-- ROBLOX Luau FIXME: Luau needs an explicit number annotation here, but should infer: CLI-49832
function jnd(timeElapsed: number): number
	if timeElapsed < 120 then
		return 120
	elseif timeElapsed < 480 then
		return 480
	elseif timeElapsed < 1080 then
		return 1080
	elseif timeElapsed < 1920 then
		return 1920
	elseif timeElapsed < 3000 then
		return 3000
	elseif timeElapsed < 4320 then
		return 4320
	else
		return math.ceil(timeElapsed / 1960) * 1960
	end
end

mod.checkForNestedUpdates = function()
	if nestedUpdateCount > NESTED_UPDATE_LIMIT then
		nestedUpdateCount = 0
		rootWithNestedUpdates = nil
		invariant(
			false,
			"Maximum update depth exceeded. This can happen when a component "
				.. "repeatedly calls setState inside componentWillUpdate or "
				.. "componentDidUpdate. React limits the number of nested updates to "
				.. "prevent infinite loops."
		)
	end

	if __DEV__ then
		if nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT then
			nestedPassiveUpdateCount = 0
			console.error(
				"Maximum update depth exceeded. This can happen when a component "
					.. "calls setState inside useEffect, but useEffect either doesn't "
					.. "have a dependency array, or one of the dependencies changes on "
					.. "every render."
			)
		end
	end
end

function flushRenderPhaseStrictModeWarningsInDEV()
	if __DEV__ then
		ReactStrictModeWarnings.flushLegacyContextWarning()

		if ReactFeatureFlags.warnAboutDeprecatedLifecycles then
			ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()
		end
	end
end

function commitDoubleInvokeEffectsInDEV(fiber: Fiber, hasPassiveEffects: boolean)
	if __DEV__ and enableDoubleInvokingEffects then
		setCurrentDebugFiberInDEV(fiber)
		invokeEffectsInDev(
			fiber,
			ReactFiberFlags.MountLayoutDev,
			invokeLayoutEffectUnmountInDEV
		)
		if hasPassiveEffects then
			invokeEffectsInDev(
				fiber,
				ReactFiberFlags.MountPassiveDev,
				invokePassiveEffectUnmountInDEV
			)
		end

		invokeEffectsInDev(
			fiber,
			ReactFiberFlags.MountLayoutDev,
			invokeLayoutEffectMountInDEV
		)
		if hasPassiveEffects then
			invokeEffectsInDev(
				fiber,
				ReactFiberFlags.MountPassiveDev,
				invokePassiveEffectMountInDEV
			)
		end
		resetCurrentDebugFiberInDEV()
	end
end

function invokeEffectsInDev(
	firstChild: Fiber,
	fiberFlags: Flags,
	invokeEffectFn: (fiber: Fiber) -> ()
): ()
	if __DEV__ and enableDoubleInvokingEffects then
		local fiber = firstChild
		while fiber ~= nil do
			if fiber.child ~= nil then
				local primarySubtreeFlag = bit32.band(fiber.subtreeFlags, fiberFlags)
				if primarySubtreeFlag ~= ReactFiberFlags.NoFlags then
					invokeEffectsInDev(fiber.child, fiberFlags, invokeEffectFn)
				end
			end

			if bit32.band(fiber.flags, fiberFlags) ~= ReactFiberFlags.NoFlags then
				invokeEffectFn(fiber)
			end
			-- ROBLOX FIXME Luau: Luau doesn't understand the loop ~= nil construct
			fiber = fiber.sibling :: Fiber
		end
	end
end

-- deviation: FIXME restore type Set<string>?, has trouble with narrowing
local didWarnStateUpdateForNotYetMountedComponent: any = nil
mod.warnAboutUpdateOnNotYetMountedFiberInDEV = function(fiber)
	if __DEV__ then
		if bit32.band(executionContext, RenderContext) ~= NoContext then
			-- We local the other warning about render phase updates deal with this one.
			return
		end

		if
			bit32.band(
				fiber.mode,
				bit32.bor(ReactTypeOfMode.BlockingMode, ReactTypeOfMode.ConcurrentMode)
			) == 0
		then
			return
		end

		local tag = fiber.tag
		if
			tag ~= ReactWorkTags.IndeterminateComponent
			and tag ~= ReactWorkTags.HostRoot
			and tag ~= ReactWorkTags.ClassComponent
			and tag ~= ReactWorkTags.FunctionComponent
			and tag ~= ReactWorkTags.ForwardRef
			and tag ~= ReactWorkTags.MemoComponent
			and tag ~= ReactWorkTags.SimpleMemoComponent
			and tag ~= ReactWorkTags.Block
		then
			-- Only warn for user-defined components, not internal ones like Suspense.
			return
		end

		-- We show the whole stack but dedupe on the top component's name because
		-- the problematic code almost always lies inside that component.
		local componentName = getComponentName(fiber.type) or "ReactComponent"
		if didWarnStateUpdateForNotYetMountedComponent ~= nil then
			if didWarnStateUpdateForNotYetMountedComponent[componentName] then
				return
			end
			didWarnStateUpdateForNotYetMountedComponent[componentName] = true
		else
			-- ROBLOX FIXME? not sure this translation is correct
			didWarnStateUpdateForNotYetMountedComponent = { [componentName] = true }
		end

		local previousFiber = ReactCurrentFiber.current
		local ok, result = pcall(function()
			setCurrentDebugFiberInDEV(fiber)
			console.error(
				"Can't perform a React state update on a component that hasn't mounted yet. "
					.. "This indicates that you have a side-effect in your render function that "
					.. "asynchronously later calls tries to update the component. Move this work to "
					.. "useEffect instead."
			)
		end)

		-- finally
		if previousFiber then
			setCurrentDebugFiberInDEV(fiber)
		else
			resetCurrentDebugFiberInDEV()
		end

		if not ok then
			error(result)
		end
	end
end

-- deviation: Declared on the mod table instead of as a local
if __DEV__ and ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback then
	local dummyFiber = nil
	mod.beginWork = function(current, unitOfWork, lanes)
		-- If a component throws an error, we replay it again in a synchronously
		-- dispatched event, so that the debugger will treat it as an uncaught
		-- error See ReactErrorUtils for more information.

		-- Before entering the begin phase, copy the work-in-progress onto a dummy
		-- fiber. If beginWork throws, we'll use this to reset the state.
		local originalWorkInProgressCopy =
			ReactFiber.assignFiberPropertiesInDEV(dummyFiber, unitOfWork)
		local ok, result =
			xpcall(originalBeginWork, describeError, current, unitOfWork, lanes)
		if not ok then
			local originalError = result

			if
				originalError ~= nil
				and typeof(originalError) == "table"
				and typeof(originalError.andThen) == "function"
			then
				-- Don't replay promises. Treat everything else like an error.
				error(originalError)
			end

			-- Keep this code in sync with handleError; any changes here must have
			-- corresponding changes there.
			resetContextDependencies()
			resetHooksAfterThrow()
			-- Don't reset current debug fiber, since we're about to work on the
			-- same fiber again.

			-- Unwind the failed stack frame
			unwindInterruptedWork(unitOfWork)

			-- Restore the original properties of the fiber.
			ReactFiber.assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy)

			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band(unitOfWork.mode, ReactTypeOfMode.ProfileMode) ~= 0
			then
				-- Reset the profiler timer.
				ReactProfilerTimer.startProfilerTimer(unitOfWork)
			end

			-- Run beginWork again.
			invokeGuardedCallback(nil, originalBeginWork, nil, current, unitOfWork, lanes)

			if hasCaughtError() then
				local replayError = clearCaughtError()
				-- `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
				-- Rethrow this error instead of the original one.
				error(replayError)
			else
				-- This branch is reachable if the render phase is impure.
				error(originalError)
			end
		end

		return result
	end
else
	mod.beginWork = originalBeginWork
end

local didWarnAboutUpdateInRender = false
local didWarnAboutUpdateInRenderForAnotherComponent
if __DEV__ then
	didWarnAboutUpdateInRenderForAnotherComponent = {}
end

mod.warnAboutRenderPhaseUpdatesInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactCurrentFiber.isRendering
			and bit32.band(executionContext, RenderContext) ~= NoContext
			and not getIsUpdatingOpaqueValueInRenderPhaseInDEV()
		then
			if
				fiber.tag == ReactWorkTags.FunctionComponent
				or fiber.tag == ReactWorkTags.ForwardRef
				or fiber.tag == ReactWorkTags.SimpleMemoComponent
			then
				local renderingComponentName = (function()
					if workInProgress ~= nil then
						return getComponentName((workInProgress :: Fiber).type)
					end
					return "Unknown"
				end)()
				-- Dedupe by the rendering component because it's the one that needs to be fixed.
				local dedupeKey = renderingComponentName
				-- ROBLOX deviation:
				-- if !didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey))
				if didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey] == nil then
					didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey] = true
					local setStateComponentName = getComponentName(fiber.type)
						or "Unknown"
					console.error(
						"Cannot update a component (`%s`) while rendering a "
							.. "different component (`%s`). To locate the bad setState() call inside `%s`, "
							.. "follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
						setStateComponentName,
						renderingComponentName,
						renderingComponentName
					)
				end
			elseif fiber.tag == ReactWorkTags.ClassComponent then
				if not didWarnAboutUpdateInRender then
					console.error(
						"Cannot update during an existing state transition (such as "
							.. "within `render`). Render methods should be a pure "
							.. "function of props and state."
					)
					didWarnAboutUpdateInRender = true
				end
			end
		end
	end
end

-- a 'shared' variable that changes when act() opens/closes in tests.
exports.IsThisRendererActing = { current = false }

exports.warnIfNotScopedWithMatchingAct = function(fiber: Fiber)
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and IsSomeRendererActing.current == true
			and exports.IsThisRendererActing.current ~= true
		then
			local previousFiber = ReactCurrentFiber.current
			local ok, result = pcall(function()
				setCurrentDebugFiberInDEV(fiber)
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when we have a better idea of what it
				-- looks like; in React, this string is broken up oddly to avoid
				-- confusing tools, but we don't have any reason to do that right now
				console.error(
					"It looks like you're using the wrong act() around your test interactions.\n"
						.. "Be sure to use the matching version of act() corresponding to your renderer:\n\n"
						.. "-- for react-roblox:\n"
						.. "local React = require(Packages.React)\n"
						.. "-- ...\n"
						.. "React.TestUtils.act(function() ... end)\n\n"
						.. "-- for react-test-renderer:\n"
						.. "local TestRenderer = require(Packages.ReactTestRenderer)\n"
						.. "-- ...\n"
						.. "TestRenderer.act(function() ... end)"
				)
			end)

			-- finally
			if previousFiber then
				setCurrentDebugFiberInDEV(fiber)
			else
				resetCurrentDebugFiberInDEV()
			end

			if not ok then
				error(result)
			end
		end
	end
end

exports.warnIfNotCurrentlyActingEffectsInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and bit32.band(fiber.mode, ReactTypeOfMode.StrictMode) ~= ReactTypeOfMode.NoMode
			and IsSomeRendererActing.current == false
			and exports.IsThisRendererActing.current == false
		then
			-- ROBLOX deviation: Use Lua syntax for example fix
			console.error(
				"An update to %s ran an effect, but was not wrapped in act(...).\n\n"
					.. "When testing, code that causes React state updates should be "
					.. "wrapped into act(...):\n\n"
					.. "act(function()\n"
					.. "  --\[\[ fire events that update state \]\]\n"
					.. "end)\n"
					.. "--\[\[ assert on the output \]\]\n\n"
					.. "This ensures that you're testing the behavior the user would see "
					.. "in the real client."
					.. " Learn more at https://reactjs.org/link/wrap-tests-with-act",
				getComponentName(fiber.type)
			)
		end
	end
end

exports.warnIfNotCurrentlyActingUpdatesInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and executionContext == NoContext
			and IsSomeRendererActing.current == false
			and exports.IsThisRendererActing.current == false
		then
			local previousFiber = ReactCurrentFiberCurrent
			local ok, result = pcall(function()
				setCurrentDebugFiberInDEV(fiber)
				-- ROBLOX deviation: Use Lua syntax for example fix
				console.error(
					"An update to %s inside a test was not wrapped in act(...).\n\n"
						.. "When testing, code that causes React state updates should be "
						.. "wrapped into act(...):\n\n"
						.. "act(function()\n"
						.. "  --\[\[ fire events that update state \]\]\n"
						.. "end)\n"
						.. "--\[\[ assert on the output \]\]\n\n"
						.. "This ensures that you're testing the behavior the user would see "
						.. "in the client application."
						.. " Learn more at https://reactjs.org/link/wrap-tests-with-act",
					getComponentName(fiber.type)
				)
			end)

			-- Finally
			if previousFiber then
				setCurrentDebugFiberInDEV(fiber)
			else
				resetCurrentDebugFiberInDEV()
			end

			if ok then
				return result
			end
		end
	end
	-- ROBLOX deviation: explicit return to silence analyze
	return
end

-- In tests, we want to enforce a mocked scheduler.
local didWarnAboutUnmockedScheduler = false
-- TODO Before we release concurrent mode, revisit this and decide whether a mocked
-- scheduler is the actual recommendation. The alternative could be a testing build,
-- a new lib, or whatever; we dunno just yet. This message is for early adopters
-- to get their tests right.

exports.warnIfUnmockedScheduler = function(fiber: Fiber)
	if __DEV__ then
		if
			didWarnAboutUnmockedScheduler == false
			and Scheduler.unstable_flushAllWithoutAsserting == nil
		then
			if
				bit32.band(fiber.mode, ReactTypeOfMode.BlockingMode) ~= 0
				or bit32.band(fiber.mode, ReactTypeOfMode.ConcurrentMode) ~= 0
			then
				didWarnAboutUnmockedScheduler = true
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when jest-roblox is in use; in React,
				-- this string is broken up oddly to avoid confusing tools, but we don't
				-- have any reason to do that right now
				console.error(
					"In Concurrent or Sync modes, the 'scheduler' module needs to be mocked "
						.. "to guarantee consistent behaviour across tests and client application. "
						.. "For example, with Jest: \n"
						-- Break up requires to avoid accidentally parsing them as dependencies.
						.. "jest.mock('scheduler', function() return require(Packages.Scheduler).unstable_mock end)\n\n"
						.. "For more info, visit https://reactjs.org/link/mock-scheduler"
				)
			elseif ReactFeatureFlags.warnAboutUnmockedScheduler == true then
				didWarnAboutUnmockedScheduler = true
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when jest-roblox is in use; in React,
				-- this string is broken up oddly to avoid confusing tools, but we don't
				-- have any reason to do that right now
				console.error(
					"Starting from React v18, the 'scheduler' module will need to be mocked "
						.. "to guarantee consistent behaviour across tests and client applications. "
						.. "For example, with Jest: \n"
						-- Break up requires to avoid accidentally parsing them as dependencies.
						.. "jest.mock('scheduler', function() return require(Packages.Scheduler).unstable_mock end)\n\n"
						.. "For more info, visit https://reactjs.org/link/mock-scheduler"
				)
			end
		end
	end
end

function computeThreadID(root: FiberRoot, lane: Lane | Lanes)
	-- Interaction threads are unique per root and expiration time.
	-- NOTE: Intentionally unsound cast. All that matters is that it's a number
	-- and it represents a batch of work. Could make a helper function instead,
	-- but meh this is fine for now.
	return lane * 1000 + root.interactionThreadID
end

exports.markSpawnedWork = function(lane: Lane | Lanes)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end
	if spawnedWorkDuringRender == nil then
		spawnedWorkDuringRender = { lane }
	else
		-- ROBLOX FIXME Luau: depends on Luau type states
		table.insert(spawnedWorkDuringRender :: Array<number>, lane)
	end
end

function scheduleInteractions(
	root: FiberRoot,
	lane: Lane | Lanes,
	interactions: Set<Interaction>
)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	if interactions.size > 0 then
		local pendingInteractionMap = root.pendingInteractionMap
		local pendingInteractions = pendingInteractionMap:get(lane)
		if pendingInteractions ~= nil then
			interactions:forEach(function(interaction)
				if not pendingInteractions:has(interaction) then
					-- Update the pending async work count for previously unscheduled interaction.
					interaction.__count += 1
				end

				pendingInteractions:add(interaction)
			end)
		else
			pendingInteractionMap:set(lane, Set.new(interactions))

			-- Update the pending async work count for the current interactions.
			for _, interaction in interactions do
				interaction.__count += 1
			end
		end

		local subscriber = __subscriberRef.current
		if subscriber ~= nil then
			local threadID = computeThreadID(root, lane)
			subscriber.onWorkScheduled(interactions, threadID)
		end
	end
end

mod.schedulePendingInteractions = function(root: FiberRoot, lane: Lane | Lanes)
	-- This is called when work is scheduled on a root.
	-- It associates the current interactions with the newly-scheduled expiration.
	-- They will be restored when that expiration is later committed.
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	scheduleInteractions(root, lane, __interactionsRef.current)
end

mod.startWorkOnPendingInteractions = function(root: FiberRoot, lanes: Lanes)
	-- This is called when new work is started on a root.
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	-- Determine which interactions this batch of work currently includes, So that
	-- we can accurately attribute time spent working on it, And so that cascading
	-- work triggered during the render phase will be associated with it.
	local interactions: Set<Interaction> = Set.new()
	root.pendingInteractionMap:forEach(function(scheduledInteractions, scheduledLane)
		if includesSomeLane(lanes, scheduledLane) then
			scheduledInteractions:forEach(function(interaction)
				interactions:add(interaction)
			end)
		end
	end)

	-- Store the current set of interactions on the ReactInternalTypes.FiberRoot for a few reasons:
	-- We can re-use it in hot functions like performConcurrentWorkOnRoot()
	-- without having to recalculate it. We will also use it in commitWork() to
	-- pass to any Profiler onRender() hooks. This also provides DevTools with a
	-- way to access it when the onCommitRoot() hook is called.
	-- ROBLOX FIXME: manual type check to workaround Luau analyze bug "Type 'Set<Interaction>' could not be converted into 'Set<Interaction>'"
	root.memoizedInteractions = interactions :: any

	if interactions.size > 0 then
		local subscriber = __subscriberRef.current
		if subscriber ~= nil then
			local threadID = computeThreadID(root, lanes)
			local ok, error_ =
				xpcall(subscriber.onWorkStarted, describeError, interactions, threadID)
			if not ok then
				-- If the subscriber throws, rethrow it in a separate task
				scheduleCallback(ImmediateSchedulerPriority, function()
					error(error_)
				end)
			end
		end
	end
end

mod.finishPendingInteractions = function(root: FiberRoot, committedLanes)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	local remainingLanesAfterCommit = root.pendingLanes

	local subscriber

	-- ROBLOX try
	local ok = true
	local error_
	if subscriber ~= nil and root.memoizedInteractions.size > 0 then
		-- FIXME: More than one lane can finish in a single commit.
		-- ROBLOX peformance: hoist non-throwable things out of the pcall() so we can remove an anon function
		local threadID = computeThreadID(root, committedLanes)
		subscriber = __subscriberRef.current
		-- ROBLOX deviation: helper for raw table set/map size > 0
		ok, error_ = xpcall(
			subscriber.onWorkStopped,
			describeError,
			root.memoizedInteractions,
			threadID
		)
	end

	-- ROBLOX finally
	-- Clear completed interactions from the pending Map.
	-- Unless the render was suspended or cascading work was scheduled,
	-- In which case– leave pending interactions until the subsequent render.
	local pendingInteractionMap = root.pendingInteractionMap
	pendingInteractionMap:forEach(function(scheduledInteractions, lane)
		-- Only decrement the pending interaction count if we're done.
		-- If there's still work at the current priority,
		-- That indicates that we are waiting for suspense data.
		if not includesSomeLane(remainingLanesAfterCommit, lane) then
			pendingInteractionMap:delete(lane)
			scheduledInteractions:forEach(function(interaction)
				interaction.__count -= 1

				if subscriber ~= nil and interaction.__count == 0 then
					local ok_, error__ = xpcall(
						subscriber.onInteractionScheduledWorkCompleted,
						describeError,
						interaction
					)
					if not ok_ then
						-- If the subscriber throws, rethrow it in a separate task
						scheduleCallback(ImmediateSchedulerPriority, function()
							error(error__)
						end)
					end
				end
			end)
		end
	end)

	-- ROBLOX catch
	if not ok then
		-- If the subscriber throws, rethrow it in a separate task
		scheduleCallback(ImmediateSchedulerPriority, function()
			error(error_)
		end)
	end
end

-- `act` testing API
--
-- TODO: This is mostly a copy-paste from the legacy `act`, which does not have
-- access to the same internals that we do here. Some trade offs in the
-- implementation no longer make sense.
local isFlushingAct = false
local isInsideThisAct = false

local flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting
local isSchedulerMocked = typeof(flushMockScheduler) == "function"

-- Returns whether additional work was scheduled. Caller should keep flushing
-- until there's no work left.
local function flushActWork(): boolean
	if flushMockScheduler ~= nil then
		local prevIsFlushing = isFlushingAct
		isFlushingAct = true
		local ok, result = xpcall(flushMockScheduler, describeError)

		-- finally
		isFlushingAct = prevIsFlushing

		if not ok then
			error(result)
		else
			return result
		end
	else
		-- No mock scheduler available. However, the only type of pending work is
		-- passive effects, which we control. So we can flush that.
		local prevIsFlushing = isFlushingAct
		isFlushingAct = true
		-- ROBLOX performance? rewrite this loop to eliminate anon function?
		local ok, result = xpcall(function()
			local didFlushWork = false
			while exports.flushPassiveEffects() do
				didFlushWork = true
			end
			return didFlushWork
		end, describeError)

		-- finally
		isFlushingAct = prevIsFlushing

		if not ok then
			error(result)
		else
			return result
		end
	end
end

local function flushWorkAndMicroTasks(onDone: (any?) -> ())
	-- ROBLOX performance: split into two pcall to eliminate anonymous func allocation per call
	local ok, result = xpcall(flushActWork, describeError)
	if ok then
		ok, result = xpcall(enqueueTask, describeError, function()
			if flushActWork() then
				flushWorkAndMicroTasks(onDone)
			else
				onDone()
			end
		end)
	end

	if not ok then
		onDone(result)
	end
end

exports.act = function(callback: () -> Thenable<any>): Thenable<any>
	-- It's only viable to export `act` when we're using mocked scheduling logic.
	-- Since there are numerous testing scenarios in which we call `require` on
	-- the Roact library _before_ we bootstrap tests, we expose a global to toggle
	-- this explicilty
	if not (__DEV__ or _G.__ROACT_17_MOCK_SCHEDULER__) then
		if didWarnAboutUsingActInProd == false then
			didWarnAboutUsingActInProd = true
			-- eslint-disable-next-line react-internal/no-production-logging
			console.error(
				"act(...) is not supported in production builds of React, and might not behave as expected."
			)
		end
	end

	local previousActingUpdatesScopeDepth = actingUpdatesScopeDepth
	actingUpdatesScopeDepth += 1

	local previousIsSomeRendererActing = IsSomeRendererActing.current
	local previousIsThisRendererActing = exports.IsThisRendererActing.current
	local previousIsInsideThisAct = isInsideThisAct
	IsSomeRendererActing.current = true
	exports.IsThisRendererActing.current = true
	isInsideThisAct = true

	local function onDone()
		actingUpdatesScopeDepth -= 1
		IsSomeRendererActing.current = previousIsSomeRendererActing
		exports.IsThisRendererActing.current = previousIsThisRendererActing
		isInsideThisAct = previousIsInsideThisAct
		if __DEV__ then
			if actingUpdatesScopeDepth > previousActingUpdatesScopeDepth then
				-- if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned
				console.error(
					"You seem to have overlapping act() calls, this is not supported. "
						.. "Be sure to await previous act() calls before making a new one. "
				)
			end
		end
	end

	local ok, result = xpcall(exports.batchedUpdates, describeError, callback)
	if not ok then
		onDone()
		error(result)
	end

	if
		result ~= nil
		and typeof(result) == "table"
		and typeof(result.andThen) == "function"
	then
		-- setup a boolean that gets set to true only
		-- once this act() call is await-ed
		local called = false
		if __DEV__ then
			if typeof(Promise) ~= nil then
				--eslint-disable-next-line no-undef
				Promise.resolve():andThen(function() end):andThen(function()
					if called == false then
						-- FIXME (roblox): We should replace this with proper Lua promise
						-- logic
						console.error(
							"You called act(Promise.new(function() --\[\[ ... \]\] end)) without :await() or :expect(). "
								.. "This could lead to unexpected testing behaviour, interleaving multiple act "
								.. "calls and mixing their scopes. You should - act(function() Promise.new(function() --\[\[ ... \]\] end):await() end);"
						)
					end
				end)
			end
		end

		-- in the async case, the returned thenable runs the callback, flushes
		-- effects and microtasks in a loop until flushPassiveEffects() == false,
		-- and cleans up
		return {
			-- ROBLOX FIXME Luau: have to explicitly annotate the unused generic arg: CLI-49996
			andThen = function<U>(self, resolve, reject)
				called = true
				return result:andThen(function()
					if
						actingUpdatesScopeDepth > 1
						or (
							isSchedulerMocked == true
							and previousIsSomeRendererActing == true
						)
					then
						onDone()
						resolve()
						return
					end
					-- we're about to exit the act() scope,
					-- now's the time to flush tasks/effects
					flushWorkAndMicroTasks(function(err: any?)
						onDone()
						if err then
							reject(err)
						else
							resolve()
						end
					end)
				end, function(err)
					onDone()
					reject(err)
				end)
			end,
		}
	else
		if __DEV__ then
			if result ~= nil then
				-- ROBLOX deviation: use Lua syntax
				console.error(
					"The callback passed to act(...) function "
						.. "must return nil, or a Promise. You returned %s",
					tostring(result)
				)
			end
		end

		-- flush effects until none remain, and cleanup
		local flushOk, flushResult = xpcall(function()
			if
				actingUpdatesScopeDepth == 1
				and (isSchedulerMocked == false or previousIsSomeRendererActing == false)
			then
				-- we're about to exit the act() scope,
				-- now's the time to flush effects
				flushActWork()
			end
			onDone()
		end, describeError)

		if not flushOk then
			onDone()
			error(flushResult)
		end

		-- in the sync case, the returned thenable only warns *if* await-ed
		return {
			-- ROBLOX FIXME Luau: have to explicitly annotate the unused generic arg: CLI-49996
			andThen = function<U>(self, resolve, reject_)
				if __DEV__ then
					console.error(
						"Do not await the result of calling act(...) with sync logic, it is not a Promise."
					)
				end
				resolve()
			end,
		}
	end
end

mod.detachFiberAfterEffects = function(fiber: Fiber)
	-- Null out fields to improve GC for references that may be lingering (e.g. DevTools).
	-- Note that we already cleared the return pointer in detachFiberMutation().
	fiber.child = nil
	fiber.deletions = nil
	fiber.dependencies = nil
	fiber.memoizedProps = nil
	fiber.memoizedState = nil
	fiber.pendingProps = nil
	fiber.sibling = nil
	fiber.stateNode = nil
	fiber.updateQueue = nil

	if __DEV__ then
		fiber._debugOwner = nil
	end
end

return exports ]]
cX.Children._4f3c15f2fbb4f53ea363ee8451e2a3e5=d9
local ea

local eb={ClassName="ModuleScript",Children={},Properties={}}
eb.Name="ReactHookEffectTags"
eb.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactHookEffectTags.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

export type HookFlags = number

return {
	--\[\[  \]\]
	NoFlags = 0b000,

	-- Represents whether effect should fire.
	--\[\[ \]\]
	HasEffect = 0b001,

	-- Represents the phase in which the effect (not the clean-up) fires.
	--\[\[    \]\]
	Layout = 0b010,
	--\[\[   \]\]
	Passive = 0b100,
} ]]
cX.Children._0925b4aa23e0f0a2af16bd8dec6f259e=eb
local ec

local ed={ClassName="ModuleScript",Children={},Properties={}}
ed.Name="ReactInternalTypes"
ed.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/7baf9d4128d41903de125527b50285ea9862cf9a/packages/react-reconciler/src/ReactInternalTypes.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Object = { [string]: any }
type SimpleSet<T> = { [T]: boolean }
type SimpleMap<K, V> = { [K]: V }
type Set<T> = LuauPolyfill.Set<T>

local ReactTypes = require(Packages.Shared)
-- ROBLOX deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type Source = ReactTypes.Source
type RefObject = ReactTypes.RefObject
type ReactContext<T> = ReactTypes.ReactContext<T>
type MutableSourceVersion = ReactTypes.MutableSourceVersion
type MutableSource<Source> = ReactTypes.MutableSource<Source>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>

-- ROBLOX deviation START: These are 'mixed' by default, and specialized by the renderer, need complicated dynamic resolution to do this properly
-- local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
-- type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
type SuspenseInstance = any
-- ROBLOX deviation END
local ReactWorkTags = require(script.Parent.ReactWorkTags)
type WorkTag = ReactWorkTags.WorkTag
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
type TypeOfMode = ReactTypeOfMode.TypeOfMode
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
type Flags = ReactFiberFlags.Flags
-- deviation: FiberLane types are defined and exported from here to avoid
-- cyclical requires
export type LanePriority = number
export type Lanes = number
export type Lane = number
export type LaneMap<T> = { [number]: T }

-- ROBLOX deviation: Update<>, SharedQueue<>, UpdateQueue<> transplanted from ReactUpdateQueue for use by createReactNoop
export type Update<State> = {
	-- TODO: Temporary field. Will remove this by storing a map of
	-- transition -> event time on the root.
	eventTime: number,
	lane: Lane,

	-- ROBLOX FIXME Luau: revert when luau supports singleton integers
	-- tag: 0 | 1 | 2 | 3,
	tag: number,
	payload: any,
	callback: (() -> ...any)?,

	next: Update<State>?,
}

export type SharedQueue<State> = {
	pending: Update<State>?,
}

export type UpdateQueue<State> = {
	baseState: State,
	firstBaseUpdate: Update<State>?,
	lastBaseUpdate: Update<State>?,
	shared: SharedQueue<State>,
	effects: Array<Update<State>>?,
}

export type HookType =
	"useState"
	| "useReducer"
	| "useContext"
	| "useRef"
	-- ROBLOX deviation: Bindings are a feature unique to Roact
	| "useBinding"
	| "useEffect"
	| "useLayoutEffect"
	| "useCallback"
	| "useMemo"
	| "useImperativeHandle"
	| "useDebugValue"
	| "useDeferredValue"
	| "useTransition"
	| "useMutableSource"
	| "useOpaqueIdentifier"
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag
-- ROBLOX deviation: we can't import types for dynamic imports like HostConfig files
-- type TimeoutHandle = ReactFiberHostConfig.TimeoutHandle;
-- type NoTimeout = ReactFiberHostConfig.NoTimeout;
type TimeoutHandle = any
type NoTimeout = any
-- ROBLOX deviation: type forwarded to top-level export
local Shared = require(Packages.Shared)
type Wakeable = Shared.Wakeable
-- ROBLOX deviation: Interaction type forwarded to top-level export
local Scheduler = require(Packages.Scheduler)
type Interaction = Scheduler.Interaction

-- ROBLOX deciation: Luau doesn't support type literals:  99 | 98 | 97 | 96 | 95 | 90
export type ReactPriorityLevel = number

export type ContextDependency<T> = {
	context: ReactContext<T>,
	observedBits: number,
	-- ROBLOX TODO: upstream only parameterizes this type with `mixed`, so avoid Luau recursive type constraint. upstream this change later.
	next: ContextDependency<T> | nil,
	-- ROBLOX deviation START: don't allow for extension unless we have to
	-- ...
	-- ROBLOX deviation END
}

export type Dependencies = {
	lanes: Lanes,
	firstContext: ContextDependency<any> | nil,
	-- ROBLOX deviation START: don't allow for extension unless we have to
	-- ...
	-- ROBLOX deviation END
}

-- ROBLOX deviation: Roact stable keys - slightly widen the type definition of a
-- stable key so that it's likely to work with existing Roact code. Includes
-- numbers for mixed/sparse tables
export type RoactStableKey = string | number

-- A Fiber is work on a Component that needs to be done or was done. There can
-- be more than one per component.
export type Fiber = {
	-- These first fields are conceptually members of an Instance. This used to
	-- be split into a separate type and intersected with the other Fiber fields,
	-- but until Flow fixes its intersection bugs, we've merged them into a
	-- single type.

	-- An Instance is shared between all versions of a component. We can easily
	-- break this out into a separate object to avoid copying so much to the
	-- alternate versions of the tree. We put this on a single object for now to
	-- minimize the number of objects created during the initial render.

	-- Tag identifying the type of fiber.
	tag: WorkTag,

	-- ROBLOX deviation: Use a slightly more permissive key type to allow for
	-- sparse arrays, which will still be distinct from actual arrays.
	-- Unique identifier of this child.
	key: RoactStableKey?,

	-- The value of element.type which is used to preserve the identity during
	-- reconciliation of this child.
	elementType: any,

	-- The resolved function/class/ associated with this fiber.
	type: any,

	-- The local state associated with this fiber.
	stateNode: any,

	-- Conceptual aliases
	-- parent : Instance -> return The parent happens to be the same as the
	-- return fiber since we've merged the fiber and instance.

	-- Remaining fields belong to Fiber

	-- The Fiber to return to after finishing processing this one.
	-- This is effectively the parent, but there can be multiple parents (two)
	-- so this is only the parent of the thing we're currently processing.
	-- It is conceptually the same as the return address of a stack frame.
	return_: Fiber | nil,

	-- Singly Linked List Tree Structure.
	child: Fiber?,
	sibling: Fiber?,
	index: number,

	-- The ref last used to attach this node.
	-- I'll avoid adding an owner field for prod and model that as functions.
	-- ROBLOX deviation: Lua doesn't allow fields on functions
	-- ref: (((any) -> ()) & {_stringRef: string?, [string]: any}) | RefObject,
	ref: nil | ((handle: any) -> ()) | { _stringRef: string?, [string]: any } | RefObject,

	-- Input is the data coming into process this fiber. Arguments. Props.
	pendingProps: any, -- This type will be more specific once we overload the tag.
	memoizedProps: any, -- The props used to create the output.

	-- A queue of state updates and callbacks.
	updateQueue: any,

	-- The state used to create the output
	memoizedState: any,

	-- Dependencies (contexts, events) for this fiber, if it has any
	dependencies: Dependencies?,

	-- Bitfield that describes properties about the fiber and its subtree. E.g.
	-- the ConcurrentMode flag indicates whether the subtree should be async-by-
	-- default. When a fiber is created, it inherits the mode of its
	-- parent. Additional flags can be set at creation time, but after that the
	-- value should remain unchanged throughout the fiber's lifetime, particularly
	-- before its child fibers are created.
	mode: TypeOfMode,

	-- Effect
	flags: Flags,
	subtreeFlags: Flags,
	deletions: Array<Fiber>?,

	-- Singly linked list fast path to the next fiber with side-effects.
	nextEffect: Fiber?,

	-- The first and last fiber with side-effect within this subtree. This allows
	-- us to reuse a slice of the linked list when we reuse the work done within
	-- this fiber.
	firstEffect: Fiber?,
	lastEffect: Fiber?,

	lanes: Lanes,
	childLanes: Lanes,

	-- This is a pooled version of a Fiber. Every fiber that gets updated will
	-- eventually have a pair. There are cases when we can clean up pairs to save
	-- memory if we need to.
	alternate: Fiber?,

	-- Time spent rendering this Fiber and its descendants for the current update.
	-- This tells us how well the tree makes use of sCU for memoization.
	-- It is reset to 0 each time we render and only updated when we don't bailout.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	actualDuration: number?,

	-- If the Fiber is currently active in the "render" phase,
	-- This marks the time at which the work began.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	actualStartTime: number?,

	-- Duration of the most recent render time for this Fiber.
	-- This value is not updated when we bailout for memoization purposes.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	selfBaseDuration: number?,

	-- Sum of base times for all descendants of this Fiber.
	-- This value bubbles up during the "complete" phase.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	treeBaseDuration: number?,

	-- Conceptual aliases
	-- workInProgress : Fiber ->  alternate The alternate used for reuse happens
	-- to be the same as work in progress.
	-- _G.__DEV__ only
	_debugID: number?,
	_debugSource: Source?,
	_debugOwner: Fiber?,
	_debugIsCurrentlyTiming: boolean?,
	_debugNeedsRemount: boolean?,

	-- Used to verify that the order of hooks does not change between renders.
	_debugHookTypes: Array<HookType>?,
}

export type SuspenseHydrationCallbacks = {
	onHydrated: ((SuspenseInstance) -> ())?,
	onDeleted: ((SuspenseInstance) -> ())?,
	-- ROBLOX deviation START: don't allow for extension unless we have to
	-- ...
	-- ROBLOX deviation END
}

-- deviation: Instead of combining all these props after the fact, we define
-- them all in one to allow Luau's syntax

-- Exported FiberRoot type includes all properties,
-- To avoid requiring potentially error-prone :any casts throughout the project.
-- Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
-- The types are defined separately within this file to ensure they stay in sync.
-- (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
export type FiberRoot = {
	-- ...BaseFiberRootProperties,
	-- The type of root (legacy, batched, concurrent, etc.)
	tag: RootTag,

	-- Any additional information from the host associated with this root.
	containerInfo: any,
	-- Used only by persistent updates.
	pendingChildren: any,
	-- The currently active root fiber. This is the mutable root of the tree.
	current: Fiber,

	-- ROBLOX deviation START: we use a lightweight unordered set for performance
	pingCache: SimpleMap<
		Wakeable,
		(SimpleSet<any> | SimpleMap<Wakeable, SimpleSet<any>>)
	> | nil,
	-- ROBLOX deviation END

	-- A finished work-in-progress HostRoot that's ready to be committed.
	finishedWork: Fiber?,
	-- Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
	-- it's superseded by a new one.
	timeoutHandle: TimeoutHandle | NoTimeout,
	-- Top context object, used by renderSubtreeIntoContainer
	context: Object?,
	pendingContext: Object?,
	-- Determines if we should attempt to hydrate on the initial mount
	hydrate: boolean,

	-- Used by useMutableSource hook to avoid tearing during hydration.
	mutableSourceEagerHydrationData: Array<MutableSource<any> | MutableSourceVersion>?,

	-- Node returned by Scheduler.scheduleCallback. Represents the next rendering
	-- task that the root will work on.
	callbackNode: any,
	callbackPriority: LanePriority,
	eventTimes: LaneMap<number>,
	expirationTimes: LaneMap<number>,

	pendingLanes: Lanes,
	suspendedLanes: Lanes,
	pingedLanes: Lanes,
	expiredLanes: Lanes,
	mutableReadLanes: Lanes,

	finishedLanes: Lanes,

	entangledLanes: Lanes,
	entanglements: LaneMap<Lanes>,

	-- ...ProfilingOnlyFiberRootProperties,
	-- The following attributes are only used by interaction tracing builds.
	-- They enable interactions to be associated with their async work,
	-- And expose interaction metadata to the React DevTools Profiler plugin.
	-- Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
	interactionThreadID: number,
	memoizedInteractions: Set<Interaction>,
	pendingInteractionMap: Map<Lane | Lanes, Set<Interaction>>,

	-- ...SuspenseCallbackOnlyFiberRootProperties,
	-- The follow fields are only used by enableSuspenseCallback for hydration.
	hydrationCallbacks: SuspenseHydrationCallbacks?,

	-- ROBLOX deviation START: don't allow for extension unless we have to
	-- ...
	-- ROBLOX deviation END
}

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

-- ROBLOX deviation: Dispatcher is defined in Shared to avoid circular deps
export type Dispatcher = Shared.Dispatcher

-- deviation: Return something so that the module system is happy
return {} ]]
cX.Children._971621cd9facd1b2bf7da2a8cf20a680=ed
local ee

local ef={ClassName="ModuleScript",Children={},Properties={}}
ef.Name="ReactMutableSource.new"
ef.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactMutableSource.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

type Array<T> = { [number]: T }
local exports = {}

local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceVersion = ReactTypes.MutableSourceVersion

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type FiberRoot = ReactInternalTypes.FiberRoot

local isPrimaryRenderer = require(script.Parent.ReactFiberHostConfig).isPrimaryRenderer

-- Work in progress version_ numbers only apply to a single render,
-- and should be reset before starting a new render.
-- This tracks which mutable sources need to be reset after a render.
local workInProgressSources: Array<MutableSource<any>> = {}

local rendererSigil
if _G.__DEV__ then
	-- Used to detect multiple renderers using the same mutable source.
	rendererSigil = {}
end

exports.markSourceAsDirty = function(mutableSource: MutableSource<any>)
	table.insert(workInProgressSources, mutableSource)
end

exports.resetWorkInProgressVersions = function()
	for i, mutableSource in workInProgressSources do
		if isPrimaryRenderer then
			mutableSource._workInProgressVersionPrimary = nil
		else
			mutableSource._workInProgressVersionSecondary = nil
		end
	end
	table.clear(workInProgressSources)
end

exports.getWorkInProgressVersion =
	function(mutableSource: MutableSource<any>): nil | MutableSourceVersion
		if isPrimaryRenderer then
			return mutableSource._workInProgressVersionPrimary
		else
			return mutableSource._workInProgressVersionSecondary
		end
	end

exports.setWorkInProgressVersion =
	function(mutableSource: MutableSource<any>, version_: MutableSourceVersion)
		if isPrimaryRenderer then
			mutableSource._workInProgressVersionPrimary = version_
		else
			mutableSource._workInProgressVersionSecondary = version_
		end
		table.insert(workInProgressSources, mutableSource)
	end

exports.warnAboutMultipleRenderersDEV = function(mutableSource: MutableSource<any>)
	if _G.__DEV__ then
		if isPrimaryRenderer then
			if mutableSource._currentPrimaryRenderer == nil then
				mutableSource._currentPrimaryRenderer = rendererSigil
			elseif mutableSource._currentPrimaryRenderer ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same mutable source. This is currently unsupported."
				)
			end
		else
			if mutableSource._currentSecondaryRenderer == nil then
				mutableSource._currentSecondaryRenderer = rendererSigil
			elseif mutableSource._currentSecondaryRenderer ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same mutable source. This is currently unsupported."
				)
			end
		end
	end
end

-- Eager reads the version of a mutable source and stores it on the root.
-- This ensures that the version used for server rendering matches the one
-- that is eventually read during hydration.
-- If they don't match there's a potential tear and a full deopt render is required.
exports.registerMutableSourceForHydration =
	function(root: FiberRoot, mutableSource: MutableSource<any>)
		local getVersion = mutableSource._getVersion
		local version_ = getVersion(mutableSource._source)

		-- TODO Clear this data once all pending hydration work is finished.
		-- Retaining it forever may interfere with GC.
		if root.mutableSourceEagerHydrationData == nil then
			root.mutableSourceEagerHydrationData = { mutableSource, version_ }
		else
			-- ROBLOX FIXME: having trouble with type coercion in this case
			-- table.insert(root.mutableSourceEagerHydrationData, mutableSource)
			-- table.insert(root.mutableSourceEagerHydrationData, version_)
		end
	end

return exports ]]
cX.Children._e09ae797b6571bf46d540bbd22d428e7=ef
local eg

local eh={ClassName="ModuleScript",Children={},Properties={}}
eh.Name="ReactPortal"
eh.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactPortal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local REACT_PORTAL_TYPE = require(Packages.Shared).ReactSymbols.REACT_PORTAL_TYPE

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type ReactPortal = ReactTypes.ReactPortal

local function createPortal(
	children: ReactNodeList,
	containerInfo: any,
	-- TODO: figure out the API for cross-renderer implementation.
	implementation: any,
	key: string?
): ReactPortal
	if key ~= nil then
		key = tostring(key)
	end
	return {
		-- This tag allow us to uniquely identify this as a React Portal
		["$$typeof"] = REACT_PORTAL_TYPE,
		key = key,
		children = children,
		containerInfo = containerInfo,
		implementation = implementation,
	}
end

return {
	createPortal = createPortal,
} ]]
cX.Children._d503afc387ba8b33c420dd8e95b38ca5=eh
local ei

local ej={ClassName="ModuleScript",Children={},Properties={}}
ej.Name="ReactProfilerTimer.new"
ej.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactProfilerTimer.new.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableProfilerCommitHooks = ReactFeatureFlags.enableProfilerCommitHooks

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local Profiler = ReactWorkTags.Profiler

-- Intentionally not named imports because Rollup would use dynamic dispatch for
-- CommonJS interop named imports.
local Scheduler = require(Packages.Scheduler)

local now = Scheduler.unstable_now

export type ProfilerTimer = {
	getCommitTime: () -> number,
	recordCommitTime: () -> (),
	startProfilerTimer: (Fiber) -> (),
	stopProfilerTimerIfRunning: (Fiber) -> (),
	stopProfilerTimerIfRunningAndRecordDelta: (Fiber) -> (),
	-- ...
}

local commitTime: number = 0
local layoutEffectStartTime: number = -1
local profilerStartTime: number = -1
local passiveEffectStartTime: number = -1

function getCommitTime(): number
	return commitTime
end

function recordCommitTime(): ()
	if not enableProfilerTimer then
		return
	end
	commitTime = now()
end

function startProfilerTimer(fiber: Fiber): ()
	if not enableProfilerTimer then
		return
	end

	profilerStartTime = now()

	-- ROBLOX deviation: JS can compare null/undefined to 0, but Lua can't
	if fiber.actualStartTime ~= nil and (fiber.actualStartTime :: number) < 0 then
		fiber.actualStartTime = now()
	end
end

function stopProfilerTimerIfRunning(fiber: Fiber): ()
	if not enableProfilerTimer then
		return
	end
	profilerStartTime = -1
end

function stopProfilerTimerIfRunningAndRecordDelta(
	fiber: Fiber,
	overrideBaseTime: boolean
): ()
	if not enableProfilerTimer then
		return
	end

	if profilerStartTime >= 0 then
		local elapsedTime_ = now() - profilerStartTime
		fiber.actualDuration += elapsedTime_
		if overrideBaseTime then
			fiber.selfBaseDuration = elapsedTime_
		end
		profilerStartTime = -1
	end
end

function recordLayoutEffectDuration(fiber: Fiber): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end

	if layoutEffectStartTime >= 0 then
		local elapsedTime_ = now() - layoutEffectStartTime

		layoutEffectStartTime = -1

		-- Store duration on the next nearest Profiler ancestor.
		local parentFiber = fiber.return_
		while parentFiber ~= nil do
			if parentFiber.tag == Profiler then
				local parentStateNode = parentFiber.stateNode
				parentStateNode.effectDuration += elapsedTime_
				break
			end
			parentFiber = parentFiber.return_
		end
	end
end

function recordPassiveEffectDuration(fiber: Fiber): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end

	if passiveEffectStartTime >= 0 then
		local elapsedTime_ = now() - passiveEffectStartTime

		passiveEffectStartTime = -1

		-- Store duration on the next nearest Profiler ancestor.
		local parentFiber = fiber.return_
		while parentFiber ~= nil do
			if parentFiber.tag == Profiler then
				local parentStateNode = parentFiber.stateNode
				if parentStateNode ~= nil then
					-- Detached fibers have their state node cleared out.
					-- In this case, the return pointer is also cleared out,
					-- so we won't be able to report the time spent in this Profiler's subtree.
					parentStateNode.passiveEffectDuration += elapsedTime_
				end
				break
			end
			parentFiber = parentFiber.return_
		end
	end
end

function startLayoutEffectTimer(): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end
	layoutEffectStartTime = now()
end

function startPassiveEffectTimer(): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end
	passiveEffectStartTime = now()
end

function transferActualDuration(fiber: Fiber): ()
	-- Transfer time spent rendering these children so we don't lose it
	-- after we rerender. This is used as a helper in special cases
	-- where we should count the work of multiple passes.
	local child = fiber.child
	while child do
		fiber.actualDuration += child.actualDuration
		child = child.sibling
	end
end

return {
	getCommitTime = getCommitTime,
	recordCommitTime = recordCommitTime,
	recordLayoutEffectDuration = recordLayoutEffectDuration,
	recordPassiveEffectDuration = recordPassiveEffectDuration,
	startLayoutEffectTimer = startLayoutEffectTimer,
	startPassiveEffectTimer = startPassiveEffectTimer,
	startProfilerTimer = startProfilerTimer,
	stopProfilerTimerIfRunning = stopProfilerTimerIfRunning,
	stopProfilerTimerIfRunningAndRecordDelta = stopProfilerTimerIfRunningAndRecordDelta,
	transferActualDuration = transferActualDuration,
} ]]
cX.Children._a723c07c7213bfc560c5664cb3a989ca=ej
local ek

local el={ClassName="ModuleScript",Children={},Properties={}}
el.Name="ReactRootTags"
el.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactRootTags.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

export type RootTag = number

return {
	LegacyRoot = 0,
	BlockingRoot = 1,
	ConcurrentRoot = 2,
} ]]
cX.Children._3f99abf24dc43c7f7bddf1c009ed9d26=el
local em

local en={ClassName="ModuleScript",Children={},Properties={}}
en.Name="ReactStrictModeWarnings.new"
en.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-reconciler/src/ReactStrictModeWarnings.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local getComponentName = require(Packages.Shared).getComponentName
local StrictMode = require(script.Parent.ReactTypeOfMode).StrictMode

type Set<T> = { [T]: boolean }
type Array<T> = { [number]: T }
type Map<K, V> = { [K]: V }
type FiberArray = Array<Fiber>
type FiberToFiberComponentsMap = Map<Fiber, FiberArray>

local ReactStrictModeWarnings = {
	recordUnsafeLifecycleWarnings = function(fiber: Fiber, instance: any) end,
	flushPendingUnsafeLifecycleWarnings = function() end,
	recordLegacyContextWarning = function(fiber: Fiber, instance: any) end,
	flushLegacyContextWarning = function() end,
	discardPendingWarnings = function() end,
}

if _G.__DEV__ then
	local findStrictRoot = function(fiber: Fiber): Fiber | nil
		local maybeStrictRoot = nil

		-- ROBLOX FIXME Luau: Luau needs to understand while not nil loops
		local node: Fiber? = fiber
		while node ~= nil do
			if bit32.band(node.mode, StrictMode) ~= 0 then
				maybeStrictRoot = node
			end
			node = node.return_
		end

		return maybeStrictRoot
	end

	local setToSortedString = function(set): string
		local array = {}
		for key, value in set do
			table.insert(array, key)
		end
		table.sort(array)
		return table.concat(array, ", ")
	end

	local pendingComponentWillMountWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillMountWarnings: Array<Fiber> = {}
	local pendingComponentWillReceivePropsWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillReceivePropsWarnings: Array<Fiber> = {}
	local pendingComponentWillUpdateWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillUpdateWarnings: Array<Fiber> = {}

	-- Tracks components we have already warned about.
	local didWarnAboutUnsafeLifecycles = {}

	ReactStrictModeWarnings.recordUnsafeLifecycleWarnings =
		function(fiber: Fiber, instance: any)
			-- Dedupe strategy: Warn once per component.
			if didWarnAboutUnsafeLifecycles[fiber.type] then
				return
			end

			if
				typeof(instance.componentWillMount) == "function"
				-- Don't warn about react-lifecycles-compat polyfilled components.
				-- ROBLOX deviation: Lua doesn't allow fields on function
				-- instance.componentWillMount.__suppressDeprecationWarning ~= true
			then
				table.insert(pendingComponentWillMountWarnings, fiber)
			end

			if
				bit32.band(fiber.mode, StrictMode) ~= 0
				and typeof(instance.UNSAFE_componentWillMount) == "function"
			then
				table.insert(pendingUNSAFE_ComponentWillMountWarnings, fiber)
			end

			if
				typeof(instance.componentWillReceiveProps) == "function"
				-- ROBLOX deviation: Lua doesn't allow fields on function
				-- instance.componentWillReceiveProps.__suppressDeprecationWarning ~= true
			then
				table.insert(pendingComponentWillReceivePropsWarnings, fiber)
			end

			if
				bit32.band(fiber.mode, StrictMode) ~= 0
				and typeof(instance.UNSAFE_componentWillReceiveProps) == "function"
			then
				table.insert(pendingUNSAFE_ComponentWillReceivePropsWarnings, fiber)
			end

			if
				typeof(instance.componentWillUpdate) == "function"
				-- ROBLOX deviation: Lua doesn't allow fields on function
				-- instance.componentWillUpdate.__suppressDeprecationWarning ~= true
			then
				table.insert(pendingComponentWillUpdateWarnings, fiber)
			end

			if
				bit32.band(fiber.mode, StrictMode) ~= 0
				and typeof(instance.UNSAFE_componentWillUpdate) == "function"
			then
				table.insert(pendingUNSAFE_ComponentWillUpdateWarnings, fiber)
			end
		end

	ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function()
		-- We do an initial pass to gather component names
		local componentWillMountUniqueNames = {}
		if #pendingComponentWillMountWarnings > 0 then
			for i, fiber in pendingComponentWillMountWarnings do
				componentWillMountUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end
			table.clear(pendingComponentWillMountWarnings)
		end

		local UNSAFE_componentWillMountUniqueNames = {}
		if #pendingUNSAFE_ComponentWillMountWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillMountWarnings do
				UNSAFE_componentWillMountUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end
			table.clear(pendingUNSAFE_ComponentWillMountWarnings)
		end

		local componentWillReceivePropsUniqueNames = {}
		if #pendingComponentWillReceivePropsWarnings > 0 then
			for i, fiber in pendingComponentWillReceivePropsWarnings do
				componentWillReceivePropsUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingComponentWillReceivePropsWarnings)
		end

		local UNSAFE_componentWillReceivePropsUniqueNames = {}
		if #pendingUNSAFE_ComponentWillReceivePropsWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillReceivePropsWarnings do
				UNSAFE_componentWillReceivePropsUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings)
		end

		local componentWillUpdateUniqueNames = {}
		if #pendingComponentWillUpdateWarnings > 0 then
			for i, fiber in pendingComponentWillUpdateWarnings do
				componentWillUpdateUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingComponentWillUpdateWarnings)
		end

		local UNSAFE_componentWillUpdateUniqueNames = {}
		if #pendingUNSAFE_ComponentWillUpdateWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillUpdateWarnings do
				UNSAFE_componentWillUpdateUniqueNames[getComponentName(fiber.type) or "Component"] =
					true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingUNSAFE_ComponentWillUpdateWarnings)
		end

		-- Finally, we flush all the warnings
		-- UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillMountUniqueNames) ~= nil then
			local sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames)
			console.error(
				"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillReceivePropsUniqueNames) ~= nil then
			local sortedNames =
				setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames)
			console.error(
				"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended "
					.. "and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* If you're updating state whenever props change, "
					.. "refactor your code to use memoization techniques or move it to "
					.. "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillUpdateUniqueNames) ~= nil then
			local sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames)
			console.error(
				"Using UNSAFE_componentWillUpdate in strict mode is not recommended "
					.. "and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillMountUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillMountUniqueNames)

			-- ROBLOX TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillMount has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n"
					.. "* Rename componentWillMount to UNSAFE_componentWillMount to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillReceivePropsUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillReceivePropsUniqueNames)

			-- ROBLOX TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillReceiveProps has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* If you're updating state whenever props change, refactor your "
					.. "code to use memoization techniques or move it to "
					.. "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n"
					.. "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillUpdateUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillUpdateUniqueNames)

			-- ROBLOX TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillUpdate has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end
	end

	local pendingLegacyContextWarning: FiberToFiberComponentsMap = {}

	-- Tracks components we have already warned about.
	local didWarnAboutLegacyContext = {}

	ReactStrictModeWarnings.recordLegacyContextWarning =
		function(fiber: Fiber, instance: any)
			local strictRoot = findStrictRoot(fiber)
			if strictRoot == nil then
				console.error(
					"Expected to find a StrictMode component in a strict mode tree. "
						.. "This error is likely caused by a bug in React. Please file an issue."
				)
				return
			end

			-- Dedup strategy: Warn once per component.
			if didWarnAboutLegacyContext[fiber.type] then
				return
			end

			-- ROBLOX FIXME Luau: Luau should narrow based on the nil guard
			local warningsForRoot = pendingLegacyContextWarning[strictRoot :: Fiber]

			-- ROBLOX deviation: Lua can't have fields on functions
			if
				typeof(fiber.type) ~= "function"
				and (
					fiber.type.contextTypes ~= nil
					or fiber.type.childContextTypes ~= nil
					or (
						instance ~= nil
						and typeof(instance.getChildContext) == "function"
					)
				)
			then
				if warningsForRoot == nil then
					warningsForRoot = {}
					-- ROBLOX FIXME Luau: Luau should narrow based on the nil guard
					pendingLegacyContextWarning[strictRoot :: Fiber] = warningsForRoot
				end
				table.insert(warningsForRoot, fiber)
			end
		end

	ReactStrictModeWarnings.flushLegacyContextWarning = function()
		for strictRoot, fiberArray in pendingLegacyContextWarning do
			if #fiberArray == 0 then
				return
			end
			local firstFiber = fiberArray[1]

			local uniqueNames = {}
			for i, fiber in fiberArray do
				uniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutLegacyContext[fiber.type] = true
			end

			local sortedNames = setToSortedString(uniqueNames)

			local ok, error_ = pcall(function()
				setCurrentDebugFiberInDEV(firstFiber)
				console.error(
					"Legacy context API has been detected within a strict-mode tree."
						.. "\n\nThe old API will be supported in all 16.x releases, but applications "
						.. "using it should migrate to the new version."
						.. "\n\nPlease update the following components: %s"
						.. "\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",
					sortedNames
				)
			end)

			-- finally
			resetCurrentDebugFiberInDEV()

			if not ok then
				error(error_)
			end
		end
	end

	ReactStrictModeWarnings.discardPendingWarnings = function()
		-- ROBLOX performance? use table.clear instead of assigning new array
		table.clear(pendingComponentWillMountWarnings)
		table.clear(pendingUNSAFE_ComponentWillMountWarnings)
		table.clear(pendingComponentWillReceivePropsWarnings)
		table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings)
		table.clear(pendingComponentWillUpdateWarnings)
		table.clear(pendingUNSAFE_ComponentWillUpdateWarnings)
		table.clear(pendingLegacyContextWarning)
	end
end

return ReactStrictModeWarnings ]]
cX.Children._ea87c010b2df636d23f39cef9f003f44=en
local eo

local ep={ClassName="ModuleScript",Children={},Properties={}}
ep.Name="ReactTestSelectors"
ep.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/3cde22a84e246fc5361f038bf0c23405b2572c22/packages/react-reconciler/src/ReactTestSelectors.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Set<T> = { [T]: boolean }
type Array<T> = LuauPolyfill.Array<T>
type Function = (...any) -> ...any
type Object = LuauPolyfill.Object

-- local type {Fiber} = require(Packages.react-reconciler/src/ReactInternalTypes'
-- local type {Instance} = require(Packages../ReactFiberHostConfig'

-- local invariant = require(Packages.shared/invariant'
-- local {HostComponent, HostText} = require(Packages.react-reconciler/src/ReactWorkTags'
-- local getComponentName = require(Packages.shared/getComponentName'

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local supportsTestSelectors = ReactFiberHostConfig.supportsTestSelectors
-- local {
--   findFiberRoot,
--   getBoundingRect,
--   getInstanceFromNode,
--   getTextContent,
--   isHiddenSubtree,
--   matchAccessibilityRole,
--   setFocusIfFocusable,
--   setupIntersectionObserver,
--   ,
-- } = require(Packages../ReactFiberHostConfig'

-- local COMPONENT_TYPE = 0b000
-- local HAS_PSEUDO_CLASS_TYPE = 0b001
-- local ROLE_TYPE = 0b010
-- local TEST_NAME_TYPE = 0b011
-- local TEXT_TYPE = 0b100

-- if typeof Symbol == 'function' and Symbol.for)
--   local symbolFor = Symbol.for
--   COMPONENT_TYPE = symbolFor('selector.component')
--   HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class')
--   ROLE_TYPE = symbolFor('selector.role')
--   TEST_NAME_TYPE = symbolFor('selector.test_id')
--   TEXT_TYPE = symbolFor('selector.text')
-- end

-- type Type = Symbol | number

-- type ComponentSelector = {|
--   $$typeof: Type,
--   value: React$AbstractComponent<empty, mixed>,
-- |}

-- type HasPsuedoClassSelector = {|
--   $$typeof: Type,
--   value: Array<Selector>,
-- |}

-- type RoleSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type TextSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type TestNameSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type Selector =
--   | ComponentSelector
--   | HasPsuedoClassSelector
--   | RoleSelector
--   | TextSelector
--   | TestNameSelector

local exports = {}

-- exports.createComponentSelector(
--   component: React$AbstractComponent<empty, mixed>,
-- ): ComponentSelector {
--   return {
--     $$typeof: COMPONENT_TYPE,
--     value: component,
--   }
-- end

-- exports.createHasPsuedoClassSelector(
--   selectors: Array<Selector>,
-- ): HasPsuedoClassSelector {
--   return {
--     $$typeof: HAS_PSEUDO_CLASS_TYPE,
--     value: selectors,
--   }
-- end

-- exports.createRoleSelector(role: string): RoleSelector {
--   return {
--     $$typeof: ROLE_TYPE,
--     value: role,
--   }
-- end

-- exports.createTextSelector(text: string): TextSelector {
--   return {
--     $$typeof: TEXT_TYPE,
--     value: text,
--   }
-- end

-- exports.createTestNameSelector(id: string): TestNameSelector {
--   return {
--     $$typeof: TEST_NAME_TYPE,
--     value: id,
--   }
-- end

-- function findFiberRootForHostRoot(hostRoot: Instance): Fiber {
--   local maybeFiber = getInstanceFromNode((hostRoot: any))
--   if maybeFiber ~= nil)
--     invariant(
--       typeof maybeFiber.memoizedProps['data-testname'] == 'string',
--       'Invalid host root specified. Should be either a React container or a node with a testname attribute.',
--     )
--     return ((maybeFiber: any): Fiber)
--   } else {
--     local fiberRoot = findFiberRoot(hostRoot)
--     invariant(
--       fiberRoot ~= nil,
--       'Could not find React container within specified host subtree.',
--     )
--     -- The Flow type for FiberRoot is a little funky.
--     -- createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.
--     return ((fiberRoot: any).stateNode.current: Fiber)
--   }
-- end

-- function matchSelector(fiber: Fiber, selector: Selector): boolean {
--   switch (selector.$$typeof)
--     case COMPONENT_TYPE:
--       if fiber.type == selector.value)
--         return true
--       }
--       break
--     case HAS_PSEUDO_CLASS_TYPE:
--       return hasMatchingPaths(
--         fiber,
--         ((selector: any): HasPsuedoClassSelector).value,
--       )
--     case ROLE_TYPE:
--       if fiber.tag == HostComponent)
--         local node = fiber.stateNode
--         if
--           matchAccessibilityRole(node, ((selector: any): RoleSelector).value)
--         )
--           return true
--         }
--       }
--       break
--     case TEXT_TYPE:
--       if fiber.tag == HostComponent or fiber.tag == HostText)
--         local textContent = getTextContent(fiber)
--         if
--           textContent ~= nil and
--           textContent.indexOf(((selector: any): TextSelector).value) >= 0
--         )
--           return true
--         }
--       }
--       break
--     case TEST_NAME_TYPE:
--       if fiber.tag == HostComponent)
--         local dataTestID = fiber.memoizedProps['data-testname']
--         if
--           typeof dataTestID == 'string' and
--           dataTestID.toLowerCase() ==
--             ((selector: any): TestNameSelector).value.toLowerCase()
--         )
--           return true
--         }
--       }
--       break
--     default:
--       invariant(null, 'Invalid selector type %s specified.', selector)
--       break
--   }

--   return false
-- end

-- function selectorToString(selector: Selector): string | nil {
--   switch (selector.$$typeof)
--     case COMPONENT_TYPE:
--       local displayName = getComponentName(selector.value) or 'Unknown'
--       return `<${displayName}>`
--     case HAS_PSEUDO_CLASS_TYPE:
--       return `:has(${selectorToString(selector) or ''})`
--     case ROLE_TYPE:
--       return `[role="${((selector: any): RoleSelector).value}"]`
--     case TEXT_TYPE:
--       return `"${((selector: any): TextSelector).value}"`
--     case TEST_NAME_TYPE:
--       return `[data-testname="${((selector: any): TestNameSelector).value}"]`
--     default:
--       invariant(null, 'Invalid selector type %s specified.', selector)
--       break
--   }

--   return nil
-- end

-- function findPaths(root: Fiber, selectors: Array<Selector>): Array<Fiber> {
--   local matchingFibers: Array<Fiber> = []

--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else {
--       while (selector ~= nil and matchSelector(fiber, selector))
--         selectorIndex++
--         selector = selectors[selectorIndex]
--       }
--     }

--     if selectorIndex == selectors.length)
--       matchingFibers.push(fiber)
--     } else {
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   return matchingFibers
-- end

-- -- Same as findPaths but with eager bailout on first match
-- function hasMatchingPaths(root: Fiber, selectors: Array<Selector>): boolean {
--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else {
--       while (selector ~= nil and matchSelector(fiber, selector))
--         selectorIndex++
--         selector = selectors[selectorIndex]
--       }
--     }

--     if selectorIndex == selectors.length)
--       return true
--     } else {
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   return false
-- end

-- exports.findAllNodes(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): Array<Instance> {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)
--   local matchingFibers = findPaths(root, selectors)

--   local instanceRoots: Array<Instance> = []

--   local stack = Array.from(matchingFibers)
--   local index = 0
--   while (index < stack.length)
--     local node = ((stack[index++]: any): Fiber)
--     if node.tag == HostComponent)
--       if isHiddenSubtree(node))
--         continue
--       }
--       instanceRoots.push(node.stateNode)
--     } else {
--       local child = node.child
--       while (child ~= nil)
--         stack.push(child)
--         child = child.sibling
--       }
--     }
--   }

--   return instanceRoots
-- end

-- exports.getFindAllNodesFailureDescription(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): string | nil {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)

--   local maxSelectorIndex: number = 0
--   local matchedNames = []

--   -- The logic of this loop should be kept in sync with findPaths()
--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else if matchSelector(fiber, selector))
--       matchedNames.push(selectorToString(selector))
--       selectorIndex++

--       if selectorIndex > maxSelectorIndex)
--         maxSelectorIndex = selectorIndex
--       }
--     }

--     if selectorIndex < selectors.length)
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   if maxSelectorIndex < selectors.length)
--     local unmatchedNames = []
--     for (local i = maxSelectorIndex; i < selectors.length; i++)
--       unmatchedNames.push(selectorToString(selectors[i]))
--     }

--     return (
--       'findAllNodes was able to match part of the selector:\n' +
--       `  ${matchedNames.join(' > ')}\n\n` +
--       'No matching component was found for:\n' +
--       `  ${unmatchedNames.join(' > ')}`
--     )
--   }

--   return nil
-- end

export type BoundingRect = {
	x: number,
	y: number,
	width: number,
	height: number,
}

-- exports.findBoundingRects(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): Array<BoundingRect> {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local instanceRoots = findAllNodes(hostRoot, selectors)

--   local boundingRects: Array<BoundingRect> = []
--   for (local i = 0; i < instanceRoots.length; i++)
--     boundingRects.push(getBoundingRect(instanceRoots[i]))
--   }

--   for (local i = boundingRects.length - 1; i > 0; i--)
--     local targetRect = boundingRects[i]
--     local targetLeft = targetRect.x
--     local targetRight = targetLeft + targetRect.width
--     local targetTop = targetRect.y
--     local targetBottom = targetTop + targetRect.height

--     for (local j = i - 1; j >= 0; j--)
--       if i ~= j)
--         local otherRect = boundingRects[j]
--         local otherLeft = otherRect.x
--         local otherRight = otherLeft + otherRect.width
--         local otherTop = otherRect.y
--         local otherBottom = otherTop + otherRect.height

--         -- Merging all rects to the minimums set would be complicated,
--         -- but we can handle the most common cases:
--         -- 1. completely overlapping rects
--         -- 2. adjacent rects that are the same width or height (e.g. items in a list)
--         --
--         -- Even given the above constraints,
--         -- we still won't end up with the fewest possible rects without doing multiple passes,
--         -- but it's good enough for this purpose.

--         if
--           targetLeft >= otherLeft and
--           targetTop >= otherTop and
--           targetRight <= otherRight and
--           targetBottom <= otherBottom
--         )
--           -- Complete overlapping rects; remove the inner one.
--           boundingRects.splice(i, 1)
--           break
--         } else if
--           targetLeft == otherLeft and
--           targetRect.width == otherRect.width and
--           !(otherBottom < targetTop) and
--           !(otherTop > targetBottom)
--         )
--           -- Adjacent vertical rects; merge them.
--           if otherTop > targetTop)
--             otherRect.height += otherTop - targetTop
--             otherRect.y = targetTop
--           }
--           if otherBottom < targetBottom)
--             otherRect.height = targetBottom - otherTop
--           }

--           boundingRects.splice(i, 1)
--           break
--         } else if
--           targetTop == otherTop and
--           targetRect.height == otherRect.height and
--           !(otherRight < targetLeft) and
--           !(otherLeft > targetRight)
--         )
--           -- Adjacent horizontal rects; merge them.
--           if otherLeft > targetLeft)
--             otherRect.width += otherLeft - targetLeft
--             otherRect.x = targetLeft
--           }
--           if otherRight < targetRight)
--             otherRect.width = targetRight - otherLeft
--           }

--           boundingRects.splice(i, 1)
--           break
--         }
--       }
--     }
--   }

--   return boundingRects
-- end

-- exports.focusWithin(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): boolean {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)
--   local matchingFibers = findPaths(root, selectors)

--   local stack = Array.from(matchingFibers)
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     if isHiddenSubtree(fiber))
--       continue
--     }
--     if fiber.tag == HostComponent)
--       local node = fiber.stateNode
--       if setFocusIfFocusable(node))
--         return true
--       }
--     }
--     local child = fiber.child
--     while (child ~= nil)
--       stack.push(child)
--       child = child.sibling
--     }
--   }

--   return false
-- end

local commitHooks: Array<Function> = {}

exports.onCommitRoot = function(): ()
	if supportsTestSelectors then
		for i, commitHook in commitHooks do
			commitHook()
		end
	end
end

export type IntersectionObserverOptions = Object

export type ObserveVisibleRectsCallback = (
	intersections: Array<{ ratio: number, rect: BoundingRect }>
) -> ()

-- exports.observeVisibleRects(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
--   callback: (intersections: Array<{ratio: number, rect: BoundingRect}>) => void,
--   options?: IntersectionObserverOptions,
-- ): {|disconnect: () => void|} {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local instanceRoots = findAllNodes(hostRoot, selectors)

--   local {disconnect, observe, unobserve} = setupIntersectionObserver(
--     instanceRoots,
--     callback,
--     options,
--   )

--   -- When React mutates the host environment, we may need to change what we're listening to.
--   local commitHook = () => {
--     local nextInstanceRoots = findAllNodes(hostRoot, selectors)

--     instanceRoots.forEach(target => {
--       if nextInstanceRoots.indexOf(target) < 0)
--         unobserve(target)
--       }
--     })

--     nextInstanceRoots.forEach(target => {
--       if instanceRoots.indexOf(target) < 0)
--         observe(target)
--       }
--     })
--   }

--   commitHooks.push(commitHook)

--   return {
--     disconnect: () => {
--       -- Stop listening for React mutations:
--       local index = commitHooks.indexOf(commitHook)
--       if index >= 0)
--         commitHooks.splice(index, 1)
--       }

--       -- Disconnect the host observer:
--       disconnect()
--     },
--   }
-- end

return exports ]]
cX.Children._578599d49bc1bc1e43ea18807bb74926=ep
local eq

local er={ClassName="ModuleScript",Children={},Properties={}}
er.Name="ReactTypeOfMode"
er.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/22dc2e42bdc00d87fc19c5e75fc7c0b3fdcdc572/packages/react-reconciler/src/ReactTypeOfMode.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

export type TypeOfMode = number

return {
	NoMode = 0b00000,
	StrictMode = 0b00001,
	-- TODO: Remove BlockingMode and ConcurrentMode by reading from the root
	-- tag instead
	BlockingMode = 0b00010,
	ConcurrentMode = 0b00100,
	ProfileMode = 0b01000,
	DebugTracingMode = 0b10000,
} ]]
cX.Children._7356b5c76b4b3df8c1cafa5ceda62e76=er
local es

local et={ClassName="ModuleScript",Children={},Properties={}}
et.Name="ReactUpdateQueue.new"
et.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactUpdateQueue.new.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

-- UpdateQueue is a linked list of prioritized updates.
--
-- Like fibers, update queues come in pairs: a current queue, which represents
-- the visible state of the screen, and a work-in-progress queue, which can be
-- mutated and processed asynchronously before it is committed — a form of
-- double buffering. If a work-in-progress render is discarded before finishing,
-- we create a new work-in-progress by cloning the current queue.
--
-- Both queues share a persistent, singly-linked list structure. To schedule an
-- update, we append it to the end of both queues. Each queue maintains a
-- pointer to first update in the persistent list that hasn't been processed.
-- The work-in-progress pointer always has a position equal to or greater than
-- the current queue, since we always work on that one. The current queue's
-- pointer is only updated during the commit phase, when we swap in the
-- work-in-progress.
--
-- For example:
--
--   Current pointer:           A - B - C - D - E - F
--   Work-in-progress pointer:              D - E - F
--                                          ^
--                                          The work-in-progress queue has
--                                          processed more updates than current.
--
-- The reason we append to both queues is because otherwise we might drop
-- updates without ever processing them. For example, if we only add updates to
-- the work-in-progress queue, some updates could be lost whenever a work-in
-- -progress render restarts by cloning from current. Similarly, if we only add
-- updates to the current queue, the updates will be lost whenever an already
-- in-progress queue commits and swaps with the current queue. However, by
-- adding to both queues, we guarantee that the update will be part of the next
-- work-in-progress. (And because the work-in-progress queue becomes the
-- current queue once it commits, there's no danger of applying the same
-- update twice.)
--
-- Prioritization
-- --------------
--
-- Updates are not sorted by priority, but by insertion; new updates are always
-- appended to the end of the list.
--
-- The priority is still important, though. When processing the update queue
-- during the render phase, only the updates with sufficient priority are
-- included in the result. If we skip an update because it has insufficient
-- priority, it remains in the queue to be processed later, during a lower
-- priority render. Crucially, all updates subsequent to a skipped update also
-- remain in the queue *regardless of their priority*. That means high priority
-- updates are sometimes processed twice, at two separate priorities. We also
-- keep track of a base state, that represents the state before the first
-- update in the queue is applied.
--
-- For example:
--
--   Given a base state of '', and the following queue of updates
--
--     A1 - B2 - C1 - D2
--
--   where the number indicates the priority, and the update is applied to the
--   previous state by appending a letter, React will process these updates as
--   two separate renders, one per distinct priority level:
--
--   First render, at priority 1:
--     Base state: ''
--     Updates: [A1, C1]
--     Result state: 'AC'
--
--   Second render, at priority 2:
--     Base state: 'A'            <-  The base state does not include C1,
--                                    because B2 was skipped.
--     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
--     Result state: 'ABCD'
--
-- Because we process updates in insertion order, and rebase high priority
-- updates when preceding updates are skipped, the final result is deterministic
-- regardless of priority. Intermediate state may vary according to system
-- resources, but the final state is always the same.

local __DEV__ = _G.__DEV__
local __YOLO__ = _G.__YOLO__

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type Lane = ReactInternalTypes.Lane
type Lanes = ReactInternalTypes.Lanes

local ReactFiberLane = require(script.Parent.ReactFiberLane)
local NoLane = ReactFiberLane.NoLane
local NoLanes = ReactFiberLane.NoLanes
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes

-- ROBLOX deviation: lazy instantiate to avoid circular require
local ReactFiberNewContext --= require(script.Parent["ReactFiberNewContext.new"])
-- local enterDisallowedContextReadInDEV = ReactFiberNewContext.enterDisallowedContextReadInDEV
-- local exitDisallowedContextReadInDEV = ReactFiberNewContext.exitDisallowedContextReadInDEV
local function enterDisallowedContextReadInDEV()
	if not ReactFiberNewContext then
		ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"]) :: any
	end
	ReactFiberNewContext.enterDisallowedContextReadInDEV()
end
local function exitDisallowedContextReadInDEV()
	if not ReactFiberNewContext then
		ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"]) :: any
	end
	ReactFiberNewContext.exitDisallowedContextReadInDEV()
end
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Callback = ReactFiberFlags.Callback
local ShouldCapture = ReactFiberFlags.ShouldCapture
local DidCapture = ReactFiberFlags.DidCapture

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode =
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode

local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local StrictMode = ReactTypeOfMode.StrictMode
-- local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
local markSkippedUpdateLanes =
	require(script.Parent.ReactFiberWorkInProgress).markSkippedUpdateLanes

-- ROBLOX deviation START: use if-then-error, which avoid string format and function call overhead, as in React 18
-- local invariant = require(Packages.Shared).invariant
-- ROBLOX deviation END
local describeError = require(Packages.Shared).describeError

local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

-- deviation: Common types
type Array<T> = { [number]: T }

-- ROBLOX deviation: transplants UpdateQueue<> and SharedState<> types to ReactInternalTypes for export to createReactNoop
type Update<T> = ReactInternalTypes.Update<T>
type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>
export type SharedQueue<T> = ReactInternalTypes.SharedQueue<T>

local exports = {}

local UpdateState = 0
exports.UpdateState = UpdateState
local ReplaceState = 1
exports.ReplaceState = ReplaceState
local ForceUpdate = 2
exports.ForceUpdate = ForceUpdate
local CaptureUpdate = 3
exports.CaptureUpdate = CaptureUpdate

-- Global state that is reset at the beginning of calling `processUpdateQueue`.
-- It should only be read right after calling `processUpdateQueue`, via
-- `checkHasForceUpdateAfterProcessing`.
local hasForceUpdate = false

local didWarnUpdateInsideUpdate
local currentlyProcessingQueue: SharedQueue<any>?
-- export local resetCurrentlyProcessingQueue
if __DEV__ then
	didWarnUpdateInsideUpdate = false
	currentlyProcessingQueue = nil
	exports.resetCurrentlyProcessingQueue = function()
		currentlyProcessingQueue = nil
	end
end

-- ROBLOX performance: use a recycle pool for update tables
local poolInitSize = 210 -- TODO: Tune to LuaApps
-- local poolAdditionalSize = 0
local updatePool = table.create(poolInitSize)
local updatePoolIndex = poolInitSize
for i = 1, poolInitSize do
	updatePool[i] = {
		eventTime = -1,
		lane = -1,
		tag = -1,
		payload = nil,
		callback = nil,
		next = nil,
	}
end

local function initializeUpdateQueue<State>(fiber: Fiber): ()
	local queue: UpdateQueue<State> = {
		baseState = fiber.memoizedState,
		firstBaseUpdate = nil,
		lastBaseUpdate = nil,
		shared = {
			pending = nil,
		},
		effects = nil,
	}
	fiber.updateQueue = queue
end
exports.initializeUpdateQueue = initializeUpdateQueue

local function cloneUpdateQueue<State>(current: Fiber, workInProgress: Fiber): ()
	-- Clone the update queue from current. Unless it's already a clone.
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any
	local currentQueue: UpdateQueue<State> = current.updateQueue :: any
	if queue == currentQueue then
		-- ROBLOX deviation START: use our queue method for hot path optimizations
		local clone: UpdateQueue<State> = table.clone(currentQueue)
		-- ROBLOX deviation END
		workInProgress.updateQueue = clone
	end
end
exports.cloneUpdateQueue = cloneUpdateQueue

-- ROBLOX deviation START: add extra parameters here so updates can be create in single table ctor
local function createUpdate(
	eventTime: number,
	lane: Lane,
	payload: any?,
	callback: (() -> ...any)?
): Update<any>
	-- ROBLOX performance: Use pooled update object when available
	if updatePoolIndex > 0 then
		local update = updatePool[updatePoolIndex]
		updatePool[updatePoolIndex] = nil
		updatePoolIndex -= 1

		update.eventTime = eventTime
		update.lane = lane
		update.tag = UpdateState
		update.payload = payload
		update.callback = callback :: any

		return update :: Update<any>
	end
	-- ROBLOX deviation END

	-- ROBLOX performance FIXME: This warning is very noisy in practice and not
	-- actionable by Roact developers in any way. We should re-establish the
	-- warning once we've done some tuning and thought more about what messaging
	-- we want to convey to Roact users

	-- if __DEV__ then
	-- 	poolAdditionalSize += 1
	-- 	console.warn(
	-- 		"ReactUpdateQueue createUpdate's object pool exhausted, allocating fresh table."
	-- 			.. "\nConsider setting poolInitSize to " .. poolInitSize + poolAdditionalSize
	-- 			.. " to avoid this occurring in the future."
	-- 	)
	-- end

	local update = {
		eventTime = eventTime,
		lane = lane,

		tag = UpdateState,
		payload = payload,
		callback = callback :: any,

		next = nil,
	}
	return update :: Update<any>
end
exports.createUpdate = createUpdate

local function enqueueUpdate<State>(fiber: Fiber, update: Update<State>)
	local updateQueue = fiber.updateQueue
	if updateQueue == nil then
		-- Only occurs if the fiber has been unmounted.
		return
	end

	local sharedQueue: SharedQueue<State> = (updateQueue :: any).shared
	local pending = sharedQueue.pending
	if pending == nil then
		-- This is the first update. Create a circular list.
		update.next = update
	else
		update.next = pending.next
		pending.next = update
	end
	sharedQueue.pending = update

	if __DEV__ then
		if currentlyProcessingQueue == sharedQueue and not didWarnUpdateInsideUpdate then
			console.error(
				"An update (setState, replaceState, or forceUpdate) was scheduled "
					.. "from inside an update function. Update functions should be pure, "
					.. "with zero side-effects. Consider using componentDidUpdate or a "
					.. "callback."
			)
			didWarnUpdateInsideUpdate = true
		end
	end
end
exports.enqueueUpdate = enqueueUpdate

local function enqueueCapturedUpdate<State>(workInProgress: Fiber, capturedUpdate: Update<State>)
	-- Captured updates are updates that are thrown by a child during the render
	-- phase. They should be discarded if the render is aborted. Therefore,
	-- we should only put them on the work-in-progress queue, not the current one.
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any

	-- Check if the work-in-progress queue is a clone.
	local current = workInProgress.alternate
	if current ~= nil then
		local currentQueue: UpdateQueue<State> = current.updateQueue :: any
		if queue == currentQueue then
			-- The work-in-progress queue is the same as current. This happens when
			-- we bail out on a parent fiber that then captures an error thrown by
			-- a child. Since we want to append the update only to the work-in
			-- -progress queue, we need to clone the updates. We usually clone during
			-- processUpdateQueue, but that didn't happen in this case because we
			-- skipped over the parent when we bailed out.
			local newFirst = nil
			local newLast = nil
			local firstBaseUpdate = queue.firstBaseUpdate
			if firstBaseUpdate ~= nil then
				-- Loop through the updates and clone them.
				local update = firstBaseUpdate
				repeat
					local clone: Update<State> = {
						eventTime = update.eventTime,
						lane = update.lane,

						tag = update.tag,
						payload = update.payload,
						callback = update.callback,

						next = nil,
					}
					if newLast == nil then
						newLast = clone
						newFirst = clone
					else
						newLast.next = clone
						newLast = clone
					end
					-- ROBLOX FIXME Luau: Luau needs to support repeat until nil pattern
					update = update.next :: Update<State>
				until update == nil

				-- Append the captured update the end of the cloned list.
				if newLast == nil then
					newLast = capturedUpdate
					newFirst = capturedUpdate
				else
					newLast.next = capturedUpdate
					newLast = capturedUpdate
				end
			else
				-- There are no base updates.
				newLast = capturedUpdate
				newFirst = capturedUpdate
			end
			queue = {
				baseState = currentQueue.baseState,
				firstBaseUpdate = newFirst,
				lastBaseUpdate = newLast,
				shared = currentQueue.shared,
				effects = currentQueue.effects,
			}
			workInProgress.updateQueue = queue
			return
		end
	end

	-- Append the update to the end of the list.
	local lastBaseUpdate = queue.lastBaseUpdate
	if lastBaseUpdate == nil then
		queue.firstBaseUpdate = capturedUpdate
	else
		lastBaseUpdate.next = capturedUpdate
	end
	queue.lastBaseUpdate = capturedUpdate
end
exports.enqueueCapturedUpdate = enqueueCapturedUpdate

local function getStateFromUpdate<State>(
	workInProgress: Fiber,
	queue: UpdateQueue<State>,
	update: Update<State>,
	prevState: State,
	nextProps: any,
	instance: any
): any
	local updateTag = update.tag
	if updateTag == ReplaceState then
		local payload = update.payload
		if type(payload) == "function" then
			-- Updater function
			if __DEV__ then
				enterDisallowedContextReadInDEV()
			end
			-- ROBLOX deviation: Upstream binds this callback to the instance;
			-- in order for us to get the same behavior, we'd need to change the
			-- signature of the updater, which doesn't make sense for our case
			local nextState = payload(prevState, nextProps)
			if __DEV__ then
				if
					debugRenderPhaseSideEffectsForStrictMode
					and bit32.band(workInProgress.mode, StrictMode) ~= 0
				then
					disableLogs()
					-- ROBLOX deviation: YOLO flag for disabling pcall
					local ok, result
					if not __YOLO__ then
						ok, result = xpcall(payload, describeError, prevState, nextProps)
					else
						ok = true
						payload(prevState, nextProps)
					end
					-- finally
					reenableLogs()

					if not ok then
						error(result)
					end
				end
				exitDisallowedContextReadInDEV()
			end
			return nextState
		end
		-- State object
		return payload
	elseif updateTag == CaptureUpdate or updateTag == UpdateState then
		if updateTag == CaptureUpdate then
			workInProgress.flags = bit32.bor(
				bit32.band(workInProgress.flags, bit32.bnot(ShouldCapture)),
				DidCapture
			)
		end
		-- Intentional fallthrough
		local payload = update.payload
		local partialState
		if type(payload) == "function" then
			-- Updater function
			if __DEV__ then
				enterDisallowedContextReadInDEV()
			end
			-- ROBLOX deviation: Upstream binds this callback to the instance;
			-- in order for us to get the same behavior, we'd need to change the
			-- signature of the updater, which doesn't make sense for our case
			partialState = payload(prevState, nextProps)
			if __DEV__ then
				if
					debugRenderPhaseSideEffectsForStrictMode
					and bit32.band(workInProgress.mode, StrictMode) ~= 0
				then
					disableLogs()
					-- ROBLOX deviation: YOLO flag for disabling pcall
					local ok, result
					if not __YOLO__ then
						ok, result = xpcall(payload, describeError, prevState, nextProps)
					else
						ok = true
						payload(prevState, nextProps)
					end
					-- finally
					reenableLogs()

					if not ok then
						error(result)
					end
				end
				exitDisallowedContextReadInDEV()
			end
		else
			-- Partial state object
			partialState = payload
		end
		if partialState == nil then
			-- Null and undefined are treated as no-ops.
			return prevState
		end
		-- Merge the partial state and the previous state.
		-- ROBLOX TODO: the below optimziation doesn't work because: invalid argument #1 to 'clone' (table has a protected metatable)
		-- local newState = if prevState ~= nil then table.clone(prevState :: any) else {}
		return Object.assign({}, prevState, partialState)
	elseif updateTag == ForceUpdate then
		hasForceUpdate = true
		return prevState
	end
	return prevState
end
exports.getStateFromUpdate = getStateFromUpdate

local function processUpdateQueue<State>(
	workInProgress: Fiber,
	props: any,
	instance: any,
	renderLanes: Lanes
): ()
	-- This is always non-null on a ClassComponent or HostRoot
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any

	hasForceUpdate = false

	if __DEV__ then
		currentlyProcessingQueue = queue.shared
	end

	local firstBaseUpdate = queue.firstBaseUpdate
	local lastBaseUpdate = queue.lastBaseUpdate

	-- Check if there are pending updates. If so, transfer them to the base queue.
	local pendingQueue = queue.shared.pending
	if pendingQueue ~= nil then
		queue.shared.pending = nil

		-- The pending queue is circular. Disconnect the pointer between first
		-- and last so that it's non-circular.
		local lastPendingUpdate = pendingQueue
		local firstPendingUpdate = lastPendingUpdate.next
		lastPendingUpdate.next = nil
		-- Append pending updates to base queue
		if lastBaseUpdate == nil then
			firstBaseUpdate = firstPendingUpdate
		else
			lastBaseUpdate.next = firstPendingUpdate
		end
		lastBaseUpdate = lastPendingUpdate

		-- If there's a current queue, and it's different from the base queue, then
		-- we need to transfer the updates to that queue, too. Because the base
		-- queue is a singly-linked list with no cycles, we can append to both
		-- lists and take advantage of structural sharing.
		-- TODO: Pass `current` as argument
		local current = workInProgress.alternate
		if current ~= nil then
			-- This is always non-null on a ClassComponent or HostRoot
			local currentQueue: UpdateQueue<State> = current.updateQueue :: any
			local currentLastBaseUpdate = currentQueue.lastBaseUpdate
			if currentLastBaseUpdate ~= lastBaseUpdate then
				if currentLastBaseUpdate == nil then
					currentQueue.firstBaseUpdate = firstPendingUpdate
				else
					currentLastBaseUpdate.next = firstPendingUpdate
				end
				currentQueue.lastBaseUpdate = lastPendingUpdate
			end
		end
	end

	-- These values may change as we process the queue.
	if firstBaseUpdate ~= nil then
		-- Iterate through the list of updates to compute the result.
		local newState = queue.baseState
		-- TODO: Don't need to accumulate this. Instead, we can remove renderLanes
		-- from the original lanes.
		local newLanes = NoLanes

		local newBaseState = nil
		local newFirstBaseUpdate = nil
		local newLastBaseUpdate = nil

		local update = firstBaseUpdate
		while true do
			local updateLane = update.lane
			local updateEventTime = update.eventTime
			if not isSubsetOfLanes(renderLanes, updateLane) then
				-- Priority is insufficient. Skip this update. If this is the first
				-- skipped update, the previous update/state is the new base
				-- update/state.
				local clone: Update<State> = {
					eventTime = updateEventTime,
					lane = updateLane,

					tag = update.tag,
					payload = update.payload,
					callback = update.callback,

					next = nil,
				}
				if newLastBaseUpdate == nil then
					newFirstBaseUpdate = clone
					newLastBaseUpdate = clone
					newBaseState = newState
				else
					newLastBaseUpdate.next = clone
					newLastBaseUpdate = clone
				end
				-- Update the remaining priority in the queue.
				newLanes = mergeLanes(newLanes, updateLane)
			else
				-- This update does have sufficient priority.

				if newLastBaseUpdate ~= nil then
					local clone: Update<State> = {
						eventTime = updateEventTime,
						-- This update is going to be committed so we never want uncommit
						-- it. Using NoLane works because 0 is a subset of all bitmasks, so
						-- this will never be skipped by the check above.
						lane = NoLane,

						tag = update.tag,
						payload = update.payload,
						callback = update.callback,

						next = nil,
					}
					newLastBaseUpdate.next = clone
					newLastBaseUpdate = clone
				end

				-- Process this update.
				newState = getStateFromUpdate(
					workInProgress,
					queue,
					update,
					newState,
					props,
					instance
				)
				local callback = update.callback
				if
					callback ~= nil
					-- If the update was already committed, we should not queue its
					-- callback again.
					and update.lane ~= NoLane
				then
					workInProgress.flags = bit32.bor(workInProgress.flags, Callback)
					local effects = queue.effects
					if effects == nil then
						queue.effects = { update }
					else
						table.insert(effects, update)
					end
				end
			end
			-- ROBLOX FIXME Luau: Luau needs to support repeat until nil pattern
			update = update.next :: Update<State>
			if update == nil then
				pendingQueue = queue.shared.pending
				if pendingQueue == nil then
					break
				else
					-- An update was scheduled from inside a reducer. Add the new
					-- pending updates to the end of the list and keep processing.
					local lastPendingUpdate = pendingQueue
					-- Intentionally unsound. Pending updates form a circular list, but we
					-- unravel them when transferring them to the base queue.
					local firstPendingUpdate = (
						lastPendingUpdate.next :: any
					) :: Update<State>
					lastPendingUpdate.next = nil
					update = firstPendingUpdate
					queue.lastBaseUpdate = lastPendingUpdate
					queue.shared.pending = nil
				end
			end
		end

		if newLastBaseUpdate == nil then
			newBaseState = newState
		end

		queue.baseState = (newBaseState :: any) :: State
		queue.firstBaseUpdate = newFirstBaseUpdate
		queue.lastBaseUpdate = newLastBaseUpdate

		-- Set the remaining expiration time to be whatever is remaining in the queue.
		-- This should be fine because the only two other things that contribute to
		-- expiration time are props and context. We're already in the middle of the
		-- begin phase by the time we start processing the queue, so we've already
		-- dealt with the props. Context in components that specify
		-- shouldComponentUpdate is tricky; but we'll have to account for
		-- that regardless.
		markSkippedUpdateLanes(newLanes)
		workInProgress.lanes = newLanes
		workInProgress.memoizedState = newState
	end

	if __DEV__ then
		currentlyProcessingQueue = nil
	end
end
exports.processUpdateQueue = processUpdateQueue

local function callCallback(callback, context)
	-- ROBLOX deviation START: use if-then-error, which avoid string format and function call overhead, as in React 18
	if type(callback) ~= "function" then
		error(
			string.format(
				"Invalid argument passed as callback. Expected a function. Instead "
					.. "received: %s",
				tostring(callback)
			)
		)
		-- ROBLOX deviation END
	end
	callback(context)
end

exports.resetHasForceUpdateBeforeProcessing = function()
	hasForceUpdate = false
end

exports.checkHasForceUpdateAfterProcessing = function(): boolean
	return hasForceUpdate
end

local function commitUpdateQueue<State>(
	finishedWork: Fiber,
	finishedQueue: UpdateQueue<State>,
	instance: any
): ()
	-- Commit the effects
	local effects = finishedQueue.effects
	finishedQueue.effects = nil
	if effects ~= nil then
		for _, effect in effects do
			local callback = effect.callback
			if callback ~= nil then
				callCallback(callback, instance)
			end

			-- ROBLOX performance: return this object to the pool
			table.clear(effect)
			table.insert(updatePool, effect :: any)
			updatePoolIndex += 1
		end
	end
end
exports.commitUpdateQueue = commitUpdateQueue

return exports ]]
cX.Children._8335ff9d80ccabfbcc57ce52f67c4d9c=et
local eu

local ev={ClassName="ModuleScript",Children={},Properties={}}
ev.Name="ReactWorkTags"
ev.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactWorkTags.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

export type WorkTag = number

return {
	FunctionComponent = 0,
	ClassComponent = 1,
	IndeterminateComponent = 2, -- Before we know whether it is function or class
	HostRoot = 3, -- Root of a host tree. Could be nested inside another node.
	HostPortal = 4, -- A subtree. Could be an entry point to a different renderer.
	HostComponent = 5,
	HostText = 6,
	Fragment = 7,
	Mode = 8,
	ContextConsumer = 9,
	ContextProvider = 10,
	ForwardRef = 11,
	Profiler = 12,
	SuspenseComponent = 13,
	MemoComponent = 14,
	SimpleMemoComponent = 15,
	LazyComponent = 16,
	IncompleteClassComponent = 17,
	DehydratedFragment = 18,
	SuspenseListComponent = 19,
	FundamentalComponent = 20,
	ScopeComponent = 21,
	Block = 22,
	OffscreenComponent = 23,
	LegacyHiddenComponent = 24,
} ]]
cX.Children._716811f0c0ff684a8e545bfef18b299c=ev
local ew

local ex={ClassName="ModuleScript",Children={},Properties={}}
ex.Name="SchedulerWithReactIntegration.new"
ex.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/d17086c7c813402a550d15a2f56dc43f1dbd1735/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
export type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel

-- Intentionally not named imports because Rollup would use dynamic dispatch for
-- CommonJS interop named imports.
local Scheduler = require(Packages.Scheduler)
-- local __interactionsRef = require(Packages.Scheduler.tracing).__interactionsRef
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local decoupleUpdatePriorityFromScheduler =
	ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local ReactFiberLane = require(script.Parent.ReactFiberLane)
local SyncLanePriority = ReactFiberLane.SyncLanePriority
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority

local Scheduler_runWithPriority = Scheduler.unstable_runWithPriority
local Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback
local Scheduler_cancelCallback = Scheduler.unstable_cancelCallback
local Scheduler_shouldYield = Scheduler.unstable_shouldYield
local Scheduler_requestPaint = Scheduler.unstable_requestPaint
local Scheduler_now = Scheduler.unstable_now
local Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel
local Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority
local Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
local Scheduler_NormalPriority = Scheduler.unstable_NormalPriority
local Scheduler_LowPriority = Scheduler.unstable_LowPriority
local Scheduler_IdlePriority = Scheduler.unstable_IdlePriority

-- deviation: Instead of defining these here, we require them from a small file
-- with _just_ these constant definitions; it helps us avoid a circular require
-- issue with `ReactFiberLanes`
local ReactFiberSchedulerPriorities =
	require(script.Parent["ReactFiberSchedulerPriorities.roblox"])
local ImmediatePriority = ReactFiberSchedulerPriorities.ImmediatePriority
local UserBlockingPriority = ReactFiberSchedulerPriorities.UserBlockingPriority
local NormalPriority = ReactFiberSchedulerPriorities.NormalPriority
local LowPriority = ReactFiberSchedulerPriorities.LowPriority
local IdlePriority = ReactFiberSchedulerPriorities.IdlePriority
local NoPriority = ReactFiberSchedulerPriorities.NoPriority

-- deviation: common types
type Array<T> = { [number]: T }

-- deviation: pre-declare functions
local flushSyncCallbackQueueImpl

-- if enableSchedulerTracing)
--   -- Provide explicit error message when production+profiling bundle of e.g.
--   -- react-dom is used with production (non-profiling) bundle of
--   -- scheduler/tracing
--   invariant(
--     __interactionsRef ~= nil and __interactionsRef.current ~= nil,
--     'It is not supported to run the profiling version of a renderer (for ' +
--       'example, `react-dom/profiling`) without also replacing the ' +
--       '`scheduler/tracing` module with `scheduler/tracing-profiling`. Your ' +
--       'bundler might have a setting for aliasing both modules. Learn more at ' +
--       'https://reactjs.org/link/profiling',
--   )
-- end

export type SchedulerCallback = (isSync: boolean) -> SchedulerCallback | nil

-- ROBLOX deviation START: don't allow extension unless we need to
-- type SchedulerCallbackOptions = { timeout: number?, ... };
type SchedulerCallbackOptions = { timeout: number? }
-- ROBLOX deviation END
local fakeCallbackNode = {}

local shouldYield = Scheduler_shouldYield
local requestPaint
-- Fall back gracefully if we're running an older version of Scheduler.
if Scheduler_requestPaint ~= nil then
	requestPaint = Scheduler_requestPaint
else
	requestPaint = function() end
end

local syncQueue: Array<SchedulerCallback>? = nil
local immediateQueueCallbackNode: any? = nil
local isFlushingSyncQueue: boolean = false
local initialTimeMs: number = Scheduler_now()

-- -- If the initial timestamp is reasonably small, use Scheduler's `now` directly.
-- -- This will be the case for modern browsers that support `performance.now`. In
-- -- older browsers, Scheduler falls back to `Date.now`, which returns a Unix
-- -- timestamp. In that case, subtract the module initialization time to simulate
-- -- the behavior of performance.now and keep our times small enough to fit
-- -- within 32 bits.
-- -- TODO: Consider lifting this into Scheduler.
-- ROBLOX FIXME: properly account for ms vs s from tick
-- local now = initialTimeMs < 10000
--   and Scheduler_now
--   or function()
--     return Scheduler_now() - initialTimeMs
--   end

-- deviation: Roblox uses `tick` under the hood, which is more like the unix
-- timestamp behavior referenced above
local function now(): number
	return Scheduler_now() - initialTimeMs
end

local function getCurrentPriorityLevel(): ReactPriorityLevel
	local currentPriorityLevel = Scheduler_getCurrentPriorityLevel()
	if currentPriorityLevel == Scheduler_ImmediatePriority then
		return ImmediatePriority
	elseif currentPriorityLevel == Scheduler_UserBlockingPriority then
		return UserBlockingPriority
	elseif currentPriorityLevel == Scheduler_NormalPriority then
		return NormalPriority
	elseif currentPriorityLevel == Scheduler_LowPriority then
		return LowPriority
	elseif currentPriorityLevel == Scheduler_IdlePriority then
		return IdlePriority
	else
		invariant(false, "Unknown priority level.")
		-- deviation: FIXME: Luau needs explicit return here
		return NoPriority
	end
end

function reactPriorityToSchedulerPriority(reactPriorityLevel)
	if reactPriorityLevel == ImmediatePriority then
		return Scheduler_ImmediatePriority
	elseif reactPriorityLevel == UserBlockingPriority then
		return Scheduler_UserBlockingPriority
	elseif reactPriorityLevel == NormalPriority then
		return Scheduler_NormalPriority
	elseif reactPriorityLevel == LowPriority then
		return Scheduler_LowPriority
	elseif reactPriorityLevel == IdlePriority then
		return Scheduler_IdlePriority
	else
		invariant(false, "Unknown priority level.")
		-- deviation: return appeases Luau
		return nil
	end
end

-- ROBLOX FIXME Luau: should be T... but hits CLI-50289: failure to unify
local function runWithPriority<T...>(
	reactPriorityLevel: ReactPriorityLevel,
	fn: () -> T...
): ...any
	local priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel)
	return Scheduler_runWithPriority(priorityLevel, fn)
end

local function scheduleCallback(
	reactPriorityLevel: ReactPriorityLevel,
	callback: SchedulerCallback,
	options: SchedulerCallbackOptions | nil
)
	local priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel)
	return Scheduler_scheduleCallback(priorityLevel, callback, options)
end

local function scheduleSyncCallback(callback: SchedulerCallback)
	-- Push this callback into an internal queue. We'll flush these either in
	-- the next tick, or earlier if something calls `flushSyncCallbackQueue`.
	if syncQueue == nil then
		syncQueue = { callback }
		-- Flush the queue in the next tick, at the earliest.
		immediateQueueCallbackNode = Scheduler_scheduleCallback(
			Scheduler_ImmediatePriority,
			flushSyncCallbackQueueImpl
		)
	else
		-- Push onto existing queue. Don't need to schedule a callback because
		-- we already scheduled one when we created the queue.
		local coercedSyncQueue = syncQueue
		table.insert(coercedSyncQueue, callback)
	end
	return fakeCallbackNode
end

local function cancelCallback(callbackNode: any)
	if callbackNode ~= fakeCallbackNode then
		Scheduler_cancelCallback(callbackNode)
	end
end

local function flushSyncCallbackQueue(): boolean
	if immediateQueueCallbackNode ~= nil then
		local node = immediateQueueCallbackNode
		immediateQueueCallbackNode = nil
		Scheduler_cancelCallback(node)
	end
	return flushSyncCallbackQueueImpl()
end

flushSyncCallbackQueueImpl = function()
	if not isFlushingSyncQueue and syncQueue ~= nil then
		-- Prevent re-entrancy.
		isFlushingSyncQueue = true
		local i = 1
		if decoupleUpdatePriorityFromScheduler then
			local previousLanePriority = getCurrentUpdateLanePriority()
			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok = true
			local result
			if not _G.__YOLO__ then
				-- ROBLOX performance: hoist non-throwables out of try{} to eliminate anon function
				local isSync = true
				local queue = syncQueue

				setCurrentUpdateLanePriority(SyncLanePriority)
				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediatePriority,
					-- ROBLOX FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
					function(): ...any
						for index, callback in queue do
							i = index
							repeat
								-- ROBLOX FIXME Luau: Luau doesn't understand loop until nil construct
								callback = callback(isSync) :: any
							until callback == nil
						end
					end
				)
				syncQueue = nil
			else
				ok = true
				local isSync = true
				local queue = syncQueue

				setCurrentUpdateLanePriority(SyncLanePriority)
				-- ROBLOX FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
				runWithPriority(ImmediatePriority, function(): ...any
					for index, callback in queue do
						i = index
						repeat
							-- ROBLOX FIXME Luau: Luau doesn't understand loop until nil construct
							callback = callback(isSync) :: any
						until callback == nil
						i += 1
					end
				end)
				syncQueue = nil
			end

			-- finally
			setCurrentUpdateLanePriority(previousLanePriority)
			isFlushingSyncQueue = false

			if not ok then
				-- If something throws, leave the remaining callbacks on the queue.
				if syncQueue ~= nil then
					syncQueue = Array.slice(syncQueue, i + 1)
				end
				-- Resume flushing in the next tick
				Scheduler_scheduleCallback(
					Scheduler_ImmediatePriority,
					flushSyncCallbackQueue
				)
				error(result)
			end
		else
			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok, result
			if not _G.__YOLO__ then
				-- ROBLOX performance: hoist non-throwables out of try{} to eliminate anon function
				local isSync = true
				local queue = syncQueue

				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediatePriority,
					-- ROBLOX FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
					function(): ...any
						for index, callback in queue do
							i = index
							repeat
								-- ROBLOX FIXME Luau: Luau doesn't understand loop until nil construct
								callback = callback(isSync) :: any
							until callback == nil
						end
					end
				)
				syncQueue = nil
			else
				ok = true
				local isSync = true
				local queue = syncQueue
				-- ROBLOX FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
				runWithPriority(ImmediatePriority, function(): ...any
					for index, callback in queue do
						i = index
						repeat
							-- ROBLOX FIXME Luau: Luau doesn't understand loop until nil construct
							callback = callback(isSync) :: any
						until callback == nil
					end
				end)
				syncQueue = nil
			end

			-- finally
			isFlushingSyncQueue = false

			if not ok then
				-- If something throws, leave the remaining callbacks on the queue.
				if syncQueue ~= nil then
					syncQueue = Array.slice(syncQueue, i + 1)
				end
				-- Resume flushing in the next tick
				Scheduler_scheduleCallback(
					Scheduler_ImmediatePriority,
					flushSyncCallbackQueue
				)
				error(result)
			end
		end
		return true
	else
		return false
	end
end

return {
	ImmediatePriority = ImmediatePriority,
	UserBlockingPriority = UserBlockingPriority,
	NormalPriority = NormalPriority,
	LowPriority = LowPriority,
	IdlePriority = IdlePriority,
	NoPriority = NoPriority,

	getCurrentPriorityLevel = getCurrentPriorityLevel,
	flushSyncCallbackQueue = flushSyncCallbackQueue,
	runWithPriority = runWithPriority,
	scheduleCallback = scheduleCallback,
	scheduleSyncCallback = scheduleSyncCallback,
	cancelCallback = cancelCallback,
	now = now,
	requestPaint = requestPaint,
	shouldYield = shouldYield,
} ]]
cX.Children._8cb955f3d1be07a883c30b95e6104839=ex
local ey

local ez={ClassName="ModuleScript",Children={},Properties={}}
ez.Name="SchedulingProfiler"
ez.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/SchedulingProfiler.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local exports = {}
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local WeakMap = LuauPolyfill.WeakMap
type WeakMap<K, V> = LuauPolyfill.WeakMap<K, V>

local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
type Lanes = ReactFiberLane.Lanes

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local ReactVersion = require(Packages.Shared).ReactVersion
local getComponentName = require(Packages.Shared).getComponentName

-- /**
--  * If performance exists and supports the subset of the User Timing API that we
--  * require.
--  */
local supportsUserTiming = _G.performance ~= nil
local performance = _G.performance
	or {
		mark = function(str)
			debug.profilebegin(str)
			debug.profileend()
		end,
	}

function formatLanes(laneOrLanes: Lane | Lanes): string
	return tostring(laneOrLanes)
end

-- Create a mark on React initialization
if enableSchedulingProfiler then
	if supportsUserTiming then
		performance.mark("--react-init-" .. tostring(ReactVersion))
	end
end

exports.markCommitStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--commit-start-" .. formatLanes(lanes))
		end
	end
end

exports.markCommitStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--commit-stop")
		end
	end
end

-- ROBLOX deviation: we use our custom Map
-- local PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map

-- $FlowFixMe: Flow cannot handle polymorphic WeakMaps
local wakeableIDs: WeakMap<Wakeable, number> = WeakMap.new()
local wakeableID: number = 0
function getWakeableID(wakeable: Wakeable): number
	if not wakeableIDs:has(wakeable) then
		wakeableIDs:set(wakeable, wakeableID)
		wakeableID += 1
	end
	return wakeableIDs:get(wakeable)
end

exports.markComponentSuspended = function(fiber: Fiber, wakeable: Wakeable): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local id = getWakeableID(wakeable)
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark(
				"--suspense-suspend-" .. tostring(id) .. "-" .. componentName
			)
			wakeable:andThen(function()
				performance.mark(
					"--suspense-resolved-" .. tostring(id) .. "-" .. componentName
				)
			end, function()
				performance.mark(
					"--suspense-rejected-" .. tostring(id) .. "-" .. componentName
				)
			end)
		end
	end
end

exports.markLayoutEffectsStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--layout-effects-start-" .. formatLanes(lanes))
		end
	end
end

exports.markLayoutEffectsStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--layout-effects-stop")
		end
	end
end

exports.markPassiveEffectsStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--passive-effects-start-" .. formatLanes(lanes))
		end
	end
end

exports.markPassiveEffectsStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--passive-effects-stop")
		end
	end
end

exports.markRenderStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-start-" .. formatLanes(lanes))
		end
	end
end

exports.markRenderYielded = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-yield")
		end
	end
end

exports.markRenderStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-stop")
		end
	end
end

exports.markRenderScheduled = function(lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--schedule-render-" .. formatLanes(lane))
		end
	end
end

exports.markForceUpdateScheduled = function(fiber: Fiber, lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark(
				"--schedule-forced-update-" .. formatLanes(lane) .. "-" .. componentName
			)
		end
	end
end

exports.markStateUpdateScheduled = function(fiber: Fiber, lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark(
				"--schedule-state-update-" .. formatLanes(lane) .. "-" .. componentName
			)
		end
	end
end

return exports ]]
cX.Children._d197ec48686201c37f2f8423b3b2aa8c=ez
local eA

local eB={ClassName="Folder",Children={},Properties={}}
eB.Name="__tests__"
cX.Children._456270010f2b3b88f95c29067fb9a3c4=eB
local eC
local eD={ClassName="ModuleScript",Children={},Properties={}}
eD.Name="DebugTracing-test.internal.spec"
eD.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/8af27aeedbc6b00bc2ef49729fc84f116c70a27c/packages/react-reconciler/src/__tests__/DebugTracing-test.internal.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

-- local function spyOnDevAndProd(object, methodName, fake)
-- 	local originalMethods = originalObjects[tostring(object)]
-- 	if originalMethods == nil then
-- 		originalMethods = {}
-- 		originalObjects[tostring(object)] = originalMethods
-- 	end
-- 	originalMethods[methodName] = object[methodName]
-- 	object[methodName] = jest:fn(fake)
-- 	return object[methodName]
-- end

-- local function restoreDevAndProd()
-- 	for originalObjectString, originalObject in originalObjects do
-- 		for methodName, originalMethod in originalObjects[originalObjectString] do
-- 			originalObject[methodName] = originalMethod
-- 		end
-- 	end
-- 	originalObjects = nil
-- end

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local it = JestGlobals.it
local xit = JestGlobals.xit
local jestExpect = JestGlobals.expect
local console = require(Packages.Shared).console
local Promise = require(Packages.Promise)

-- ROBLOX Test Noise: jest capabilities needed to spy on console
describe("DebugTracing", function()
	local React
	local ReactTestRenderer
	local Scheduler
	beforeEach(function()
		jest.resetModules()

		-- ROBLOX deviation: upstream uses special comments to know which flags to flip. we do it manually.
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.enableDebugTracing = true
		ReactFeatureFlags.enableSchedulingProfiler = true
		ReactFeatureFlags.enableProfilerTimer = true
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = true
		ReactFeatureFlags.enableSuspenseServerRenderer = true
		ReactFeatureFlags.decoupleUpdatePriorityFromScheduler = true
		React = require(Packages.React)
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		Scheduler = require(Packages.Scheduler)

		-- local groups = {}

		-- ROBLOX deviation: we currently don't have a good way to intercept
		-- console.log, group, or groupEnd in a reasonably-aligned way

		-- spyOnDevAndProd(console, "log", function(message)
		-- 	table.insert(logs, "log: " .. message)
		-- end)
		-- spyOnDevAndProd(console, "group", function(message)
		-- 	table.insert(logs, "group: " .. message)
		-- 	table.insert(groups, message)
		-- end)
		-- spyOnDevAndProd(console, "groupEnd", function()
		-- 	local message = table.remove(groups, 1)
		-- 	table.insert(logs, "groupEnd: " .. message)
		-- end)
	end)

	-- @gate experimental
	it(
		"should not log anything for sync render without suspends or state updates",
		function()
			jestExpect(function()
				ReactTestRenderer.create(
					React.createElement(
						React.unstable_DebugTracingMode,
						nil,
						React.createElement("div")
					)
				)
			end).toLogDev({})
		end
	)

	-- @gate experimental
	it(
		"should not log anything for concurrent render without suspends or state updates",
		function()
			jestExpect(function()
				ReactTestRenderer.create(
					React.createElement(
						React.unstable_DebugTracingMode,
						nil,
						React.createElement("div")
					),
					{ unstable_isConcurrent = true }
				)
			end).toLogDev({})

			jestExpect(function()
				jestExpect(Scheduler).toFlushUntilNextPaint({})
			end).toLogDev({})
		end
	)

	-- ROBLOX FIXME: we never receive "Example resolved", might be a Promise emulation issue
	-- @gate experimental && build === 'development' && enableDebugTracing
	xit("should log sync render with suspense", function()
		-- ROBLOX deviation: evaera Prosmise.resolve doesn't match JS Promise, so we delay(0) to match
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			return true
		end)
		local function Example()
			error(fakeSuspensePromise)
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(
						React.Suspense,
						{ fallback = {} },
						React.createElement(Example)
					)
				)
			)
		end).toLogDev({
			-- "* render (0b0000000000000000000000000000001)",
			"* Example suspended",
			-- "* render (0b0000000000000000000000000000001)"
		}, { withoutStack = true })

		jestExpect(function()
			fakeSuspensePromise:await()
		end).toLogDev({
			"* Example resolved",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it.skip("should log sync render with CPU suspense", function()
		local function Example()
			console.log("<Example/>")
			return nil
		end

		local function Wrapper(props)
			local children = props.children
			console.log("<Wrapper/>")
			return children
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(
						Wrapper,
						nil,
						React.createElement(
							React.Suspense,
							{ fallback = {}, unstable_expectedLoadTime = 1 },
							React.createElement(Example)
						)
					)
				)
			)
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000000000000001)",
			"<Wrapper/>",
			-- 	"groupEnd: * render (0b0000000000000000000000000000001)",
		}, { withoutStack = true })

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * render (0b0000010000000000000000000000000)",
			"<Example/>",
			-- 	"groupEnd: * render (0b0000010000000000000000000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	xit("should log concurrent render with suspense", function()
		-- ROBLOX deviation: evaera Prosmise.resolve doesn't match JS Promise, so we delay(0) to match
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			return true
		end)
		local function Example()
			error(fakeSuspensePromise)
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(
						React.Suspense,
						{ fallback = {} },
						React.createElement(Example)
					)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000001000000000)",
			"* Example suspended",
			-- 	"groupEnd: * render (0b0000000000000000000001000000000)",
		}, { withoutStack = true })

		jestExpect(function()
			fakeSuspensePromise:await()
		end).toLogDev({ "* Example resolved" }, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	xit("should log concurrent render with CPU suspense", function()
		local function Example()
			console.log("<Example/>")
			return nil
		end

		local function Wrapper(props)
			local children = props.children
			console.log("<Wrapper/>")
			return children
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(
						Wrapper,
						nil,
						React.createElement(
							React.Suspense,
							{ fallback = {}, unstable_expectedLoadTime = 1 },
							React.createElement(Example)
						)
					)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000001000000000)",
			"<Wrapper/>",
			-- 	"groupEnd: * render (0b0000000000000000000001000000000)",
		}, { withoutStack = true })

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * render (0b0000010000000000000000000000000)",
			"<Example/>",
			-- 	"groupEnd: * render (0b0000010000000000000000000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it("should log cascading class component updates", function()
		local Example = React.Component:extend("Example")
		function Example:init()
			self.state = { didMount = false }
		end
		function Example:componentDidMount()
			self:setState({ didMount = true })
		end
		function Example:render()
			return nil
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(Example)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * commit (0b0000000000000000000001000000000)",
			-- 	"group: * layout effects (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000000000000001)",
			-- 	"groupEnd: * layout effects (0b0000000000000000000001000000000)",
			-- 	"groupEnd: * commit (0b0000000000000000000001000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it("should log render phase state updates for class component", function()
		local Example = React.Component:extend("Example")
		function Example:init()
			self.state = { didRender = false }
		end
		function Example:render()
			if self.state.didRender == false then
				self:setState({ didRender = true })
			end
			return nil
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(Example)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(function()
				jestExpect(Scheduler).toFlushUntilNextPaint({})
			end).toErrorDev("Cannot update during an existing state transition")
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000001000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it("should log cascading layout updates", function()
		local function Example()
			local didMount, setDidMount = React.useState(false)
			React.useLayoutEffect(function()
				setDidMount(true)
			end, {})
			return didMount
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(Example)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * commit (0b0000000000000000000001000000000)",
			-- 	"group: * layout effects (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000000000000001)",
			-- 	"groupEnd: * layout effects (0b0000000000000000000001000000000)",
			-- 	"groupEnd: * commit (0b0000000000000000000001000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it("should log cascading passive updates", function()
		local function Example()
			local didMount, setDidMount = React.useState(false)
			React.useEffect(function()
				setDidMount(true)
			end, {})
			return didMount
		end

		jestExpect(function()
			ReactTestRenderer.act(function()
				ReactTestRenderer.create(
					React.createElement(
						React.unstable_DebugTracingMode,
						nil,
						React.createElement(Example)
					),
					{ unstable_isConcurrent = true }
				)
			end)
		end).toLogDev({
			-- 	"group: * passive effects (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000010000000000)",
			-- 	"groupEnd: * passive effects (0b0000000000000000000001000000000)",
		}, { withoutStack = true })
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	it("should log render phase updates", function()
		local function Example()
			local didRender, setDidRender = React.useState(false)
			if not didRender then
				setDidRender(true)
			end
			return didRender
		end

		jestExpect(function()
			ReactTestRenderer.act(function()
				ReactTestRenderer.create(
					React.createElement(
						React.unstable_DebugTracingMode,
						nil,
						React.createElement(Example)
					),
					{ unstable_isConcurrent = true }
				)
			end)
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000001000000000)",
			"* Example updated state (0b0000000000000000000001000000000)",
			-- 	"groupEnd: * render (0b0000000000000000000001000000000)",
		}, { withoutStack = true })

		-- ROBLOX deviation: we don't have build-time gating like upstream
		-- gate(function(flags)
		-- 	if flags.new then
		-- jestExpect(logs).toEqual({
		-- })
		-- 	else
		-- 		jestExpect(logs).toEqual({
		-- 			"group: * render (0b0000000000000000000001000000000)",
		-- 			"log: * Example updated state (0b0000000000000000000010000000000)",
		-- 			"log: * Example updated state (0b0000000000000000000010000000000)",
		-- 			"groupEnd: * render (0b0000000000000000000001000000000)",
		-- 		})
		-- 	end
		-- end)
	end)

	-- @gate experimental && build === 'development' && enableDebugTracing
	xit("should log when user code logs", function()
		local function Example()
			console.log("Hello from user code")
			return nil
		end

		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(
					React.unstable_DebugTracingMode,
					nil,
					React.createElement(Example)
				),
				{ unstable_isConcurrent = true }
			)
		end).toLogDev({})

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toLogDev({
			-- 	"group: * render (0b0000000000000000000001000000000)",
			"Hello from user code",
			-- 	"groupEnd: * render (0b0000000000000000000001000000000)",
		})
	end)

	-- @gate experimental
	it(
		"should not log anything outside of a unstable_DebugTracingMode subtree",
		function()
			local function ExampleThatCascades()
				local didMount, setDidMount = React.useState(false)
				React.useLayoutEffect(function()
					setDidMount(true)
				end, {})
				return didMount
			end

			local fakeSuspensePromise = Promise.new(function()
				return {}
			end)
			local function ExampleThatSuspends()
				error(fakeSuspensePromise)
			end

			local function Example()
				return nil
			end

			jestExpect(function()
				ReactTestRenderer.create(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(ExampleThatCascades),
						React.createElement(
							React.Suspense,
							{ fallback = {} },
							nil,
							React.createElement(ExampleThatSuspends)
						),
						React.createElement(
							React.unstable_DebugTracingMode,
							nil,
							React.createElement(Example)
						)
					)
				)
			end).toLogDev({})
		end
	)
end) ]]
eC.Children._d105a20f93531a93699c093d0b79ead5=eD
local eE

local eF={ClassName="ModuleScript",Children={},Properties={}}
eF.Name="ReactClassSetStateCallback.spec"
eF.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d7dce572c7453737a685e791e7afcbc7e2b2fe16/packages/react-reconciler/src/__tests__/ReactClassSetStateCallback-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

--\[\[ eslint-disable no-func-assign \]\]
local Packages = script.Parent.Parent.Parent
local React

local ReactNoop
local Scheduler

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
end)

local function Text(props)
	Scheduler.unstable_yieldValue(props.text)
	return React.createElement("span", {
		prop = props.text,
	})
end

it(
	"regression: setState callback (2nd arg) should only fire once, even after a rebase",
	function()
		local app
		local App = React.Component:extend("App")
		function App:init()
			self:setState({ step = 0 })
		end
		function App:render()
			app = self
			return React.createElement(Text, { text = self.state.step })
		end

		local root = ReactNoop.createRoot()
		ReactNoop.act(function()
			root.render(React.createElement(App))
		end)
		jestExpect(Scheduler).toHaveYielded({ 0 })

		ReactNoop.act(function()
			app:setState({ step = 1 }, function()
				return Scheduler.unstable_yieldValue("Callback 1")
			end)

			ReactNoop.flushSync(function()
				app:setState({ step = 2 }, function()
					return Scheduler.unstable_yieldValue("Callback 2")
				end)
			end)
		end)
		jestExpect(Scheduler).toHaveYielded({ 2, "Callback 2", 2, "Callback 1" })
	end
) ]]
eC.Children._2397b6e1f9d1cc6b67a11e651e236ef1=eF
local eG

local eH={ClassName="ModuleScript",Children={},Properties={}}
eH.Name="ReactComponentLifeCycle.roblox.spec"
eH.Properties.Source=[[ -- Copy of ReactComponentLifeCycle.spec.lua that instead tests old Roact lifecycle method names (which we'll support temporarily)

--\[\[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]
--\[\[*
 * TODO: We should make any setState calls fail in
 * `getInitialState` and `componentWillMount`. They will usually fail
 * anyways because `this._renderedComponent` is empty, however, if a component
 * is *reused*, then that won't be the case and things will appear to work in
 * some cases. Better to just block all updates in initialization.
 \]\]

local HttpService = game:GetService("HttpService")
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local jest = JestGlobals.jest

-- deviation: Move all of the following into the test function body to match
-- convention
local React
-- local ReactDOM
local ReactNoop
-- local ReactTestUtils
-- local PropTypes

local clone = function(o)
	return HttpService:JSONDecode(HttpService:JSONEncode(o))
end

local GET_INIT_STATE_RETURN_VAL = {
	hasWillMountCompleted = false,
	hasRenderCompleted = false,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local INIT_RENDER_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = false,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local DID_MOUNT_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = true,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local NEXT_RENDER_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = true,
	hasDidMountCompleted = true,
	hasWillUnmountCompleted = false,
}

local WILL_UNMOUNT_STATE = {
	hasWillMountCompleted = true,
	hasDidMountCompleted = true,
	hasRenderCompleted = true,
	hasWillUnmountCompleted = false,
}

local POST_WILL_UNMOUNT_STATE = {
	hasWillMountCompleted = true,
	hasDidMountCompleted = true,
	hasRenderCompleted = true,
	hasWillUnmountCompleted = true,
}

--\[\[
      Every React component is in one of these life cycles.
      * MOUNTED
        * Mounted components have a DOM node representation and are capable of
        receiving new props.
      * UNMOUNTED
        * Unmounted components are inactive and cannot receive new props.
    \]\]
type ComponentLifeCycle = string

local function getLifeCycleState(instance): ComponentLifeCycle
	return instance.__updater.isMounted(instance) and "MOUNTED" or "UNMOUNTED"
end

local prevCompatWarnings
beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()

	prevCompatWarnings = _G.__COMPAT_WARNINGS__
	_G.__COMPAT_WARNINGS__ = false

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	-- ReactDOM = require('react-dom')
	-- ReactTestUtils = require('react-dom/test-utils')
	-- PropTypes = require('prop-types')

	-- ROBLOX deviation: these tests are failing with debugRenderPhaseSideEffectsForStrictMode on.
	-- https://github.com/Roblox/roact-alignment/issues/105
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
end)

afterEach(function()
	_G.__COMPAT_WARNINGS__ = prevCompatWarnings
end)

it("should correctly determine if a component is mounted", function()
	local isMounted
	local Component = React.Component:extend("Component")

	function Component:init()
		isMounted = function()
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			return self.__updater.isMounted(self)
		end
	end
	function Component:UNSAFE_componentWillMount()
		jestExpect(isMounted()).toBe(false)
	end
	function Component:didMount()
		-- ROBLOX deviation: assert self is non nil
		jestExpect(self).never.toEqual(nil)
		jestExpect(isMounted()).toBe(true)
	end
	function Component:render()
		jestExpect(isMounted()).toBe(false)
		return React.createElement("div")
	end

	local element = React.createElement(Component)

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(element)
		end)
		jestExpect(isMounted()).toBe(true)
	end).toErrorDev({
		"Component is accessing isMounted inside its render()",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })
end)

it("should correctly determine if a nil component is mounted", function()
	local isMounted
	local Component = React.Component:extend("Component")

	function Component:init()
		isMounted = function()
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			return self.__updater.isMounted(self)
		end
	end
	function Component:UNSAFE_componentWillMount()
		jestExpect(isMounted()).toBe(false)
	end
	function Component:didMount()
		jestExpect(isMounted()).toBe(true)
	end
	function Component:render()
		jestExpect(isMounted()).toBe(false)
		return nil
	end

	local element = React.createElement(Component)

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(element)
		end)
		jestExpect(isMounted()).toBe(true)
	end).toErrorDev({
		"Component is accessing isMounted inside its render()",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })
end)

it("should carry through each of the phases of setup", function()
	local _testJournal: any = {}
	local getTestLifeCycleState, getInstanceState
	local LifeCycleComponent = React.Component:extend("LifeCycleComponent")
	function LifeCycleComponent:init()
		local initState = {
			hasWillMountCompleted = false,
			hasDidMountCompleted = false,
			hasRenderCompleted = false,
			hasWillUnmountCompleted = false,
		}
		getTestLifeCycleState = function()
			return getLifeCycleState(self)
		end
		getInstanceState = function()
			return self.state
		end
		_testJournal.returnedFromGetInitialState = clone(initState)
		_testJournal.lifeCycleAtStartOfGetInitialState = getTestLifeCycleState()
		self.state = initState
	end

	function LifeCycleComponent:UNSAFE_componentWillMount()
		_testJournal.stateAtStartOfWillMount = clone(self.state)
		_testJournal.lifeCycleAtStartOfWillMount = getTestLifeCycleState()
		self.state.hasWillMountCompleted = true
	end

	function LifeCycleComponent:didMount()
		_testJournal.stateAtStartOfDidMount = clone(self.state)
		_testJournal.lifeCycleAtStartOfDidMount = getTestLifeCycleState()
		self:setState({ hasDidMountCompleted = true })
	end

	function LifeCycleComponent:render()
		local isInitialRender = not self.state.hasRenderCompleted
		if isInitialRender then
			_testJournal.stateInInitialRender = clone(self.state)
			_testJournal.lifeCycleInInitialRender = getTestLifeCycleState()
		else
			_testJournal.stateInLaterRender = clone(self.state)
			_testJournal.lifeCycleInLaterRender = getTestLifeCycleState()
		end
		-- you would *NEVER* do anything like this in real code!
		self.state.hasRenderCompleted = true
		return React.createElement("TextLabel", { Text = "I am the inner DIV" })
	end

	function LifeCycleComponent:willUnmount()
		-- ROBLOX deviation: assert self is non nil
		jestExpect(self).never.toEqual(nil)

		_testJournal.stateAtStartOfWillUnmount = clone(self.state)
		_testJournal.lifeCycleAtStartOfWillUnmount = getTestLifeCycleState()
		self.state.hasWillUnmountCompleted = true
	end

	-- A component that is merely "constructed" (as in "constructor") but not
	-- yet initialized, or rendered.
	--
	-- local container = document.createElement('div')

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(LifeCycleComponent))
		end)
	end).toErrorDev({
		"LifeCycleComponent is accessing isMounted inside its render() function",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })

	-- getInitialState
	jestExpect(_testJournal.returnedFromGetInitialState).toEqual(
		GET_INIT_STATE_RETURN_VAL
	)
	jestExpect(_testJournal.lifeCycleAtStartOfGetInitialState).toBe("UNMOUNTED")

	-- componentWillMount
	jestExpect(_testJournal.stateAtStartOfWillMount).toEqual(
		_testJournal.returnedFromGetInitialState
	)
	jestExpect(_testJournal.lifeCycleAtStartOfWillMount).toBe("UNMOUNTED")

	-- didMount
	jestExpect(_testJournal.stateAtStartOfDidMount).toEqual(DID_MOUNT_STATE)
	jestExpect(_testJournal.lifeCycleAtStartOfDidMount).toBe("MOUNTED")

	-- initial render
	jestExpect(_testJournal.stateInInitialRender).toEqual(INIT_RENDER_STATE)
	jestExpect(_testJournal.lifeCycleInInitialRender).toBe("UNMOUNTED")

	jestExpect(getTestLifeCycleState()).toBe("MOUNTED")

	-- Now *update the component*
	-- instance.forceUpdate()
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(LifeCycleComponent))
	end)

	-- render 2nd time
	jestExpect(_testJournal.stateInLaterRender).toEqual(NEXT_RENDER_STATE)
	jestExpect(_testJournal.lifeCycleInLaterRender).toBe("MOUNTED")

	jestExpect(getTestLifeCycleState()).toBe("MOUNTED")

	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)

	jestExpect(_testJournal.stateAtStartOfWillUnmount).toEqual(WILL_UNMOUNT_STATE)
	-- willUnmount called right before unmount.
	jestExpect(_testJournal.lifeCycleAtStartOfWillUnmount).toBe("MOUNTED")

	-- But the current lifecycle of the component is unmounted.
	jestExpect(getTestLifeCycleState()).toBe("UNMOUNTED")
	jestExpect(getInstanceState()).toEqual(POST_WILL_UNMOUNT_STATE)
end)

it("should allow state updates in didMount", function()
	local getComponentState
	--\[\[*
       * calls setState in an didMount.
       \]\]
	local SetStateInComponentDidMount =
		React.Component:extend("SetStateInComponentDidMount")
	function SetStateInComponentDidMount:init()
		self.state = {
			stateField = self.props.valueToUseInitially,
		}
		getComponentState = function()
			return self.state
		end
	end

	function SetStateInComponentDidMount:didMount()
		self:setState({ stateField = self.props.valueToUseAfterMount })
	end

	function SetStateInComponentDidMount:render()
		return React.createElement("div")
	end

	local element = React.createElement(SetStateInComponentDidMount, {
		valueToUseInitially = "hello",
		valueToUseAfterMount = "goodbye",
	})
	ReactNoop.act(function()
		ReactNoop.render(element)
	end)
	jestExpect(getComponentState().stateField).toBe("goodbye")
end)

it("should call nested legacy lifecycle methods in the right order", function()
	local log
	local logger = function(msg)
		return function()
			-- return true for shouldUpdate
			table.insert(log, msg)
			return true
		end
	end

	local Outer = React.Component:extend("Outer")
	-- pre-declare
	local Inner = React.Component:extend("Inner")
	Outer.UNSAFE_componentWillMount = logger("outer componentWillMount")
	Outer.didMount = logger("outer didMount")
	Outer.UNSAFE_componentWillReceiveProps = logger("outer componentWillReceiveProps")
	Outer.shouldUpdate = logger("outer shouldUpdate")
	Outer.willUpdate = logger("outer willUpdate")
	Outer.didUpdate = logger("outer didUpdate")
	Outer.willUnmount = logger("outer willUnmount")
	function Outer:render()
		return React.createElement(
			"Frame",
			{},
			React.createElement(Inner, {
				x = self.props.x,
			})
		)
	end

	Inner.UNSAFE_componentWillMount = logger("inner componentWillMount")
	Inner.didMount = logger("inner didMount")
	Inner.UNSAFE_componentWillReceiveProps = logger("inner componentWillReceiveProps")
	Inner.shouldUpdate = logger("inner shouldUpdate")
	Inner.willUpdate = logger("inner willUpdate")
	Inner.didUpdate = logger("inner didUpdate")
	Inner.willUnmount = logger("inner willUnmount")
	function Inner:render()
		return React.createElement("TextLabel", { Text = self.props.x })
	end

	log = {}
	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Outer, { x = 1 }))
		end)
	end).toErrorDev({
		-- ROBLOX: The upstream equivalents of these tests run with react-dom
		-- using the legacy root, so they don't throw warnings related to strict
		-- mode; we compromise by keeping it in concurrent mode to better match
		-- production, but anticipating the warnings
		"Using UNSAFE_componentWillMount in strict mode is not recommended",
		"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
		"Using UNSAFE_componentWillUpdate in strict mode is not recommended",
	}, { withoutStack = true })
	jestExpect(log).toEqual({
		"outer componentWillMount",
		"inner componentWillMount",
		"inner didMount",
		"outer didMount",
	})

	-- Dedup warnings
	log = {}
	-- jestExpect(function())
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 2 }))
	end)
	jestExpect(log).toEqual({
		"outer componentWillReceiveProps",
		"outer shouldUpdate",
		"outer willUpdate",
		"inner componentWillReceiveProps",
		"inner shouldUpdate",
		"inner willUpdate",
		"inner didUpdate",
		"outer didUpdate",
	})

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)
	jestExpect(log).toEqual({
		"outer willUnmount",
		"inner willUnmount",
	})
end)

it("should call nested new lifecycle methods in the right order", function()
	local log
	local logger = function(msg)
		return function()
			-- return true for shouldUpdate
			table.insert(log, msg)
			return true
		end
	end
	local Outer = React.Component:extend("Outer")
	-- pre-declare
	local Inner = React.Component:extend("Inner")
	function Outer:init()
		self.state = {}
	end
	function Outer.getDerivedStateFromProps(props, prevState)
		table.insert(log, "outer getDerivedStateFromProps")
		return nil
	end
	Outer.didMount = logger("outer didMount")
	Outer.shouldUpdate = logger("outer shouldUpdate")
	Outer.getSnapshotBeforeUpdate = logger("outer getSnapshotBeforeUpdate")
	Outer.didUpdate = logger("outer didUpdate")
	Outer.willUnmount = logger("outer willUnmount")
	function Outer:render()
		return React.createElement(
			"Frame",
			{},
			React.createElement(Inner, { x = self.props.x })
		)
	end

	function Inner:init()
		self.state = {}
	end
	function Inner.getDerivedStateFromProps(props, prevState)
		table.insert(log, "inner getDerivedStateFromProps")
		return nil
	end
	Inner.didMount = logger("inner didMount")
	Inner.shouldUpdate = logger("inner shouldUpdate")
	Inner.getSnapshotBeforeUpdate = logger("inner getSnapshotBeforeUpdate")
	Inner.didUpdate = logger("inner didUpdate")
	Inner.willUnmount = logger("inner willUnmount")
	function Inner:render()
		return React.createElement("TextLabel", { Text = self.props.x })
	end

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 1 }))
	end)
	jestExpect(log).toEqual({
		"outer getDerivedStateFromProps",
		"inner getDerivedStateFromProps",
		"inner didMount",
		"outer didMount",
	})

	-- Dedup warnings
	log = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 2 }))
	end)
	jestExpect(log).toEqual({
		"outer getDerivedStateFromProps",
		"outer shouldUpdate",
		"inner getDerivedStateFromProps",
		"inner shouldUpdate",
		"inner getSnapshotBeforeUpdate",
		"outer getSnapshotBeforeUpdate",
		"inner didUpdate",
		"outer didUpdate",
	})

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)
	jestExpect(log).toEqual({
		"outer willUnmount",
		"inner willUnmount",
	})
end)

it("should warn if state is not initialized before getDerivedStateFromProps", function()
	local MyComponent = React.Component:extend("MyComponent")
	function MyComponent.getDerivedStateFromProps()
		return nil
	end
	function MyComponent:render()
		return nil
	end

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)
	end).toErrorDev(
		"`MyComponent` uses `getDerivedStateFromProps` but its initial state has not been initialized. "
			.. "This is not recommended. Instead, define the initial state by "
			.. "passing an object to `self:setState` in the `init` method of `MyComponent`. "
			.. "This ensures that `getDerivedStateFromProps` arguments have a consistent shape."
	)

	-- De-duped
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(MyComponent))
	end)
end)

it("should pass the return value from getSnapshotBeforeUpdate to didUpdate", function()
	local log = {}

	local MyComponent = React.Component:extend("MyComponent")
	function MyComponent:init()
		self.state = {
			value = 0,
		}
	end
	function MyComponent.getDerivedStateFromProps(nextProps, prevState)
		return {
			value = prevState.value + 1,
		}
	end
	function MyComponent:getSnapshotBeforeUpdate(prevProps, prevState)
		table.insert(
			log,
			string.format(
				"getSnapshotBeforeUpdate() prevProps:%s prevState:%s",
				prevProps.value,
				prevState.value
			)
		)
		return "abc"
	end
	function MyComponent:didUpdate(prevProps, prevState, snapshot)
		table.insert(
			log,
			string.format(
				"didUpdate() prevProps:%s prevState:%s snapshot:%s",
				prevProps.value,
				prevState.value,
				snapshot
			)
		)
	end
	function MyComponent:render()
		table.insert(log, "render")
		return nil
	end

	ReactNoop.act(function()
		ReactNoop.render(
			React.createElement(
				"Frame",
				{},
				React.createElement(MyComponent, {
					value = "foo",
				})
			)
		)
	end)
	jestExpect(log).toEqual({ "render" })
	log = {}

	ReactNoop.act(function()
		ReactNoop.render(
			React.createElement(
				"Frame",
				{},
				React.createElement(MyComponent, {
					value = "bar",
				})
			)
		)
	end)
	jestExpect(log).toEqual({
		"render",
		"getSnapshotBeforeUpdate() prevProps:foo prevState:1",
		"didUpdate() prevProps:foo prevState:1 snapshot:abc",
	})
	log = {}

	ReactNoop.act(function()
		ReactNoop.render(
			React.createElement(
				"Frame",
				{},
				React.createElement(MyComponent, {
					value = "baz",
				})
			)
		)
	end)
	jestExpect(log).toEqual({
		"render",
		"getSnapshotBeforeUpdate() prevProps:bar prevState:2",
		"didUpdate() prevProps:bar prevState:2 snapshot:abc",
	})
	log = {}

	ReactNoop.act(function()
		ReactNoop.render(React.createElement("Frame"))
	end)
	jestExpect(log).toEqual({})
end)

it(
	"should pass previous state to shouldUpdate even with getDerivedStateFromProps",
	function()
		local divRef = React.createRef()
		local capturedValue
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init(props)
			self.state = {
				value = props.value,
			}
		end

		function SimpleComponent.getDerivedStateFromProps(nextProps, prevState)
			if nextProps.value == prevState.value then
				return nil
			end
			return { value = nextProps.value }
		end

		function SimpleComponent:shouldUpdate(nextProps, nextState)
			return nextState.value ~= self.state.value
		end

		function SimpleComponent:render()
			capturedValue = self.state.value
			return React.createElement(
				"Frame",
				{ ref = divRef },
				React.createElement("TextLabel", { Text = self.state.value })
			)
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(SimpleComponent, { value = "initial" }))
		end)
		jestExpect(capturedValue).toBe("initial")
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(SimpleComponent, { value = "updated" }))
		end)
		jestExpect(capturedValue).toBe("updated")
	end
)

it(
	"should warn if getSnapshotBeforeUpdate is defined with no componentDidUpdate",
	function()
		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:getSnapshotBeforeUpdate()
			return nil
		end
		function MyComponent:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(MyComponent))
			end)
		end).toErrorDev(
			"MyComponent: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). "
				.. "This component defines getSnapshotBeforeUpdate() only."
		)

		-- De-duped
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)
	end
)

describe("Naming conventions", function()
	local prevCompatWarnings
	beforeEach(function()
		prevCompatWarnings = _G.__COMPAT_WARNINGS__
		_G.__COMPAT_WARNINGS__ = true
		jest.resetModules()
		jest.useFakeTimers()
		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
	end)

	afterEach(function()
		_G.__COMPAT_WARNINGS__ = prevCompatWarnings
	end)

	local function testWithComponentKind(component: string)
		it("should warn if using old Roact didMount naming in " .. component, function()
			local Foo = React[component]:extend("Foo")
			jestExpect(function()
				function Foo:didMount() end
			end).toWarnDev(
				"Foo is using method 'didMount', which is no longer supported and should be updated to 'componentDidMount'\nFile: ReactComponentLifeCycle.roblox.spec:",
				{ withoutStack = true }
			)
		end)
		it(
			"should warn if using old Roact shouldUpdate naming in " .. component,
			function()
				local Foo = React[component]:extend("Foo")
				jestExpect(function()
					function Foo:shouldUpdate() end
				end).toWarnDev(
					"Foo is using method 'shouldUpdate', which is no longer supported and should be updated to 'shouldComponentUpdate'\nFile: ReactComponentLifeCycle.roblox.spec:",
					{ withoutStack = true }
				)
			end
		)
		it("should warn if using old Roact willUpdate naming in " .. component, function()
			local Foo = React[component]:extend("Foo")
			jestExpect(function()
				function Foo:willUpdate() end
			end).toWarnDev(
				"Foo is using method 'willUpdate', which is no longer supported and should be updated to 'UNSAFE_componentWillUpdate'\nFile: ReactComponentLifeCycle.roblox.spec:",
				{ withoutStack = true }
			)
		end)
		it("should warn if using old Roact didUpdate naming in " .. component, function()
			local Foo = React[component]:extend("Foo")
			jestExpect(function()
				function Foo:didUpdate() end
			end).toWarnDev(
				"Foo is using method 'didUpdate', which is no longer supported and should be updated to 'componentDidUpdate'\nFile: ReactComponentLifeCycle.roblox.spec:",
				{ withoutStack = true }
			)
		end)
		it(
			"should warn if using old Roact willUnmount naming in " .. component,
			function()
				local Foo = React[component]:extend("Foo")
				jestExpect(function()
					function Foo:willUnmount() end
				end).toWarnDev(
					"Foo is using method 'willUnmount', which is no longer supported and should be updated to 'componentWillUnmount'\nFile: ReactComponentLifeCycle.roblox.spec:",
					{ withoutStack = true }
				)
			end
		)
		it(
			"should warn if both didMount and componentDidMount are defined on the same "
				.. component,
			function()
				local Foo = React[component]:extend("Foo")
				function Foo:componentDidMount() end
				jestExpect(function()
					function Foo:didMount() end
				end).toWarnDev(
					"Warning: Foo already defined 'componentDidMount', but it also defining the deprecated Roact method 'didMount'. Foo should only implement one of these methods, preferably using the non-deprecated name.",
					{ withoutStack = true }
				)
			end
		)
		it(
			"should warn if both shouldUpdate and shouldComponentUpdate are defined on the same "
				.. component,
			function()
				local Foo = React[component]:extend("Foo")
				function Foo:shouldComponentUpdate() end
				jestExpect(function()
					function Foo:shouldUpdate() end
				end).toWarnDev(
					"Warning: Foo already defined 'shouldComponentUpdate', but it also defining the deprecated Roact method 'shouldUpdate'. Foo should only implement one of these methods, preferably using the non-deprecated name.",
					{ withoutStack = true }
				)
			end
		)
		it(
			"should warn if both willUpdate and componentWillUpdate are defined on the same "
				.. component,
			function()
				local Foo = React[component]:extend("Foo")
				function Foo:componentWillUpdate() end
				jestExpect(function()
					function Foo:willUpdate() end
				end).toWarnDev(
					"Warning: Foo already defined 'UNSAFE_componentWillUpdate', but it also defining the deprecated Roact method 'willUpdate'. Foo should only implement one of these methods, preferably using the non-deprecated name.",
					{ withoutStack = true }
				)

				-- tests same thing but with UNSAFE_componentWillUpdate() which is the preferred name starting from Roact 16.x
				local Bar = React[component]:extend("Bar")
				function Bar:UNSAFE_componentWillUpdate() end
				jestExpect(function()
					function Bar:willUpdate() end
				end).toWarnDev(
					"Warning: Bar already defined 'UNSAFE_componentWillUpdate', but it also defining the deprecated Roact method 'willUpdate'. Bar should only implement one of these methods, preferably using the non-deprecated name.",
					{ withoutStack = true }
				)
			end
		)
		it(
			"should worn if both didUpdate and componentDidUpdate are defined on the same "
				.. component,
			function()
				local Foo = React[component]:extend("Foo")
				function Foo:componentDidUpdate() end
				jestExpect(function()
					function Foo:didUpdate() end
				end).toWarnDev(
					"Warning: Foo already defined 'componentDidUpdate', but it also defining the deprecated Roact method 'didUpdate'. Foo should only implement one of these methods, preferably using the non-deprecated name.",
					{ withoutStack = true }
				)
			end
		)
		it(
			"should warn if both willUnmount and componentWillUnmount are defined on the same "
				.. component,
			function()
				local Foo = React[component]:extend("Foo")
				function Foo:componentWillUnmount() end
				jestExpect(function()
					function Foo:willUnmount() end
				end).toWarnDev(
					"Warning: Foo already defined 'componentWillUnmount', but it also defining the deprecated Roact method 'willUnmount'. Foo should only implement one of these methods, preferably using the non-deprecated name",
					{ withoutStack = true }
				)
			end
		)
	end

	testWithComponentKind("Component")
	testWithComponentKind("PureComponent")
end) ]]
eC.Children._7b3a1523a9c897d91b351a3c72fbb20b=eH
local eI

local eJ={ClassName="ModuleScript",Children={},Properties={}}
eJ.Name="ReactComponentLifeCycle.spec"
eJ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/__tests__/ReactComponentLifeCycle-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]
--\[\[*
 * TODO: We should make any setState calls fail in
 * `getInitialState` and `componentWillMount`. They will usually fail
 * anyways because `this._renderedComponent` is empty, however, if a component
 * is *reused*, then that won't be the case and things will appear to work in
 * some cases. Better to just block all updates in initialization.
 \]\]
local HttpService = game:GetService("HttpService")
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local xit = JestGlobals.xit
local beforeEach = JestGlobals.beforeEach

local Error = require(Packages.LuauPolyfill).Error

-- deviation: Move all of the following into the test function body to match
-- convention
local React
-- local ReactDOM
local ReactNoop
-- local ReactTestUtils
-- local PropTypes

local clone = function(o)
	return HttpService:JSONDecode(HttpService:JSONEncode(o))
end

local GET_INIT_STATE_RETURN_VAL = {
	hasWillMountCompleted = false,
	hasRenderCompleted = false,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local INIT_RENDER_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = false,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local DID_MOUNT_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = true,
	hasDidMountCompleted = false,
	hasWillUnmountCompleted = false,
}

local NEXT_RENDER_STATE = {
	hasWillMountCompleted = true,
	hasRenderCompleted = true,
	hasDidMountCompleted = true,
	hasWillUnmountCompleted = false,
}

local WILL_UNMOUNT_STATE = {
	hasWillMountCompleted = true,
	hasDidMountCompleted = true,
	hasRenderCompleted = true,
	hasWillUnmountCompleted = false,
}

local POST_WILL_UNMOUNT_STATE = {
	hasWillMountCompleted = true,
	hasDidMountCompleted = true,
	hasRenderCompleted = true,
	hasWillUnmountCompleted = true,
}

--\[\[
    Every React component is in one of these life cycles.
    * MOUNTED
      * Mounted components have a DOM node representation and are capable of
      receiving new props.
    * UNMOUNTED
      * Unmounted components are inactive and cannot receive new props.
  \]\]
type ComponentLifeCycle = string

local function getLifeCycleState(instance): ComponentLifeCycle
	return instance.__updater.isMounted(instance) and "MOUNTED" or "UNMOUNTED"
end

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	-- ReactDOM = require('react-dom')
	-- ReactTestUtils = require('react-dom/test-utils')
	-- PropTypes = require('prop-types')

	-- ROBLOX deviation: these tests are failing with debugRenderPhaseSideEffectsForStrictMode on.
	-- https://github.com/Roblox/roact-alignment/issues/105
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
end)

-- ROBLOX TODO: do we need to test this in roblox renderer?
-- xit('should not reuse an instance when it has been unmounted', function()
--   local container = document.createElement('div')

--   class StatefulComponent extends React.Component {
--     state = {}

--     render()
--       return <div />
--     end
--   end

--     local element = <StatefulComponent />
--     local firstInstance = ReactDOM.render(element, container)
--     ReactDOM.unmountComponentAtNode(container)
--     local secondInstance = ReactDOM.render(element, container)
--     jestExpect(firstInstance).not.toBe(secondInstance)
--   })

--   --\[\[*
--    * If a state update triggers rerendering that in turn fires an onDOMReady,
--    * that second onDOMReady should not fail.
--    \]\]
--   xit('it should fire onDOMReady when already in onDOMReady', function()
--     local _testJournal = []

--     class Child extends React.Component {
--       componentDidMount()
--         _testJournal.push('Child:onDOMReady')
--       end

--       render()
--         return <div />
--       end
--     end

--     class SwitcherParent extends React.Component {
--       constructor(props)
--         super(props)
--         _testJournal.push('SwitcherParent:getInitialState')
--         this.state = {showHasOnDOMReadyComponent: false}
--       end

--       componentDidMount()
--         _testJournal.push('SwitcherParent:onDOMReady')
--         this.switchIt()
--       end

--       switchIt = function()
--         this.setState({showHasOnDOMReadyComponent: true})
--       end

--       render()
--         return (
--           <div>
--             {this.state.showHasOnDOMReadyComponent ? <Child /> : <div />}
--           </div>
--         )
--       end
--     end

--     ReactTestUtils.renderIntoDocument(<SwitcherParent />)
--     jestExpect(_testJournal).toEqual([
--       'SwitcherParent:getInitialState',
--       'SwitcherParent:onDOMReady',
--       'Child:onDOMReady',
--     ])
--   })

--\[\[ROBLOX DEVIATION: State is now automatically initialized to a singleton that gives warnings
    on access if state has not been initialized with setState. The code in the test below will
    no longer throw an error.
  \]\]
-- You could assign state here, but not access members of it, unless you
-- had provided a getInitialState method.
xit("throws when accessing state in componentWillMount", function()
	local StatefulComponent = React.Component:extend("StatefulComponent")

	function StatefulComponent:UNSAFE_componentWillMount()
		-- ROBLOX deviation: ensure self is non nil
		jestExpect(self).never.toEqual(nil)

		return self.state.yada
	end

	function StatefulComponent:render()
		-- ROBLOX deviation: ensure self is non nil
		jestExpect(self).never.toEqual(nil)
		return React.createElement("div")
	end

	local instance = React.createElement(StatefulComponent)
	jestExpect(function()
		ReactNoop.act(function()
			instance = ReactNoop.render(instance)
		end)
		-- deviation
	end).toThrow("yada")
end)

it("should allow update state inside of componentWillMount", function()
	local StatefulComponent = React.Component:extend("StatefulComponent")

	function StatefulComponent:UNSAFE_componentWillMount()
		self:setState({ stateField = "something" })
	end

	function StatefulComponent:render()
		return React.createElement("div")
	end

	local instance = React.createElement(StatefulComponent)
	jestExpect(function()
		jestExpect(function()
			ReactNoop.act(function()
				instance = ReactNoop.render(instance)
			end)
		end).toErrorDev({
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
		}, { withoutStack = true })
	end).never.toThrow()
end)

it("warns if setting 'self.state = props'", function()
	local StatefulComponent = React.Component:extend("StatefulComponent")

	function StatefulComponent:init()
		self.state = self.props
	end

	function StatefulComponent:render()
		return React.createElement("div")
	end

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(StatefulComponent))
		end)
	end).toErrorDev(
		"StatefulComponent: It is not recommended to assign props directly to state "
			.. "because updates to props won't be reflected in state. "
			.. "In most cases, it is better to use props directly."
	)
end)

-- ROBLOX DEVIATION: skipped because we ARE supporting setState in constructor in roact alignment (see LUAFDN-322)
xit("should not allow update state inside of getInitialState", function()
	local StatefulComponent = React.Component:extend("StatefulComponent")

	function StatefulComponent:init()
		self:setState({ stateField = "something" })
		self.state = { stateField = "somethingelse" }
	end

	function StatefulComponent:render()
		return React.createElement("div")
	end

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(StatefulComponent))
		end)
	end).toErrorDev(
		"Warning: Can't call setState on a component that is not yet mounted. "
			.. "This is a no-op, but it might indicate a bug in your application. "
			.. "Instead, assign to `self.state` directly with the desired state "
			.. "in the StatefulComponent component's `init` method."
	)

	-- Check deduplication; (no extra warnings should be logged).
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(StatefulComponent))
	end)
end)

it("should correctly determine if a component is mounted", function()
	local isMounted
	local Component = React.Component:extend("Component")

	function Component:init()
		isMounted = function()
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			return self.__updater.isMounted(self)
		end
	end
	function Component:UNSAFE_componentWillMount()
		jestExpect(isMounted()).toBe(false)
	end
	function Component:componentDidMount()
		-- ROBLOX deviation: assert self is non nil
		jestExpect(self).never.toEqual(nil)
		jestExpect(isMounted()).toBe(true)
	end
	function Component:render()
		jestExpect(isMounted()).toBe(false)
		return React.createElement("div")
	end

	local element = React.createElement(Component)

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(element)
		end)
		jestExpect(isMounted()).toBe(true)
	end).toErrorDev({
		"Component is accessing isMounted inside its render()",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })
end)

it("should correctly determine if a nil component is mounted", function()
	local isMounted
	local Component = React.Component:extend("Component")

	function Component:init()
		isMounted = function()
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			return self.__updater.isMounted(self)
		end
	end
	function Component:UNSAFE_componentWillMount()
		jestExpect(isMounted()).toBe(false)
	end
	function Component:componentDidMount()
		jestExpect(isMounted()).toBe(true)
	end
	function Component:render()
		jestExpect(isMounted()).toBe(false)
		return nil
	end

	local element = React.createElement(Component)

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(element)
		end)
		jestExpect(isMounted()).toBe(true)
	end).toErrorDev({
		"Component is accessing isMounted inside its render()",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })
end)

it("isMounted should return false when unmounted", function()
	local isMounted
	local Component = React.Component:extend("Component")
	function Component:init()
		isMounted = function()
			return self.__updater.isMounted(self)
		end
	end
	function Component:render()
		return React.createElement("div")
	end

	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Component))
	end)

	-- No longer a public API, but we can test that it works internally by
	-- reaching into the updater.
	jestExpect(isMounted()).toBe(true)

	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)

	jestExpect(isMounted()).toBe(false)
end)

--   xit('warns if findDOMNode is used inside render', function()
--     class Component extends React.Component {
--       state = {isMounted: false}
--       componentDidMount()
--         this.setState({isMounted: true})
--       end
--       render()
--         if this.state.isMounted)
--           jestExpect(ReactDOM.findDOMNode(this).tagName).toBe('DIV')
--      end
--         return <div />
--       end
--  end

--     jestExpect(function()
--       ReactNoop.render(<Component />)
--     }).toErrorDev('Component is accessing findDOMNode inside its render()')
--   })

it("should carry through each of the phases of setup", function()
	local _testJournal: any = {}
	local getTestLifeCycleState, getInstanceState
	local LifeCycleComponent = React.Component:extend("LifeCycleComponent")
	function LifeCycleComponent:init()
		local initState = {
			hasWillMountCompleted = false,
			hasDidMountCompleted = false,
			hasRenderCompleted = false,
			hasWillUnmountCompleted = false,
		}
		getTestLifeCycleState = function()
			return getLifeCycleState(self)
		end
		getInstanceState = function()
			return self.state
		end
		_testJournal.returnedFromGetInitialState = clone(initState)
		_testJournal.lifeCycleAtStartOfGetInitialState = getTestLifeCycleState()
		self.state = initState
	end

	function LifeCycleComponent:UNSAFE_componentWillMount()
		_testJournal.stateAtStartOfWillMount = clone(self.state)
		_testJournal.lifeCycleAtStartOfWillMount = getTestLifeCycleState()
		self.state.hasWillMountCompleted = true
	end

	function LifeCycleComponent:componentDidMount()
		_testJournal.stateAtStartOfDidMount = clone(self.state)
		_testJournal.lifeCycleAtStartOfDidMount = getTestLifeCycleState()
		self:setState({ hasDidMountCompleted = true })
	end

	function LifeCycleComponent:render()
		local isInitialRender = not self.state.hasRenderCompleted
		if isInitialRender then
			_testJournal.stateInInitialRender = clone(self.state)
			_testJournal.lifeCycleInInitialRender = getTestLifeCycleState()
		else
			_testJournal.stateInLaterRender = clone(self.state)
			_testJournal.lifeCycleInLaterRender = getTestLifeCycleState()
		end
		-- you would *NEVER* do anything like this in real code!
		self.state.hasRenderCompleted = true
		return React.createElement("TextLabel", { Text = "I am the inner DIV" })
	end

	function LifeCycleComponent:componentWillUnmount()
		-- ROBLOX deviation: assert self is non nil
		jestExpect(self).never.toEqual(nil)

		_testJournal.stateAtStartOfWillUnmount = clone(self.state)
		_testJournal.lifeCycleAtStartOfWillUnmount = getTestLifeCycleState()
		self.state.hasWillUnmountCompleted = true
	end

	-- A component that is merely "constructed" (as in "constructor") but not
	-- yet initialized, or rendered.
	--
	-- local container = document.createElement('div')

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(LifeCycleComponent))
		end)
	end).toErrorDev({
		"LifeCycleComponent is accessing isMounted inside its render() function",
		"UNSAFE_componentWillMount in strict mode is not recommended",
	}, { withoutStack = 1 })

	-- getInitialState
	jestExpect(_testJournal.returnedFromGetInitialState).toEqual(
		GET_INIT_STATE_RETURN_VAL
	)
	jestExpect(_testJournal.lifeCycleAtStartOfGetInitialState).toBe("UNMOUNTED")

	-- componentWillMount
	jestExpect(_testJournal.stateAtStartOfWillMount).toEqual(
		_testJournal.returnedFromGetInitialState
	)
	jestExpect(_testJournal.lifeCycleAtStartOfWillMount).toBe("UNMOUNTED")

	-- componentDidMount
	jestExpect(_testJournal.stateAtStartOfDidMount).toEqual(DID_MOUNT_STATE)
	jestExpect(_testJournal.lifeCycleAtStartOfDidMount).toBe("MOUNTED")

	-- initial render
	jestExpect(_testJournal.stateInInitialRender).toEqual(INIT_RENDER_STATE)
	jestExpect(_testJournal.lifeCycleInInitialRender).toBe("UNMOUNTED")

	jestExpect(getTestLifeCycleState()).toBe("MOUNTED")

	-- Now *update the component*
	-- instance.forceUpdate()
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(LifeCycleComponent))
	end)

	-- render 2nd time
	jestExpect(_testJournal.stateInLaterRender).toEqual(NEXT_RENDER_STATE)
	jestExpect(_testJournal.lifeCycleInLaterRender).toBe("MOUNTED")

	jestExpect(getTestLifeCycleState()).toBe("MOUNTED")

	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)

	jestExpect(_testJournal.stateAtStartOfWillUnmount).toEqual(WILL_UNMOUNT_STATE)
	-- componentWillUnmount called right before unmount.
	jestExpect(_testJournal.lifeCycleAtStartOfWillUnmount).toBe("MOUNTED")

	-- But the current lifecycle of the component is unmounted.
	jestExpect(getTestLifeCycleState()).toBe("UNMOUNTED")
	jestExpect(getInstanceState()).toEqual(POST_WILL_UNMOUNT_STATE)
end)

-- getting to the real error here requires commenting out many try/catch, but here it is:
--   LoadedCode.RoactAlignment.Modules.Scheduler.forks.SchedulerHostConfig.mock:172: Already flushing work.
-- LoadedCode.RoactAlignment.Modules.Scheduler.forks.SchedulerHostConfig.mock:172
-- LoadedCode.RoactAlignment.Modules.ReactNoopRenderer.createReactNoop:1242 function noopAct
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.__tests__.ReactComponentLifeCycle.spec:538 function updateTooltip
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.__tests__.ReactComponentLifeCycle.spec:528 function componentDidMount
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberCommitWork.new:820
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberCommitWork.new:661 function recursivelyCommitLayoutEffects
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberCommitWork.new:613 function recursivelyCommitLayoutEffects
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberCommitWork.new:613 function recursivelyCommitLayoutEffects
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:2103
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:1906
-- LoadedCode.RoactAlignment.Modules.Scheduler.Scheduler:210 function unstable_runWithPriority
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.SchedulerWithReactIntegration.new:164 function runWithPriority
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:1903
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:980
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:860
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.ReactFiberWorkLoop.new:758
-- LoadedCode.RoactAlignment.Modules.Scheduler.Scheduler:160
-- LoadedCode.RoactAlignment.Modules.Scheduler.Scheduler:129
-- LoadedCode.RoactAlignment.Modules.Scheduler.forks.SchedulerHostConfig.mock:180
-- LoadedCode.RoactAlignment.Modules.ReactNoopRenderer.createReactNoop:1242 function noopAct
-- LoadedCode.RoactAlignment.Modules.ReactReconciler.__tests__.ReactComponentLifeCycle.spec:575

-- ROBLOX TODO: throws LoadedCode.RoactAlignment.Packages.Modules.Scheduler.forks.SchedulerHostConfig.mock:172: Already flushing work.
xit("should not throw when updating an auxiliary component", function()
	local Tooltip = React.Component:extend("Tooltip")
	function Tooltip:render()
		return React.createElement("div", nil, self.props.children)
	end

	function Tooltip:componentDidMount()
		self.container = "some container"
		self:updateTooltip()
	end

	function Tooltip:componentDidUpdate()
		self:updateTooltip()
	end

	function Tooltip:updateTooltip()
		-- Even though this.props.tooltip has an owner, updating it shouldn't
		-- throw here because it's mounted as a root component
		ReactNoop.act(function()
			ReactNoop.renderToRootWithID(self.props.tooltip, self.container)
		end)
	end

	local Component = React.Component:extend("Component")

	function Component:render()
		return React.createElement(
			Tooltip,
			{ tooltip = React.createElement("div", nil, self.props.tooltipText) },
			self.props.text
		)
	end

	ReactNoop.act(function()
		ReactNoop.render(
			React.createElement(Component, { text = "uno", tooltipText = "one" })
		)
	end)

	-- Since `instance` is a root component, we can set its props. This also
	-- makes Tooltip rerender the tooltip component, which shouldn't throw.
	ReactNoop.act(function()
		ReactNoop.render(
			React.createElement(Component, { text = "dos", tooltipText = "two" })
		)
	end)
end)

it("should allow state updates in componentDidMount", function()
	local getComponentState
	--\[\[*
     * calls setState in an componentDidMount.
     \]\]
	local SetStateInComponentDidMount =
		React.Component:extend("SetStateInComponentDidMount")
	function SetStateInComponentDidMount:init()
		self.state = {
			stateField = self.props.valueToUseInitially,
		}
		getComponentState = function()
			return self.state
		end
	end

	function SetStateInComponentDidMount:componentDidMount()
		self:setState({ stateField = self.props.valueToUseAfterMount })
	end

	function SetStateInComponentDidMount:render()
		return React.createElement("div")
	end

	local element = React.createElement(SetStateInComponentDidMount, {
		valueToUseInitially = "hello",
		valueToUseAfterMount = "goodbye",
	})
	ReactNoop.act(function()
		ReactNoop.render(element)
	end)
	jestExpect(getComponentState().stateField).toBe("goodbye")
end)

it("should call nested legacy lifecycle methods in the right order", function()
	local log
	local logger = function(msg)
		return function()
			-- return true for shouldComponentUpdate
			table.insert(log, msg)
			return true
		end
	end

	local Outer = React.Component:extend("Outer")
	-- pre-declare
	local Inner = React.Component:extend("Inner")
	Outer.UNSAFE_componentWillMount = logger("outer componentWillMount")
	Outer.componentDidMount = logger("outer componentDidMount")
	Outer.UNSAFE_componentWillReceiveProps = logger("outer componentWillReceiveProps")
	Outer.shouldComponentUpdate = logger("outer shouldComponentUpdate")
	Outer.UNSAFE_componentWillUpdate = logger("outer componentWillUpdate")
	Outer.componentDidUpdate = logger("outer componentDidUpdate")
	Outer.componentWillUnmount = logger("outer componentWillUnmount")
	function Outer:render()
		return React.createElement(
			"Frame",
			{},
			React.createElement(Inner, {
				x = self.props.x,
			})
		)
	end

	Inner.UNSAFE_componentWillMount = logger("inner componentWillMount")
	Inner.componentDidMount = logger("inner componentDidMount")
	Inner.UNSAFE_componentWillReceiveProps = logger("inner componentWillReceiveProps")
	Inner.shouldComponentUpdate = logger("inner shouldComponentUpdate")
	Inner.UNSAFE_componentWillUpdate = logger("inner componentWillUpdate")
	Inner.componentDidUpdate = logger("inner componentDidUpdate")
	Inner.componentWillUnmount = logger("inner componentWillUnmount")
	function Inner:render()
		return React.createElement("TextLabel", { Text = self.props.x })
	end

	log = {}
	-- ROBLOX deviation START: Wrap to catch warnings (see deviation below)
	jestExpect(function()
		-- ROBLOX deviation END
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Outer, { x = 1 }))
		end)
		-- ROBLOX deviation START: The upstream equivalents of these tests run with react-dom
		-- using the legacy root, so they don't throw warnings related to strict
		-- mode; we compromise by keeping it in concurrent mode to better match
		-- production, but anticipating the warnings
	end).toErrorDev({
		"Using UNSAFE_componentWillMount in strict mode is not recommended",
		"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
		"Using UNSAFE_componentWillUpdate in strict mode is not recommended",
	}, { withoutStack = true })
	-- ROBLOX deviation END
	jestExpect(log).toEqual({
		"outer componentWillMount",
		"inner componentWillMount",
		"inner componentDidMount",
		"outer componentDidMount",
	})

	-- Dedup warnings
	log = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 2 }))
	end)
	jestExpect(log).toEqual({
		"outer componentWillReceiveProps",
		"outer shouldComponentUpdate",
		"outer componentWillUpdate",
		"inner componentWillReceiveProps",
		"inner shouldComponentUpdate",
		"inner componentWillUpdate",
		"inner componentDidUpdate",
		"outer componentDidUpdate",
	})

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)
	jestExpect(log).toEqual({
		"outer componentWillUnmount",
		"inner componentWillUnmount",
	})
end)

it("should call nested new lifecycle methods in the right order", function()
	local log
	local logger = function(msg)
		return function()
			-- return true for shouldComponentUpdate
			table.insert(log, msg)
			return true
		end
	end
	local Outer = React.Component:extend("Outer")
	-- pre-declare
	local Inner = React.Component:extend("Inner")
	function Outer:init()
		self.state = {}
	end
	function Outer.getDerivedStateFromProps(props, prevState)
		table.insert(log, "outer getDerivedStateFromProps")
		return nil
	end
	Outer.componentDidMount = logger("outer componentDidMount")
	Outer.shouldComponentUpdate = logger("outer shouldComponentUpdate")
	Outer.getSnapshotBeforeUpdate = logger("outer getSnapshotBeforeUpdate")
	Outer.componentDidUpdate = logger("outer componentDidUpdate")
	Outer.componentWillUnmount = logger("outer componentWillUnmount")
	function Outer:render()
		return React.createElement(
			"Frame",
			{},
			React.createElement(Inner, { x = self.props.x })
		)
	end

	function Inner:init()
		self.state = {}
	end
	function Inner.getDerivedStateFromProps(props, prevState)
		table.insert(log, "inner getDerivedStateFromProps")
		return nil
	end
	Inner.componentDidMount = logger("inner componentDidMount")
	Inner.shouldComponentUpdate = logger("inner shouldComponentUpdate")
	Inner.getSnapshotBeforeUpdate = logger("inner getSnapshotBeforeUpdate")
	Inner.componentDidUpdate = logger("inner componentDidUpdate")
	Inner.componentWillUnmount = logger("inner componentWillUnmount")
	function Inner:render()
		return React.createElement("TextLabel", { Text = self.props.x })
	end

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 1 }))
	end)
	jestExpect(log).toEqual({
		"outer getDerivedStateFromProps",
		"inner getDerivedStateFromProps",
		"inner componentDidMount",
		"outer componentDidMount",
	})

	-- Dedup warnings
	log = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(Outer, { x = 2 }))
	end)
	jestExpect(log).toEqual({
		"outer getDerivedStateFromProps",
		"outer shouldComponentUpdate",
		"inner getDerivedStateFromProps",
		"inner shouldComponentUpdate",
		"inner getSnapshotBeforeUpdate",
		"outer getSnapshotBeforeUpdate",
		"inner componentDidUpdate",
		"outer componentDidUpdate",
	})

	log = {}
	ReactNoop.act(function()
		ReactNoop.render(nil)
	end)
	jestExpect(log).toEqual({
		"outer componentWillUnmount",
		"inner componentWillUnmount",
	})
end)

it(
	"should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present",
	function()
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = {}
		end
		function Component.getDerivedStateFromProps()
			return nil
		end
		function Component:componentWillMount()
			error(Error("unexpected"))
		end
		function Component:componentWillReceiveProps()
			-- ROBLOX deviation: assert self is non nil
			jestExpect(self).never.toEqual(nil)

			error(Error("unexpected"))
		end
		function Component:componentWillUpdate()
			error(Error("unexpected"))
		end
		function Component:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(Component))
				end)
			end).toErrorDev(
				"Unsafe legacy lifecycles will not be called for components using new component APIs."
			)
		end).toWarnDev(
			-- We should consider removing this altogether; the old behavior referred
			-- to here is unique to React. None of Roact's old behavior is reflected
			-- by these messages and is likely to confuse existing users
			{
				"componentWillMount has been renamed",
				"componentWillReceiveProps has been renamed",
				"componentWillUpdate has been renamed",
			},
			{ withoutStack = true }
		)
	end
)

-- ROBLOX FIXME: outputs none of the toWarnDev() expected messages in DEV mode
it(
	"should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present",
	function()
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = {}
		end
		function Component:getSnapshotBeforeUpdate()
			return nil
		end
		function Component:componentWillMount()
			error(Error("unexpected"))
		end
		function Component:componentWillReceiveProps()
			error(Error("unexpected"))
		end
		function Component:componentWillUpdate()
			-- ROBLOX deviation: assert self is non nil
			jestExpect(self).never.toEqual(nil)
			error(Error("unexpected"))
		end
		function Component:componentDidUpdate()
			-- ROBLOX deviation: assert self is non nil
			jestExpect(self).never.toEqual(nil)
		end
		function Component:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(Component, { value = 1 }))
				end)
			end).toErrorDev(
				"Unsafe legacy lifecycles will not be called for components using new component APIs."
			)
		end).toWarnDev({
			"componentWillMount has been renamed",
			"componentWillReceiveProps has been renamed",
			"componentWillUpdate has been renamed",
		}, { withoutStack = true })
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component, { value = 2 }))
		end)
	end
)

it(
	"should not invoke new unsafe lifecycles (cWM/cWRP/cWU) if static gDSFP is present",
	function()
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = {}
		end
		function Component.getDerivedStateFromProps()
			return nil
		end
		function Component:UNSAFE_componentWillMount()
			error(Error("unexpected"))
		end
		function Component:UNSAFE_componentWillReceiveProps()
			error(Error("unexpected"))
		end
		function Component:UNSAFE_componentWillUpdate()
			error(Error("unexpected"))
		end
		function Component:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(Component, { value = 1 }))
			end)
		end).toErrorDev({
			"Unsafe legacy lifecycles will not be called for components using new component APIs.",
			-- deviation: ReactNoop runs with a StrictMode root and logs more warnings
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
			"Using UNSAFE_componentWillUpdate in strict mode is not recommended",
		}, { withoutStack = 3 })
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Component, { value = 2 }))
		end)
	end
)

it(
	"should warn about deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present",
	function()
		local AllLegacyLifecycles = React.Component:extend("AllLegacyLifecycles")
		function AllLegacyLifecycles:init()
			self.state = {}
		end
		function AllLegacyLifecycles.getDerivedStateFromProps()
			return nil
		end
		function AllLegacyLifecycles:componentWillMount() end
		function AllLegacyLifecycles:UNSAFE_componentWillReceiveProps() end
		function AllLegacyLifecycles:componentWillUpdate() end
		function AllLegacyLifecycles:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(AllLegacyLifecycles))
				end)
			end).toErrorDev({
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "AllLegacyLifecycles uses getDerivedStateFromProps() but also contains the following legacy lifecycles:\n"
					.. "  componentWillMount\n"
					.. "  UNSAFE_componentWillReceiveProps\n"
					.. "  componentWillUpdate\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles",
				"UNSAFE_componentWillReceiveProps in strict mode is not recommended",
			}, { withoutStack = 1 })
		end).toWarnDev({
			"componentWillMount has been renamed",
			"componentWillUpdate has been renamed",
		}, { withoutStack = true })

		local WillMount = React.Component:extend("WillMount")
		function WillMount:init()
			self.state = {}
		end
		function WillMount.getDerivedStateFromProps()
			return nil
		end
		function WillMount:UNSAFE_componentWillMount() end
		function WillMount:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(WillMount))
			end).toErrorDev({
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "WillMount uses getDerivedStateFromProps() but also contains the following legacy lifecycles:\n"
					.. "  UNSAFE_componentWillMount\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles",
				"UNSAFE_componentWillMount in strict mode is not recommended",
			}, { withoutStack = 1 })
		end)

		local WillMountAndUpdate = React.Component:extend("WillMountAndUpdate")
		function WillMountAndUpdate:init()
			self.state = {}
		end
		function WillMountAndUpdate.getDerivedStateFromProps()
			return nil
		end
		function WillMountAndUpdate:componentWillMount() end
		function WillMountAndUpdate:UNSAFE_componentWillUpdate() end
		function WillMountAndUpdate:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(WillMountAndUpdate))
				end)
			end).toErrorDev({
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "WillMountAndUpdate uses getDerivedStateFromProps() but also contains the following legacy lifecycles:\n"
					.. "  componentWillMount\n"
					.. "  UNSAFE_componentWillUpdate\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles",
				"UNSAFE_componentWillUpdate in strict mode is not recommended",
			}, { withoutStack = 1 })
		end).toWarnDev({ "componentWillMount has been renamed" }, {
			withoutStack = true,
		})

		local WillReceiveProps = React.Component:extend("WillReceiveProps")
		function WillReceiveProps:init()
			self.state = {}
		end
		function WillReceiveProps.getDerivedStateFromProps()
			return nil
		end
		function WillReceiveProps:componentWillReceiveProps() end
		function WillReceiveProps:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(WillReceiveProps))
				end)
			end).toErrorDev(
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "WillReceiveProps uses getDerivedStateFromProps() but also contains the following legacy lifecycles:\n"
					.. "  componentWillReceiveProps\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles"
			)
		end).toWarnDev({ "componentWillReceiveProps has been renamed" }, {
			withoutStack = true,
		})
	end
)

it(
	"should warn about deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present",
	function()
		local AllLegacyLifecycles = React.Component:extend("AllLegacyLifecycles")
		function AllLegacyLifecycles:init()
			self.state = {}
		end
		function AllLegacyLifecycles:getSnapshotBeforeUpdate() end
		function AllLegacyLifecycles:componentWillMount() end
		function AllLegacyLifecycles:UNSAFE_componentWillReceiveProps() end
		function AllLegacyLifecycles:componentWillUpdate() end
		function AllLegacyLifecycles:componentDidUpdate() end
		function AllLegacyLifecycles:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(AllLegacyLifecycles))
				end)
			end).toErrorDev({
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "AllLegacyLifecycles uses getSnapshotBeforeUpdate() but also contains the following legacy lifecycles:\n"
					.. "  componentWillMount\n"
					.. "  UNSAFE_componentWillReceiveProps\n"
					.. "  componentWillUpdate\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles",
				"UNSAFE_componentWillReceiveProps in strict mode is not recommended",
			}, { withoutStack = 1 })
		end).toWarnDev({
			"componentWillMount has been renamed",
			"componentWillUpdate has been renamed",
		}, { withoutStack = true })

		local WillMount = React.Component:extend("WillMount")
		function WillMount:init()
			self.state = {}
		end
		function WillMount:getSnapshotBeforeUpdate() end
		function WillMount:UNSAFE_componentWillMount() end
		function WillMount:componentDidUpdate() end
		function WillMount:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(WillMount))
			end)
		end).toErrorDev({
			"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
				.. "WillMount uses getSnapshotBeforeUpdate() but also contains the following legacy lifecycles:\n"
				.. "  UNSAFE_componentWillMount\n\n"
				.. "The above lifecycles should be removed. Learn more about this warning here:\n"
				.. "https://reactjs.org/link/unsafe-component-lifecycles",
			"UNSAFE_componentWillMount in strict mode is not recommended",
		}, { withoutStack = 1 })

		local WillMountAndUpdate = React.Component:extend("WillMountAndUpdate")
		function WillMountAndUpdate:init()
			self.state = {}
		end
		function WillMountAndUpdate:getSnapshotBeforeUpdate() end
		function WillMountAndUpdate:componentWillMount() end
		function WillMountAndUpdate:UNSAFE_componentWillUpdate() end
		function WillMountAndUpdate:componentDidUpdate() end
		function WillMountAndUpdate:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(WillMountAndUpdate))
				end)
			end).toErrorDev({
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "WillMountAndUpdate uses getSnapshotBeforeUpdate() but also contains the following legacy lifecycles:\n"
					.. "  componentWillMount\n"
					.. "  UNSAFE_componentWillUpdate\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles",
				"UNSAFE_componentWillUpdate in strict mode is not recommended",
			}, { withoutStack = 1 })
		end).toWarnDev({ "componentWillMount has been renamed" }, {
			withoutStack = true,
		})

		local WillReceiveProps = React.Component:extend("WillReceiveProps")
		function WillReceiveProps:init()
			self.state = {}
		end
		function WillReceiveProps:getSnapshotBeforeUpdate() end
		function WillReceiveProps:componentWillReceiveProps() end
		function WillReceiveProps:componentDidUpdate() end
		function WillReceiveProps:render()
			return nil
		end

		jestExpect(function()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(WillReceiveProps))
				end)
			end).toErrorDev(
				"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
					.. "WillReceiveProps uses getSnapshotBeforeUpdate() but also contains the following legacy lifecycles:\n"
					.. "  componentWillReceiveProps\n\n"
					.. "The above lifecycles should be removed. Learn more about this warning here:\n"
					.. "https://reactjs.org/link/unsafe-component-lifecycles"
			)
		end).toWarnDev({ "componentWillReceiveProps has been renamed" }, {
			withoutStack = true,
		})
	end
)

--   if !require('shared/ReactFeatureFlags').disableModulePatternComponents)
--     it('calls effects on module-pattern component', function()
--       local log = []

--       function Parent()
--         return {
--           render()
--             jestExpect(typeof this.props).toBe('table’')
--             log.push('render')
--             return <Child />
--           },
--           UNSAFE_componentWillMount()
--             log.push('will mount')
--           },
--           componentDidMount()
--             log.push('did mount')
--           },
--           componentDidUpdate()
--             log.push('did update')
--           },
--           getChildContext()
--             return {x: 2}
--           },
--      end
--       end
--       Parent.childContextTypes = {
--         x: PropTypes.number,
--       end
--       function Child(props, context)
--         jestExpect(context.x).toBe(2)
--         return <div />
--       end
--       Child.contextTypes = {
--         x: PropTypes.number,
--       end

--       local div = document.createElement('div')
--       jestExpect(() =>
--         ReactDOM.render(<Parent ref={c => c and log.push('ref')} />, div),
--       ).toErrorDev(
--         'Warning: The <Parent /> component appears to be a function component that returns a class instance. ' +
--           'Change Parent to a class that extends React.Component instead. ' +
--           "If you can't use a class try assigning the prototype on the function as a workaround. " +
--           '`Parent.prototype = React.Component.prototype`. ' +
--           "Don't use an arrow function since it cannot be called with `new` by React.",
--       )
--       ReactDOM.render(<Parent ref={c => c and log.push('ref')} />, div)

--       jestExpect(log).toEqual([
--         'will mount',
--         'render',
--         'did mount',
--         'ref',

--         'render',
--         'did update',
--         'ref',
--       ])
--     })
--   end

--   -- We have no distinction between nil and undefined, so this might not be
--   -- useful unless we want to try to capture missing return
--   xit('should warn if getDerivedStateFromProps returns undefined', function()
--     class MyComponent extends React.Component {
--       state = {}
--       static getDerivedStateFromProps() {}
--       render()
--         return nil
--       end
--  end

--     local div = document.createElement('div')
--     jestExpect(() => ReactDOM.render(<MyComponent />, div)).toErrorDev(
--       'MyComponent.getDerivedStateFromProps(): A valid state object (or nil) must ' +
--         'be returned. You have returned undefined.',
--     )

--     -- De-duped
--     ReactDOM.render(<MyComponent />, div)
--   })

it("should warn if state is not initialized before getDerivedStateFromProps", function()
	local MyComponent = React.Component:extend("MyComponent")
	function MyComponent.getDerivedStateFromProps()
		return nil
	end
	function MyComponent:render()
		return nil
	end

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)
	end).toErrorDev(
		"Warning: `MyComponent` uses `getDerivedStateFromProps` but its initial state has not been initialized. "
			.. "This is not recommended. Instead, define the initial state by "
			.. "passing an object to `self:setState` in the `init` method of `MyComponent`. "
			.. "This ensures that `getDerivedStateFromProps` arguments have a consistent shape."
	)

	-- De-duped
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(MyComponent))
	end)
end)

it("should invoke both deprecated and new lifecycles if both are present", function()
	local log = {}

	local MyComponent = React.Component:extend("MyComponent")
	function MyComponent:componentWillMount()
		table.insert(log, "componentWillMount")
	end
	function MyComponent:componentWillReceiveProps()
		table.insert(log, "componentWillReceiveProps")
	end
	function MyComponent:componentWillUpdate()
		table.insert(log, "componentWillUpdate")
	end
	function MyComponent:UNSAFE_componentWillMount()
		table.insert(log, "UNSAFE_componentWillMount")
	end
	function MyComponent:UNSAFE_componentWillReceiveProps()
		table.insert(log, "UNSAFE_componentWillReceiveProps")
	end
	function MyComponent:UNSAFE_componentWillUpdate()
		table.insert(log, "UNSAFE_componentWillUpdate")
	end
	function MyComponent:render()
		return nil
	end

	jestExpect(function()
		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(MyComponent, { foo = "bar" }))
			end)
		end).toWarnDev({
			"componentWillMount has been renamed",
			"componentWillReceiveProps has been renamed",
			"componentWillUpdate has been renamed",
		}, { withoutStack = true })
	end).toErrorDev({
		"Using UNSAFE_componentWillMount in strict mode is not recommended",
		"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
		"Using UNSAFE_componentWillUpdate in strict mode is not recommended",
	}, { withoutStack = true })
	jestExpect(log).toEqual({ "componentWillMount", "UNSAFE_componentWillMount" })

	log = {}

	ReactNoop.act(function()
		ReactNoop.render(React.createElement(MyComponent, { foo = "baz" }))
	end)
	jestExpect(log).toEqual({
		"componentWillReceiveProps",
		"UNSAFE_componentWillReceiveProps",
		"componentWillUpdate",
		"UNSAFE_componentWillUpdate",
	})
end)

-- ROBLOX TODO: possibly a bug in the test due to divRef deviations, but a function state update doesn't get all the way through
xit(
	"should not override state with stale values if prevState is spread within getDerivedStateFromProps",
	function()
		local divRef = React.createRef()
		local childInstance
		-- ROBLOX deviation: Noop renderer doesn't udpated the divRef like reactDOM does. figure out idiomatic way to update
		local capturedValue

		local Child = React.Component:extend("Child")
		function Child:init()
			self.state = { local_ = 0 }
		end
		function Child.getDerivedStateFromProps(nextProps, prevState)
			prevState.remote = nextProps.remote
			return prevState
		end
		function Child:updateState()
			self:setState(function(state)
				return { local_ = state.local_ + 1 }
			end)
			self.props.onChange(self, self.state.remote + 1)
		end
		function Child:render()
			capturedValue = "remote:"
				.. tostring(self.state.remote)
				.. ", local:"
				.. tostring(self.state.local_)
			childInstance = self
			local renderedDiv = React.createElement("div", {
				onClick = self.updateState,
				ref = divRef,
			}, capturedValue)
			divRef.current = renderedDiv
			return renderedDiv
		end

		local Parent = React.Component:extend("Parent")
		function Parent:init()
			self.state = { value = 0 }
		end
		function Parent:handleChange(value)
			self:setState({ value = value })
		end
		function Parent:render()
			return React.createElement(
				Child,
				{ remote = self.state.value, onChange = self.handleChange }
			)
		end

		ReactNoop.act(function()
			ReactNoop.render(React.createElement(Parent))
		end)

		-- ROBLOX TODO: divRef doesn't get updated with Noop renderer like it does in DOM
		-- jestExpect(divRef.current.textContent).toBe('remote:0, local:0')
		jestExpect(capturedValue).toBe("remote:0, local:0")

		ReactNoop.act(function()
			-- Trigger setState() calls
			childInstance:updateState()
		end)
		-- ROBLOX TODO: remote is still 0 on this next line
		-- jestExpect(divRef.current.textContent).toBe('remote:1, local:1')
		jestExpect(capturedValue).toBe("remote:1, local:1")

		-- Trigger batched setState() calls
		divRef.current.click()
		jestExpect(divRef.current.textContent).toBe("remote:2, local:2")
	end
)

it(
	"should pass the return value from getSnapshotBeforeUpdate to componentDidUpdate",
	function()
		local log = {}

		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:init()
			self.state = {
				value = 0,
			}
		end
		function MyComponent.getDerivedStateFromProps(nextProps, prevState)
			return {
				value = prevState.value + 1,
			}
		end
		function MyComponent:getSnapshotBeforeUpdate(prevProps, prevState)
			table.insert(
				log,
				string.format(
					"getSnapshotBeforeUpdate() prevProps:%s prevState:%s",
					prevProps.value,
					prevState.value
				)
			)
			return "abc"
		end
		function MyComponent:componentDidUpdate(prevProps, prevState, snapshot)
			table.insert(
				log,
				string.format(
					"componentDidUpdate() prevProps:%s prevState:%s snapshot:%s",
					prevProps.value,
					prevState.value,
					snapshot
				)
			)
		end
		function MyComponent:render()
			table.insert(log, "render")
			return nil
		end

		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					"Frame",
					{},
					React.createElement(MyComponent, {
						value = "foo",
					})
				)
			)
		end)
		jestExpect(log).toEqual({ "render" })
		log = {}

		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					"Frame",
					{},
					React.createElement(MyComponent, {
						value = "bar",
					})
				)
			)
		end)
		jestExpect(log).toEqual({
			"render",
			"getSnapshotBeforeUpdate() prevProps:foo prevState:1",
			"componentDidUpdate() prevProps:foo prevState:1 snapshot:abc",
		})
		log = {}

		ReactNoop.act(function()
			ReactNoop.render(
				React.createElement(
					"Frame",
					{},
					React.createElement(MyComponent, {
						value = "baz",
					})
				)
			)
		end)
		jestExpect(log).toEqual({
			"render",
			"getSnapshotBeforeUpdate() prevProps:bar prevState:2",
			"componentDidUpdate() prevProps:bar prevState:2 snapshot:abc",
		})
		log = {}

		ReactNoop.act(function()
			ReactNoop.render(React.createElement("Frame"))
		end)
		jestExpect(log).toEqual({})
	end
)

it(
	"should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps",
	function()
		local divRef = React.createRef()
		local capturedValue
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init(props)
			self.state = {
				value = props.value,
			}
		end

		function SimpleComponent.getDerivedStateFromProps(nextProps, prevState)
			if nextProps.value == prevState.value then
				return nil
			end
			return { value = nextProps.value }
		end

		function SimpleComponent:shouldComponentUpdate(nextProps, nextState)
			return nextState.value ~= self.state.value
		end

		function SimpleComponent:render()
			capturedValue = self.state.value
			return React.createElement(
				"Frame",
				{ ref = divRef },
				React.createElement("TextLabel", { Text = self.state.value })
			)
		end

		-- ROBLOX TODO: upstream uses reactDOM renderer, which means divRef gets updated properly. figure out what can work for Noop
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(SimpleComponent, { value = "initial" }))
		end)
		jestExpect(capturedValue).toBe("initial")
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(SimpleComponent, { value = "updated" }))
		end)
		jestExpect(capturedValue).toBe("updated")
	end
)

--   -- ROBLOX TODO? Don't think we can convert this, since it relies on refs and DOM objects
--   xit('should call getSnapshotBeforeUpdate before mutations are committed', function()
--     local log = []

--     class MyComponent extends React.Component {
--       divRef = React.createRef()
--       getSnapshotBeforeUpdate(prevProps, prevState)
--         log.push('getSnapshotBeforeUpdate')
--         jestExpect(this.divRef.current.textContent).toBe(
--           `value:${prevProps.value}`,
--         )
--         return 'foobar'
--       end
--       componentDidUpdate(prevProps, prevState, snapshot)
--         log.push('componentDidUpdate')
--         jestExpect(this.divRef.current.textContent).toBe(
--           `value:${this.props.value}`,
--         )
--         jestExpect(snapshot).toBe('foobar')
--       end
--       render()
--         log.push('render')
--         return <div ref={this.divRef}>{`value:${this.props.value}`}</div>
--       end
--  end

--     local div = document.createElement('div')
--     ReactDOM.render(<MyComponent value="foo" />, div)
--     jestExpect(log).toEqual(['render'])
--     log.length = 0

--     ReactDOM.render(<MyComponent value="bar" />, div)
--     jestExpect(log).toEqual([
--       'render',
--       'getSnapshotBeforeUpdate',
--       'componentDidUpdate',
--     ])
--     log.length = 0
--   })

--   -- ROBLOX TODO? We have no distinction between nil and undefined, so this might not be
--   -- useful unless we want to try to capture missing return
--   xit('should warn if getSnapshotBeforeUpdate returns undefined', function()
--     class MyComponent extends React.Component {
--       getSnapshotBeforeUpdate() {}
--       componentDidUpdate() {}
--       render()
--         return nil
--       end
--  end

--     local div = document.createElement('div')
--     ReactDOM.render(<MyComponent value="foo" />, div)
--     jestExpect(() => ReactDOM.render(<MyComponent value="bar" />, div)).toErrorDev(
--       'MyComponent.getSnapshotBeforeUpdate(): A snapshot value (or nil) must ' +
--         'be returned. You have returned undefined.',
--     )

--     -- De-duped
--     ReactDOM.render(<MyComponent value="baz" />, div)
--   })

it(
	"should warn if getSnapshotBeforeUpdate is defined with no componentDidUpdate",
	function()
		local MyComponent = React.Component:extend("MyComponent")
		function MyComponent:getSnapshotBeforeUpdate()
			return nil
		end
		function MyComponent:render()
			return nil
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(MyComponent))
			end)
		end).toErrorDev(
			"MyComponent: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). "
				.. "This component defines getSnapshotBeforeUpdate() only."
		)

		-- De-duped
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent))
		end)
	end
)

it("warns about deprecated unsafe lifecycles", function()
	local MyComponent = React.Component:extend("MyComponent")
	function MyComponent:componentWillMount() end
	function MyComponent:componentWillReceiveProps() end
	function MyComponent:componentWillUpdate() end
	function MyComponent:render()
		return nil
	end

	jestExpect(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(MyComponent, { x = 1 }))
		end)
	end).toWarnDev({
		--\[\[ eslint-disable max-len \]\]
		\[\[Warning: componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: MyComponent\]\],
		\[\[Warning: componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: MyComponent\]\],
		\[\[Warning: componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.

Please update the following components: MyComponent\]\],
		--\[\[ eslint-enable max-len \]\]
	}, { withoutStack = true })

	-- Dedupe check (update and instantiate new)
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(MyComponent, { x = 2 }))
		ReactNoop.render(React.createElement(MyComponent, { key = "new", x = 1 }))
	end)
end)

--   describe('react-lifecycles-compat', function()
--     local {polyfill} = require('react-lifecycles-compat')

--     xit('should not warn for components with polyfilled getDerivedStateFromProps', function()
--       class PolyfilledComponent extends React.Component {
--         state = {}
--         static getDerivedStateFromProps()
--           return nil
--      end
--         render()
--           return nil
--      end
--       end

--       polyfill(PolyfilledComponent)

--       local container = document.createElement('div')
--       ReactDOM.render(
--         <React.StrictMode>
--           <PolyfilledComponent />
--         </React.StrictMode>,
--         container,
--       )
--     })

--     xit('should not warn for components with polyfilled getSnapshotBeforeUpdate', function()
--       class PolyfilledComponent extends React.Component {
--         getSnapshotBeforeUpdate()
--           return nil
--      end
--         componentDidUpdate() {}
--         render()
--           return nil
--      end
--       end

--       polyfill(PolyfilledComponent)

--       local container = document.createElement('div')
--       ReactDOM.render(
--         <React.StrictMode>
--           <PolyfilledComponent />
--         </React.StrictMode>,
--         container,
--       )
--     })
--   }) ]]
eC.Children._44988b54e8ad947299d211b746fa6037=eJ
local eK

local eL={ClassName="ModuleScript",Children={},Properties={}}
eL.Name="ReactErrorBoundaries-internal.spec"
eL.Properties.Source=[[ -- Upstream = https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-dom/src/__tests__/ReactErrorBoundaries-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  */
--!strict
local Packages = script.Parent.Parent.Parent

-- local PropTypes
local React
-- local ReactDOM
local ReactNoop
-- local act
local Scheduler
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

-- ROBLOX Test Noise: in upstream, jest setup config makes these tests hide
-- the error boundary warnings they trigger (scripts/jest/setupTests.js:72)
-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
local function textContent(node)
	local res
	local queue = Array.slice(node.getChildren())
	while #queue > 0 do
		local currentNode: any? = table.remove(queue)
		if currentNode and currentNode.text then
			res = currentNode.text .. (res or "")
		end
		if currentNode and currentNode.children then
			for _, value in currentNode.children do
				table.insert(queue, value)
			end
		end
	end
	return res or ""
end

describe("ReactErrorBoundaries", function()
	local BrokenConstructor
	local BrokenComponentWillMount
	local BrokenComponentDidMount
	local BrokenComponentWillReceiveProps
	local BrokenComponentWillUpdate
	local BrokenComponentDidUpdate
	local BrokenComponentWillUnmount
	local BrokenRenderErrorBoundary
	local BrokenComponentWillMountErrorBoundary
	local BrokenComponentDidMountErrorBoundary
	local BrokenRender
	local BrokenUseEffect
	local BrokenUseLayoutEffect
	local ErrorBoundary
	local ErrorMessage
	local NoopErrorBoundary
	local RetryErrorBoundary
	local Normal

	beforeEach(function()
		jest.resetModules()
		jest.useFakeTimers()

		-- PropTypes = require('prop-types')
		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		-- ReactDOM = require('react-dom')
		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
		-- act = require('react-dom/test-utils').unstable_concurrentAct

		BrokenConstructor = React.Component:extend("BrokenConstructor")

		function BrokenConstructor:init()
			Scheduler.unstable_yieldValue("BrokenConstructor constructor [!]")
			error("Hello", 0)
		end
		function BrokenConstructor:render()
			Scheduler.unstable_yieldValue("BrokenConstructor render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenConstructor:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenConstructor componentWillMount")
		end
		function BrokenConstructor:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenConstructor componentDidMount")
		end
		function BrokenConstructor:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue("BrokenConstructor componentWillReceiveProps")
		end
		function BrokenConstructor:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue("BrokenConstructor componentWillUpdate")
		end
		function BrokenConstructor:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenConstructor componentDidUpdate")
		end

		function BrokenConstructor:componentWillUnmount()
			Scheduler.unstable_yieldValue("BrokenConstructor componentWillUnmount")
		end

		BrokenComponentWillMount = React.Component:extend("BrokenComponentWillMount")

		function BrokenComponentWillMount:init()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount constructor")
		end

		function BrokenComponentWillMount:render()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount render")
			return React.createElement("div", nil, self.props.children)
		end

		function BrokenComponentWillMount:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMount componentWillMount [!]"
			)
			error("Hello", 0)
		end

		function BrokenComponentWillMount:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount componentDidMount")
		end
		function BrokenComponentWillMount:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMount componentWillReceiveProps"
			)
		end

		function BrokenComponentWillMount:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount componentWillUpdate")
		end

		function BrokenComponentWillMount:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount componentDidUpdate")
		end

		function BrokenComponentWillMount:componentWillUnmount()
			Scheduler.unstable_yieldValue("BrokenComponentWillMount componentWillUnmount")
		end

		BrokenComponentDidMount = React.Component:extend("BrokenComponentDidMount")

		function BrokenComponentDidMount:init()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount constructor")
		end
		function BrokenComponentDidMount:render()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentDidMount:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount componentWillMount")
		end
		function BrokenComponentDidMount:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount componentDidMount [!]")
			error("Hello", 0)
		end
		function BrokenComponentDidMount:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMount componentWillReceiveProps"
			)
		end
		function BrokenComponentDidMount:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount componentWillUpdate")
		end
		function BrokenComponentDidMount:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount componentDidUpdate")
		end
		function BrokenComponentDidMount:componentWillUnmount()
			Scheduler.unstable_yieldValue("BrokenComponentDidMount componentWillUnmount")
		end

		BrokenComponentWillReceiveProps =
			React.Component:extend("BrokenComponentWillReceiveProps")

		function BrokenComponentWillReceiveProps:init()
			Scheduler.unstable_yieldValue("BrokenComponentWillReceiveProps constructor")
		end
		function BrokenComponentWillReceiveProps:render()
			Scheduler.unstable_yieldValue("BrokenComponentWillReceiveProps render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentWillReceiveProps:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentWillMount"
			)
		end
		function BrokenComponentWillReceiveProps:componentDidMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentDidMount"
			)
		end
		function BrokenComponentWillReceiveProps:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentWillReceiveProps [!]"
			)
			error("Hello", 0)
		end
		function BrokenComponentWillReceiveProps:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentWillUpdate"
			)
		end
		function BrokenComponentWillReceiveProps:componentDidUpdate()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentDidUpdate"
			)
		end
		function BrokenComponentWillReceiveProps:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillReceiveProps componentWillUnmount"
			)
		end

		BrokenComponentWillUpdate = React.Component:extend("BrokenComponentWillUpdate")

		function BrokenComponentWillUpdate:init()
			Scheduler.unstable_yieldValue("BrokenComponentWillUpdate constructor")
		end
		function BrokenComponentWillUpdate:render()
			Scheduler.unstable_yieldValue("BrokenComponentWillUpdate render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentWillUpdate:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenComponentWillUpdate componentWillMount")
		end
		function BrokenComponentWillUpdate:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenComponentWillUpdate componentDidMount")
		end
		function BrokenComponentWillUpdate:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUpdate componentWillReceiveProps"
			)
		end
		function BrokenComponentWillUpdate:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUpdate componentWillUpdate [!]"
			)
			error("Hello", 0)
		end
		function BrokenComponentWillUpdate:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentWillUpdate componentDidUpdate")
		end
		function BrokenComponentWillUpdate:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUpdate componentWillUnmount"
			)
		end

		BrokenComponentDidUpdate = React.Component:extend("BrokenComponentDidUpdate")

		function BrokenComponentDidUpdate:init()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate constructor")
		end
		function BrokenComponentDidUpdate:render()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentDidUpdate:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate componentWillMount")
		end
		function BrokenComponentDidUpdate:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate componentDidMount")
		end
		function BrokenComponentDidUpdate:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidUpdate componentWillReceiveProps"
			)
		end
		function BrokenComponentDidUpdate:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate componentWillUpdate")
		end
		function BrokenComponentDidUpdate:componentDidUpdate()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidUpdate componentDidUpdate [!]"
			)

			-- ROBLOX deviation: or 'Hello' in place of setting defaultProps
			error(self.props.errorText or "Hello", 0)
		end
		function BrokenComponentDidUpdate:componentWillUnmount()
			Scheduler.unstable_yieldValue("BrokenComponentDidUpdate componentWillUnmount")
		end

		BrokenComponentWillUnmount = React.Component:extend("BrokenComponentWillUnmount")

		function BrokenComponentWillUnmount:init()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount constructor")
		end
		function BrokenComponentWillUnmount:render()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount render")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentWillUnmount:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount componentWillMount")
		end
		function BrokenComponentWillUnmount:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount componentDidMount")
		end
		function BrokenComponentWillUnmount:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUnmount componentWillReceiveProps"
			)
		end
		function BrokenComponentWillUnmount:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUnmount componentWillUpdate"
			)
		end
		function BrokenComponentWillUnmount:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount componentDidUpdate")
		end
		function BrokenComponentWillUnmount:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUnmount componentWillUnmount [!]"
			)
			-- ROBLOX deviation: or 'Hello' in place of setting defaultProps
			error(self.props.errorText or "Hello", 0)
		end

		BrokenComponentWillMountErrorBoundary =
			React.Component:extend("BrokenComponentWillMountErrorBoundary")

		function BrokenComponentWillMountErrorBoundary:init()
			self.state = { error = nil }
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary constructor"
			)
		end
		function BrokenComponentWillMountErrorBoundary:render()
			if self.state.error then
				Scheduler.unstable_yieldValue(
					"BrokenComponentWillMountErrorBoundary render error"
				)
				return React.createElement(
					"div",
					nil,
					"Caught an error: " .. tostring(self.state.error.message)
				)
			end
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary render success"
			)
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentWillMountErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary componentWillMount [!]"
			)
			error("Hello", 0)
		end
		function BrokenComponentWillMountErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary componentDidMount"
			)
		end
		function BrokenComponentWillMountErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary componentWillUnmount"
			)
		end
		function BrokenComponentWillMountErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillMountErrorBoundary static getDerivedStateFromError"
			)
			return { error = error_ }
		end

		BrokenComponentDidMountErrorBoundary =
			React.Component:extend("BrokenComponentDidMountErrorBoundary")

		function BrokenComponentDidMountErrorBoundary:init()
			self.state = { error = nil }
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary constructor"
			)
		end
		function BrokenComponentDidMountErrorBoundary:render()
			if self.state.error then
				Scheduler.unstable_yieldValue(
					"BrokenComponentDidMountErrorBoundary render error"
				)
				return React.createElement(
					"div",
					nil,
					"Caught an error: " .. tostring(self.state.error.message)
				)
			end
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary render success"
			)
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenComponentDidMountErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary componentWillMount"
			)
		end
		function BrokenComponentDidMountErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary componentDidMount [!]"
			)
			error("Hello", 0)
		end
		function BrokenComponentDidMountErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary componentWillUnmount"
			)
		end
		function BrokenComponentDidMountErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue(
				"BrokenComponentDidMountErrorBoundary static getDerivedStateFromError"
			)
			return { error = error_ }
		end

		BrokenRenderErrorBoundary = React.Component:extend("BrokenRenderErrorBoundary")

		function BrokenRenderErrorBoundary:init()
			self.state = { error = nil }
			Scheduler.unstable_yieldValue("BrokenRenderErrorBoundary constructor")
		end
		function BrokenRenderErrorBoundary:render()
			if self.state.error then
				Scheduler.unstable_yieldValue(
					"BrokenRenderErrorBoundary render error [!]"
				)
				error("Hello", 0)
			end
			Scheduler.unstable_yieldValue("BrokenRenderErrorBoundary render success")
			return React.createElement("div", nil, self.props.children)
		end
		function BrokenRenderErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenRenderErrorBoundary componentWillMount")
		end
		function BrokenRenderErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenRenderErrorBoundary componentDidMount")
		end
		function BrokenRenderErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenRenderErrorBoundary componentWillUnmount"
			)
		end
		function BrokenRenderErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue(
				"BrokenRenderErrorBoundary static getDerivedStateFromError"
			)
			return { error = error_ }
		end

		BrokenRender = React.Component:extend("BrokenRender")

		function BrokenRender:init()
			Scheduler.unstable_yieldValue("BrokenRender constructor")
		end
		function BrokenRender:render()
			Scheduler.unstable_yieldValue("BrokenRender render [!]")
			error("Hello", 0)
		end
		function BrokenRender:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("BrokenRender componentWillMount")
		end
		function BrokenRender:componentDidMount()
			Scheduler.unstable_yieldValue("BrokenRender componentDidMount")
		end
		function BrokenRender:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue("BrokenRender componentWillReceiveProps")
		end
		function BrokenRender:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue("BrokenRender componentWillUpdate")
		end
		function BrokenRender:componentDidUpdate()
			Scheduler.unstable_yieldValue("BrokenRender componentDidUpdate")
		end
		function BrokenRender:componentWillUnmount()
			Scheduler.unstable_yieldValue("BrokenRender componentWillUnmount")
		end

		BrokenUseEffect = function(props)
			local children = props.children

			Scheduler.unstable_yieldValue("BrokenUseEffect render")
			React.useEffect(function()
				Scheduler.unstable_yieldValue("BrokenUseEffect useEffect [!]")
				error("Hello", 0)
			end)

			return children
		end
		BrokenUseLayoutEffect = function(props)
			local children = props.children

			Scheduler.unstable_yieldValue("BrokenUseLayoutEffect render")
			React.useLayoutEffect(function()
				Scheduler.unstable_yieldValue("BrokenUseLayoutEffect useLayoutEffect [!]")
				error("Hello", 0)
			end)

			return children
		end

		NoopErrorBoundary = React.Component:extend("NoopErrorBoundary")

		function NoopErrorBoundary:init()
			Scheduler.unstable_yieldValue("NoopErrorBoundary constructor")
		end
		function NoopErrorBoundary:render()
			Scheduler.unstable_yieldValue("NoopErrorBoundary render")
			return React.createElement(BrokenRender)
		end
		function NoopErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("NoopErrorBoundary componentWillMount")
		end
		function NoopErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue("NoopErrorBoundary componentDidMount")
		end
		function NoopErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue("NoopErrorBoundary componentWillUnmount")
		end
		function NoopErrorBoundary.getDerivedStateFromError()
			Scheduler.unstable_yieldValue(
				"NoopErrorBoundary static getDerivedStateFromError"
			)
			return nil
		end

		Normal = React.Component:extend("Normal")

		Normal.defaultProps = {
			logName = "Normal",
		}
		function Normal:init()
			Scheduler.unstable_yieldValue(self.props.logName .. " constructor")
		end
		function Normal:render()
			Scheduler.unstable_yieldValue(self.props.logName .. " render")
			return React.createElement("div", nil, self.props.children)
		end
		function Normal:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillMount")
		end
		function Normal:componentDidMount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentDidMount")
		end
		function Normal:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				self.props.logName .. " componentWillReceiveProps"
			)
		end
		function Normal:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillUpdate")
		end
		function Normal:componentDidUpdate()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentDidUpdate")
		end
		function Normal:componentWillUnmount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillUnmount")
		end

		ErrorBoundary = React.Component:extend("ErrorBoundary")

		function ErrorBoundary:init()
			self.state = {
				error = nil,
			}
			Scheduler.unstable_yieldValue(self.props.logName .. " constructor")
		end
		function ErrorBoundary:render()
			if self.state.error and not self.props.forceRetry then
				Scheduler.unstable_yieldValue(self.props.logName .. " render error")
				return self.props.renderError(self.state.error, self.props)
			end
			Scheduler.unstable_yieldValue(self.props.logName .. " render success")
			return React.createElement("div", nil, self.props.children)
		end
		function ErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue("ErrorBoundary static getDerivedStateFromError")
			return { error = error_ }
		end
		function ErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillMount")
		end
		function ErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentDidMount")
		end
		function ErrorBoundary:UNSAFE_componentWillReceiveProps()
			Scheduler.unstable_yieldValue(
				self.props.logName .. " componentWillReceiveProps"
			)
		end
		function ErrorBoundary:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillUpdate")
		end
		function ErrorBoundary:componentDidUpdate()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentDidUpdate")
		end
		function ErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue(self.props.logName .. " componentWillUnmount")
		end
		ErrorBoundary.defaultProps = {
			logName = "ErrorBoundary",
			renderError = function(error_, props)
				local errorMessage = error_
				-- ROBLOX deviation: additional logic to deal with pre-polyfill error object
				if typeof(error_) == "table" then
					errorMessage = error_.message
				end
				return React.createElement("div", {
					ref = props.errorMessageRef,
				}, "Caught an error: ", errorMessage, ".")
			end,
		}

		RetryErrorBoundary = React.Component:extend("RetryErrorBoundary")

		function RetryErrorBoundary:init()
			Scheduler.unstable_yieldValue("RetryErrorBoundary constructor")
		end
		function RetryErrorBoundary:render()
			Scheduler.unstable_yieldValue("RetryErrorBoundary render")
			return React.createElement(BrokenRender)
		end
		function RetryErrorBoundary:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("RetryErrorBoundary componentWillMount")
		end
		function RetryErrorBoundary:componentDidMount()
			Scheduler.unstable_yieldValue("RetryErrorBoundary componentDidMount")
		end
		function RetryErrorBoundary:componentWillUnmount()
			Scheduler.unstable_yieldValue("RetryErrorBoundary componentWillUnmount")
		end
		function RetryErrorBoundary.getDerivedStateFromError(error)
			Scheduler.unstable_yieldValue(
				"RetryErrorBoundary static getDerivedStateFromError [!]"
			)
			-- In Fiber, calling setState() (and failing) is treated as a rethrow.
			return {}
		end

		ErrorMessage = React.Component:extend("ErrorMessage")

		function ErrorMessage:init()
			Scheduler.unstable_yieldValue("ErrorMessage constructor")
		end
		function ErrorMessage:UNSAFE_componentWillMount()
			Scheduler.unstable_yieldValue("ErrorMessage componentWillMount")
		end
		function ErrorMessage:componentDidMount()
			Scheduler.unstable_yieldValue("ErrorMessage componentDidMount")
		end
		function ErrorMessage:componentWillUnmount()
			Scheduler.unstable_yieldValue("ErrorMessage componentWillUnmount")
		end
		function ErrorMessage:render()
			Scheduler.unstable_yieldValue("ErrorMessage render")
			return React.createElement(
				"div",
				nil,
				"Caught an error: " .. tostring(self.props.message)
			)
		end
	end)
	it("does not swallow exceptions on mounting without boundaries", function()
		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(BrokenRender))
			end)
		end).toThrow("Hello")

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(BrokenComponentWillMount))
			end)
		end).toThrow("Hello")

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(BrokenComponentDidMount))
			end)
		end).toThrow("Hello")
	end)
	it("does not swallow exceptions on updating without boundaries", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(BrokenComponentWillUpdate))
		jestExpect(function()
			root.render(React.createElement(BrokenComponentWillUpdate))
		end).toThrow("Hello")

		root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(BrokenComponentWillReceiveProps))
		jestExpect(function()
			root.render(React.createElement(BrokenComponentWillReceiveProps))
		end).toThrow("Hello")

		root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(BrokenComponentDidUpdate))
		jestExpect(function()
			root.render(React.createElement(BrokenComponentDidUpdate))
		end).toThrow("Hello")
	end)
	it("does not swallow exceptions on unmounting without boundaries", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(BrokenComponentWillUnmount))
		jestExpect(function()
			-- ROBLOX deviation: render nil to unmount
			root.render(nil)
		end).toThrow("Hello")
	end)
	it("prevents errors from leaking into other roots", function()
		local root1 = ReactNoop.createLegacyRoot()
		local root2 = ReactNoop.createLegacyRoot()
		local root3 = ReactNoop.createLegacyRoot()

		root1.render(React.createElement("span", nil, "Before 1"))
		jestExpect(function()
			root2.render(React.createElement(BrokenRender))
		end).toThrow("Hello")
		root3.render(
			React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
		)
		jestExpect(root1.getChildren()[1].text).toEqual("Before 1")
		jestExpect(root2.getChildren()[1]).toEqual(nil)

		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root3)).toEqual("Caught an error: Hello.")

		root1.render(React.createElement("span", nil, "After 1"), root1)
		root2.render(React.createElement("span", nil, "After 2"), root2)
		root3.render(
			React.createElement(ErrorBoundary, { forceRetry = true }, "After 3"),
			root3
		)
		jestExpect(root1.getChildren()[1].text).toEqual("After 1")
		jestExpect(root2.getChildren()[1].text).toEqual("After 2")
		jestExpect(root3.getChildren()[1].text).toEqual("After 3")
		root1.render(nil)
		root2.render(nil)
		root3.render(nil)
		jestExpect(root1.getChildren()[1]).toEqual(nil)
		jestExpect(root2.getChildren()[1]).toEqual(nil)
		jestExpect(root3.getChildren()[1]).toEqual(nil)
	end)
	it("logs a single error when using error boundary", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		jestExpect(function()
			return root.render(
				React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
			)
		end).toErrorDev(
			"The above error occurred in the <BrokenRender> component:",
			{ logAllErrors = true }
		)

		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Catch and render an error message
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("renders an error state if child throws in render", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Catch and render an error message
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("renders an error state if child throws in constructor", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenConstructor)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenConstructor constructor [!]",
			-- Catch and render an error message
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("renders an error state if child throws in componentWillMount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentWillMount)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenComponentWillMount constructor",
			"BrokenComponentWillMount componentWillMount [!]",
			-- Catch and render an error message
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it(
		"renders an error state if context provider throws in componentWillMount",
		function()
			-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
			local root = ReactNoop.createLegacyRoot()

			local BrokenComponentWillMountWithContext =
				React.Component:extend("BrokenComponentWillMountWithContext")

			function BrokenComponentWillMountWithContext:getChildContext()
				return { foo = 42 }
			end
			function BrokenComponentWillMountWithContext:render()
				return React.createElement("div", nil, self.props.children)
			end
			function BrokenComponentWillMountWithContext:UNSAFE_componentWillMount()
				error("Hello", 0)
			end

			BrokenComponentWillMountWithContext.childContextTypes = {
				-- ROBLOX Deviation: using 0 as a workaround for Proptypes.number
				foo = 0,
			}

			root.render(
				React.createElement(
					ErrorBoundary,
					nil,
					React.createElement(BrokenComponentWillMountWithContext)
				)
			)
			jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		end
	)
	if not ReactFeatureFlags.disableModulePatternComponents then
		it(
			"renders an error state if module-style context provider throws in componentWillMount",
			function()
				-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
				local root = ReactNoop.createLegacyRoot()

				local function BrokenComponentWillMountWithContext()
					return {
						getChildContext = function()
							return { foo = 42 }
						end,
						render = function(self)
							return React.createElement("div", nil, self.props.children)
						end,
						UNSAFE_componentWillMount = function()
							error("Hello")
						end,
					}
				end

				-- ROBLOX deviation: no propTypes, test seems to work OK without it
				-- BrokenComponentWillMountWithContext.childContextTypes = {
				--     foo = 0,
				-- }

				jestExpect(function()
					return root.render(
						React.createElement(
							ErrorBoundary,
							nil,
							React.createElement(BrokenComponentWillMountWithContext)
						)
					)
				end).toErrorDev(
					"Warning: The <BrokenComponentWillMountWithContext /> component appears to be a function component that "
						.. "returns a class instance. "
						.. "Change BrokenComponentWillMountWithContext to a class that extends React.Component instead. "
					-- ROBLOX deviation: Remove JS specifics
					-- .. "If you can't use a class try assigning the prototype on the function as a workaround. "
					-- 	.. "`BrokenComponentWillMountWithContext.prototype = React.Component.prototype`. "
					-- 	.. "Don't use an arrow function since it cannot be called with `new` by React."
				)
				-- ROBLOX FIXME: fails here, but error message above is correct. root appears to have empty children tables
				-- jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
			end
		)
	end
	it("mounts the error message if mounting fails", function()
		local function renderError(error_)
			local errorMessage = error_
			-- ROBLOX deviation: additional logic to deal with pre-polyfill error object
			if typeof(error_) == "table" then
				errorMessage = error_.message
			end
			return React.createElement(ErrorMessage, {
				message = errorMessage,
			})
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				{ renderError = renderError },
				React.createElement(BrokenRender)
			)
		)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Catch and render an error message
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorMessage constructor",
			"ErrorMessage componentWillMount",
			"ErrorMessage render",
			"ErrorMessage componentDidMount",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
			"ErrorMessage componentWillUnmount",
		})
	end)
	it("propagates errors on retry on mounting", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					RetryErrorBoundary,
					nil,
					React.createElement(BrokenRender)
				)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"RetryErrorBoundary constructor",
			"RetryErrorBoundary componentWillMount",
			"RetryErrorBoundary render",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Retry
			"RetryErrorBoundary static getDerivedStateFromError [!]",
			"RetryErrorBoundary componentWillMount",
			"RetryErrorBoundary render",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- This time, the error propagates to the higher boundary
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("propagates errors inside boundary during componentWillMount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentWillMountErrorBoundary)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenComponentWillMountErrorBoundary constructor",
			"BrokenComponentWillMountErrorBoundary componentWillMount [!]",
			-- The error propagates to the higher boundary
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("propagates errors inside boundary while rendering error state", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					BrokenRenderErrorBoundary,
					nil,
					React.createElement(BrokenRender)
				)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRenderErrorBoundary constructor",
			"BrokenRenderErrorBoundary componentWillMount",
			"BrokenRenderErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Attempt to handle the error
			"BrokenRenderErrorBoundary static getDerivedStateFromError",
			"BrokenRenderErrorBoundary componentWillMount",
			"BrokenRenderErrorBoundary render error [!]",
			-- Attempt to handle the error again
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("does not call componentWillUnmount when aborting initial mount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenRender),
				React.createElement(Normal)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			-- Render first child
			"Normal constructor",
			"Normal componentWillMount",
			"Normal render",
			-- Render second child (it throws)
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Render third child, even though an earlier sibling threw.
			"Normal constructor",
			"Normal componentWillMount",
			"Normal render",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("resets callback refs if mounting aborts", function()
		local function childRef(x)
			-- throw new Error(typeof(x))
			-- ROBLOX deviation: use explicit '[object HTMLDivElement]' string because Lua uses tables
			local XAsString = x and "[object HTMLDivElement]" or "nil"
			Scheduler.unstable_yieldValue("Child ref is set to " .. XAsString)
		end
		local function errorMessageRef(x)
			-- ROBLOX deviation: use explicit '[object HTMLDivElement]' string because Lua uses tables
			local XAsString = x and "[object HTMLDivElement]" or "nil"
			Scheduler.unstable_yieldValue("Error message ref is set to " .. XAsString)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				{ errorMessageRef = errorMessageRef },
				React.createElement("div", { ref = childRef }),
				React.createElement(BrokenRender)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"Error message ref is set to [object HTMLDivElement]",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
			"Error message ref is set to nil",
		})
	end)
	it("resets object refs if mounting aborts", function()
		local childRef = React.createRef()
		local errorMessageRef = React.createRef()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				{ errorMessageRef = errorMessageRef },
				React.createElement("div", { ref = childRef }),
				React.createElement(BrokenRender)
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: workaround for object '[object HTMLDivElement]'
		jestExpect(string.find(tostring(errorMessageRef.current), "table: ") ~= nil).toEqual(
			true
		)
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
		jestExpect(errorMessageRef.current).toEqual(nil)
	end)
	it("successfully mounts if no error occurs", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement("div", nil, { "Mounted successfully." })
			)
		)
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Mounted successfully.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"ErrorBoundary componentDidMount",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches if child throws in constructor during update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(ErrorBoundary, nil, React.createElement(Normal)))
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(Normal, {
					logName = "Normal2",
				}),
				React.createElement(BrokenConstructor)
			)
		)

		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			-- Normal2 will attempt to mount:
			"Normal2 constructor",
			"Normal2 componentWillMount",
			"Normal2 render",
			-- BrokenConstructor will abort rendering:
			"BrokenConstructor constructor [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			-- Render the error message
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches if child throws in componentWillMount during update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(ErrorBoundary, nil, React.createElement(Normal)))
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(Normal, {
					logName = "Normal2",
				}),
				React.createElement(BrokenComponentWillMount)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			-- Normal2 will attempt to mount:
			"Normal2 constructor",
			"Normal2 componentWillMount",
			"Normal2 render",
			-- BrokenComponentWillMount will abort rendering:
			"BrokenComponentWillMount constructor",
			"BrokenComponentWillMount componentWillMount [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			-- Render the error message
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches if child throws in componentWillReceiveProps during update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenComponentWillReceiveProps)
			)
		)
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenComponentWillReceiveProps)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			-- BrokenComponentWillReceiveProps will abort rendering:
			"BrokenComponentWillReceiveProps componentWillReceiveProps [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			-- Render the error message
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"BrokenComponentWillReceiveProps componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches if child throws in componentWillUpdate during update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenComponentWillUpdate)
			)
		)
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenComponentWillUpdate)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			-- BrokenComponentWillUpdate will abort rendering:
			"BrokenComponentWillUpdate componentWillReceiveProps",
			"BrokenComponentWillUpdate componentWillUpdate [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"BrokenComponentWillUpdate componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches if child throws in render during update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(ErrorBoundary, nil, React.createElement(Normal)))
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(Normal, {
					logName = "Normal2",
				}),
				React.createElement(BrokenRender)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			-- Normal2 will attempt to mount:
			"Normal2 constructor",
			"Normal2 componentWillMount",
			"Normal2 render",
			-- BrokenRender will abort rendering:
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		-- ROBLOX deviation: render nil to unmount
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("keeps refs up-to-date during updates", function()
		local function child1Ref(x)
			-- ROBLOX deviation: use explicit '[object HTMLDivElement]' string because Lua uses tables
			local XAsString = x and "[object HTMLDivElement]" or "nil"
			Scheduler.unstable_yieldValue("Child1 ref is set to " .. XAsString)
		end
		local function child2Ref(x)
			-- ROBLOX deviation: use explicit '[object HTMLDivElement]' string because Lua uses tables
			local XAsString = x and "[object HTMLDivElement]" or "nil"
			Scheduler.unstable_yieldValue("Child2 ref is set to " .. XAsString)
		end
		local function errorMessageRef(x)
			-- ROBLOX deviation: use explicit '[object HTMLDivElement]' string because Lua uses tables
			local XAsString = x and "[object HTMLDivElement]" or "nil"
			Scheduler.unstable_yieldValue("Error message ref is set to " .. XAsString)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				{ errorMessageRef = errorMessageRef },
				React.createElement("div", { ref = child1Ref })
			)
		)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"Child1 ref is set to [object HTMLDivElement]",
			"ErrorBoundary componentDidMount",
		})
		root.render(
			React.createElement(
				ErrorBoundary,
				{ errorMessageRef = errorMessageRef },
				React.createElement("div", { ref = child1Ref }),
				React.createElement("div", { ref = child2Ref }),
				React.createElement(BrokenRender)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			-- BrokenRender will abort rendering:
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			-- Update Child1 ref since Child1 has been unmounted
			-- Child2 ref is never set because its mounting aborted
			"Child1 ref is set to nil",
			"Error message ref is set to [object HTMLDivElement]",
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
			"Error message ref is set to nil",
		})
	end)
	it("recovers from componentWillUnmount errors on update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentWillUnmount),
				React.createElement(BrokenComponentWillUnmount),
				React.createElement(Normal)
			)
		)
		Scheduler.unstable_clearYields()
		-- ROBLOX DEVIATION: Pass a key to the "BrokenWillUnmount" element. This allows for
		-- compatibility when we go from rendering multiple children to rendering a single
		-- child, as we apply keys to children in an array by default, but not to a single
		-- element
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentWillUnmount, { key = 1 })
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			-- Update existing child:
			"BrokenComponentWillUnmount componentWillReceiveProps",
			"BrokenComponentWillUnmount componentWillUpdate",
			"BrokenComponentWillUnmount render",
			-- Unmounting throws:
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			-- Fiber proceeds with lifecycles despite errors
			"Normal componentWillUnmount",
			-- The components have updated in this phase
			"BrokenComponentWillUnmount componentDidUpdate",
			"ErrorBoundary componentDidUpdate",
			-- The initial render was aborted, so
			-- Fiber retries from the root.
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			"ErrorBoundary componentDidUpdate",
			-- The second willUnmount error should be captured and logged, too.
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			-- Render an error now (stack will do it later)
			"ErrorBoundary render error",
			-- Attempt to unmount previous child:
			-- Done
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("recovers from nested componentWillUnmount errors on update", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					Normal,
					nil,
					React.createElement(BrokenComponentWillUnmount)
				),
				React.createElement(BrokenComponentWillUnmount)
			)
		)
		Scheduler.unstable_clearYields()
		-- ROBLOX DEVIATION: Pass a key to the "Normal" element. This allows for compatibility
		-- when we go from rendering multiple children to rendering a single child, as we
		-- apply keys to children in an array by default, but not to a single element
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					Normal,
					{ key = 1 },
					React.createElement(BrokenComponentWillUnmount)
				)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			-- Update existing children:
			"Normal componentWillReceiveProps",
			"Normal componentWillUpdate",
			"Normal render",
			"BrokenComponentWillUnmount componentWillReceiveProps",
			"BrokenComponentWillUnmount componentWillUpdate",
			"BrokenComponentWillUnmount render",
			-- Unmounting throws:
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			-- Fiber proceeds with lifecycles despite errors
			"BrokenComponentWillUnmount componentDidUpdate",
			"Normal componentDidUpdate",
			"ErrorBoundary componentDidUpdate",
			-- Now that commit phase is done, Fiber handles errors
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"Normal componentWillUnmount",
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			"ErrorBoundary componentDidUpdate",
			-- The second willUnmount error should be captured and logged, too.
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			-- Render an error now (stack will do it later)
			"ErrorBoundary render error",
			-- Done
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("picks the right boundary when handling unmounting errors", function()
		local function renderInnerError(error_)
			return React.createElement(
				"div",
				nil,
				"Caught an inner error: ",
				error_.message,
				"."
			)
		end
		local function renderOuterError(error_)
			return React.createElement(
				"div",
				nil,
				"Caught an outer error: ",
				error_.message,
				"."
			)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(React.createElement(
			ErrorBoundary,
			{
				logName = "OuterErrorBoundary",
				renderError = renderOuterError,
			},
			React.createElement(ErrorBoundary, {
				logName = "InnerErrorBoundary",
				renderError = renderInnerError,
			}, React.createElement(BrokenComponentWillUnmount))
		))
		Scheduler.unstable_clearYields()
		root.render(React.createElement(
			ErrorBoundary,
			{
				logName = "OuterErrorBoundary",
				renderError = renderOuterError,
			},
			React.createElement(ErrorBoundary, {
				logName = "InnerErrorBoundary",
				renderError = renderInnerError,
			})
		))
		jestExpect(textContent(root)).toEqual("Caught an inner error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			-- Update outer boundary
			"OuterErrorBoundary componentWillReceiveProps",
			"OuterErrorBoundary componentWillUpdate",
			"OuterErrorBoundary render success",
			-- Update inner boundary
			"InnerErrorBoundary componentWillReceiveProps",
			"InnerErrorBoundary componentWillUpdate",
			"InnerErrorBoundary render success",
			-- Try unmounting child
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			-- Now that commit phase is done, Fiber handles errors
			-- Only inner boundary receives the error:
			"InnerErrorBoundary componentDidUpdate",
			"OuterErrorBoundary componentDidUpdate",
			"ErrorBoundary static getDerivedStateFromError",
			"InnerErrorBoundary componentWillUpdate",
			-- Render an error now
			"InnerErrorBoundary render error",
			-- In Fiber, this was a local update to the
			-- inner boundary so only its hook fires
			"InnerErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"OuterErrorBoundary componentWillUnmount",
			"InnerErrorBoundary componentWillUnmount",
		})
	end)
	it("can recover from error state", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
		)
		root.render(React.createElement(ErrorBoundary, nil, React.createElement(Normal)))
		-- Error boundary doesn't retry by itself
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		-- Force the success path:
		Scheduler.unstable_clearYields()

		root.render(
			React.createElement(
				ErrorBoundary,
				{ forceRetry = true },
				React.createElement(Normal)
			)
		)

		jestExpect(textContent(root)).never.toContain("Caught an error")

		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			-- Mount children:
			"Normal constructor",
			"Normal componentWillMount",
			"Normal render",
			-- Finalize updates:
			"Normal componentDidMount",
			"ErrorBoundary componentDidUpdate",
		})

		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
			"Normal componentWillUnmount",
		})
	end)
	it("can update multiple times in error state", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		root.render(
			React.createElement(ErrorBoundary, nil, React.createElement(BrokenRender))
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")

		-- ROBLOX deviation: render nil to clear children for textContent
		root.render(nil)
		root.render(React.createElement("div", nil, "Other screen"))
		jestExpect(textContent(root)).toEqual("Other screen")
		root.render(nil)
	end)
	it("doesn't get into inconsistent state during removals", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenComponentWillUnmount),
				React.createElement(Normal)
			)
		)
		root.render(React.createElement(ErrorBoundary))
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		Scheduler.unstable_clearYields()
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("doesn't get into inconsistent state during additions", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(React.createElement(ErrorBoundary))
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Normal),
				React.createElement(BrokenRender),
				React.createElement(Normal)
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		Scheduler.unstable_clearYields()
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("doesn't get into inconsistent state during reorders", function()
		local fail_ = false

		local MaybeBrokenRender = React.Component:extend("MaybeBrokenRender")
		function MaybeBrokenRender:render()
			if fail_ then
				error("Hello", 0)
			end

			return React.createElement("div", nil, self.props.children)
		end

		local function getAMixOfNormalAndBrokenRenderElements()
			local elements = {}

			-- ROBLOX deviation START: loop more times to test our object caching logic
			for i = 1, 1000 do
				table.insert(elements, React.createElement(Normal, { key = i }))
			end
			-- ROBLOX deviation END

			table.insert(elements, React.createElement(MaybeBrokenRender, { key = 101 }))

			local currentIndex = #elements

			while 1 ~= currentIndex do
				local randomIndex = math.floor(math.random() * currentIndex) + 1

				currentIndex -= 1

				local temporaryValue = elements[currentIndex]

				elements[currentIndex] = elements[randomIndex]
				elements[randomIndex] = temporaryValue
			end

			return elements
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		-- ROBLOX FIXME LUAU: For some reason, `{React_Element<any, any>}`
		-- is not a valid type for children here
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				getAMixOfNormalAndBrokenRenderElements() :: any
			)
		)
		jestExpect(textContent(root)).never.toContain("Caught an error")

		fail_ = true

		-- ROBLOX FIXME LUAU: For some reason, `{React_Element<any, any>}`
		-- is not a valid type for children here
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				getAMixOfNormalAndBrokenRenderElements() :: any
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		Scheduler.unstable_clearYields()
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches errors originating downstream", function()
		local fail_ = false
		local Stateful = React.Component:extend("Stateful")

		function Stateful:init()
			self.state = {
				shouldThrow = false,
			}
		end
		function Stateful:render()
			if fail_ then
				Scheduler.unstable_yieldValue("Stateful render [!]")
				error("Hello", 0)
			end

			return React.createElement("div", nil, self.props.children)
		end

		local statefulInst
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(Stateful, {
					ref = function(inst)
						statefulInst = inst
					end,
				})
			)
		)
		Scheduler.unstable_clearYields()
		jestExpect(function()
			fail_ = true
			statefulInst:forceUpdate()
		end).never.toThrow()
		jestExpect(Scheduler).toHaveYielded({
			"Stateful render [!]",
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches errors in componentDidMount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					BrokenComponentWillUnmount,
					nil,
					React.createElement(Normal)
				),
				React.createElement(BrokenComponentDidMount),
				React.createElement(Normal, {
					logName = "LastChild",
				})
			)
		)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenComponentWillUnmount constructor",
			"BrokenComponentWillUnmount componentWillMount",
			"BrokenComponentWillUnmount render",
			"Normal constructor",
			"Normal componentWillMount",
			"Normal render",
			"BrokenComponentDidMount constructor",
			"BrokenComponentDidMount componentWillMount",
			"BrokenComponentDidMount render",
			"LastChild constructor",
			"LastChild componentWillMount",
			"LastChild render",
			-- Start flushing didMount queue
			"Normal componentDidMount",
			"BrokenComponentWillUnmount componentDidMount",
			"BrokenComponentDidMount componentDidMount [!]",
			-- Continue despite the error
			"LastChild componentDidMount",
			-- Now we are ready to handle the error
			"ErrorBoundary componentDidMount",
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			-- Safely unmount every child
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			-- Continue unmounting safely despite any errors
			"Normal componentWillUnmount",
			"BrokenComponentDidMount componentWillUnmount",
			"LastChild componentWillUnmount",
			-- The willUnmount error should be captured and logged, too.
			"ErrorBoundary componentDidUpdate",
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			-- The update has finished
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("catches errors in componentDidUpdate", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentDidUpdate)
			)
		)
		Scheduler.unstable_clearYields()
		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentDidUpdate)
			)
		)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillReceiveProps",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render success",
			"BrokenComponentDidUpdate componentWillReceiveProps",
			"BrokenComponentDidUpdate componentWillUpdate",
			"BrokenComponentDidUpdate render",
			-- All lifecycles run
			"BrokenComponentDidUpdate componentDidUpdate [!]",
			"ErrorBoundary componentDidUpdate",
			-- Then, error is handled
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"BrokenComponentDidUpdate componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	-- ROBLOX TODO: Eyeballing result shows expected functionality. ReactNoop.act() doesn't flush in the same way
	-- that ReactDOM's act method does; need to resolve this with either ReactDOM port or closer match of act() in another renderer
	xit("catches errors in useEffect", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		ReactNoop.act(function()
			root.render(
				React.createElement(
					ErrorBoundary,
					nil,
					React.createElement(BrokenUseEffect, nil, "Initial value")
				)
			)
			jestExpect(Scheduler).toHaveYielded({
				"ErrorBoundary constructor",
				"ErrorBoundary componentWillMount",
				"ErrorBoundary render success",
				"BrokenUseEffect render",
				"ErrorBoundary componentDidMount",
			})
			jestExpect(textContent(root)).toEqual("Initial value")
			Scheduler.unstable_clearYields()
		end)

		-- verify flushed passive effects and handle the error
		jestExpect(Scheduler).toHaveYielded({
			"BrokenUseEffect useEffect [!]",
			-- Handle the error
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidUpdate",
		})
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
	end)
	it("catches errors in useLayoutEffect", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenUseLayoutEffect, nil, "Initial value")
			)
		)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenUseLayoutEffect render",
			"BrokenUseLayoutEffect useLayoutEffect [!]",
			-- Fiber proceeds with the hooks
			"ErrorBoundary componentDidMount",
			-- The error propagates to the higher boundary
			"ErrorBoundary static getDerivedStateFromError",
			-- Fiber retries from the root
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"ErrorBoundary componentDidUpdate",
		})
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
	end)
	it("propagates errors inside boundary during componentDidMount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(BrokenComponentDidMountErrorBoundary, {
					renderError = function(error_)
						return React.createElement(
							"div",
							nil,
							"We should never catch our own error: ",
							error_.message,
							"."
						)
					end,
				})
			)
		)
		jestExpect(textContent(root)).toEqual("Caught an error: Hello.")
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary constructor",
			"ErrorBoundary componentWillMount",
			"ErrorBoundary render success",
			"BrokenComponentDidMountErrorBoundary constructor",
			"BrokenComponentDidMountErrorBoundary componentWillMount",
			"BrokenComponentDidMountErrorBoundary render success",
			"BrokenComponentDidMountErrorBoundary componentDidMount [!]",
			-- Fiber proceeds with the hooks
			"ErrorBoundary componentDidMount",
			-- The error propagates to the higher boundary
			"ErrorBoundary static getDerivedStateFromError",
			-- Fiber retries from the root
			"ErrorBoundary componentWillUpdate",
			"ErrorBoundary render error",
			"BrokenComponentDidMountErrorBoundary componentWillUnmount",
			"ErrorBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"ErrorBoundary componentWillUnmount",
		})
	end)
	it("calls static getDerivedStateFromError for each error that is captured", function()
		local function renderUnmountError(error_)
			return React.createElement(
				"div",
				nil,
				"Caught an unmounting error: ",
				error_.message,
				"."
			)
		end
		local function renderUpdateError(error_)
			return React.createElement(
				"div",
				nil,
				"Caught an updating error: ",
				error_.message,
				"."
			)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(
			ErrorBoundary,
			{
				logName = "OuterErrorBoundary",
			},
			React.createElement(
				ErrorBoundary,
				{
					logName = "InnerUnmountBoundary",
					renderError = renderUnmountError,
				},
				React.createElement(BrokenComponentWillUnmount, {
					errorText = "E1",
				}),
				React.createElement(BrokenComponentWillUnmount, {
					errorText = "E2",
				})
			),
			React.createElement(
				ErrorBoundary,
				{
					logName = "InnerUpdateBoundary",
					renderError = renderUpdateError,
				},
				React.createElement(BrokenComponentDidUpdate, {
					errorText = "E3",
				}),
				React.createElement(BrokenComponentDidUpdate, {
					errorText = "E4",
				})
			)
		))
		Scheduler.unstable_clearYields()
		root.render(React.createElement(
			ErrorBoundary,
			{
				logName = "OuterErrorBoundary",
			},
			React.createElement(ErrorBoundary, {
				logName = "InnerUnmountBoundary",
				renderError = renderUnmountError,
			}),
			React.createElement(
				ErrorBoundary,
				{
					logName = "InnerUpdateBoundary",
					renderError = renderUpdateError,
				},
				React.createElement(BrokenComponentDidUpdate, {
					errorText = "E3",
				}),
				React.createElement(BrokenComponentDidUpdate, {
					errorText = "E4",
				})
			)
		))
		jestExpect(textContent(root)).toEqual(
			"Caught an unmounting error: E2.Caught an updating error: E4."
		)
		jestExpect(Scheduler).toHaveYielded({
			-- Begin update phase
			"OuterErrorBoundary componentWillReceiveProps",
			"OuterErrorBoundary componentWillUpdate",
			"OuterErrorBoundary render success",
			"InnerUnmountBoundary componentWillReceiveProps",
			"InnerUnmountBoundary componentWillUpdate",
			"InnerUnmountBoundary render success",
			"InnerUpdateBoundary componentWillReceiveProps",
			"InnerUpdateBoundary componentWillUpdate",
			"InnerUpdateBoundary render success",
			-- First come the updates
			"BrokenComponentDidUpdate componentWillReceiveProps",
			"BrokenComponentDidUpdate componentWillUpdate",
			"BrokenComponentDidUpdate render",
			"BrokenComponentDidUpdate componentWillReceiveProps",
			"BrokenComponentDidUpdate componentWillUpdate",
			"BrokenComponentDidUpdate render",
			-- We're in commit phase now, deleting
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			"BrokenComponentWillUnmount componentWillUnmount [!]",
			-- Continue despite errors, handle them after commit is done
			"InnerUnmountBoundary componentDidUpdate",
			-- We're still in commit phase, now calling update lifecycles
			"BrokenComponentDidUpdate componentDidUpdate [!]",
			-- Again, continue despite errors, we'll handle them later
			"BrokenComponentDidUpdate componentDidUpdate [!]",
			"InnerUpdateBoundary componentDidUpdate",
			"OuterErrorBoundary componentDidUpdate",
			-- After the commit phase, attempt to recover from any errors that
			-- were captured
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary static getDerivedStateFromError",
			"InnerUnmountBoundary componentWillUpdate",
			"InnerUnmountBoundary render error",
			"ErrorBoundary static getDerivedStateFromError",
			"ErrorBoundary static getDerivedStateFromError",
			"InnerUpdateBoundary componentWillUpdate",
			"InnerUpdateBoundary render error",
			"BrokenComponentDidUpdate componentWillUnmount",
			"BrokenComponentDidUpdate componentWillUnmount",
			"InnerUnmountBoundary componentDidUpdate",
			"InnerUpdateBoundary componentDidUpdate",
		})
		root.render(nil)
		jestExpect(Scheduler).toHaveYielded({
			"OuterErrorBoundary componentWillUnmount",
			"InnerUnmountBoundary componentWillUnmount",
			"InnerUpdateBoundary componentWillUnmount",
		})
	end)
	it("discards a bad root if the root component fails", function()
		local X = nil
		local Y = nil
		local err1
		local err2
		local ok, result

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		ok, result = pcall(function()
			jestExpect(function()
				return root.render(React.createElement(X))
			end).toErrorDev(
				"React.createElement: type is invalid -- expected a string "
					.. "(for built-in components) or a class/function "
					.. "(for composite components) but got: nil."
			)
		end)
		if not ok then
			err1 = result
		end

		ok, result = pcall(function()
			jestExpect(function()
				return root.render(React.createElement(Y))
			end).toErrorDev(
				"React.createElement: type is invalid -- expected a string "
					.. "(for built-in components) or a class/function "
					.. "(for composite components) but got: nil."
			)
		end)
		if not ok then
			err2 = result
		end

		jestExpect(err1.message).toMatch("but got: nil")
		jestExpect(err2.message).toMatch("but got: nil")
	end)
	it("renders empty output if error boundary does not handle the error", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		jestExpect(function()
			return root.render(
				React.createElement(
					"div",
					nil,
					"Sibling",
					React.createElement(
						NoopErrorBoundary,
						nil,
						React.createElement(BrokenRender)
					)
				)
			)
		end).toThrow("Hello")
		jestExpect(textContent(root)).toEqual("")
		jestExpect(Scheduler).toHaveYielded({
			"NoopErrorBoundary constructor",
			"NoopErrorBoundary componentWillMount",
			"NoopErrorBoundary render",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
			-- Noop error boundaries retry render (and fail again)
			"NoopErrorBoundary static getDerivedStateFromError",
			"NoopErrorBoundary render",
			"BrokenRender constructor",
			"BrokenRender componentWillMount",
			"BrokenRender render [!]",
		})
	end)
	it("passes first error when two errors happen in commit", function()
		local errors = {}
		local caughtError

		local Child = React.Component:extend("Child")

		function Child:render()
			return React.createElement("div")
		end
		function Child:componentDidMount()
			table.insert(errors, "child sad")
			error("child sad")
		end
		local Parent = React.Component:extend("Parent")

		function Parent:render()
			return React.createElement(Child)
		end
		function Parent:componentDidMount()
			table.insert(errors, "parent sad")
			error("parent sad")
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		-- Here, we test the behavior where there is no error boundary and we
		-- delegate to the host root.
		local ok, e = pcall(root.render, React.createElement(Parent))
		if not ok then
			if e.message ~= "parent sad" and e.message ~= "child sad" then
				error(e)
			end
			caughtError = e
		end

		jestExpect(errors).toEqual({
			"child sad",
			"parent sad",
		})
		-- Error should be the first thrown
		jestExpect(caughtError.message).toBe("child sad")
	end)
	it("propagates uncaught error inside unbatched initial mount", function()
		local function Foo()
			error("foo error", 0)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		jestExpect(function()
			ReactNoop.batchedUpdates(function()
				root.render(React.createElement(Foo))
			end)
		end).toThrow("foo error")
	end)
	it("handles errors that occur in before-mutation commit hook", function()
		local errors = {}
		local caughtError

		local Child = React.Component:extend("Child")

		function Child:getSnapshotBeforeUpdate()
			table.insert(errors, "child sad")
			error("child sad")
		end
		function Child:componentDidUpdate() end
		function Child:render()
			return React.createElement("div")
		end

		local Parent = React.Component:extend("Parent")
		function Parent:getSnapshotBeforeUpdate()
			table.insert(errors, "parent sad")
			error("parent sad")
		end
		function Parent:componentDidUpdate() end
		function Parent:render()
			return React.createElement(Child, self.props)
		end

		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(React.createElement(Parent, { value = 1 }))
		local ok, e = pcall(root.render, React.createElement(Parent, { value = 2 }))
		if not ok then
			if
				not (string.sub(e.message, -#"parent sad") == "parent sad")
				and not (string.sub(e.message, -#"child sad") == "child sad")
			then
				error(e)
			end
			caughtError = e
		end
		jestExpect(errors).toEqual({
			"child sad",
			"parent sad",
		})
		-- Error should be the first thrown
		jestExpect(caughtError.message).toBe("child sad")
	end)
	it(
		"should warn if an error boundary with only componentDidCatch does not update state",
		function()
			local InvalidErrorBoundary = React.Component:extend("InvalidErrorBoundary")

			function InvalidErrorBoundary:componentDidCatch(error, info)
				-- This component does not define getDerivedStateFromError().
				-- It also doesn't call setState().
				-- So it would swallow errors (which is probably unintentional).
			end
			function InvalidErrorBoundary:render()
				return self.props.children
			end

			local function Throws()
				error("expected")
			end

			-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
			local root = ReactNoop.createLegacyRoot()

			-- deviation: ReactNoop runs with a StrictMode root and logs more warnings
			jestExpect(function()
				root.render(
					React.createElement(
						InvalidErrorBoundary,
						nil,
						React.createElement(Throws)
					)
				)
			end).toErrorDev(
				"InvalidErrorBoundary: Error boundaries should implement getDerivedStateFromError(). "
					.. "In that method, return a state update to display an error message or fallback UI."
			)
			jestExpect(textContent(root)).toEqual("")
		end
	)
	it(
		"should call both componentDidCatch and getDerivedStateFromError if both exist on a component",
		function()
			-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
			local root = ReactNoop.createLegacyRoot()

			local componentDidCatchError, getDerivedStateFromErrorError
			local ErrorBoundaryWithBothMethods =
				React.Component:extend("ErrorBoundaryWithBothMethods")
			function ErrorBoundaryWithBothMethods:init()
				self.state = {}
			end
			function ErrorBoundaryWithBothMethods.getDerivedStateFromError(error_)
				getDerivedStateFromErrorError = error_

				return { error = error_ }
			end
			function ErrorBoundaryWithBothMethods:componentDidCatch(error_, info)
				componentDidCatchError = error_
			end
			function ErrorBoundaryWithBothMethods:render()
				return (function()
					if self.state.error then
						return "ErrorBoundary"
					end

					return self.props.children
				end)()
			end

			local thrownError = LuauPolyfill.Error.new("expected")
			local Throws = function()
				error(thrownError, 0)
			end

			root.render(
				React.createElement(
					ErrorBoundaryWithBothMethods,
					nil,
					React.createElement(Throws)
				)
			)
			jestExpect(textContent(root)).toEqual("ErrorBoundary")

			jestExpect(componentDidCatchError).toEqual(thrownError)
			jestExpect(getDerivedStateFromErrorError).toEqual(thrownError)
		end
	)
	-- ROBLOX TODO: ReactDOMComponent not translated
	xit("should catch errors from invariants in completion phase", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement("input", nil, React.createElement("div"))
			)
		)
		jestExpect(textContent(root)).toContain(
			"Caught an error: input is a void element tag"
		)
	end)
	it("should catch errors from errors in the throw phase from boundaries", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		local thrownError = "original error"
		local Throws = function()
			error(thrownError, 0)
		end
		local EvilErrorBoundary = React.Component:extend("EvilErrorBoundary")

		function EvilErrorBoundary:componentDidCatch()
			error("gotta catch em all", 0)
		end

		function EvilErrorBoundary:render()
			return self.props.children
		end

		root.render(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(EvilErrorBoundary, nil, React.createElement(Throws))
			)
		)
		jestExpect(textContent(root)).toContain("Caught an error: gotta catch em all.")
	end)
	-- ROBLOX TODO: when focused this test passes, however it causes 'runAllTimers flushes all scheduled callbacks' and
	-- 'executes callbacks in order of priority' tests to fail in SchedulerNoDOM but only in __DEV__ mode
	local skipIfDev = (function()
		if _G.__DEV__ then
			return it.skip
		end
		return it
	end)()
	skipIfDev("should protect errors from errors in the stack generation", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()
		local evilError = setmetatable({
			message = "gotta catch em all",
		}, {
			__index = function(mytable, key)
				-- ROBLOX TODO: when we convert to LuauPolyfill errors, ensure this stack error is handled correctly
				if key == "stack" then
					error("gotta catch em all")
				else
					return mytable
				end
			end,
		})

		-- ROBLOX deviation: uses Class component instead of functional component so we can set displayName
		local Throws = React.Component:extend("Throws")
		function Throws:render()
			error(evilError)
		end

		Throws = setmetatable(Throws, {
			__index = function(mytable, key)
				if key == "displayName" then
					error("gotta catch em all", 0)
				else
					return Throws
				end
			end,
		})

		local function Wrapper()
			return React.createElement(Throws :: any)
		end

		root.render(React.createElement(ErrorBoundary, nil, React.createElement(Wrapper)))
		-- ROBLOX deviation: using textContent helper in place of upstream .textContent()
		jestExpect(textContent(root)).toContain("Caught an error: gotta catch em all.")
	end)
	-- @gate skipUnmountedBoundaries
	it("catches errors thrown in componentWillUnmount", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		local Component = React.Component:extend("Component")
		function Component:render()
			local id = self.props.id
			Scheduler.unstable_yieldValue("Component render " .. id)
			return id
		end

		local LocalErrorBoundary = React.Component:extend("LocalErrorBoundary")

		function LocalErrorBoundary:init()
			self.state = {}
		end

		function LocalErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue("ErrorBoundary static getDerivedStateFromError")
			return { error = error_ }
		end
		function LocalErrorBoundary:render()
			local children, id, fallbackID =
				self.props.children, self.props.id, self.props.fallbackID
			local error_ = self.state.error

			if error_ then
				Scheduler.unstable_yieldValue(string.format("%s render error", id))

				return React.createElement(Component, { id = fallbackID })
			end

			Scheduler.unstable_yieldValue(string.format("%s render success", id))

			return children or nil
		end

		local LocalBrokenComponentWillUnmount =
			React.Component:extend("LocalBrokenComponentWillUnmount")

		function LocalBrokenComponentWillUnmount:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"BrokenComponentWillUnmount componentWillUnmount"
			)
			error("Expected")
		end
		function LocalBrokenComponentWillUnmount:render()
			Scheduler.unstable_yieldValue("BrokenComponentWillUnmount render")
			return "broken"
		end

		root.render(React.createElement(
			LocalErrorBoundary,
			{
				id = "OuterBoundary",
				fallbackID = "OuterFallback",
			},
			React.createElement(Component, {
				id = "sibling",
			}),
			React.createElement(LocalErrorBoundary, {
				id = "InnerBoundary",
				fallbackID = "InnerFallback",
			}, React.createElement(LocalBrokenComponentWillUnmount))
		))
		jestExpect(root.getChildren()[1].text).toEqual("sibling")
		jestExpect(root.getChildren()[2].text).toEqual("broken")
		jestExpect(Scheduler).toHaveYielded({
			"OuterBoundary render success",
			"Component render sibling",
			"InnerBoundary render success",
			"BrokenComponentWillUnmount render",
		})
		root.render(React.createElement(
			LocalErrorBoundary,
			{
				id = "OuterBoundary",
				fallbackID = "OuterFallback",
			},
			React.createElement(Component, {
				id = "sibling",
			})
		))
		-- React should skip over the unmounting boundary and find the nearest still-mounted boundary.
		jestExpect(textContent(root)).toEqual("OuterFallback")
		jestExpect(textContent(root)).toEqual("OuterFallback")
		jestExpect(Scheduler).toHaveYielded({
			"OuterBoundary render success",
			"Component render sibling",
			"BrokenComponentWillUnmount componentWillUnmount",
			"ErrorBoundary static getDerivedStateFromError",
			"OuterBoundary render error",
			"Component render OuterFallback",
		})
	end)
	-- @gate skipUnmountedBoundaries
	it("catches errors thrown while detaching refs", function()
		-- ROBLOX deviation: using legacy root of Noop renderer instead of ReactDOM
		local root = ReactNoop.createLegacyRoot()

		local Component = React.Component:extend("Component")

		function Component:render()
			local id = self.props.id

			Scheduler.unstable_yieldValue("Component render " .. id)

			return id
		end

		local LocalErrorBoundary = React.Component:extend("LocalErrorBoundary")

		function LocalErrorBoundary:init()
			self.state = {}
		end
		function LocalErrorBoundary.getDerivedStateFromError(error_)
			Scheduler.unstable_yieldValue("ErrorBoundary static getDerivedStateFromError")
			return { error = error_ }
		end
		function LocalErrorBoundary:render()
			local children, id, fallbackID =
				self.props.children, self.props.id, self.props.fallbackID
			local error_ = self.state.error

			if error_ then
				Scheduler.unstable_yieldValue(string.format("%s render error", id))

				return React.createElement(Component, { id = fallbackID })
			end

			Scheduler.unstable_yieldValue(string.format("%s render success", id))

			return children or nil
		end

		local LocalBrokenCallbackRef = React.Component:extend("LocalBrokenCallbackRef")

		function LocalBrokenCallbackRef._ref(ref)
			Scheduler.unstable_yieldValue(
				"LocalBrokenCallbackRef ref " .. tostring(not not ref)
			)
			if ref == nil then
				error("Expected")
			end
		end
		function LocalBrokenCallbackRef:render()
			Scheduler.unstable_yieldValue("LocalBrokenCallbackRef render")

			return React.createElement("div", {
				ref = self._ref,
			}, "ref")
		end

		root.render(React.createElement(
			LocalErrorBoundary,
			{
				id = "OuterBoundary",
				fallbackID = "OuterFallback",
			},
			React.createElement(Component, {
				id = "sibling",
			}),
			React.createElement(LocalErrorBoundary, {
				id = "InnerBoundary",
				fallbackID = "InnerFallback",
			}, React.createElement(LocalBrokenCallbackRef))
		))
		jestExpect(root.getChildren()[1].text).toEqual("sibling")
		jestExpect(root.getChildren()[2].text).toEqual("ref")
		jestExpect(Scheduler).toHaveYielded({
			"OuterBoundary render success",
			"Component render sibling",
			"InnerBoundary render success",
			"LocalBrokenCallbackRef render",
			"LocalBrokenCallbackRef ref true",
		})
		root.render(React.createElement(
			LocalErrorBoundary,
			{
				id = "OuterBoundary",
				fallbackID = "OuterFallback",
			},
			React.createElement(Component, {
				id = "sibling",
			})
		))
		-- React should skip over the unmounting boundary and find the nearest still-mounted boundary.
		local rootChildren = root.getChildren()
		jestExpect(rootChildren[1].text).toEqual("OuterFallback")
		jestExpect(rootChildren[#rootChildren].text).toEqual("OuterFallback")
		jestExpect(Scheduler).toHaveYielded({
			"OuterBoundary render success",
			"Component render sibling",
			"LocalBrokenCallbackRef ref false",
			"ErrorBoundary static getDerivedStateFromError",
			"OuterBoundary render error",
			"Component render OuterFallback",
		})
	end)
end) ]]
eC.Children._7a81c6ac2b742e9ca5bcc2bb7490afc3=eL
local eM

local eN={ClassName="ModuleScript",Children={},Properties={}}
eN.Name="ReactFiberComponentStack.roblox.spec"
eN.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest
local ReactInternalTypes = require(script.Parent.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactFiberComponentStack

describe("ReactFiberComponentStack", function()
	beforeEach(function()
		jest.resetModules()
		ReactFiberComponentStack = require(script.Parent.Parent.ReactFiberComponentStack)
	end)

	it("given a nil fiber then it gives correct error message", function()
		local message =
			ReactFiberComponentStack.getStackByFiberInDevAndProd((nil :: any) :: Fiber)
		jestExpect(message).toContain("attempt to index nil")
	end)

	it("given a fiber that throws Error then it gives correct error message", function()
		local throwingFiber = {}
		setmetatable(throwingFiber, {
			__index = function(t, k)
				if k == "tag" then
					error(Error.new("this was an error object in a spec file"))
				end
				return nil
			end,
		})

		local message = ReactFiberComponentStack.getStackByFiberInDevAndProd(
			(throwingFiber :: any) :: Fiber
		)
		jestExpect(message).toContain("this was an error object in a spec file")
	end)

	it(
		"given a fiber that throws a non-Error table then it gives correct error message",
		function()
			local customErrorTable = {}
			setmetatable(customErrorTable, {
				__tostring = function(t, k)
					return "this was a custom __tostring"
				end,
			})

			local throwingFiber = {}
			setmetatable(throwingFiber, {
				__index = function(t, k)
					if k == "tag" then
						error(customErrorTable)
					end
					return nil
				end,
			})

			local message = ReactFiberComponentStack.getStackByFiberInDevAndProd(
				(throwingFiber :: any) :: Fiber
			)
			jestExpect(message).toContain("this was a custom __tostring")
		end
	)
end) ]]
eC.Children._1bc6b9a60a4bd1e62784cb034d35a1ae=eN
local eO

local eP={ClassName="ModuleScript",Children={},Properties={}}
eP.Name="ReactFiberContext-internal.spec"
eP.Properties.Source=[[ -- awaiting pull request: https://github.com/facebook/react/pull/20155
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it

local ReactFiberContext
local ReactFiber
local ReactRootTags
local ReactFeatureFlags

beforeEach(function()
	jest.resetModules()

	ReactFiberContext = require(script.Parent.Parent["ReactFiberContext.new"])
	ReactFiber = require(script.Parent.Parent["ReactFiber.new"])
	ReactRootTags = require(script.Parent.Parent.ReactRootTags)
	ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.disableLegacyContext = false
end)

describe("Context stack", function()
	it("should throw when pushing to top level of non-empty stack", function()
		local fiber = ReactFiber.createHostRootFiber(ReactRootTags.BlockingRoot)
		local context = {
			foo = 1,
		}
		-- The first call here is a valid use of pushTopLevelContextObject
		ReactFiberContext.pushTopLevelContextObject(fiber, context, true)
		jestExpect(function()
			local moreContext = {
				bar = 2,
			}
			ReactFiberContext.pushTopLevelContextObject(fiber, moreContext, true)
		end).toThrow("Unexpected context found on stack.")
	end)

	it("should throw if when invalidating a provider that isn't initialized", function()
		local fiber = ReactFiber.createHostRootFiber(ReactRootTags.BlockingRoot)
		jestExpect(function()
			ReactFiberContext.invalidateContextProvider(fiber, nil, true)
		end).toThrow("Expected to have an instance by this point.")
	end)
end) ]]
eC.Children._41ba882ca1bb1151c9ed7877fa4e6a42=eP
local eQ

local eR={ClassName="ModuleScript",Children={},Properties={}}
eR.Name="ReactFiberDevToolsHook-internal.spec"
eR.Properties.Source=[[ -- awaiting pull request: https://github.com/facebook/react/pull/20155
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeAll = JestGlobals.beforeAll
local afterAll = JestGlobals.afterAll
local it = JestGlobals.it

local Map = require(Packages.LuauPolyfill).Map

local ReactFiberDevToolsHook, ReactDevtoolsShared

beforeEach(function()
	jest.resetModules()

	ReactFiberDevToolsHook = require(script.Parent.Parent["ReactFiberDevToolsHook.new"])
	ReactDevtoolsShared = require(Packages.Dev.ReactDevtoolsShared)
end)

describe("DevTools hook detection", function()
	local originalDevtoolsState
	beforeAll(function()
		originalDevtoolsState = _G.__REACT_DEVTOOLS_GLOBAL_HOOK__
	end)

	afterAll(function()
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = originalDevtoolsState
	end)

	local itIfDev = if _G.__DEV__ then it else it.skip :: any
	itIfDev("should log an error when fibers aren't supported", function()
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
			isDisabled = false,
			supportsHooks = false,
		}
		jestExpect(function()
			local result = ReactFiberDevToolsHook.injectInternals({})
			-- expect logs to include error
			jestExpect(result).toBe(true)
			-- ROBLOX deviation: assert the console error, upstream doesn't
		end).toErrorDev(
			"The installed version of React DevTools is too old",
			{ withoutStack = true }
		)
	end)

	-- ROBLOX deviation START: verify that renderers are attached correctly
	it("attaches renderers", function()
		local renderer123 = {
			findFiberByHostInstance = function() end,
		}
		local renderer456 = {
			findFiberByHostInstance = function() end,
		}
		local hook = {
			renderers = Map.new({
				{ 123, renderer123 },
				{ 456, renderer456 },
			}),
			rendererInterfaces = Map.new(),
			emit = jest.fn(),
			sub = jest.fn(),
		}
		local agent = {
			addListener = jest.fn(),
		}
		_G.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook

		ReactDevtoolsShared.backend.initBackend(hook, agent, {})

		jestExpect(hook.emit).toHaveBeenCalledTimes(3)

		jestExpect(hook.emit).toHaveBeenNthCalledWith(1, "renderer-attached", {
			id = 123,
			renderer = renderer123,
			rendererInterface = jestExpect.anything(),
		})
		jestExpect(hook.emit).toHaveBeenNthCalledWith(2, "renderer-attached", {
			id = 456,
			renderer = renderer456,
			rendererInterface = jestExpect.anything(),
		})
		jestExpect(hook.emit).toHaveBeenNthCalledWith(3, "react-devtools", agent)
	end)
	-- ROBLOX deviation END
end) ]]
eC.Children._9c8cffb6762654f7edeaf09429f891b2=eR
local eS

local eT={ClassName="ModuleScript",Children={},Properties={}}
eT.Name="ReactFiberHostContext-internal.spec"
eT.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/ea2af878cc3fb139b0e08cf9bc4b2f4178429d69/packages/react-reconciler/src/__tests__/ReactFiberHostContext-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 \]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

describe("ReactFiberHostContext", function()
	local ReactFiberReconciler
	local ConcurrentRoot
	local React

	beforeEach(function()
		jest.resetModules()
		React = require(Packages.React)
		ReactFiberReconciler = require(script.Parent.Parent)
		ConcurrentRoot = require(script.Parent.Parent.ReactRootTags)
	end)

	it("works with nil host context", function()
		local creates = 0
		local Renderer = ReactFiberReconciler({
			prepareForCommit = function()
				return nil
			end,
			resetAfterCommit = function() end,
			getRootHostContext = function()
				return nil
			end,
			getChildHostContext = function()
				return nil
			end,
			shouldSetTextContent = function()
				return false
			end,
			createInstance = function()
				creates += 1
			end,
			finalizeInitialChildren = function()
				return nil
			end,
			appendInitialChild = function()
				return nil
			end,
			now = function()
				return 0
			end,
			appendChildToContainer = function()
				return nil
			end,
			clearContainer = function() end,
			supportsMutation = true,
		})

		local container = Renderer.createContainer(
			--\[\[ root: \]\]
			nil,
			ConcurrentRoot,
			false,
			nil
		)
		Renderer.updateContainer(
			React.createElement("a", nil, React.createElement("b")),
			container,
			--\[\[ parentComponent: \]\]
			nil,
			--\[\[ callback: \]\]
			nil
		)

		jestExpect(creates).toBe(2)
	end)

	it("should send the context to prepareForCommit and resetAfterCommit", function()
		local rootContext = {}
		local Renderer = ReactFiberReconciler({
			prepareForCommit = function(hostContext)
				jestExpect(hostContext).toBe(rootContext)
				return nil
			end,
			resetAfterCommit = function(hostContext)
				jestExpect(hostContext).toBe(rootContext)
			end,
			getRootHostContext = function()
				return nil
			end,
			getChildHostContext = function()
				return nil
			end,
			shouldSetTextContent = function()
				return false
			end,
			createInstance = function()
				return nil
			end,
			finalizeInitialChildren = function()
				return nil
			end,
			appendInitialChild = function()
				return nil
			end,
			now = function()
				return 0
			end,
			appendChildToContainer = function()
				return nil
			end,
			clearContainer = function() end,
			supportsMutation = true,
		})

		local container =
			Renderer.createContainer(rootContext, ConcurrentRoot, false, nil)
		Renderer.updateContainer(
			React.createElement("a", nil, React.createElement("b")),
			container,
			--\[\[ parentComponent= \]\]
			nil,
			--\[\[ callback= \]\]
			nil
		)
	end)
end) ]]
eC.Children._ad10fae37230cd7832897066aadc03e2=eT
local eU

local eV={ClassName="ModuleScript",Children={},Properties={}}
eV.Name="ReactFiberLane.roblox.spec"
eV.Properties.Source=[[ -- awaiting pull request: https://github.com/facebook/react/pull/20155
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local ReactFiberSchedulerPriorities =
	require(script.Parent.Parent["ReactFiberSchedulerPriorities.roblox"])
local ImmediatePriority = ReactFiberSchedulerPriorities.ImmediatePriority
local NormalPriority = ReactFiberSchedulerPriorities.NormalPriority
local NoPriority = ReactFiberSchedulerPriorities.NoPriority
local UserBlockingPriority = ReactFiberSchedulerPriorities.UserBlockingPriority

local ReactFiberLane

beforeEach(function()
	jest.resetModules()
	ReactFiberLane = require(script.Parent.Parent.ReactFiberLane)
end)

describe("lanePriorityToSchedulerPriority", function()
	local INVALID_PRIORITY_LANE = 999

	local expectedPriorities = {
		SyncLanePriority = ImmediatePriority,
		SyncBatchedLanePriority = ImmediatePriority,
		InputDiscreteLanePriority = UserBlockingPriority,
		InputContinuousLanePriority = UserBlockingPriority,
		DefaultLanePriority = NormalPriority,
		TransitionPriority = NormalPriority,
		NoLanePriority = NoPriority,
	}
	-- ROBLOX FIXME Luau: need to fix CLI-56768 to remove any casts
	for priorityName, priority in expectedPriorities :: any do
		it(
			string.format(
				"returns the expected priority (%d) for lane %s",
				priority,
				priorityName
			),
			function()
				local lane = ReactFiberLane[priorityName]
				jestExpect(lane).toBeDefined()
				jestExpect(ReactFiberLane.lanePriorityToSchedulerPriority(lane)).toBe(
					priority
				)
			end
		)
	end

	it("throws when giving an invalid lane priority", function()
		jestExpect(function()
			ReactFiberLane.lanePriorityToSchedulerPriority(INVALID_PRIORITY_LANE)
		end).toThrow(
			string.format(
				"Invalid update priority: %s. This is a bug in React",
				tostring(INVALID_PRIORITY_LANE)
			)
		)
	end)
end)

describe("getHighestPriorityPendingLanes", function()
	it("returns the Sync lane and sets the sync lane priority", function()
		local root = { pendingLanes = ReactFiberLane.SyncLane }
		local lane = ReactFiberLane.getHighestPriorityPendingLanes(root)

		jestExpect(lane).toBe(ReactFiberLane.SyncLane)
		local nextLanesPriority = ReactFiberLane.returnNextLanesPriority()
		jestExpect(nextLanesPriority).toBe(ReactFiberLane.SyncLanePriority)
	end)
end)

describe("getNextLanes", function()
	describe("given no pending lanes", function()
		local root

		beforeEach(function()
			root = { pendingLanes = ReactFiberLane.NoLanes }
		end)

		it("returns no lanes", function()
			jestExpect(ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)).toBe(
				ReactFiberLane.NoLanes
			)
		end)

		it("sets the highest lane priority to no lane", function()
			ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
			jestExpect(ReactFiberLane.returnNextLanesPriority()).toBe(
				ReactFiberLane.NoLanePriority
			)
		end)
	end)
	describe("given expired lanes", function()
		local root

		beforeEach(function()
			root = {
				pendingLanes = ReactFiberLane.SyncLane,
				expiredLanes = ReactFiberLane.SyncLane,
				suspendedLanes = ReactFiberLane.NoLanes,
				pingedLanes = ReactFiberLane.NoLanes,
				entangledLanes = ReactFiberLane.NoLanes,
			}
		end)

		describe("no entangled lanes", function()
			describe("pending lanes with higher priority than expired lanes", function()
				beforeEach(function()
					root = Object.assign(root, {
						pendingLanes = ReactFiberLane.mergeLanes(
							ReactFiberLane.SomeRetryLane,
							ReactFiberLane.DefaultHydrationLane
						),
						expiredLanes = ReactFiberLane.DefaultLanes,
					})
				end)

				it(
					"returns the lanes above or equal to the priority of the expired lanes",
					function()
						local result =
							ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
						jestExpect(result).toBe(ReactFiberLane.DefaultHydrationLane)
					end
				)

				it("sets the highest lane priority to sync lane", function()
					ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
					jestExpect(ReactFiberLane.returnNextLanesPriority()).toBe(
						ReactFiberLane.SyncLanePriority
					)
				end)
			end)

			describe("pending lanes with lower priority than expired lanes", function()
				beforeEach(function()
					root = Object.assign(root, {
						pendingLanes = ReactFiberLane.SyncBatchedLane,
						expiredLanes = ReactFiberLane.SyncLane,
					})
				end)

				it("returns no lanes", function()
					local result =
						ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
					jestExpect(result).toBe(ReactFiberLane.NoLanes)
				end)

				it("sets the highest lane priority to sync lane", function()
					ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
					jestExpect(ReactFiberLane.returnNextLanesPriority()).toBe(
						ReactFiberLane.SyncLanePriority
					)
				end)
			end)
		end)

		it("sets the highest lane priority to sync lane", function()
			local result = ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)
			jestExpect(result).toBe(ReactFiberLane.SyncLane)
			jestExpect(ReactFiberLane.returnNextLanesPriority()).toBe(
				ReactFiberLane.SyncLanePriority
			)
		end)

		it("sets the highest lane priority to sync lane 2", function()
			root = Object.assign(root, {
				expiredLanes = ReactFiberLane.SyncBatchedLane,
			})
			local result = ReactFiberLane.getNextLanes(root, ReactFiberLane.NoLanes)

			jestExpect(result).toBe(ReactFiberLane.SyncLane)
			jestExpect(ReactFiberLane.returnNextLanesPriority()).toBe(
				ReactFiberLane.SyncLanePriority
			)
		end)
	end)
end)

describe("includesNonIdleWork", function()
	local nonIdleLaneNames = {
		"SyncLane",
		"SyncBatchedLane",
		"InputDiscreteHydrationLane",
		"DefaultHydrationLane",
		"SomeRetryLane",
		"SelectiveHydrationLane",
	}

	for _, laneName in nonIdleLaneNames do
		it(string.format("is true for %s", laneName), function()
			local lane = ReactFiberLane[laneName]

			jestExpect(lane).toBeDefined()
			jestExpect(ReactFiberLane.includesNonIdleWork(lane)).toBe(true)
		end)
	end

	local idleLaneNames = {
		"NoLane",
		"OffscreenLane",
		"IdleHydrationLane",
	}

	for _, laneName in idleLaneNames do
		it(string.format("is false for %s", laneName), function()
			local lane = ReactFiberLane[laneName]

			jestExpect(lane).toBeDefined()
			jestExpect(ReactFiberLane.includesNonIdleWork(lane)).toBe(false)
		end)
	end
end)

describe("includesOnlyRetries", function()
	it("is true for a retry lane", function()
		jestExpect(ReactFiberLane.includesOnlyRetries(ReactFiberLane.SomeRetryLane)).toBe(
			true
		)
	end)

	it("is false for the sync lane", function()
		jestExpect(ReactFiberLane.includesOnlyRetries(ReactFiberLane.SyncLane)).toBe(
			false
		)
	end)

	it("is false for a retry lane merged with another lane", function()
		local mergedLanes = ReactFiberLane.mergeLanes(
			ReactFiberLane.SyncLane,
			ReactFiberLane.SomeRetryLane
		)
		jestExpect(ReactFiberLane.includesOnlyRetries(mergedLanes)).toBe(false)
	end)
end)

describe("includesSomeLane", function()
	it("is true given the same lane", function()
		local lane = ReactFiberLane.SyncLane
		jestExpect(ReactFiberLane.includesSomeLane(lane, lane)).toBe(true)
	end)

	it("is true given lanes that includes the other", function()
		local lane = ReactFiberLane.SyncLane
		local mergedLanes =
			ReactFiberLane.mergeLanes(lane, ReactFiberLane.DefaultHydrationLane)

		jestExpect(ReactFiberLane.includesSomeLane(mergedLanes, lane)).toBe(true)
	end)

	it("is false for two seperate lanes", function()
		jestExpect(
			ReactFiberLane.includesSomeLane(
				ReactFiberLane.SyncLane,
				ReactFiberLane.DefaultHydrationLane
			)
		).toBe(false)
	end)
end)

describe("isSubsetOfLanes", function()
	it("is true given the same lane", function()
		local lane = ReactFiberLane.SyncLane

		jestExpect(ReactFiberLane.isSubsetOfLanes(lane, lane)).toBe(true)
	end)

	it("is true given lanes that includes the other", function()
		local subset = ReactFiberLane.mergeLanes(
			ReactFiberLane.SyncLane,
			ReactFiberLane.DefaultHydrationLane
		)
		local mergedLanes =
			ReactFiberLane.mergeLanes(subset, ReactFiberLane.SyncBatchedLane)

		jestExpect(ReactFiberLane.includesSomeLane(mergedLanes, subset)).toBe(true)
	end)

	it("is false for two seperate lanes", function()
		jestExpect(
			ReactFiberLane.includesSomeLane(
				ReactFiberLane.SyncLane,
				ReactFiberLane.DefaultHydrationLane
			)
		).toBe(false)
	end)
end)

describe("mergeLanes", function()
	it("returns a lane that includes both inputs", function()
		local laneA = ReactFiberLane.SyncLane
		local laneB = ReactFiberLane.DefaultHydrationLane
		local mergedLanes = ReactFiberLane.mergeLanes(laneA, laneB)

		jestExpect(ReactFiberLane.includesSomeLane(mergedLanes, laneA)).toBe(true)
		jestExpect(ReactFiberLane.includesSomeLane(mergedLanes, laneB)).toBe(true)
	end)

	it("returns the same lane given two identical lanes", function()
		local lane = ReactFiberLane.SyncLane
		jestExpect(ReactFiberLane.mergeLanes(lane, lane)).toBe(lane)
	end)
end)

describe("removeLanes", function()
	it("returns the lanes without the given lane", function()
		local laneA = ReactFiberLane.SyncLane
		local laneB = ReactFiberLane.DefaultHydrationLane
		local mergedLanes = ReactFiberLane.mergeLanes(laneA, laneB)

		jestExpect(ReactFiberLane.removeLanes(mergedLanes, laneA)).toBe(laneB)
		jestExpect(ReactFiberLane.removeLanes(mergedLanes, laneB)).toBe(laneA)
	end)

	it("returns the same lane when removing a lane not included", function()
		local lanes = ReactFiberLane.mergeLanes(
			ReactFiberLane.SyncLane,
			ReactFiberLane.DefaultHydrationLane
		)
		jestExpect(ReactFiberLane.removeLanes(lanes, ReactFiberLane.SyncBatchedLane)).toBe(
			lanes
		)
	end)
end)

describe("higherPriorityLane", function()
	it("returns the other lane if one is NoLane", function()
		local lane = ReactFiberLane.SyncLane

		jestExpect(ReactFiberLane.higherPriorityLane(ReactFiberLane.NoLane, lane)).toBe(
			lane
		)
		jestExpect(ReactFiberLane.higherPriorityLane(lane, ReactFiberLane.NoLane)).toBe(
			lane
		)
	end)

	it("returns the higher priority lane", function()
		local higherLane = ReactFiberLane.SyncLane
		local otherLane = ReactFiberLane.OffscreenLane
		jestExpect(ReactFiberLane.higherPriorityLane(higherLane, otherLane)).toBe(
			higherLane
		)
		jestExpect(ReactFiberLane.higherPriorityLane(otherLane, higherLane)).toBe(
			higherLane
		)
	end)
end)

describe("higherLanePriority", function()
	it("returns the other priority if one is NoLanePriority", function()
		local priority = ReactFiberLane.DefaultLanePriority
		jestExpect(
			ReactFiberLane.higherLanePriority(ReactFiberLane.NoLanePriority, priority)
		).toBe(priority)
		jestExpect(
			ReactFiberLane.higherLanePriority(priority, ReactFiberLane.NoLanePriority)
		).toBe(priority)
	end)

	it("returns the higher lane priority", function()
		local higherPriority = ReactFiberLane.SyncLanePriority
		local otherPriority = ReactFiberLane.TransitionPriority
		jestExpect(ReactFiberLane.higherLanePriority(higherPriority, otherPriority)).toBe(
			higherPriority
		)
		jestExpect(ReactFiberLane.higherLanePriority(otherPriority, higherPriority)).toBe(
			higherPriority
		)
	end)
end) ]]
eC.Children._36c8df4f46265b8cbc6086cb47fe1cb8=eV
local eW

local eX={ClassName="ModuleScript",Children={},Properties={}}
eX.Name="ReactFiberRoot.roblox.spec"
eX.Properties.Source=[[ -- awaiting pull request: https://github.com/facebook/react/pull/20155
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

local ReactFiberRoot
local ReactRootTags

beforeEach(function()
	jest.resetModules()

	ReactFiberRoot = require(script.Parent.Parent["ReactFiberRoot.new"])
	ReactRootTags = require(script.Parent.Parent.ReactRootTags)
end)

it("should properly initialize a fiber created with createFiberRoot", function()
	local fiberRoot =
		ReactFiberRoot.createFiberRoot({}, ReactRootTags.BlockingRoot, false)

	jestExpect(fiberRoot.current).toBeDefined()
	jestExpect(fiberRoot.current.updateQueue).toBeDefined()
end) ]]
eC.Children._3b43b676f1ed9c693c1dc11749a887ef=eX
local eY

local eZ={ClassName="ModuleScript",Children={},Properties={}}
eZ.Name="ReactFiberStack-test.roblox.spec"
eZ.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local it = JestGlobals.it

local ReactFiberStack

describe("ReactFiberStack", function()
	beforeEach(function()
		jest.resetModules()
		ReactFiberStack = require(script.Parent.Parent["ReactFiberStack.new"])
	end)

	it("creates a cursor with the given default value", function()
		local defaultValue = { foo = 3 }
		jestExpect(ReactFiberStack.createCursor(defaultValue)).toEqual({
			current = defaultValue,
		})
	end)

	it("initializes the stack empty", function()
		jestExpect(ReactFiberStack.isEmpty()).toBe(true)
	end)

	describe("stack manipulations", function()
		local cursor
		local fiber

		beforeEach(function()
			cursor = ReactFiberStack.createCursor(nil)
			fiber = {}
		end)

		it("pushes an element and the stack is not empty", function()
			ReactFiberStack.push(cursor, true, fiber)
			jestExpect(ReactFiberStack.isEmpty()).toBe(false)
		end)

		it("pushes an element and assigns the value to the cursor", function()
			local pushedElement = { foo = 3 }
			ReactFiberStack.push(cursor, pushedElement, fiber)
			jestExpect(cursor.current).toEqual(pushedElement)
		end)

		it("pushes an element, pops it back and the stack is empty", function()
			ReactFiberStack.push(cursor, true, fiber)
			ReactFiberStack.pop(cursor, fiber)
			jestExpect(ReactFiberStack.isEmpty()).toBe(true)
		end)

		it(
			"pushes an element, pops it back and the cursor has its initial value",
			function()
				local initialCursorValue = "foo"
				cursor.current = initialCursorValue

				ReactFiberStack.push(cursor, true, fiber)
				ReactFiberStack.pop(cursor, fiber)
				jestExpect(cursor.current).toBe(initialCursorValue)
			end
		)
	end)
end) ]]
eC.Children._6206ed711a9b0730f6ee031e1dd8713c=eZ
local e_

local e0={ClassName="ModuleScript",Children={},Properties={}}
e0.Name="ReactFiberSuspenseComponent.roblox.spec"
e0.Properties.Source=[[ local Reconciler = script.Parent.Parent
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it

local ReactFiberSuspenseComponent

describe("ReactFiberSuspenseComponent", function()
	beforeEach(function()
		jest.resetModules()

		ReactFiberSuspenseComponent =
			require(Reconciler["ReactFiberSuspenseComponent.new"])
	end)

	describe("shouldCaptureSuspense", function()
		local shouldCaptureSuspense
		local fiber

		beforeEach(function()
			shouldCaptureSuspense = ReactFiberSuspenseComponent.shouldCaptureSuspense
			fiber = {
				memoizedState = nil,
				memoizedProps = {},
			}
		end)

		local function generateTest(expected, hasInvisibleParent)
			if hasInvisibleParent == nil then
				generateTest(expected, true)
				generateTest(expected, false)
			else
				local testName = string.format(
					"is %s if it %s invisible parent",
					tostring(expected),
					hasInvisibleParent and "does not have" or "has"
				)
				it(testName, function()
					jestExpect(shouldCaptureSuspense(fiber, hasInvisibleParent)).toBe(
						expected
					)
				end)
			end
		end

		describe("with a memoizedState", function()
			beforeEach(function()
				fiber.memoizedState = { dehydrated = nil }
			end)
			describe("memoizedState.dehydrated is not null", function()
				beforeEach(function()
					fiber.memoizedState.dehydrated = {}
				end)
				generateTest(true)
			end)

			describe("memoizedState.dehydrated is null", function()
				generateTest(false)
			end)
		end)

		describe("with no memoizedState", function()
			describe("without fallback prop", function()
				generateTest(false)
			end)

			describe("with fallback prop", function()
				beforeEach(function()
					fiber.memoizedProps.fallback = {}
				end)

				describe("without flag unstable_avoidThisFallback", function()
					generateTest(true)
				end)

				describe("with flag unstable_avoidThisFallback", function()
					beforeEach(function()
						fiber.memoizedProps.unstable_avoidThisFallback = true
					end)
					generateTest(false, true)
					generateTest(true, false)
				end)
			end)
		end)
	end)
end) ]]
eC.Children._5b07e76a240a50f0b6280c34b7aaa057=e0
local e1

local e2={ClassName="ModuleScript",Children={},Properties={}}
e2.Name="ReactFiberSuspenseContext.roblox.spec"
e2.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local ReactFiber = require(script.Parent.Parent["ReactFiber.new"])

local ReactFiberSuspenseContext

describe("ReactFiberSuspenseContext", function()
	beforeEach(function()
		jest.resetModules()
		ReactFiberSuspenseContext =
			require(script.Parent.Parent["ReactFiberSuspenseContext.new"])
	end)

	describe("suspense context stack", function()
		local someContext
		local fiber
		local suspenseStackCursor

		beforeEach(function()
			someContext = 0b1000
			fiber = ReactFiber.createFiberFromText("", 0, 0)
			suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor
		end)

		it("pushes the context and assigns the value to the cursor", function()
			ReactFiberSuspenseContext.pushSuspenseContext(fiber, someContext)
			jestExpect(suspenseStackCursor).toEqual({ current = someContext })
		end)

		it("pushes and pops and sets the cursor to its initial value", function()
			local initialValue = suspenseStackCursor.current

			ReactFiberSuspenseContext.pushSuspenseContext(fiber, someContext)
			ReactFiberSuspenseContext.popSuspenseContext(fiber)
			jestExpect(suspenseStackCursor).toEqual({ current = initialValue })
		end)
	end)

	describe("hasSuspenseContext", function()
		it("is true for parent context and its subtree context", function()
			local subtree = 0b1000
			local parent =
				ReactFiberSuspenseContext.addSubtreeSuspenseContext(10000, subtree)

			jestExpect(ReactFiberSuspenseContext.hasSuspenseContext(parent, subtree)).toBe(
				true
			)
		end)

		it("is false for two different context", function()
			jestExpect(ReactFiberSuspenseContext.hasSuspenseContext(0b1000, 0b10000)).toBe(
				false
			)
		end)
	end)
end) ]]
eC.Children._c65acb0fc569e19567b3334696654a58=e2
local e3

local e4={ClassName="ModuleScript",Children={},Properties={}}
e4.Name="ReactFiberTreeReflection.roblox.spec"
e4.Properties.Source=[[ local Reconciler = script.Parent.Parent
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local setInstance = require(Packages.Shared).ReactInstanceMap.set
local ReactWorkTags = require(Reconciler.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local FunctionComponent = ReactWorkTags.FunctionComponent
local SuspenseComponent = ReactWorkTags.SuspenseComponent

local ReactFiberFlags = require(Reconciler.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
local ReactFiberLane = require(Reconciler.ReactFiberLane)

local ReactFiberTreeReflection

describe("ReactFiberTreeReflection", function()
	beforeEach(function()
		jest.resetModules()

		ReactFiberTreeReflection = require(Reconciler.ReactFiberTreeReflection)
	end)

	describe("getSuspenseInstanceFromFiber", function()
		local getSuspenseInstanceFromFiber

		beforeEach(function()
			getSuspenseInstanceFromFiber =
				ReactFiberTreeReflection.getSuspenseInstanceFromFiber
		end)

		local function mockFiber(mock)
			return Object.assign({
				tag = SuspenseComponent,
				alternate = nil,
				memoizedState = nil,
			}, mock)
		end

		it("returns the dehydrated memoized state from the fiber", function()
			local suspenseInstance = {}
			local fiber = mockFiber({
				memoizedState = { dehydrated = suspenseInstance },
			})
			jestExpect(getSuspenseInstanceFromFiber(fiber)).toBe(suspenseInstance)
		end)

		it("returns the dehydrated memoized state from the alternate fiber", function()
			local suspenseInstance = {}
			local fiber = mockFiber({
				alternate = mockFiber({
					memoizedState = { dehydrated = suspenseInstance },
				}),
			})
			jestExpect(getSuspenseInstanceFromFiber(fiber)).toBe(suspenseInstance)
		end)

		it("returns null if the fiber does not have the SuspenseComponent tag", function()
			local fiber = mockFiber({ tag = FunctionComponent })
			jestExpect(getSuspenseInstanceFromFiber(fiber)).toBe(nil)
		end)
	end)

	describe("getContainerFromFiber", function()
		local getContainerFromFiber

		beforeEach(function()
			getContainerFromFiber = ReactFiberTreeReflection.getContainerFromFiber
		end)

		local function mockFiber(mock)
			return Object.assign({
				tag = HostRoot,
			}, mock)
		end

		it("returns a container if fiber is a host root", function()
			local container = {}
			local fiber = mockFiber({
				stateNode = { containerInfo = container },
			})
			jestExpect(getContainerFromFiber(fiber)).toBe(container)
		end)

		it("returns null if the fiber is not a host root", function()
			local fiber = mockFiber({ tag = FunctionComponent })
			jestExpect(getContainerFromFiber(fiber)).toBe(nil)
		end)
	end)

	describe("different fiber states", function()
		local function mockFiber(mock)
			return Object.assign({
				alternate = nil,
				return_ = nil,
				tag = FunctionComponent,
				flags = NoFlags,
				subtreeFlags = NoFlags,
				lanes = ReactFiberLane.NoLanes,
				childLanes = ReactFiberLane.NoLanes,
			}, mock)
		end
		local fiber

		local function generateIsFiberMounted(expected)
			it(string.format("isFiberMounted() is %s", tostring(expected)), function()
				jestExpect(ReactFiberTreeReflection.isFiberMounted(fiber)).toBe(expected)
			end)
		end

		local function generateIsMounted(expected)
			it(string.format("isMounted() is %s", tostring(expected)), function()
				local component = {}
				setInstance(component, fiber)
				jestExpect(ReactFiberTreeReflection.isMounted(component)).toBe(expected)
			end)
		end

		describe("with an alternate fiber", function()
			describe("last return node has the HostRoot tag", function()
				beforeEach(function()
					local rootFiber = mockFiber({ tag = HostRoot })
					local middleFiber = mockFiber({ return_ = rootFiber })
					fiber = mockFiber({
						alternate = mockFiber(),
						return_ = middleFiber,
					})
				end)

				generateIsFiberMounted(true)
				generateIsMounted(true)

				it("getNearestMountedFiber() returns the same fiber", function()
					jestExpect(ReactFiberTreeReflection.getNearestMountedFiber(fiber)).toBe(
						fiber
					)
				end)
			end)

			describe("last return node does not have the HostRoot tag", function()
				beforeEach(function()
					local rootFiber = mockFiber()

					fiber = mockFiber({
						alternate = mockFiber(),
						return_ = rootFiber,
					})
				end)

				it("getNearestMountedFiber() returns null", function()
					jestExpect(ReactFiberTreeReflection.getNearestMountedFiber(fiber)).toBe(
						nil
					)
				end)

				it("findCurrentFiberUsingSlowPath() throws", function()
					jestExpect(function()
						ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(fiber)
					end).toThrow("Unable to find node on an unmounted component")
				end)

				generateIsFiberMounted(false)
				generateIsMounted(false)
			end)

			describe("fiber has the RootHost tag", function()
				beforeEach(function()
					fiber = mockFiber({
						alternate = mockFiber(),
						tag = HostRoot,
					})
				end)

				it("getNearestMountedFiber() returns the same fiber", function()
					jestExpect(ReactFiberTreeReflection.getNearestMountedFiber(fiber)).toBe(
						fiber
					)
				end)

				it(
					"findCurrentFiberUsingSlowPath() returns the same fiber "
						.. "if the stateNode.current is the fiber",
					function()
						fiber.stateNode = { current = fiber }

						jestExpect(
							ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(fiber)
						).toBe(fiber)
					end
				)

				it(
					"findCurrentFiberUsingSlowPath() returns the alternate fiber "
						.. "if the stateNode.current is not the given fiber",
					function()
						fiber.stateNode = { current = nil }

						jestExpect(
							ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(fiber)
						).toBe(fiber.alternate)
					end
				)

				generateIsFiberMounted(true)
				generateIsMounted(true)
			end)
		end)

		describe("without an alternate fiber", function()
			describe(
				"all its return nodes do not have the placement or hydrating flag",
				function()
					beforeEach(function()
						local rootFiber = mockFiber({ tag = HostRoot })
						local middleFiber = mockFiber({ return_ = rootFiber })

						fiber = mockFiber({ return_ = middleFiber })
					end)

					it("getNearestMountedFiber() returns the same fiber", function()
						jestExpect(ReactFiberTreeReflection.getNearestMountedFiber(fiber)).toBe(
							fiber
						)
					end)

					it(
						"findCurrentFiberUsingSlowPath() returns the same fiber",
						function()
							jestExpect(
								ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(
									fiber
								)
							).toBe(fiber)
						end
					)

					generateIsFiberMounted(true)
					generateIsMounted(true)
				end
			)

			local fiberFlags = {
				placement = Placement,
				hydrating = Hydrating,
			}
			-- ROBLOX FIXME Luau: need to fix CLI-56768 to remove any casts
			for name, flag in fiberFlags :: any do
				describe(
					string.format("one of the return node has the %s flag", name),
					function()
						local rootFiber

						beforeEach(function()
							rootFiber = mockFiber({ tag = HostRoot })

							local middleFiber = mockFiber({
								return_ = rootFiber,
								flags = flag,
							})

							fiber = mockFiber({ return_ = middleFiber })
						end)

						it("getNearestMountedFiber() returns the parent fiber", function()
							jestExpect(
								ReactFiberTreeReflection.getNearestMountedFiber(fiber)
							).toBe(rootFiber)
						end)

						it("findCurrentFiberUsingSlowPath() returns null", function()
							jestExpect(
								ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(
									fiber
								)
							).toBe(nil)
						end)

						generateIsFiberMounted(false)
						generateIsMounted(false)
					end
				)

				describe(
					string.format(
						"the return node of the fiber where it has the %s ",
						name
					) .. "flag does not have the HostRoot tags",
					function()
						beforeEach(function()
							local rootFiber = mockFiber()
							local middleFiber = mockFiber({
								return_ = rootFiber,
								flags = flag,
							})

							fiber = mockFiber({ return_ = middleFiber })
						end)

						it("getNearestMountedFiber() returns null", function()
							jestExpect(
								ReactFiberTreeReflection.getNearestMountedFiber(fiber)
							).toBe(nil)
						end)

						it("findCurrentFiberUsingSlowPath() throws", function()
							jestExpect(function()
								ReactFiberTreeReflection.findCurrentFiberUsingSlowPath(
									fiber
								)
							end).toThrow(
								"Unable to find node on an unmounted component"
							)
						end)

						generateIsFiberMounted(false)
						generateIsMounted(false)
					end
				)
			end
		end)
	end)

	describe("isFiberSuspenseAndTimedOut", function()
		local isFiberSuspenseAndTimedOut
		beforeEach(function()
			isFiberSuspenseAndTimedOut =
				ReactFiberTreeReflection.isFiberSuspenseAndTimedOut
		end)

		it(
			"is true for a SuspenseComponent fiber when memoizedState.dehydrated is null",
			function()
				local fiber = {
					tag = SuspenseComponent,
					memoizedState = { dehydrated = nil },
				}
				jestExpect(isFiberSuspenseAndTimedOut(fiber)).toBe(true)
			end
		)

		it("is false if the fiber is not tagged as SuspenseComponent", function()
			local fiber = {
				tag = ClassComponent,
				memoizedState = { dehydrated = nil },
			}
			jestExpect(isFiberSuspenseAndTimedOut(fiber)).toBe(false)
		end)

		it("is false if the fiber does not have memoizedState", function()
			local fiber = {
				tag = SuspenseComponent,
				memoizedState = nil,
			}
			jestExpect(isFiberSuspenseAndTimedOut(fiber)).toBe(false)
		end)

		it("is false if the fiber memoizedState.dehydrated is not null", function()
			local fiber = {
				tag = SuspenseComponent,
				memoizedState = {
					dehydrated = "foo",
				},
			}
			jestExpect(isFiberSuspenseAndTimedOut(fiber)).toBe(false)
		end)
	end)

	describe("doesFiberContain", function()
		local doesFiberContain
		beforeEach(function()
			doesFiberContain = ReactFiberTreeReflection.doesFiberContain
		end)

		local function mockFiber(mock)
			return Object.assign({
				return_ = nil,
				alternate = nil,
			}, mock or {})
		end

		it("is true if the parent and the child are the same fiber", function()
			local fiber = mockFiber()
			jestExpect(doesFiberContain(fiber, fiber)).toBe(true)
		end)

		it("is true if the parent alternate and the child are the same fiber", function()
			local fiber = mockFiber()
			local parent = mockFiber({ alternate = fiber })
			jestExpect(doesFiberContain(parent, fiber)).toBe(true)
		end)

		it(
			"is true if the child return node and the parent are the same fiber",
			function()
				local parent = mockFiber()
				local child = mockFiber({ return_ = parent })
				jestExpect(doesFiberContain(parent, child)).toBe(true)
			end
		)

		it(
			"is true if the child return node and the parent alternate are the same fiber",
			function()
				local parentAlternate = mockFiber()
				local parent = mockFiber({ alternate = parentAlternate })
				local child = mockFiber({ return_ = parentAlternate })
				jestExpect(doesFiberContain(parent, child)).toBe(true)
			end
		)

		it("is false if none of the child parents are the parent fiber", function()
			local parent = mockFiber()
			local child = mockFiber()
			jestExpect(doesFiberContain(parent, child)).toBe(false)
		end)
	end)
end) ]]
eC.Children._e331cf8104ed0714a435ffff4a6a6876=e4
local e5

local e6={ClassName="ModuleScript",Children={},Properties={}}
e6.Name="ReactHooks-internal.spec"
e6.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactHooks-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local React
local ReactFeatureFlags
local ReactTestRenderer
local Scheduler
-- local ReactDOMServer
local act
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local it = JestGlobals.it
local xit = JestGlobals.xit
local describe = JestGlobals.describe
describe("ReactHooks", function()
	local Promise = require(Packages.Promise)
	local LuauPolyfill = require(Packages.LuauPolyfill)
	local Array = LuauPolyfill.Array
	type Array<T> = LuauPolyfill.Array<T>
	type Function = (...any) -> ...any
	local Error = LuauPolyfill.Error

	beforeEach(function()
		jest.resetModules()
		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		React = require(Packages.React)
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		Scheduler = require(Packages.Scheduler)
		-- ReactDOMServer = require("react-dom/server")
		act = ReactTestRenderer.unstable_concurrentAct
	end)
	if _G.__DEV__ then
		it("useDebugValue throws when used in a class component", function()
			type Example = { render: any } --\[\[ ROBLOX TODO: replace 'any' type/ add missing \]\]
			local Example = React.Component:extend("Example")
			function Example:render()
				React.useDebugValue("abc")
				return nil
			end
			-- ROBLOX Test Noise: jest setup config makes this hide error
			-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
			jestExpect(function()
				ReactTestRenderer.create(React.createElement(Example))
			end).toThrow(
				"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen"
					.. " for one of the following reasons:\n"
					.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
					.. "2. You might be breaking the Rules of Hooks\n"
					.. "3. You might have more than one copy of React in the same app\n"
					.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
			)
		end)
	end
	it("bails out in the render phase if all of the state is the same", function()
		local useState, useLayoutEffect = React.useState, React.useLayoutEffect
		local function Child(props)
			local text = props.text
			Scheduler.unstable_yieldValue("Child: " .. tostring(text))
			return text
		end
		local setCounter1
		local setCounter2
		local function Parent()
			local counter1, _setCounter1 = useState(0)
			setCounter1 = _setCounter1
			local counter2, _setCounter2 = useState(0)
			setCounter2 = _setCounter2
			local text = string.format("%s, %s", tostring(counter1), tostring(counter2))
			Scheduler.unstable_yieldValue(string.format("Parent: %s", text))
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue(string.format("Effect: %s", text))
			end)
			return React.createElement(Child, { text = text })
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })

		root.update(React.createElement(Parent))
		jestExpect(Scheduler).toFlushAndYield({
			"Parent: 0, 0",
			"Child: 0, 0",
			"Effect: 0, 0",
		})
		jestExpect(root).toMatchRenderedOutput("0, 0")
		act(function()
			setCounter1(1)
			setCounter2(1)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Parent: 1, 1",
			"Child: 1, 1",
			"Effect: 1, 1",
		})
		act(function()
			return setCounter1(1)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Parent: 1, 1" })
		act(function()
			setCounter1(1)
			setCounter2(2)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Parent: 1, 2",
			"Child: 1, 2",
			"Effect: 1, 2",
		})
		act(function()
			setCounter1(9)
			setCounter2(3)
			setCounter1(4)
			setCounter2(7)
			setCounter1(1)
			setCounter2(2)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Parent: 1, 2" })
		act(function()
			setCounter1(0 / -1)
			setCounter2(0 / 0)
		end)
		jestExpect(Scheduler).toHaveYielded({
			-- ROBLOX deviation: use Luau stringified versions of the math
			"Parent: -0, nan",
			"Child: -0, nan",
			"Effect: -0, nan",
		})
		act(function()
			setCounter1(0 / -1)
			setCounter2(0 / 0)
			setCounter2(math.huge)
			setCounter2(0 / 0)
		end)
		-- ROBLOX deviation: use Luau stringified versions of the math
		jestExpect(Scheduler).toHaveYielded({ "Parent: -0, nan" })
		act(function()
			setCounter1(0)
		end)
		jestExpect(Scheduler).toHaveYielded({
			-- ROBLOX deviation: use Luau stringified versions of the math
			"Parent: 0, nan",
			"Child: 0, nan",
			"Effect: 0, nan",
		})
	end)
	it(
		"bails out in render phase if all the state is the same and props bail out with memo",
		function()
			local useState, memo = React.useState, React.memo
			local function Child(props)
				local text = props.text
				Scheduler.unstable_yieldValue("Child: " .. tostring(text))
				return text
			end
			local setCounter1
			local setCounter2
			local function Parent(props)
				local theme = props.theme
				local counter1, _setCounter1 = useState(0)
				setCounter1 = _setCounter1
				local counter2, _setCounter2 = useState(0)
				setCounter2 = _setCounter2
				local text = string.format(
					"%s, %s (%s)",
					tostring(counter1),
					tostring(counter2),
					theme
				)
				Scheduler.unstable_yieldValue(string.format("Parent: %s", text))
				return React.createElement(Child, { text = text })
			end
			-- ROBLOX TODO: contribute this rename upstream, it makes the code and types sane
			local ParentMemo = memo(Parent)
			local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
			root.update(React.createElement(ParentMemo, { theme = "light" }))
			jestExpect(Scheduler).toFlushAndYield({
				"Parent: 0, 0 (light)",
				"Child: 0, 0 (light)",
			})
			jestExpect(root).toMatchRenderedOutput("0, 0 (light)")
			act(function()
				setCounter1(1)
				setCounter2(1)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 1, 1 (light)",
				"Child: 1, 1 (light)",
			})
			act(function()
				return setCounter1(1)
			end)
			jestExpect(Scheduler).toHaveYielded({ "Parent: 1, 1 (light)" })
			act(function()
				setCounter1(1)
				setCounter2(2)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 1, 2 (light)",
				"Child: 1, 2 (light)",
			})
			act(function()
				setCounter1(1)
				setCounter2(2)
				root.update(React.createElement(ParentMemo, { theme = "dark" }))
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 1, 2 (dark)",
				"Child: 1, 2 (dark)",
			})
			act(function()
				setCounter1(1)
				setCounter2(2)
				root.update(React.createElement(ParentMemo, { theme = "dark" }))
			end)
			jestExpect(Scheduler).toHaveYielded({ "Parent: 1, 2 (dark)" })
		end
	)
	it("warns about setState second argument", function()
		local useState = React.useState
		local setCounter
		local function Counter()
			local counter, _setCounter = useState(0)
			setCounter = _setCounter
			Scheduler.unstable_yieldValue(string.format("Count: %s", tostring(counter)))
			return counter
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
		root.update(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(root).toMatchRenderedOutput("0")
		jestExpect(function()
			act(function()
				-- ROBLOX deviation: Luau types prevent us from even trying this abuse case unless we cast away safety
				return (setCounter :: any)(1, function()
					error(Error.new("Expected to ignore the callback."))
				end)
			end)
		end).toErrorDev(
			"State updates from the useState() and useReducer() Hooks "
				.. "don't support the second callback argument. "
				.. "To execute a side effect after rendering, "
				.. "declare it in the component body with useEffect().",
			{ withoutStack = true }
		)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(root).toMatchRenderedOutput("1")
	end)

	it("warns about dispatch second argument", function()
		local useReducer = React.useReducer
		local dispatch
		local function Counter()
			local counter, _dispatch = useReducer(function(s, a)
				return a
			end, 0)
			dispatch = _dispatch
			Scheduler.unstable_yieldValue(string.format("Count: %s", counter))
			return counter
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
		root.update(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(root).toMatchRenderedOutput("0")
		jestExpect(function()
			act(function()
				-- ROBLOX deviation: Luau types prevent us from even trying this abuse case unless we cast away safety
				return (dispatch :: any)(1, function()
					error(Error.new("Expected to ignore the callback."))
				end)
			end)
		end).toErrorDev(
			"State updates from the useState() and useReducer() Hooks "
				.. "don't support the second callback argument. "
				.. "To execute a side effect after rendering, "
				.. "declare it in the component body with useEffect().",
			{ withoutStack = true }
		)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(root).toMatchRenderedOutput("1")
	end)
	it("never bails out if context has changed", function()
		local useState, useLayoutEffect, useContext =
			React.useState, React.useLayoutEffect, React.useContext
		local ThemeContext = React.createContext("light")
		local setTheme
		local function ThemeProvider(props)
			local children = props.children
			local theme, _setTheme = useState("light")
			Scheduler.unstable_yieldValue("Theme: " .. tostring(theme))
			setTheme = _setTheme
			return React.createElement(ThemeContext.Provider, { value = theme }, children)
		end
		local function Child(ref)
			local text = ref.text
			Scheduler.unstable_yieldValue("Child: " .. tostring(text))
			return text
		end
		local setCounter
		local function Parent()
			local counter, _setCounter = useState(0)
			setCounter = _setCounter
			local theme = useContext(ThemeContext)
			local text = string.format("%d (%s)", counter, theme)
			Scheduler.unstable_yieldValue(string.format("Parent: %s", text))
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue(string.format("Effect: %s", text))
			end)
			return React.createElement(Child, { text = text })
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
		act(function()
			root.update(
				React.createElement(ThemeProvider, nil, React.createElement(Parent))
			)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Theme: light",
			"Parent: 0 (light)",
			"Child: 0 (light)",
			"Effect: 0 (light)",
		})
		jestExpect(root).toMatchRenderedOutput("0 (light)")
		setTheme("light")
		jestExpect(Scheduler).toFlushAndYield({})
		jestExpect(root).toMatchRenderedOutput("0 (light)")
		act(function()
			return setCounter(1)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Parent: 1 (light)",
			"Child: 1 (light)",
			"Effect: 1 (light)",
		})
		jestExpect(root).toMatchRenderedOutput("1 (light)")
		act(function()
			return setCounter(1)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Parent: 1 (light)" })
		jestExpect(root).toMatchRenderedOutput("1 (light)")
		act(function()
			setCounter(1)
			setTheme("dark")
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Theme: dark",
			"Parent: 1 (dark)",
			"Child: 1 (dark)",
			"Effect: 1 (dark)",
		})
		jestExpect(root).toMatchRenderedOutput("1 (dark)")
	end)
	it(
		"can bail out without calling render phase (as an optimization) if queue is known to be empty",
		function()
			local useState, useLayoutEffect = React.useState, React.useLayoutEffect
			local function Child(ref)
				local text = ref.text
				Scheduler.unstable_yieldValue("Child: " .. tostring(text))
				return text
			end
			local setCounter
			local function Parent()
				local counter, _setCounter = useState(0)
				setCounter = _setCounter
				Scheduler.unstable_yieldValue("Parent: " .. tostring(counter))
				useLayoutEffect(function()
					Scheduler.unstable_yieldValue("Effect: " .. tostring(counter))
				end)
				return React.createElement(Child, { text = counter })
			end
			local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
			root.update(React.createElement(Parent))
			jestExpect(Scheduler).toFlushAndYield({
				"Parent: 0",
				"Child: 0",
				"Effect: 0",
			})
			jestExpect(root).toMatchRenderedOutput("0")
			act(function()
				return setCounter(1)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 1",
				"Child: 1",
				"Effect: 1",
			})
			jestExpect(root).toMatchRenderedOutput("1")
			act(function()
				return setCounter(1)
			end)
			jestExpect(Scheduler).toHaveYielded({ "Parent: 1" })
			jestExpect(root).toMatchRenderedOutput("1")
			act(function()
				return setCounter(1)
			end)
			jestExpect(Scheduler).toFlushAndYield({})
			jestExpect(root).toMatchRenderedOutput("1")
			act(function()
				return setCounter(2)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 2",
				"Child: 2",
				"Effect: 2",
			})
			jestExpect(root).toMatchRenderedOutput("2")
			act(function()
				setCounter(0)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Parent: 0",
				"Child: 0",
				"Effect: 0",
			})
			jestExpect(root).toMatchRenderedOutput("0")
			act(function()
				setCounter(0)
			end)
			jestExpect(Scheduler).toHaveYielded({ "Parent: 0" })
			jestExpect(root).toMatchRenderedOutput("0")
			act(function()
				setCounter(0)
			end)
			jestExpect(Scheduler).toFlushAndYield({})
			jestExpect(root).toMatchRenderedOutput("0")
			act(function()
				setCounter(0 / -1)
			end)
			-- ROBLOX deviation: use Luau stringified versions of the math
			jestExpect(Scheduler).toHaveYielded({
				"Parent: -0",
				"Child: -0",
				"Effect: -0",
			})
			jestExpect(root).toMatchRenderedOutput("-0")
		end
	)
	it("bails out multiple times in a row without entering render phase", function()
		local useState = React.useState
		local function Child(ref)
			local text = ref.text
			Scheduler.unstable_yieldValue("Child: " .. tostring(text))
			return text
		end
		local setCounter
		local function Parent()
			local counter, _setCounter = useState(0)
			setCounter = _setCounter
			Scheduler.unstable_yieldValue("Parent: " .. tostring(counter))
			return React.createElement(Child, { text = counter })
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
		root.update(React.createElement(Parent))
		jestExpect(Scheduler).toFlushAndYield({ "Parent: 0", "Child: 0" })
		jestExpect(root).toMatchRenderedOutput("0")
		local function update(value)
			setCounter(function(previous)
				Scheduler.unstable_yieldValue(
					string.format(
						"Compute state (%s -> %s)",
						tostring(previous),
						tostring(value)
					)
				)
				return value
			end)
		end
		ReactTestRenderer.unstable_batchedUpdates(function()
			update(0)
			update(0)
			update(0)
			update(1)
			update(2)
			update(3)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Compute state (0 -> 0)",
			"Compute state (0 -> 0)",
			"Compute state (0 -> 0)",
			"Compute state (0 -> 1)",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Compute state (1 -> 2)",
			"Compute state (2 -> 3)",
			"Parent: 3",
			"Child: 3",
		})
		jestExpect(root).toMatchRenderedOutput("3")
	end)
	it("can rebase on top of a previously skipped update", function()
		local useState = React.useState
		local function Child(ref)
			local text = ref.text
			Scheduler.unstable_yieldValue("Child: " .. tostring(text))
			return text
		end
		local setCounter
		local function Parent()
			local counter, _setCounter = useState(1)
			setCounter = _setCounter
			Scheduler.unstable_yieldValue("Parent: " .. tostring(counter))
			return React.createElement(Child, { text = counter })
		end
		local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })
		root.update(React.createElement(Parent))
		jestExpect(Scheduler).toFlushAndYield({ "Parent: 1", "Child: 1" })
		jestExpect(root).toMatchRenderedOutput("1")
		local function update(compute)
			setCounter(function(previous)
				local value = compute(previous)
				Scheduler.unstable_yieldValue(
					string.format(
						"Compute state (%s -> %s)",
						tostring(previous),
						tostring(value)
					)
				)
				return value
			end)
		end
		ReactTestRenderer.unstable_batchedUpdates(function()
			return update(function(n)
				return n * 100
			end)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Compute state (1 -> 100)" })
		root.unstable_flushSync(function()
			update(function(n)
				return n + 5
			end)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Compute state (1 -> 6)",
			"Parent: 6",
			"Child: 6",
		})
		jestExpect(root).toMatchRenderedOutput("6")
		jestExpect(Scheduler).toFlushAndYield({
			"Compute state (100 -> 105)",
			"Parent: 105",
			"Child: 105",
		})
		jestExpect(root).toMatchRenderedOutput("105")
	end)
	-- ROBLOX deviation START: Skip this test, as the warning has been
	-- silenced to accomodate nils in dependency arrays. We'd like to
	-- address this possible misuse with a lint instead
	-- https://jira.rbx.com/browse/LUAFDN-1175
	xit("warns about variable number of dependencies", function()
		local useLayoutEffect = React.useLayoutEffect
		local function App(props)
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue(
					"Did commit: " .. tostring(Array.join(props.dependencies, ", "))
				)
			end, props.dependencies)
			return props.dependencies
		end
		local root =
			ReactTestRenderer.create(React.createElement(App, { dependencies = { "A" } }))
		jestExpect(Scheduler).toHaveYielded({ "Did commit: A" })
		jestExpect(function()
			root.update(React.createElement(App, { dependencies = { "A", "B" } }))
		end).toErrorDev({
			"Warning: The final argument passed to useLayoutEffect changed size "
				.. "between renders. The order and size of this array must remain "
				.. "constant.\n\n"
				.. 'Previous: ["A"]\n'
				.. 'Incoming: ["A", "B"]\n',
		})
	end)
	-- ROBLOX deviation END
	it("warns if switching from dependencies to no dependencies", function()
		local useMemo = React.useMemo
		local function App(props)
			local text, hasDeps = props.text, props.hasDeps
			local resolvedText = useMemo(
				function()
					Scheduler.unstable_yieldValue("Compute")
					-- ROBLOX TODO: add String.toUpperCase to polyfill
					return string.upper(text)
				end,
				-- ROBLOX Luau FIXME: Luau forced me put in this annotation to avoid Type '{string}' could not be converted into 'nil'
				(function(): { string } | nil
					if hasDeps then
						return nil
					else
						return { text }
					end
				end)()
			)
			return resolvedText
		end
		local root = ReactTestRenderer.create(nil)
		root.update(React.createElement(App, { text = "Hello", hasDeps = true }))
		jestExpect(Scheduler).toHaveYielded({ "Compute" })
		jestExpect(root).toMatchRenderedOutput("HELLO")
		jestExpect(function()
			root.update(React.createElement(App, { text = "Hello", hasDeps = false }))
		end).toErrorDev({
			"Warning: useMemo received a final argument during this render, but "
				.. "not during the previous render. Even though the final argument is "
				.. "optional, its type cannot change between renders.",
		})
	end)
	it("warns if deps is not an array", function()
		local useEffect, useLayoutEffect, useMemo, useCallback =
			React.useEffect, React.useLayoutEffect, React.useMemo, React.useCallback
		local function App(props)
			useEffect(function() end, props.deps)
			useLayoutEffect(function() end, props.deps)
			-- ROBLOX TODO: upstream this type safety fix
			useMemo(function()
				return nil
			end, props.deps)
			useCallback(function() end, props.deps)
			return nil
		end
		jestExpect(function()
			act(function()
				-- ROBLOX TODO: upstream this hard cast, since this abuse case violates the API
				ReactTestRenderer.create(
					React.createElement(App, { deps = "hello" :: any })
				)
			end)
		end).toErrorDev({
			"Warning: useEffect received a final argument that is not an array (instead, received `string`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useLayoutEffect received a final argument that is not an array (instead, received `string`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useMemo received a final argument that is not an array (instead, received `string`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useCallback received a final argument that is not an array (instead, received `string`). "
				.. "When specified, the final argument must be an array.",
		})
		jestExpect(function()
			act(function()
				-- ROBLOX TODO: upstream this hard cast, since this abuse case violates the API
				ReactTestRenderer.create(
					React.createElement(App, { deps = 100500 :: any })
				)
			end)
		end).toErrorDev({
			"Warning: useEffect received a final argument that is not an array (instead, received `number`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useLayoutEffect received a final argument that is not an array (instead, received `number`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useMemo received a final argument that is not an array (instead, received `number`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useCallback received a final argument that is not an array (instead, received `number`). "
				.. "When specified, the final argument must be an array.",
		})
		jestExpect(function()
			act(function()
				-- ROBLOX deviation: empty table isn't distinguishable from an array
				ReactTestRenderer.create(
					-- ROBLOX TODO: upstream this hard cast, since this abuse case violates the API
					React.createElement(App, { deps = { notempty = true } :: any })
				)
			end)
		end).toErrorDev({
			-- ROBLOX deviation: table type instead of object
			"Warning: useEffect received a final argument that is not an array (instead, received `table`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useLayoutEffect received a final argument that is not an array (instead, received `table`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useMemo received a final argument that is not an array (instead, received `table`). "
				.. "When specified, the final argument must be an array.",
			"Warning: useCallback received a final argument that is not an array (instead, received `table`). "
				.. "When specified, the final argument must be an array.",
		})
		act(function()
			ReactTestRenderer.create(React.createElement(App, { deps = {} }))
			ReactTestRenderer.create(React.createElement(App, { deps = nil }))
			ReactTestRenderer.create(React.createElement(App, { deps = nil }))
		end)
	end)
	-- ROBLOX deviation START: regresses an issue where valid use of dependencies arrays with nils would result in warnings
	it("does not warn for sparse dep arrays", function()
		local useEffect, useLayoutEffect, useMemo, useCallback =
			React.useEffect, React.useLayoutEffect, React.useMemo, React.useCallback
		local function App(props)
			useEffect(function() end, props.deps)
			useLayoutEffect(function() end, props.deps)
			-- ROBLOX TODO: upstream this type safety fix
			useMemo(function()
				return nil
			end, props.deps)
			useCallback(function() end, props.deps)
			return nil
		end
		jestExpect(function()
			act(function()
				ReactTestRenderer.create(
					React.createElement(App, { deps = { nil, "world", "!" } :: { any } })
				)
			end)
		end).toErrorDev({})
		jestExpect(function()
			act(function()
				ReactTestRenderer.create(
					React.createElement(
						App,
						{ deps = { "hello", "world", "!" } :: { any } }
					)
				)
			end)
		end).toErrorDev({})
		jestExpect(function()
			act(function()
				ReactTestRenderer.create(
					React.createElement(App, { deps = { "hello", nil, "!" } :: { any } })
				)
			end)
		end).toErrorDev({})
	end)
	-- ROBLOX deviation END
	-- ROBLOX FIXME: this test depends on fix in https://github.com/Roblox/luau-polyfill/pull/112
	xit("warns if deps is not an array for useImperativeHandle", function()
		local useImperativeHandle = React.useImperativeHandle
		local App = React.forwardRef(function(props: { deps: any }, ref)
			useImperativeHandle(ref, function()
				return nil
			end, props.deps)
			return nil
		end)
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(App, { deps = "hello" }))
		end).toErrorDev({
			"Warning: useImperativeHandle received a final argument that is not an array (instead, received `string`). "
				.. "When specified, the final argument must be an array.",
		}, { withoutStack = true }) -- ROBLOX FIXME: upstream doesn't need withoutStack = true
		ReactTestRenderer.create(React.createElement(App, { deps = {} }))
		ReactTestRenderer.create(React.createElement(App, { deps = nil }))
		ReactTestRenderer.create(React.createElement(App, { deps = nil }))
	end)
	it("does not forget render phase useState updates inside an effect", function()
		local useState, useEffect = React.useState, React.useEffect
		local function Counter()
			local counter, setCounter = useState(0)
			if counter == 0 then
				setCounter(function(x)
					return x + 1
				end)
				setCounter(function(x)
					return x + 1
				end)
			end
			useEffect(function()
				setCounter(function(x)
					return x + 1
				end)
				setCounter(function(x)
					return x + 1
				end)
			end, {})
			return counter
		end
		local root = ReactTestRenderer.create(nil)
		act(function()
			root.update(React.createElement(Counter))
		end)
		jestExpect(root).toMatchRenderedOutput("4")
	end)
	it(
		"does not forget render phase useReducer updates inside an effect with hoisted reducer",
		function()
			local useReducer, useEffect = React.useReducer, React.useEffect
			-- ROBLOX Luau FIXME: Luau should know x is number because of the useReducer<> generic: https://jira.rbx.com/browse/CLI-29033
			-- ROBLOX Luau FIXME: I have to explicit add _action: nil, but it should be inferred: https://jira.rbx.com/browse/CLI-49121
			local function reducer(x: number, _action: nil)
				return x + 1
			end
			local function Counter()
				local counter, increment = useReducer(reducer, 0)
				if counter == 0 then
					increment()
					increment()
				end
				useEffect(function()
					increment()
					increment()
				end, {})
				return counter
			end
			local root = ReactTestRenderer.create(nil)
			act(function()
				root.update(React.createElement(Counter))
			end)
			jestExpect(root).toMatchRenderedOutput("4")
		end
	)
	it(
		"does not forget render phase useReducer updates inside an effect with inline reducer",
		function()
			local useReducer, useEffect = React.useReducer, React.useEffect
			local function Counter()
				-- ROBLOX Luau FIXME: Luau should know x is number because of the useReducer<> generic: https://jira.rbx.com/browse/CLI-29033
				-- ROBLOX Luau FIXME: I have to explicit add _action: nil, but it should be inferred: https://jira.rbx.com/browse/CLI-49121
				local counter, increment = useReducer(function(x: number, _action: nil)
					return x + 1
				end, 0)
				if counter == 0 then
					increment()
					increment()
				end
				useEffect(function()
					increment()
					increment()
				end, {})
				return counter
			end
			local root = ReactTestRenderer.create(nil)
			act(function()
				root.update(React.createElement(Counter))
			end)
			jestExpect(root).toMatchRenderedOutput("4")
		end
	)
	it("warns for bad useImperativeHandle first arg", function()
		local useImperativeHandle = React.useImperativeHandle
		local function App()
			-- ROBLOX deviation: Luau types prevent this abuse, so we cast away to any to test the scenario
			(useImperativeHandle :: any)({ focus = function(self) end })
			return nil
		end
		jestExpect(function()
			jestExpect(function()
				ReactTestRenderer.create(React.createElement(App))
				-- ROBLOX deviation: Lua has different error when trying to call a nil
			end).toThrow("attempt to call a nil value")
		end).toErrorDev({
			"Expected useImperativeHandle() first argument to either be a "
				.. "ref callback or React.createRef() object. "
				.. "Instead received: an object with keys {focus}.",
			"Warning: Expected useImperativeHandle() second argument to be a function "
				-- ROBLOX deviation: nil instead of undefined
				.. "that creates a handle. Instead received: nil.",
		})
	end)
	it("warns for bad useImperativeHandle second arg", function()
		local useImperativeHandle = React.useImperativeHandle
		local App = React.forwardRef(function(props, ref)
			-- ROBLOX deviation: Luau types prevent this abuse, so we cast away to any to test the scenario
			(useImperativeHandle :: any)(ref, { focus = function(self) end })
			return nil
		end)
		jestExpect(function()
			ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev({
			-- ROBLOX deviation: Lua says `table` instead of `object`
			"Expected useImperativeHandle() second argument to be a function "
				.. "that creates a handle. Instead received: table.",
		})
	end)
	-- 	it("works with ReactDOMServer calls inside a component", function()
	-- 		local useState = React.useState
	-- 		local function App(props)
	-- 			local markup1 = ReactDOMServer:renderToString(
	-- 				React.createElement("p", nil, "hello")
	-- 			)
	-- 			local markup2 = ReactDOMServer:renderToStaticMarkup(
	-- 				React.createElement("p", nil, "bye")
	-- 			)
	-- 			local counter = useState(0)
	-- 			return markup1 + counter + markup2
	-- 		end
	-- 		local root = ReactTestRenderer.create(React.createElement(App))
	-- 		jestExpect(root.toJSON()).toMatchSnapshot()
	-- 	end)
	it("throws when calling hooks inside .memo's compare function", function()
		local useState = React.useState
		local function App()
			useState(0)
			return nil
		end
		local MemoApp = React.memo(App, function()
			useState(0)
			return false
		end)
		local root = ReactTestRenderer.create(React.createElement(MemoApp))
		jestExpect(function()
			return root.update(React.createElement(MemoApp))
		end).toThrow(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
		jestExpect(function()
			return root.update(React.createElement(MemoApp))
		end).never.toThrow(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
		jestExpect(function()
			return root.update(React.createElement(MemoApp))
		end).toThrow(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
	end)
	it("warns when calling hooks inside useMemo", function()
		local useMemo, useState = React.useMemo, React.useState
		local function App()
			useMemo(function()
				useState(0)
				return nil
			end)
			return nil
		end
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev(
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks."
		)
	end)
	it("warns when reading context inside useMemo", function()
		local useMemo, createContext = React.useMemo, React.createContext
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = createContext("light")
		local function App()
			return useMemo(function()
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				return ReactCurrentDispatcher.current.readContext(ThemeContext)
			end, {})
		end
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev("Context can only be read while React is rendering")
	end)
	it("warns when reading context inside useMemo after reading outside it", function()
		local useMemo, createContext = React.useMemo, React.createContext
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = createContext("light")
		local firstRead, secondRead
		local function App()
			-- ROBLOX TODO: this assert/invariant should be in upstream
			assert(ReactCurrentDispatcher.current ~= nil, "current dispatcher is nil!")
			firstRead = ReactCurrentDispatcher.current.readContext(ThemeContext)
			useMemo(function()
				return nil
			end)
			secondRead = ReactCurrentDispatcher.current.readContext(ThemeContext)
			return useMemo(function()
				return ReactCurrentDispatcher.current.readContext(ThemeContext)
			end, {})
		end
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev("Context can only be read while React is rendering")
		jestExpect(firstRead).toBe("light")
		jestExpect(secondRead).toBe("light")
	end)
	-- ROBLOX FIXME: throw happens in ReactFiberHooks, but error doesn't propagate
	xit("throws when reading context inside useEffect", function()
		local useEffect, createContext = React.useEffect, React.createContext
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = createContext("light")
		local function App()
			useEffect(function()
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				ReactCurrentDispatcher.current.readContext(ThemeContext)
			end)
			return nil
		end
		jestExpect(function()
			act(function()
				ReactTestRenderer.create(React.createElement(App))
			end)
		end).toThrow("Context can only be read while React is rendering")
	end)
	it("throws when reading context inside useLayoutEffect", function()
		local useLayoutEffect, createContext = React.useLayoutEffect, React.createContext
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = createContext("light")
		local function App()
			useLayoutEffect(function()
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				ReactCurrentDispatcher.current.readContext(ThemeContext)
			end)
			return nil
		end
		-- ROBLOX Test Noise: jest setup config makes this hide error
		-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toThrow("Context can only be read while React is rendering")
	end)
	it("warns when reading context inside useReducer", function()
		local useReducer, createContext = React.useReducer, React.createContext
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = createContext("light")
		local function App()
			local state, dispatch = useReducer(function(s, action)
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				ReactCurrentDispatcher.current.readContext(ThemeContext)
				return action
			end, 0)
			if state == 0 then
				dispatch(1)
			end
			return nil
		end
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev({ "Context can only be read while React is rendering" })
	end)
	it("warns when reading context inside eager useReducer", function()
		local useState, createContext = React.useState, React.createContext
		local ThemeContext = createContext("light")
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local _setState
		local function Fn()
			-- ROBLOX TODO: this is `0` upstream, which is incorrect
			local _, setState = useState(nil :: string?)
			_setState = setState
			return nil
		end
		local Cls = React.Component:extend("Cls")
		function Cls:render()
			_setState(function()
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				return ReactCurrentDispatcher.current.readContext(ThemeContext)
			end)
			return nil
		end
		jestExpect(function()
			return ReactTestRenderer.create(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Fn),
					React.createElement(Cls)
				)
			)
		end).toErrorDev({
			"Context can only be read while React is rendering",
			"Cannot update a component (`Fn`) while rendering a different component (`Cls`).",
		})
	end)
	it("warns when calling hooks inside useReducer", function()
		local useReducer, useState, useRef =
			React.useReducer, React.useState, React.useRef
		local function App()
			-- ROBLOX Luau FIXME: Luau should know x is number because of the useReducer<> generic: https://jira.rbx.com/browse/CLI-29033
			-- ROBLOX Luau FIXME: I have to explicit add _action: nil, but it should be inferred: https://jira.rbx.com/browse/CLI-49121
			local value, dispatch = useReducer(function(state: number, _action)
				useRef(0)
				return state + 1
			end, 0)
			if value == 0 then
				dispatch("foo")
			end
			useState(0)
			return value
		end
		jestExpect(function()
			jestExpect(function()
				ReactTestRenderer.create(React.createElement(App))
			end).toThrow("Rendered more hooks than during the previous render.")
		end).toErrorDev({
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
			"Warning: React has detected a change in the order of Hooks called by App. "
				.. "This will lead to bugs and errors if not fixed. For more information, "
				.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
				.. "   Previous render            Next render\n"
				.. "   ------------------------------------------------------\n"
				.. "1. useReducer                 useReducer\n"
				.. "2. useState                   useRef\n"
				.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n",
		})
	end)
	it("warns when calling hooks inside useState's initialize function", function()
		local useState, useRef = React.useState, React.useRef
		local function App()
			useState(function()
				useRef(0)
				return 0
			end)
			return nil
		end
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(App))
		end).toErrorDev(
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks."
		)
	end)
	it("resets warning internal state when interrupted by an error", function()
		local ReactCurrentDispatcher =
			React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
		local ThemeContext = React.createContext("light")
		local function App()
			React.useMemo(function()
				-- ROBLOX TODO: this assert/invariant should be in upstream
				assert(
					ReactCurrentDispatcher.current ~= nil,
					"current dispatcher is nil!"
				)
				ReactCurrentDispatcher.current.readContext(ThemeContext)
				React.useRef(0)
				error(Error.new("No."))
			end, {})
		end
		type Boundary = { state: any, render: any } --\[\[ ROBLOX TODO: replace 'any' type/ add missing \]\]
		local Boundary = React.Component:extend("Boundary")
		function Boundary:init()
			self:setState({})
		end
		function Boundary.getDerivedStateFromError(error_)
			return { err = true }
		end
		function Boundary:render()
			if self.state.err then
				return "Oops"
			end
			return self.props.children
		end
		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(Boundary, nil, React.createElement(App))
			)
		end).toErrorDev({
			"Context can only be read while React is rendering",
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
			"Context can only be read while React is rendering",
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
		})
		local function Valid()
			React.useState(0)
			React.useMemo(function()
				return nil
			end)
			React.useReducer(function()
				return nil
			end, 0)
			React.useEffect(function() end)
			React.useLayoutEffect(function() end)
			React.useCallback(function() end)
			React.useRef(0)
			React.useImperativeHandle(function()
				return nil
			end, function()
				return nil
			end)
			if _G.__DEV__ then
				React.useDebugValue(0)
			end
			return nil
		end
		act(function()
			ReactTestRenderer.create(React.createElement(Valid))
		end)
		jestExpect(function()
			ReactTestRenderer.create(
				React.createElement(Boundary, nil, React.createElement(App))
			)
		end).toErrorDev({
			"Context can only be read while React is rendering",
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
			"Context can only be read while React is rendering",
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks",
		})
	end)
	-- ROBLOX deviation: upstream has 2 tests with same name, which TestEZ doesn't allow
	it("double-invokes components with Hooks in Strict Mode", function()
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = true
		local useState, StrictMode = React.useState, React.StrictMode
		local renderCount = 0
		local function NoHooks()
			renderCount += 1
			return React.createElement("div")
		end
		local function HasHooks()
			useState(0)
			renderCount += 1
			return React.createElement("div")
		end
		local FwdRef = React.forwardRef(function(props, ref)
			renderCount += 1
			return React.createElement("div")
		end)
		local FwdRefHasHooks = React.forwardRef(function(props, ref)
			useState(0)
			renderCount += 1
			return React.createElement("div")
		end)
		local Memo = React.memo(function(props)
			renderCount += 1
			return React.createElement("div")
		end)
		local MemoHasHooks = React.memo(function(props)
			useState(0)
			renderCount += 1
			return React.createElement("div")
		end)
		local function Factory()
			return {
				state = {},
				render = function(self)
					renderCount += 1
					return React.createElement("div")
				end,
			}
		end
		local renderer = ReactTestRenderer.create(nil)
		renderCount = 0
		renderer.update(React.createElement(NoHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(NoHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(NoHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(NoHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(React.createElement(FwdRef))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(FwdRef))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(StrictMode, nil, React.createElement(FwdRef)))
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(React.createElement(StrictMode, nil, React.createElement(FwdRef)))
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(React.createElement(Memo, { arg = 1 }))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(Memo, { arg = 2 }))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(Memo, { arg = 1 }))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(Memo, { arg = 2 }))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		if not ReactFeatureFlags.disableModulePatternComponents then
			renderCount = 0
			jestExpect(function()
				return renderer.update(React.createElement(Factory))
			end).toErrorDev(
				"Warning: The <Factory /> component appears to be a function component that returns a class instance. "
					.. "Change Factory to a class that extends React.Component instead. "
				-- ROBLOX deviation: we exclude this JS specific advice
				-- .. "If you can't use a class try assigning the prototype on the function as a workaround. "
				-- .. "`Factory.prototype = React.Component.prototype`. "
				-- .. "Don't use an arrow function since it cannot be called with `new` by React."
			)
			jestExpect(renderCount).toBe(1)
			renderCount = 0
			renderer.update(React.createElement(Factory))
			jestExpect(renderCount).toBe(1)
			renderCount = 0
			renderer.update(
				React.createElement(StrictMode, nil, React.createElement(Factory))
			)
			jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
			renderCount = 0
			renderer.update(
				React.createElement(StrictMode, nil, React.createElement(Factory))
			)
			jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		end
		renderCount = 0
		renderer.update(React.createElement(HasHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(HasHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(HasHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(HasHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(React.createElement(FwdRefHasHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(FwdRefHasHooks))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(FwdRefHasHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(
			React.createElement(StrictMode, nil, React.createElement(FwdRefHasHooks))
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(React.createElement(MemoHasHooks, { arg = 1 }))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(React.createElement(MemoHasHooks, { arg = 2 }))
		jestExpect(renderCount).toBe(1)
		renderCount = 0
		renderer.update(
			React.createElement(
				StrictMode,
				nil,
				React.createElement(MemoHasHooks, { arg = 1 })
			)
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		renderCount = 0
		renderer.update(
			React.createElement(
				StrictMode,
				nil,
				React.createElement(MemoHasHooks, { arg = 2 })
			)
		)
		jestExpect(renderCount).toBe(_G.__DEV__ and 2 or 1)
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
	end)
	it("double-invokes useMemo in DEV StrictMode despite []", function()
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = true
		local useMemo, StrictMode = React.useMemo, React.StrictMode
		local useMemoCount = 0
		local function BadUseMemo()
			useMemo(function()
				useMemoCount += 1
				return nil
			end, {})
			return React.createElement("div")
		end
		useMemoCount = 0
		ReactTestRenderer.create(
			React.createElement(StrictMode, nil, React.createElement(BadUseMemo))
		)
		jestExpect(useMemoCount).toBe(_G.__DEV__ and 2 or 1)
		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
	end)
	describe("hook ordering", function()
		local function useCallbackHelper()
			return React.useCallback(function() end, {})
		end
		local function useContextHelper()
			return React.useContext(React.createContext(0))
		end
		local function useDebugValueHelper()
			React.useDebugValue("abc")
		end
		local function useEffectHelper()
			React.useEffect(function()
				return function() end
			end, {})
		end
		local function useImperativeHandleHelper()
			React.useImperativeHandle({ current = 0 }, function()
				return 0
			end, {})
		end
		local function useLayoutEffectHelper()
			React.useLayoutEffect(function()
				return function() end
			end, {})
		end
		local function useMemoHelper()
			return React.useMemo(function()
				return 123
			end, {})
		end
		local function useReducerHelper()
			return React.useReducer(function(s, a)
				return a
			end, 0)
		end
		local function useRefHelper()
			return React.useRef(nil)
		end
		local function useStateHelper(): number
			return React.useState(0)
		end
		local orderedHooks: Array<Function> = {
			useCallbackHelper,
			useContextHelper,
			useDebugValueHelper,
			useEffectHelper,
			useLayoutEffectHelper,
			useMemoHelper,
			useReducerHelper,
			useRefHelper,
			useStateHelper,
		}
		local hooksInList: Array<Function> = {
			useCallbackHelper,
			useEffectHelper,
			useImperativeHandleHelper,
			useLayoutEffectHelper,
			useMemoHelper,
			useReducerHelper,
			useRefHelper,
			useStateHelper,
		}
		-- ROBLOX TODO: unflag this when we implement useTransition and useDeferredValueHelper
		if _G.__EXPERIMENTAL__ then
			-- local function useTransitionHelper()
			-- 	return React.useTransition()
			-- end
			-- local function useDeferredValueHelper()
			-- 	return React.useDeferredValue(0, { timeoutMs = 1000 })
			-- end
			-- table.insert(orderedHooks, useTransitionHelper)
			-- table.insert(orderedHooks, useDeferredValueHelper)
			-- table.insert(hooksInList, useTransitionHelper)
			-- table.insert(hooksInList, useDeferredValueHelper)
		end
		local function formatHookNamesToMatchErrorMessage(hookNameA, hookNameB)
			return string.format(
				"use%s%s%s",
				hookNameA,
				string.rep(" ", 24 - string.len(hookNameA)),
				(function()
					if hookNameB then
						return string.format("use%s", hookNameB)
					else
						return ""
					end
				end)()
			)
		end
		-- ROBLOX Luau FIXME: Luau should infer the correct T and not require explicit annotations here
		Array.forEach(orderedHooks, function(firstHelper: () -> (), index: number)
			local secondHelper = (function()
				if
					index
					> 0 --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
				then
					return orderedHooks[index]
				else
					return orderedHooks[#orderedHooks]
				end
			end)()
			-- ROBLOX deviation: functions can't have fields in Lua
			-- local hookNameA = firstHelper.name
			local hookNameA =
				debug.info(firstHelper, "n"):gsub("use", ""):gsub("Helper", "")
			-- ROBLOX deviation: functions can't have fields in Lua
			-- local hookNameB = secondHelper.name
			local hookNameB =
				debug.info(secondHelper, "n"):gsub("use", ""):gsub("Helper", "")
			-- ROBLOX FIXME: gives error about fewer hooks than expected instead
			xit(
				("warns on using differently ordered hooks (%s, %s) on subsequent renders"):format(
					hookNameA,
					hookNameB
				),
				function()
					local function App(props)
						if props.update then
							secondHelper()
							firstHelper()
						else
							firstHelper()
							secondHelper()
						end
						useRefHelper()
						return nil
					end
					local root
					act(function()
						root = ReactTestRenderer.create(
							React.createElement(App, { update = false })
						)
					end)
					jestExpect(function()
						xpcall(function()
							act(function()
								root.update(React.createElement(App, { update = true }))
							end)
						end, function(error_) end)
					end).toErrorDev({
						"Warning: React has detected a change in the order of Hooks called by App. "
							.. "This will lead to bugs and errors if not fixed. For more information, "
							.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
							.. "   Previous render            Next render\n"
							.. "   ------------------------------------------------------\n"
							.. string.format(
								"1. %s\n",
								formatHookNamesToMatchErrorMessage(hookNameA, hookNameB)
							)
							.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n"
							.. "    in App (at **)",
					})
					xpcall(function()
						act(function()
							root.update(React.createElement(App, { update = false }))
						end)
					end, function(error_) end)
				end
			)
			it(
				string.format(
					"warns when more hooks (%s, %s) are used during update than mount",
					hookNameA,
					hookNameB
				),
				function()
					local function App(props)
						if props.update then
							firstHelper()
							secondHelper()
						else
							firstHelper()
						end
						return nil
					end
					local root
					act(function()
						root = ReactTestRenderer.create(
							React.createElement(App, { update = false })
						)
					end)
					jestExpect(function()
						xpcall(function()
							act(function()
								root.update(React.createElement(App, { update = true }))
							end)
						end, function(error_) end)
					end).toErrorDev({
						"Warning: React has detected a change in the order of Hooks called by App. "
							.. "This will lead to bugs and errors if not fixed. For more information, "
							.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
							.. "   Previous render            Next render\n"
							.. "   ------------------------------------------------------\n"
							.. string.format(
								"1. %s\n",
								formatHookNamesToMatchErrorMessage(hookNameA, hookNameA)
							)
							.. ("2. undefined                  use%s\n"):format(hookNameB)
							.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n"
							.. "    in App (at **)",
					})
				end
			)
		end)
		-- ROBLOX Luau FIXME: Luau should infer the correct T and not require explicit annotations here
		Array.forEach(hooksInList, function(firstHelper: () -> (), index: number)
			local secondHelper = (function()
				if
					index
					> 0 --\[\[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number \]\]
				then
					return hooksInList[index]
				else
					return hooksInList[#hooksInList]
				end
			end)()
			-- ROBLOX deviation: functions can't have fields in Lua
			-- local hookNameA = firstHelper.name
			local hookNameA =
				debug.info(firstHelper, "n"):gsub("use", ""):gsub("Helper", "")
			-- ROBLOX deviation: functions can't have fields in Lua
			-- local hookNameB = secondHelper.name
			local hookNameB =
				debug.info(secondHelper, "n"):gsub("use", ""):gsub("Helper", "")
			-- ROBLOX FIXME: it is throwing the error, but toThrowError isn't unpacking the Error object?
			xit(
				string.format(
					"warns when fewer hooks (%s, %s) are used during update than mount",
					hookNameA,
					hookNameB
				),
				function()
					local function App(props)
						if props.update then
							firstHelper()
						else
							firstHelper()
							secondHelper()
						end
						return nil
					end
					local root
					act(function()
						root = ReactTestRenderer.create(
							React.createElement(App, { update = false })
						)
					end)
					jestExpect(function()
						act(function()
							root.update(React.createElement(App, { update = true }))
						end)
					end).toThrow("Rendered fewer hooks than expected.")
				end
			)
		end)
		-- ROBLOX FIXME: gives fewer hooks rendered error instead
		xit(
			"warns on using differently ordered hooks "
				.. "(useImperativeHandleHelper, useMemoHelper) on subsequent renders",
			function()
				local function App(props)
					if props.update then
						useMemoHelper()
						useImperativeHandleHelper()
					else
						useImperativeHandleHelper()
						useMemoHelper()
					end
					useRefHelper()
					return nil
				end
				local root =
					ReactTestRenderer.create(React.createElement(App, { update = false }))
				jestExpect(function()
					xpcall(function()
						root.update(React.createElement(App, { update = true }))
					end, function(error_) end)
				end).toErrorDev({
					-- ROBLOX deviation: we put 'Warning' on the front of this for some reason
					"Warning: React has detected a change in the order of Hooks called by App. "
						.. "This will lead to bugs and errors if not fixed. For more information, "
						.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
						.. "   Previous render            Next render\n"
						.. "   ------------------------------------------------------\n"
						.. string.format(
							"1. %s\n",
							formatHookNamesToMatchErrorMessage("ImperativeHandle", "Memo")
						)
						.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n"
						.. "    in App (at **)",
				})
				root.update(React.createElement(App, { update = false }))
			end
		)
		it("detects a bad hook order even if the component throws", function()
			local useState, useReducer = React.useState, React.useReducer
			local function useCustomHook()
				useState(0)
			end
			local function App(props)
				if props.update then
					useCustomHook()
					useReducer(function(s, a)
						return a
					end, 0)
					error(Error.new("custom error"))
				else
					useReducer(function(s, a)
						return a
					end, 0)
					useCustomHook()
				end
				return nil
			end
			local root =
				ReactTestRenderer.create(React.createElement(App, { update = false }))
			jestExpect(function()
				jestExpect(function()
					return root.update(React.createElement(App, { update = true }))
				end).toThrow("custom error")
			end).toErrorDev({
				"Warning: React has detected a change in the order of Hooks called by App. "
					.. "This will lead to bugs and errors if not fixed. For more information, "
					.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
					.. "   Previous render            Next render\n"
					.. "   ------------------------------------------------------\n"
					.. "1. useReducer                 useState\n"
					.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n",
			})
		end)
	end)
	it(
		"does not swallow original error when updating another component in render phase",
		function()
			local useState = React.useState
			local _setState
			local function A()
				local _, setState = useState(0)
				_setState = setState
				return nil
			end
			local function B()
				_setState(function()
					error(Error.new("Hello"))
				end)
				return nil
			end
			jestExpect(function()
				act(function()
					ReactTestRenderer.unstable_batchedUpdates(function()
						ReactTestRenderer.create(
							React.createElement(
								React.Fragment,
								nil,
								React.createElement(A),
								React.createElement(B)
							)
						)
						jestExpect(function()
							Scheduler.unstable_flushAll()
						end).toThrow("Hello")
					end)
				end)
				-- ROBLOX deviation: use toErrorDev instead of spyOn(console, 'error')
			end).toErrorDev(
				"Warning: Cannot update a component (`A`) while rendering "
					.. "a different component (`B`)."
			)
		end
	)
	-- Regression test for https://github.com/facebook/react/issues/15057
	it(
		"does not fire a false positive warning when previous effect unmounts the component",
		function()
			local A, B, C
			local useState, useEffect = React.useState, React.useEffect
			local globalListener
			function A()
				local show, setShow = useState(true)
				local function hideMe()
					setShow(false)
				end
				return if show then React.createElement(B, { hideMe = hideMe }) else nil
			end
			function B(props)
				return React.createElement(C, props)
			end
			function C(ref)
				local hideMe = ref.hideMe
				local _, setState = useState("")
				useEffect(function()
					local isStale = false
					globalListener = function()
						if not isStale then
							setState("hello")
						end
					end
					return function()
						isStale = true
						hideMe()
					end
				end)
				return nil
			end
			act(function()
				ReactTestRenderer.create(React.createElement(A))
			end)
			jestExpect(function()
				globalListener()
				globalListener()
			end).toErrorDev({
				"An update to C inside a test was not wrapped in act",
				"An update to C inside a test was not wrapped in act",
			})
		end
	)
	it("does not fire a false positive warning when suspending memo", function()
		local Suspense, useState = React.Suspense, React.useState
		local wasSuspended = false
		local function trySuspend()
			if not wasSuspended then
				error(Promise.delay(0):andThen(function(resolve)
					wasSuspended = true
					resolve()
				end))
			end
		end
		local function Child()
			useState(0)
			trySuspend()
			return "hello"
		end
		local Wrapper = React.memo(Child)
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{ fallback = "loading" },
				React.createElement(Wrapper)
			)
		)
		jestExpect(root).toMatchRenderedOutput("loading")
		Promise.delay(0):await()
		Scheduler.unstable_flushAll()
		jestExpect(root).toMatchRenderedOutput("hello")
	end)
	it("does not fire a false positive warning when suspending forwardRef", function()
		local Suspense, useState = React.Suspense, React.useState
		local wasSuspended = false
		local function trySuspend()
			if not wasSuspended then
				error(Promise.delay(0):andThen(function(resolve)
					wasSuspended = true
					resolve()
				end))
			end
		end
		local function render(props, ref)
			useState(0)
			trySuspend()
			return "hello"
		end
		local Wrapper = React.forwardRef(render)
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{ fallback = "loading" },
				React.createElement(Wrapper)
			)
		)
		jestExpect(root).toMatchRenderedOutput("loading")
		Promise.delay(0):await()
		Scheduler.unstable_flushAll()
		jestExpect(root).toMatchRenderedOutput("hello")
	end)
	it(
		"does not fire a false positive warning when suspending memo(forwardRef)",
		function()
			local Suspense, useState = React.Suspense, React.useState
			local wasSuspended = false
			local function trySuspend()
				if not wasSuspended then
					error(Promise.delay(0):andThen(function(resolve)
						wasSuspended = true
						resolve()
					end))
				end
			end
			local function render(props, ref)
				useState(0)
				trySuspend()
				return "hello"
			end
			local Wrapper = React.memo(React.forwardRef(render))
			local root = ReactTestRenderer.create(
				React.createElement(
					Suspense,
					{ fallback = "loading" },
					React.createElement(Wrapper)
				)
			)
			jestExpect(root).toMatchRenderedOutput("loading")
			Promise.delay(0):await()
			Scheduler.unstable_flushAll()
			jestExpect(root).toMatchRenderedOutput("hello")
		end
	)
	it("resets hooks when an error is thrown in the middle of a list of hooks", function()
		local useEffect, useState = React.useEffect, React.useState
		-- ROBLOX deviation: hoist
		local function Wrapper(props)
			local children = props.children
			return children
		end
		local ErrorBoundary = React.Component:extend("ErrorBoundary")
		function ErrorBoundary:init()
			self:setState({})
		end
		function ErrorBoundary.getDerivedStateFromError()
			return { hasError = true }
		end
		function ErrorBoundary:render()
			return React.createElement(
				Wrapper,
				nil,
				self.state.hasError and "Error!" or self.props.children
			)
		end
		local setShouldThrow
		local function Thrower()
			local shouldThrow, _setShouldThrow = useState(false)
			setShouldThrow = _setShouldThrow
			if shouldThrow then
				error(Error.new("Throw!"))
			end
			useEffect(function() end, {})
			return "Throw!"
		end
		local root
		act(function()
			root = ReactTestRenderer.create(
				React.createElement(ErrorBoundary, nil, React.createElement(Thrower))
			)
		end)
		jestExpect(root).toMatchRenderedOutput("Throw!")
		act(function()
			return setShouldThrow(true)
		end)
		jestExpect(root).toMatchRenderedOutput("Error!")
	end)
end) ]]
eC.Children._f8f84c00f810eec6893cda6466f77cd6=e6
local e7

local e8={ClassName="ModuleScript",Children={},Properties={}}
e8.Name="ReactHooksWithNoopRenderer.spec"
e8.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/99cae887f3a8bde760a111516d254c1225242edf/packages/react-reconciler/src/__tests__/ReactHooksWithNoopRenderer-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

--\[\[ eslint-disable no-func-assign \]\]
local Packages = script.Parent.Parent.Parent
local React

local Promise
local LuauPolyfill = require(Packages.LuauPolyfill)
local clearTimeout = LuauPolyfill.clearTimeout
local setTimeout = LuauPolyfill.setTimeout
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

-- local textCache
-- local readText
-- local resolveText
local ReactNoop
local Scheduler
-- local SchedulerTracing
local Suspense
local useState
local useReducer
local useEffect
local useLayoutEffect
local useCallback
local useMemo
local useRef
-- ROBLOX deviation: binding support
local useBinding
local useImperativeHandle
-- local useTransition
-- local useDeferredValue
local forwardRef
local memo
local act

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	Promise = require(Packages.Promise)

	LuauPolyfill = require(Packages.LuauPolyfill)
	clearTimeout = LuauPolyfill.clearTimeout
	setTimeout = LuauPolyfill.setTimeout

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
	-- SchedulerTracing = require(Scheduler.tracing)
	useState = React.useState
	useReducer = React.useReducer
	useEffect = React.useEffect
	useLayoutEffect = React.useLayoutEffect
	useCallback = React.useCallback
	useMemo = React.useMemo
	useRef = React.useRef
	-- ROBLOX deviation: binding support
	useBinding = React.useBinding
	useImperativeHandle = React.useImperativeHandle
	forwardRef = React.forwardRef
	memo = React.memo
	--   useTransition = React.unstable_useTransition
	--   useDeferredValue = React.unstable_useDeferredValue
	Suspense = React.Suspense
	act = ReactNoop.act

	--   textCache = new Map()

	--   readText = text => {
	--     local record = textCache.get(text)
	--     if record ~= undefined)
	--       switch (record.status)
	--         case 'pending':
	--           throw record.promise
	--         case 'rejected':
	--           throw Error('Failed to load: ' .. text)
	--         case 'resolved':
	--           return text
	--       end
	--     } else {
	--       local ping
	--       local promise = new Promise(resolve => (ping = resolve))
	--       local newRecord = {
	--         status: 'pending',
	--         ping: ping,
	--         promise,
	--       end
	--       textCache.set(text, newRecord)
	--       throw promise
	--     end
	--   end

	--   resolveText = text => {
	--     local record = textCache.get(text)
	--     if record ~= undefined)
	--       if record.status == 'pending')
	--         Scheduler.unstable_yieldValue(`Promise resolved [${text}]`)
	--         record.ping()
	--         record.ping = nil
	--         record.status = 'resolved'
	--         clearTimeout(record.promise._timer)
	--         record.promise = nil
	--       end
	--     } else {
	--       local newRecord = {
	--         ping: nil,
	--         status: 'resolved',
	--         promise: nil,
	--       end
	--       textCache.set(text, newRecord)
	--     end
	--   end
end)

local function span(prop)
	return { type = "span", hidden = false, children = {}, prop = prop }
end

local function Text(props)
	Scheduler.unstable_yieldValue(props.text)
	return React.createElement("span", {
		prop = props.text,
	})
end

-- function AsyncText(props)
--   local text = props.text
--   try {
--     readText(text)
--     Scheduler.unstable_yieldValue(text)
--     return <span prop={text} />
--   } catch (promise)
--     if typeof promise.then == 'function')
--       Scheduler.unstable_yieldValue(`Suspend! [${text}]`)
--       if typeof props.ms == 'number' and promise._timer == undefined)
--         promise._timer = setTimeout(function()
--           resolveText(text)
--         }, props.ms)
--       end
--     } else {
--       Scheduler.unstable_yieldValue(`Error! [${text}]`)
--     end
--     throw promise
--   end
-- end

-- function advanceTimers(ms)
--   -- Note: This advances Jest's virtual time but not React's. Use
--   -- ReactNoop.expire for that.
--   if typeof ms ~= 'number')
--     throw new Error('Must specify ms')
--   end
--   jest.advanceTimersByTime(ms)
--   -- Wait until the end of the current tick
--   -- We cannot use a timer since we're faking them
--   return Promise.resolve().then(function()})
-- end

-- ROBLOX Test Noise: jest setup config makes this hide error
-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
it("resumes after an interruption", function()
	local function Counter(props: { label: string }, ref)
		local count, updateCount = useState(0)
		useImperativeHandle(ref, function()
			return { updateCount = updateCount }
		end)
		return React.createElement(
			Text,
			{ text = tostring(props.label) .. ": " .. count }
		)
	end
	-- ROBLOX TODO: upstream this rename so this can typecheck and be generally sane
	local CounterRef = forwardRef(Counter)

	-- Initial mount
	local counter = React.createRef()
	ReactNoop.render(React.createElement(CounterRef, { label = "Count", ref = counter }))
	jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
	jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

	-- Schedule some updates
	ReactNoop.batchedUpdates(function()
		counter.current.updateCount(1)
		counter.current.updateCount(function(count: number)
			return count + 10
		end)
	end)

	-- Partially flush without committing
	jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 11" })
	jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

	-- Interrupt with a high priority update
	ReactNoop.flushSync(function()
		ReactNoop.render(React.createElement(CounterRef, { label = "Total" }))
	end)
	jestExpect(Scheduler).toHaveYielded({ "Total: 0" })

	-- Resume rendering
	jestExpect(Scheduler).toFlushAndYield({ "Total: 11" })
	jestExpect(ReactNoop.getChildren()).toEqual({ span("Total: 11") })
end)

it("throws inside class components", function()
	local BadCounter = React.Component:extend("BadCounter")
	function BadCounter:render()
		local count = useState(0)
		return React.createElement(Text, { text = self.props.label + ": " .. count })
	end
	ReactNoop.render(React.createElement(BadCounter))

	jestExpect(Scheduler).toFlushAndThrow(
		"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
			.. " one of the following reasons:\n"
			.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
			.. "2. You might be breaking the Rules of Hooks\n"
			.. "3. You might have more than one copy of React in the same app\n"
			.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
	)

	-- Confirm that a subsequent hook works properly.
	local function GoodCounter(props, ref)
		local count = useState(props.initialCount)
		return React.createElement(Text, { text = count })
	end
	ReactNoop.render(React.createElement(GoodCounter, { initialCount = 10 }))
	jestExpect(Scheduler).toFlushAndYield({ 10 })
end)

-- if !require('shared/ReactFeatureFlags').disableModulePatternComponents)
--   it('throws inside module-style components', function()
--     function Counter()
--       return {
--         render()
--           local [count] = useState(0)
--           return <Text text={this.props.label + ': ' .. count} />
--         },
--       end
--     end
--     ReactNoop.render(<Counter />)
--     jestExpect(function()
--       jestExpect(Scheduler).toFlushAndThrow(
--         'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen ' ..
--           'for one of the following reasons:\n' ..
--           '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' ..
--           '2. You might be breaking the Rules of Hooks\n' ..
--           '3. You might have more than one copy of React in the same app\n' ..
--           'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
--       ),
--     ).toErrorDev(
--       'Warning: The <Counter /> component appears to be a function component that returns a class instance. ' ..
--         'Change Counter to a class that extends React.Component instead. ' ..
--         "If you can't use a class try assigning the prototype on the function as a workaround. " ..
--         '`Counter.prototype = React.Component.prototype`. ' ..
--         "Don't use an arrow function since it cannot be called with `new` by React.",
--     )

--     -- Confirm that a subsequent hook works properly.
--     function GoodCounter(props)
--       local [count] = useState(props.initialCount)
--       return <Text text={count} />
--     end
--     ReactNoop.render(<GoodCounter initialCount={10} />)
--     jestExpect(Scheduler).toFlushAndYield([10])
--   })
-- end

-- ROBLOX note: test aligned to React 18 so we get a hot path optimization in upstream
it("throws when called outside the render phase", function()
	jestExpect(function()
		jestExpect(function()
			useState(0)
		end).toThrow(
			-- ROBLOX deviation: Lua-specific error on nil deref
			"attempt to index nil with 'useState'"
		)
	end).toErrorDev(
		"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
			.. " one of the following reasons:\n"
			.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
			.. "2. You might be breaking the Rules of Hooks\n"
			.. "3. You might have more than one copy of React in the same app\n"
			.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.",
		{ withoutStack = true }
	)
end)

describe("useState", function()
	it("simple mount and update", function()
		local function Counter(props, ref)
			local count, updateCount = useState(0)
			useImperativeHandle(ref, function()
				return { updateCount = updateCount }
			end)
			return React.createElement(Text, { text = "Count: " .. count })
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, { ref = counter }))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		act(function()
			return counter.current.updateCount(1)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })

		act(function()
			-- ROBLOX FIXME Luau: Luau should know updateCount takes is ((number) -> number)
			return counter.current.updateCount(function(count_: number)
				return count_ + 10
			end)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 11" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 11") })
	end)

	it("lazy state initializer", function()
		local function Counter(props, ref)
			local count, updateCount = useState(function()
				Scheduler.unstable_yieldValue("getInitialState")
				return props.initialState
			end)
			useImperativeHandle(ref, function()
				return { updateCount = updateCount }
			end)
			return React.createElement(Text, { text = "Count: " .. count })
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(
			React.createElement(CounterRef, { initialState = 42, ref = counter })
		)
		jestExpect(Scheduler).toFlushAndYield({ "getInitialState", "Count: 42" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 42") })

		act(function()
			return counter.current.updateCount(7)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 7" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 7") })
	end)

	it("multiple states", function()
		local function Counter(props, ref)
			local count, updateCount = useState(0)
			local label, updateLabel = useState("Count")
			useImperativeHandle(ref, function()
				return {
					updateCount = updateCount,
					updateLabel = updateLabel,
				}
			end)
			return React.createElement(Text, { text = label .. ": " .. count })
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, { ref = counter }))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		act(function()
			return counter.current.updateCount(7)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 7" })

		act(function()
			return counter.current.updateLabel("Total")
		end)
		jestExpect(Scheduler).toHaveYielded({ "Total: 7" })
	end)

	it("returns the same updater function every time", function()
		local updater = nil
		local function Counter()
			local count, updateCount = useState(0)
			updater = updateCount
			return React.createElement(Text, { text = "Count: " .. count })
		end
		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		local firstUpdater = updater

		act(function()
			return firstUpdater(1)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })

		local secondUpdater = updater

		act(function()
			return firstUpdater(function(count)
				return count + 10
			end)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 11" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 11") })

		jestExpect(firstUpdater).toEqual(secondUpdater)
	end)

	it("does not warn on set after unmount", function()
		local _, updateCount
		local function Counter(props, ref)
			_, updateCount = useState(0)
			return nil
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushWithoutYielding()
		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushWithoutYielding()
		act(function()
			updateCount(1)
		end)
	end)

	it("works with memo", function()
		local count, updateCount
		local function Counter()
			count, updateCount = useState(0)
			return React.createElement(Text, { text = "Count: " .. count })
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterMemo = memo(Counter)

		ReactNoop.render(React.createElement(CounterMemo))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		ReactNoop.render(React.createElement(CounterMemo))
		jestExpect(Scheduler).toFlushAndYield({})
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		act(function()
			return updateCount(1)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
	end)
end)

describe("updates during the render phase", function()
	it("restarts the render function and applies the new updates on top", function()
		local function ScrollView(props)
			-- ROBLOX LUAU FIXME: without annotation, generates the
			-- following error:
			-- roact-alignment\modules\react-reconciler\src\__tests__\ReactHooksWithNoopRenderer.spec.lua:473:53-63: (E001) TypeError: Type '{ row: number }' could not be converted into 'any?'
			-- caused by:
			--   None of the union options are compatible. For example: Type '{ row: number }' could not be converted into '{+ row: never +}'
			-- caused by:
			--   Property 'row' is not compatible. Type 'number' could not be converted into 'never'
			local newRow: number = props.row
			local isScrollingDown, setIsScrollingDown = useState(false)
			local row, setRow = useState(nil :: number?)

			if row ~= newRow then
				-- Row changed since last render. Update isScrollingDown.
				setIsScrollingDown(row ~= nil and newRow > row)
				setRow(newRow)
			end

			return React.createElement(Text, {
				text = string.format("Scrolling down: %s", tostring(isScrollingDown)),
			})
		end

		ReactNoop.render(React.createElement(ScrollView, { row = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: false" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: false") })

		ReactNoop.render(React.createElement(ScrollView, { row = 5 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: true" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: true") })

		ReactNoop.render(React.createElement(ScrollView, { row = 5 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: true" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: true") })

		ReactNoop.render(React.createElement(ScrollView, { row = 10 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: true" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: true") })

		ReactNoop.render(React.createElement(ScrollView, { row = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: false" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: false") })

		ReactNoop.render(React.createElement(ScrollView, { row = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "Scrolling down: false" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Scrolling down: false") })
	end)

	-- ROBLOX TODO: this test uses await, need to figure that out
	--   it('warns about render phase update on a different component', async function()
	--     local setStep
	--     function Foo()
	--       local [step, _setStep] = useState(0)
	--       setStep = _setStep
	--       return <Text text={`Foo [${step}]`} />
	--     end

	--     function Bar({triggerUpdate})
	--       if triggerUpdate)
	--         setStep(x => x + 1)
	--       end
	--       return <Text text="Bar" />
	--     end

	--     local root = ReactNoop.createRoot()

	--     await ReactNoop.act(async function()
	--       root.render(
	--         <>
	--           <Foo />
	--           <Bar />
	--         </>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded(['Foo [0]', 'Bar'])

	--     -- Bar will update Foo during its render phase. React should warn.
	--     await ReactNoop.act(async function()
	--       root.render(
	--         <>
	--           <Foo />
	--           <Bar triggerUpdate={true} />
	--         </>,
	--       )
	--       jestExpect(function()
	--         jestExpect(Scheduler).toFlushAndYield(
	--           __DEV__
	--             ? ['Foo [0]', 'Bar', 'Foo [2]']
	--             : ['Foo [0]', 'Bar', 'Foo [1]'],
	--         ),
	--       ).toErrorDev([
	--         'Cannot update a component (`Foo`) while rendering a ' ..
	--           'different component (`Bar`). To locate the bad setState() call inside `Bar`',
	--       ])
	--     })

	--     -- It should not warn again (deduplication).
	--     await ReactNoop.act(async function()
	--       root.render(
	--         <>
	--           <Foo />
	--           <Bar triggerUpdate={true} />
	--         </>,
	--       )
	--       jestExpect(Scheduler).toFlushAndYield(
	--         __DEV__
	--           ? ['Foo [2]', 'Bar', 'Foo [4]']
	--           : ['Foo [1]', 'Bar', 'Foo [2]'],
	--       )
	--     })
	--   })

	it("keeps restarting until there are no more new updates", function()
		local function Counter()
			local count, setCount = useState(0)
			if count < 3 then
				setCount(count + 1)
			end
			Scheduler.unstable_yieldValue("Render: " .. count)
			return React.createElement(Text, { text = count })
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({
			"Render: 0",
			"Render: 1",
			"Render: 2",
			"Render: 3",
			3,
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(3) })
	end)

	it("updates multiple times within same render function", function()
		local function Counter()
			local count, setCount = useState(0)
			if count < 12 then
				setCount(function(c)
					return c + 1
				end)
				setCount(function(c)
					return c + 1
				end)
				setCount(function(c)
					return c + 1
				end)
			end
			Scheduler.unstable_yieldValue("Render: " .. count)
			return React.createElement(Text, { text = count })
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({
			-- Should increase by three each time
			"Render: 0",
			"Render: 3",
			"Render: 6",
			"Render: 9",
			"Render: 12",
			12,
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(12) })
	end)

	it("throws after too many iterations", function()
		local function Counter()
			local count, setCount = useState(0)
			setCount(count + 1)
			Scheduler.unstable_yieldValue("Render: " .. count)
			return React.createElement(Text, { text = count })
		end
		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndThrow(
			"Too many re-renders. React limits the number of renders to prevent "
				.. "an infinite loop."
		)
	end)

	it("works with useReducer", function()
		local function reducer(state: number, action)
			local returnVal = state
			if action == "increment" then
				returnVal = state + 1
			end
			return returnVal
		end
		local function Counter(props)
			local count, dispatch = useReducer(reducer, 0)
			if count < 3 then
				dispatch("increment")
			end
			Scheduler.unstable_yieldValue("Render: " .. count)
			return React.createElement(Text, { text = count })
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({
			"Render: 0",
			"Render: 1",
			"Render: 2",
			"Render: 3",
			3,
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(3) })
	end)

	it("uses reducer passed at time of render, not time of dispatch", function()
		-- This test is a bit contrived but it demonstrates a subtle edge case.

		-- Reducer A increments by 1. Reducer B increments by 10.
		local function reducerA(state: number, action)
			if action == "increment" then
				return state + 1
			elseif action == "reset" then
				return 0
			end
			-- ROBLOX deviation: upstream has no case, but Luau wants an explicit return
			return 0
		end

		local function reducerB(state: number, action)
			if action == "increment" then
				return state + 10
			elseif action == "reset" then
				return 0
			end
			-- ROBLOX deviation: upstream has no case, but Luau wants an explicit return
			return 0
		end

		local function Counter(props, ref)
			local reducer_, setReducer = useState(function()
				return reducerA
			end)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				return { dispatch = dispatch }
			end)
			if count < 20 then
				dispatch("increment")
				-- Swap reducers each time we increment
				if reducer_ == reducerA then
					setReducer(function()
						return reducerB
					end)
				else
					setReducer(function()
						return reducerA
					end)
				end
			end
			Scheduler.unstable_yieldValue("Render: " .. count)
			return React.createElement(Text, { text = count })
		end

		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, { ref = counter }))
		jestExpect(Scheduler).toFlushAndYield({
			-- The count should increase by alternating amounts of 10 and 1
			-- until we reach 21.
			"Render: 0",
			"Render: 10",
			"Render: 11",
			"Render: 21",
			21,
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(21) })

		-- Test that it works on update, too. This time the log is a bit different
		-- because we started with reducerB instead of reducerA.
		ReactNoop.act(function()
			counter.current.dispatch("reset")
		end)
		ReactNoop.render(React.createElement(CounterRef, { ref = counter }))
		jestExpect(Scheduler).toHaveYielded({
			"Render: 0",
			"Render: 1",
			"Render: 11",
			"Render: 12",
			"Render: 22",
			22,
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(22) })
	end)
	it("discards render phase updates if something suspends", function()
		local thenable = { andThen = function() end }
		local Bar

		local function Foo(props)
			local signal = props.signal
			return React.createElement(
				Suspense,
				{ fallback = "Loading..." },
				React.createElement(Bar, { signal = signal })
			)
		end

		function Bar(props)
			local newSignal = props.signal
			local counter, setCounter = useState(0)
			local signal, setSignal = useState(true)

			-- Increment a counter every time the signal changes
			if signal ~= newSignal then
				setCounter(function(c)
					return c + 1
				end)
				setSignal(newSignal)
				if counter == 0 then
					-- We're suspending during a render that includes render phase
					-- updates. Those updates should not persist to the next render.
					Scheduler.unstable_yieldValue("Suspend!")
					error(thenable)
				end
			end

			return React.createElement(Text, { text = counter })
		end

		local root = ReactNoop.createRoot()
		root.render(React.createElement(Foo, { signal = true }))

		jestExpect(Scheduler).toFlushAndYield({ 0 })
		jestExpect(root).toMatchRenderedOutput(React.createElement("span", { prop = 0 }))

		root.render(React.createElement(Foo, { signal = false }))
		jestExpect(Scheduler).toFlushAndYield({ "Suspend!" })
		jestExpect(root).toMatchRenderedOutput(React.createElement("span", { prop = 0 }))

		-- Rendering again should suspend again.
		root.render(React.createElement(Foo, { signal = false }))
		jestExpect(Scheduler).toFlushAndYield({ "Suspend!" })
	end)
	it(
		"discards render phase updates if something suspends, but not other updates in the same component",
		function()
			local thenable = { andThen = function() end }
			local Bar

			local function Foo(props)
				local signal = props.signal
				return React.createElement(
					Suspense,
					{ fallback = "Loading..." },
					React.createElement(Bar, { signal = signal })
				)
			end

			local setLabel

			function Bar(props)
				local newSignal = props.signal
				local counter, setCounter = useState(0)

				if counter == 1 then
					-- We're suspending during a render that includes render phase
					-- updates. Those updates should not persist to the next render.
					Scheduler.unstable_yieldValue("Suspend!")
					error(thenable)
				end

				local signal, setSignal = useState(true)

				-- Increment a counter every time the signal changes
				if signal ~= newSignal then
					setCounter(function(c)
						return c + 1
					end)
					setSignal(newSignal)
				end

				local label, _setLabel = useState("A")
				setLabel = _setLabel

				return React.createElement(
					Text,
					{ text = label .. ":" .. tostring(counter) }
				)
			end

			local root = ReactNoop.createRoot()
			root.render(React.createElement(Foo, { signal = true }))

			jestExpect(Scheduler).toFlushAndYield({ "A:0" })
			jestExpect(root).toMatchRenderedOutput(
				React.createElement("span", { prop = "A:0" })
			)

			ReactNoop.act(function()
				root.render(React.createElement(Foo, { signal = false }))
				setLabel("B")

				jestExpect(Scheduler).toFlushAndYield({ "Suspend!" })
				jestExpect(root).toMatchRenderedOutput(
					React.createElement("span", { prop = "A:0" })
				)

				-- Rendering again should suspend again.
				root.render(React.createElement(Foo, { signal = false }))
				jestExpect(Scheduler).toFlushAndYield({ "Suspend!" })

				-- Flip the signal back to "cancel" the update. However, the update to
				-- label should still proceed. It shouldn't have been dropped.
				root.render(React.createElement(Foo, { signal = true }))
				jestExpect(Scheduler).toFlushAndYield({ "B:0" })
				jestExpect(root).toMatchRenderedOutput(
					React.createElement("span", { prop = "B:0" })
				)
				return Promise.resolve()
			end)
		end
	)

	it("regression: render phase updates cause lower pri work to be dropped", function()
		local setRow
		local function ScrollView()
			local row, _setRow = useState(10)
			setRow = _setRow

			local scrollDirection, setScrollDirection = useState("Up")
			-- ROBLOX TODO Luau? it would be nice if setPrevRow usage in the closure informed this `nil` so we didn't need this annotation
			local prevRow, setPrevRow = useState((nil :: any) :: number)

			if prevRow ~= row then
				local direction = "Up"
				if prevRow ~= nil and row > prevRow then
					direction = "Down"
				end
				setScrollDirection(direction)
				-- ROBLOX FIXME Luau: even with explicit nubmer? annotation above, we still get None of the union options are compatible. For example: Type 'number' could not be converted into '(nil) -> nil'
				setPrevRow(row)
			end

			return React.createElement(Text, { text = scrollDirection })
		end

		local root = ReactNoop.createRoot()

		act(function()
			root.render(React.createElement(ScrollView, { row = 10 }))
		end)
		jestExpect(Scheduler).toHaveYielded({ "Up" })
		jestExpect(root).toMatchRenderedOutput(
			React.createElement("span", { prop = "Up" })
		)

		act(function()
			ReactNoop.discreteUpdates(function()
				setRow(5)
			end)
			setRow(20)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Up", "Down" })
		jestExpect(root).toMatchRenderedOutput(
			React.createElement("span", { prop = "Down" })
		)
	end)

	--   -- TODO: This should probably warn
	--   -- @gate experimental
	--   it('calling startTransition inside render phase', async function()
	--     local startTransition
	--     function App()
	--       local [counter, setCounter] = useState(0)
	--       local [_startTransition] = useTransition()
	--       startTransition = _startTransition

	--       if counter == 0)
	--         startTransition(function()
	--           setCounter(c => c + 1)
	--         })
	--       end

	--       return <Text text={counter} />
	--     end

	--     local root = ReactNoop.createRoot()
	--     root.render(<App />)
	--     jestExpect(Scheduler).toFlushAndYield([1])
	--     jestExpect(root).toMatchRenderedOutput(<span prop={1} />)
	--   })
end)

describe("useReducer", function()
	it("simple mount and update", function()
		local INCREMENT = "INCREMENT"
		local DECREMENT = "DECREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == "INCREMENT" then
				return state + 1
			elseif action == "DECREMENT" then
				return state - 1
			else
				return state
			end
		end

		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				return { dispatch = dispatch }
			end)
			return React.createElement(Text, {
				text = "Count: " .. count,
			})
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, {
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		act(function()
			return counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		act(function()
			counter.current.dispatch(DECREMENT)
			counter.current.dispatch(DECREMENT)
			counter.current.dispatch(DECREMENT)
		end)

		jestExpect(Scheduler).toHaveYielded({ "Count: -2" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: -2") })
	end)

	it("lazy init", function()
		local INCREMENT = "INCREMENT"
		local DECREMENT = "DECREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == "INCREMENT" then
				return state + 1
			elseif action == "DECREMENT" then
				return state - 1
			else
				return state
			end
		end

		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, props, function(p)
				Scheduler.unstable_yieldValue("Init")
				return p.initialCount
			end)
			useImperativeHandle(ref, function()
				return { dispatch = dispatch }
			end)
			return React.createElement(Text, {
				text = "Count: " .. count,
			})
		end
		-- ROBLOX TODO: upstream this rename, which keeps the code and types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, {
			initialCount = 10,
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Init", "Count: 10" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 10") })

		act(function()
			return counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 11" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 11") })

		act(function()
			counter.current.dispatch(DECREMENT)
			counter.current.dispatch(DECREMENT)
			counter.current.dispatch(DECREMENT)
		end)

		jestExpect(Scheduler).toHaveYielded({ "Count: 8" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 8") })
	end)

	-- Regression test for https://github.com/facebook/react/issues/14360
	it("handles dispatches with mixed priorities", function()
		local INCREMENT = "INCREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == INCREMENT then
				return state + 1
			else
				return state
			end
		end
		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				return { dispatch = dispatch }
			end)

			return React.createElement(Text, {
				text = "Count: " .. count,
			})
		end

		-- ROBLOX TODO: upstream this rename to make code/types more sane
		local CounterRef = forwardRef(Counter)

		local counter = React.createRef()

		ReactNoop.render(React.createElement(CounterRef, { ref = counter }))
		jestExpect(Scheduler).toFlushAndYield({
			"Count: 0",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 0"),
		})
		ReactNoop.batchedUpdates(function()
			counter.current.dispatch(INCREMENT)
			counter.current.dispatch(INCREMENT)
			counter.current.dispatch(INCREMENT)
		end)
		ReactNoop.flushSync(function()
			counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Count: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 1"),
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Count: 4",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 4"),
		})
	end)
end)

describe("useEffect", function()
	it("simple mount and update", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Passive effect [%d]", props.count)
				)
			end)
			return React.createElement(Text, {
				text = "Count: " .. props.count,
			})
		end
		act(function()
			ReactNoop.render(
				React.createElement(Counter, {
					count = 0,
				}),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
			-- Effects are deferred until after the commit
			jestExpect(Scheduler).toFlushAndYield({ "Passive effect [0]" })
		end)

		act(function()
			ReactNoop.render(
				React.createElement(Counter, {
					count = 1,
				}),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
			-- Effects are deferred until after the commit
			jestExpect(Scheduler).toFlushAndYield({ "Passive effect [1]" })
		end)
	end)

	it("flushes passive effects even with sibling deletions", function()
		local function LayoutEffect(props)
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Layout effect")
			end)
			return React.createElement(Text, { text = "Layout" })
		end
		local function PassiveEffect(props)
			useEffect(function()
				Scheduler.unstable_yieldValue("Passive effect")
			end, {})
			return React.createElement(Text, { text = "Passive" })
		end
		local passive = React.createElement(PassiveEffect, { key = "p" })
		act(function()
			ReactNoop.render({
				React.createElement(LayoutEffect, { key = "l" }),
				passive,
			})
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Layout",
				"Passive",
				"Layout effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Layout"),
				span("Passive"),
			})
			-- Destroying the first child shouldn't prevent the passive effect from
			-- being executed
			ReactNoop.render({ passive })
			jestExpect(Scheduler).toFlushAndYield({ "Passive effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Passive") })
		end)
		-- exiting act calls flushPassiveEffects(), but there are none left to flush.
		jestExpect(Scheduler).toHaveYielded({})
	end)

	it("flushes passive effects even if siblings schedule an update", function()
		local function PassiveEffect(props)
			useEffect(function()
				Scheduler.unstable_yieldValue("Passive effect")
			end)
			return React.createElement(Text, { text = "Passive" })
		end
		local function LayoutEffect(props)
			local count, setCount = useState(0)
			useLayoutEffect(function()
				-- Scheduling work shouldn't interfere with the queued passive effect
				if count == 0 then
					setCount(1)
				end
				Scheduler.unstable_yieldValue("Layout effect " .. count)
			end)
			return React.createElement(Text, { text = "Layout" })
		end

		ReactNoop.render({
			React.createElement(PassiveEffect, { key = "p" }),
			React.createElement(LayoutEffect, { key = "l" }),
		})

		act(function()
			jestExpect(Scheduler).toFlushAndYield({
				"Passive",
				"Layout",
				"Layout effect 0",
				"Passive effect",
				"Layout",
				"Layout effect 1",
			})
		end)

		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Passive"),
			span("Layout"),
		})
	end)

	it("flushes passive effects even if siblings schedule a new root", function()
		local function PassiveEffect(props)
			useEffect(function()
				Scheduler.unstable_yieldValue("Passive effect")
			end, {})
			return React.createElement(Text, { text = "Passive" })
		end
		local function LayoutEffect(props)
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Layout effect")
				-- Scheduling work shouldn't interfere with the queued passive effect
				ReactNoop.renderToRootWithID(
					React.createElement(Text, { text = "New Root" }),
					"root2"
				)
			end)
			return React.createElement(Text, { text = "Layout" })
		end
		act(function()
			ReactNoop.render({
				React.createElement(PassiveEffect, { key = "p" }),
				React.createElement(LayoutEffect, { key = "l" }),
			})
			jestExpect(Scheduler).toFlushAndYield({
				"Passive",
				"Layout",
				"Layout effect",
				"Passive effect",
				"New Root",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Passive"),
				span("Layout"),
			})
		end)
	end)

	it(
		"flushes effects serially by flushing old effects before flushing "
			.. "new ones, if they haven't already fired",
		function()
			local function getCommittedText()
				local children = ReactNoop.getChildren()
				if children == nil then
					return nil
				end
				return children[1].prop
			end

			local function Counter(props)
				useEffect(function()
					Scheduler.unstable_yieldValue(
						"Committed state when effect was fired: "
							.. tostring(getCommittedText())
					)
				end)
				return React.createElement(Text, { text = props.count })
			end
			act(function()
				ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
					Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYieldThrough({ 0, "Sync effect" } :: Array<any>)
				jestExpect(ReactNoop.getChildren()).toEqual({ span(0) })
				-- Before the effects have a chance to flush, schedule another update
				ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
					Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					-- The previous effect flushes before the reconciliation
					"Committed state when effect was fired: 0",
					1,
					"Sync effect",
				} :: Array<any>)
				jestExpect(ReactNoop.getChildren()).toEqual({ span(1) })
			end)

			jestExpect(Scheduler).toHaveYielded({
				"Committed state when effect was fired: 1",
			})
		end
	)

	it("defers passive effect destroy functions during unmount", function()
		local function Child(props)
			local bar = props.bar
			local foo = props.foo
			React.useEffect(function()
				Scheduler.unstable_yieldValue("passive bar create")
				return function()
					Scheduler.unstable_yieldValue("passive bar destroy")
				end
			end, {
				bar,
			})
			React.useLayoutEffect(function()
				Scheduler.unstable_yieldValue("layout bar create")
				return function()
					Scheduler.unstable_yieldValue("layout bar destroy")
				end
			end, {
				bar,
			})
			React.useEffect(function()
				Scheduler.unstable_yieldValue("passive foo create")
				return function()
					Scheduler.unstable_yieldValue("passive foo destroy")
				end
			end, {
				foo,
			})
			React.useLayoutEffect(function()
				Scheduler.unstable_yieldValue("layout foo create")
				return function()
					Scheduler.unstable_yieldValue("layout foo destroy")
				end
			end, {
				foo,
			})
			Scheduler.unstable_yieldValue("render")
			return nil
		end

		act(function()
			ReactNoop.render(React.createElement(Child, { bar = 1, foo = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"render",
				"layout bar create",
				"layout foo create",
				"Sync effect",
			})
			-- Effects are deferred until after the commit
			jestExpect(Scheduler).toFlushAndYield({
				"passive bar create",
				"passive foo create",
			})
		end)

		-- This update is exists to test an internal implementation detail:
		-- Effects without updating dependencies lose their layout/passive tag during an update.
		act(function()
			ReactNoop.render(React.createElement(Child, { bar = 1, foo = 2 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"render",
				"layout foo destroy",
				"layout foo create",
				"Sync effect",
			})
			-- Effects are deferred until after the commit
			jestExpect(Scheduler).toFlushAndYield({
				"passive foo destroy",
				"passive foo create",
			})
		end)

		-- Unmount the component and verify that passive destroy functions are deferred until post-commit.
		act(function()
			ReactNoop.render(nil, function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"layout bar destroy",
				"layout foo destroy",
				"Sync effect",
			})
			-- Effects are deferred until after the commit
			jestExpect(Scheduler).toFlushAndYield({
				"passive bar destroy",
				"passive foo destroy",
			})
		end)
	end)

	it(
		"does not warn about state updates for unmounted components with pending passive unmounts",
		function()
			local completePendingRequest = nil
			local function Component()
				Scheduler.unstable_yieldValue("Component")
				local didLoad, setDidLoad = React.useState(false)
				React.useLayoutEffect(function()
					Scheduler.unstable_yieldValue("layout create")
					return function()
						Scheduler.unstable_yieldValue("layout destroy")
					end
				end, {})
				React.useEffect(function()
					Scheduler.unstable_yieldValue("passive create")
					-- Mimic an XHR request with a complete handler that updates state.
					completePendingRequest = function()
						setDidLoad(true)
					end
					return function()
						Scheduler.unstable_yieldValue("passive destroy")
					end
				end, {})
				return didLoad
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Component),
					"root",
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Component",
					"layout create",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(Scheduler).toHaveYielded({ "passive create" })

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYieldThrough({ "layout destroy" })

				-- Simulate an XHR completing, which will cause a state update-
				-- but should not log a warning.
				completePendingRequest()

				ReactNoop.flushPassiveEffects()
				jestExpect(Scheduler).toHaveYielded({ "passive destroy" })
			end)
		end
	)

	it(
		"does not warn about state updates for unmounted components with pending passive unmounts for alternates",
		function()
			local setParentState = nil
			local setChildStates = {}

			-- deviation: reordered so Parent function could reference Child
			local function Child(props)
				-- ROBLOX FIXME Luau: shouldn't need this annotation, it should see the .. operator and infer the type for props argument
				local label: string = props.label
				local state, setState = useState(0)
				useLayoutEffect(function()
					Scheduler.unstable_yieldValue("Child " .. label .. " commit")
				end)
				useEffect(function()
					table.insert(setChildStates, setState)
					Scheduler.unstable_yieldValue("Child " .. label .. " passive create")
					return function()
						Scheduler.unstable_yieldValue(
							"Child " .. label .. " passive destroy"
						)
					end
				end, {})
				Scheduler.unstable_yieldValue("Child " .. label .. " render")
				return state
			end

			local function Parent()
				local state, setState = useState(true)
				setParentState = setState
				Scheduler.unstable_yieldValue("Parent " .. tostring(state) .. " render")
				useLayoutEffect(function()
					Scheduler.unstable_yieldValue(
						"Parent " .. tostring(state) .. " commit"
					)
				end)
				if state then
					return React.createElement(
						React.Fragment,
						nil,
						React.createElement(Child, { label = "one" }),
						React.createElement(Child, { label = "two" })
					)
				else
					-- ROBLOX FIXME Luau: needs local type inference and normalization
					return nil :: any
				end
			end

			-- Schedule debounced state update for child (prob a no-op for this test)
			-- later tick: schedule unmount for parent
			-- start process unmount (but don't flush passive effectS)
			-- State update on child
			act(function()
				ReactNoop.render(React.createElement(Parent))
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Parent true render",
					"Child one render",
					"Child two render",
					"Child one commit",
					"Child two commit",
					"Parent true commit",
					"Child one passive create",
					"Child two passive create",
				})

				-- Update children.
				-- deviation: forEach() translated using Array.map
				Array.map(setChildStates, function(setChildState)
					return setChildState(1)
				end)

				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Child one render",
					"Child two render",
					"Child one commit",
					"Child two commit",
				})

				-- Schedule another update for children, and partially process it.
				-- deviation: forEach() translated using Array.map

				Array.map(setChildStates, function(setChildState)
					return setChildState(2)
				end)

				jestExpect(Scheduler).toFlushAndYieldThrough({ "Child one render" })

				-- Schedule unmount for the parent that unmounts children with pending update.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_UserBlockingPriority,
					function()
						return setParentState(false)
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Parent false render",
					"Parent false commit",
				})

				-- Schedule updates for children too (which should be ignored)
				-- deviation: forEach() translated using Array.map
				Array.map(setChildStates, function(setChildState)
					return setChildState(2)
				end)

				jestExpect(Scheduler).toFlushAndYield({
					"Child one passive destroy",
					"Child two passive destroy",
				})
			end)
		end
	)

	it(
		"does not warn about state updates for unmounted components with no pending passive unmounts",
		function()
			local completePendingRequest = nil
			local function Component()
				Scheduler.unstable_yieldValue("Component")
				local didLoad, setDidLoad = React.useState(false)
				React.useLayoutEffect(function()
					Scheduler.unstable_yieldValue("layout create")
					-- Mimic an XHR request with a complete handler that updates state.
					completePendingRequest = function()
						setDidLoad(true)
					end
					return function()
						Scheduler.unstable_yieldValue("layout destroy")
					end
				end, {})
				return didLoad
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Component),
					"root",
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Component",
					"layout create",
					"Sync effect",
				})

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYieldThrough({ "layout destroy" })

				-- Simulate an XHR completing.
				completePendingRequest()
			end)
		end
	)

	it(
		"does not warn if there are pending passive unmount effects but not for the current fiber",
		function()
			local completePendingRequest = nil
			local function ComponentWithXHR()
				Scheduler.unstable_yieldValue("Component")
				local didLoad, setDidLoad = React.useState(false)
				React.useLayoutEffect(function()
					Scheduler.unstable_yieldValue("a:layout create")
					return function()
						Scheduler.unstable_yieldValue("a:layout destroy")
					end
				end, {})
				React.useEffect(function()
					Scheduler.unstable_yieldValue("a:passive create")
					-- Mimic an XHR request with a complete handler that updates state.
					completePendingRequest = function()
						setDidLoad(true)
					end
				end, {})
				return didLoad
			end

			local function ComponentWithPendingPassiveUnmount()
				React.useEffect(function()
					Scheduler.unstable_yieldValue("b:passive create")
					return function()
						Scheduler.unstable_yieldValue("b:passive destroy")
					end
				end, {})
				return nil
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(ComponentWithXHR),
						React.createElement(ComponentWithPendingPassiveUnmount)
					),
					"root",
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Component",
					"a:layout create",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(Scheduler).toHaveYielded({
					"a:passive create",
					"b:passive create",
				})

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYieldThrough({ "a:layout destroy" })

				-- Simulate an XHR completing in the component without a pending passive effect..
				completePendingRequest()
			end)
		end
	)

	it(
		"does not warn if there are updates after pending passive unmount effects have been flushed",
		function()
			local updaterFunction

			local function Component()
				Scheduler.unstable_yieldValue("Component")
				local state, setState = React.useState(false)
				updaterFunction = setState
				React.useEffect(function()
					Scheduler.unstable_yieldValue("passive create")
					return function()
						Scheduler.unstable_yieldValue("passive destroy")
					end
				end, {})
				return state
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Component),
					"root",
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Component",
				"Sync effect",
				"passive create",
			})

			ReactNoop.unmountRootWithID("root")
			jestExpect(Scheduler).toFlushAndYield({ "passive destroy" })

			act(function()
				updaterFunction(true)
			end)
		end
	)

	it(
		"does not show a warning when a component updates its own state from within passive unmount function",
		function()
			local function Component()
				Scheduler.unstable_yieldValue("Component")
				local didLoad, setDidLoad = React.useState(false)
				React.useEffect(function()
					Scheduler.unstable_yieldValue("passive create")
					return function()
						setDidLoad(true)
						Scheduler.unstable_yieldValue("passive destroy")
					end
				end, {})
				return didLoad
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Component),
					"root",
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Component",
					"Sync effect",
					"passive create",
				})

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYield({ "passive destroy" })
			end)
		end
	)

	it(
		"does not show a warning when a component updates a childs state from within passive unmount function",
		function()
			local Child
			local function Parent()
				Scheduler.unstable_yieldValue("Parent")
				-- ROBLOX TODO: this explicit typing should be upstreamed
				local updaterRef = React.useRef(nil :: ((boolean) -> ())?)
				React.useEffect(function()
					Scheduler.unstable_yieldValue("Parent passive create")
					return function()
						-- ROBLOX deviation: this is a real nil-ability issue, but Luau doesn't grok expect().never.toBe(nil) yet
						assert(
							updaterRef.current ~= nil,
							"updaterRef was't initialized before render"
						)
						updaterRef.current(true)
						Scheduler.unstable_yieldValue("Parent passive destroy")
					end
				end, {})
				return React.createElement(Child, { updaterRef = updaterRef })
			end

			function Child(props)
				local updaterRef = props.updaterRef
				Scheduler.unstable_yieldValue("Child")
				local state, setState = React.useState(false)
				React.useEffect(function()
					Scheduler.unstable_yieldValue("Child passive create")
					-- ROBLOX FIXME: Assigning to ref.current like this is
					-- not allowed in legacy Roact, and it appears that it
					-- was previously disallowed in React as well. There was
					-- quite a bit of discussion about it here:
					-- https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065

					-- For now, we've relaxed this restriction to maximize
					-- compatibility. We should consider using a binding
					-- here, which would be the idiomatic approach in legacy
					-- Roact, and re-introducing the restriction.
					updaterRef.current = setState
				end, {})
				return state
			end

			act(function()
				ReactNoop.renderToRootWithID(React.createElement(Parent), "root")
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Parent",
					"Child",
					"Child passive create",
					"Parent passive create",
				})

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYield({ "Parent passive destroy" })
			end)
		end
	)

	it(
		"does not show a warning when a component updates a parents state from within passive unmount function",
		function()
			local Child
			local function Parent()
				local state, setState = React.useState(false)
				Scheduler.unstable_yieldValue("Parent")
				return React.createElement(Child, { setState = setState, state = state })
			end

			function Child(props)
				local state = props.state
				local setState = props.setState
				Scheduler.unstable_yieldValue("Child")
				React.useEffect(function()
					Scheduler.unstable_yieldValue("Child passive create")
					return function()
						Scheduler.unstable_yieldValue("Child passive destroy")
						setState(true)
					end
				end, {})
				return state
			end

			act(function()
				ReactNoop.renderToRootWithID(React.createElement(Parent), "root")
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Parent",
					"Child",
					"Child passive create",
				})

				-- Unmount but don't process pending passive destroy function
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYield({ "Child passive destroy" })
			end)
		end
	)

	it("updates have async priority", function()
		local function Counter(props)
			local count, updateCount = useState("(empty)")
			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Schedule update {%d}", props.count)
				)
				updateCount(tostring(props.count))
			end, {
				props.count,
			})
			return React.createElement(Text, { text = "Count: " .. count })
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: (empty)",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: (empty)") })
			ReactNoop.flushPassiveEffects()
			jestExpect(Scheduler).toHaveYielded({ "Schedule update {0}" })
			jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		end)

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
			ReactNoop.flushPassiveEffects()
			jestExpect(Scheduler).toHaveYielded({ "Schedule update {1}" })
			jestExpect(Scheduler).toFlushAndYield({ "Count: 1" })
		end)
	end)

	it("updates have async priority even if effects are flushed early", function()
		local function Counter(props)
			local count, updateCount = useState("(empty)")
			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Schedule update {%d}", props.count)
				)
				updateCount(tostring(props.count))
			end, {
				props.count,
			})
			return React.createElement(Text, { text = "Count: " .. count })
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: (empty)",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: (empty)") })

			-- Rendering again should flush the previous commit's effects
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Schedule update {0}",
				"Count: 0",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: (empty)") })

			jestExpect(Scheduler).toFlushAndYieldThrough({ "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
			ReactNoop.flushPassiveEffects()
			jestExpect(Scheduler).toHaveYielded({ "Schedule update {1}" })
			jestExpect(Scheduler).toFlushAndYield({ "Count: 1" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)
	end)

	it("does not flush non-discrete passive effects when flushing sync", function()
		local _updateCount
		local function Counter(props)
			local count, updateCount = useState(0)
			_updateCount = updateCount
			useEffect(function()
				Scheduler.unstable_yieldValue("Will set count to 1")
				updateCount(1)
			end, {})
			return React.createElement(Text, { text = "Count: " .. tostring(count) })
		end

		-- we explicitly wait for missing act() warnings here since
		-- it's a lot harder to simulate this condition inside an act scope
		jestExpect(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end).toErrorDev({ "An update to Counter ran an effect" })

		-- A flush sync doesn't cause the passive effects to fire.
		-- So we haven't added the other update yet.
		act(function()
			ReactNoop.flushSync(function()
				_updateCount(2)
			end)
		end)

		-- As a result we, somewhat surprisingly, commit them in the opposite order.
		-- This should be fine because any non-discrete set of work doesn't guarantee order
		-- and easily could've happened slightly later too.
		jestExpect(Scheduler).toHaveYielded({
			"Will set count to 1",
			"Count: 2",
			"Count: 1",
		})

		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
	end)

	-- ROBLOX TODO: schedulerTracing
	-- @gate enableSchedulerTracing
	--   it('does not flush non-discrete passive effects when flushing sync (with tracing)', function()
	--     local onInteractionScheduledWorkCompleted = jest.fn()
	--     local onWorkCanceled = jest.fn()

	--     SchedulerTracing.unstable_subscribe({
	--         onInteractionScheduledWorkCompleted = onInteractionScheduledWorkCompleted,
	--         onInteractionTraced = jest.fn(),
	--         onWorkCanceled = onWorkCanceled,
	--         onWorkScheduled = jest.fn(),
	--         onWorkStarted = jest.fn(),
	--         onWorkStopped = jest.fn(),
	--     })

	--     local _updateCount

	--     local function Counter(props)
	--         local _useState, _useState2, count, updateCount = useState(0), _slicedToArray(_useState, 2), _useState2[0], _useState2[1]

	--         _updateCount = updateCount

	--         useEffect(function()
	--             jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({tracingEvent})
	--             Scheduler.unstable_yieldValue('Will set count to 1')
	--             updateCount(1)
	--         end, {})

	--         return React.createElement(Text, {
	--             text = 'Count: ' + count,
	--         })
	--     end

	--     local tracingEvent = {
	--         id = 0,
	--         name = 'hello',
	--         timestamp = 0,
	--     }

	--     jestExpect(function()
	--         SchedulerTracing.unstable_trace(tracingEvent.name, tracingEvent.timestamp, function()
	--             ReactNoop.render(React.createElement(Counter, {count = 0}), function()
	--                 return Scheduler.unstable_yieldValue('Sync effect')
	--             end)
	--         end)
	--         jestExpect(Scheduler).toFlushAndYieldThrough({
	--             'Count: 0',
	--             'Sync effect',
	--         })
	--         jestExpect(ReactNoop.getChildren()).toEqual({
	--             span('Count: 0'),
	--         })
	--     end).toErrorDev({
	--         'An update to Counter ran an effect',
	--     })
	--     jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(0)
	--     act(function()
	--         ReactNoop.flushSync(function()
	--             _updateCount(2)
	--         end)
	--     end)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Will set count to 1',
	--         'Count: 2',
	--         'Count: 1',
	--     })
	--     jestExpect(ReactNoop.getChildren()).toEqual({
	--         span('Count: 1'),
	--     })
	--     jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(1)
	--     jestExpect(onWorkCanceled).toHaveBeenCalledTimes(0)
	-- end)

	it(
		"in legacy mode, useEffect is deferred and updates finish synchronously (in a single batch)",
		function()
			local function Counter(props)
				local count, updateCount = useState("(empty)")

				useEffect(function()
					-- Update multiple times. These should all be batched together in
					-- a single render.
					updateCount(tostring(props.count))
					updateCount(tostring(props.count))
					updateCount(tostring(props.count))
					updateCount(tostring(props.count))
					updateCount(tostring(props.count))
					updateCount(tostring(props.count))
				end, {
					props.count,
				})

				return React.createElement(Text, {
					text = "Count: " .. count,
				})
			end

			act(function()
				ReactNoop.renderLegacySyncRoot(
					React.createElement(Counter, { count = 0 })
				)
				-- Even in legacy mode, effects are deferred until after paint
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Count: (empty)",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({
					span("Count: (empty)"),
				})
			end)
			-- effects get forced on exiting act()
			-- There were multiple updates, but there should only be a
			-- single render
			jestExpect(Scheduler).toHaveYielded({
				"Count: 0",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 0"),
			})
		end
	)

	it("flushSync is not allowed", function()
		local function Counter(props)
			local count, updateCount = useState("(empty)")

			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Schedule update [%d]", props.count)
				)
				ReactNoop.flushSync(function()
					updateCount(tostring(props.count))
				end)
				jestExpect(ReactNoop.getChildren()).never.toEqual({
					span(string.format("Count: %d", props.count)),
				})
			end, {
				props.count,
			})

			return React.createElement(Text, {
				text = "Count: " .. count,
			})
		end

		jestExpect(function()
			return act(function()
				ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Count: (empty)",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({
					span("Count: (empty)"),
				})
			end)
		end).toErrorDev("flushSync was called from inside a lifecycle method")
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 0"),
		})
	end)

	it("unmounts previous effect", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Did create [%d]", props.count)
				)
				return function()
					Scheduler.unstable_yieldValue(
						string.format("Did destroy [%d]", props.count)
					)
				end
			end)
			return React.createElement(Text, { text = "Count: " .. props.count })
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did create [0]" })

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did destroy [0]", "Did create [1]" })
	end)

	it("unmounts on deletion", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					"Did create [" .. tostring(props.count) .. "]"
				)
				return function()
					Scheduler.unstable_yieldValue(
						"Did destroy [" .. tostring(props.count) .. "]"
					)
				end
			end)
			return React.createElement(
				Text,
				{ text = "Count: " .. tostring(props.count) }
			)
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did create [0]" })

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushAndYield({ "Did destroy [0]" })
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)

	it("unmounts on deletion after skipped effect", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					string.format("Did create [%d]", props.count)
				)
				return function()
					Scheduler.unstable_yieldValue(
						string.format("Did destroy [%d]", props.count)
					)
				end
			end, {})
			return React.createElement(Text, { text = "Count: " .. props.count })
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did create [0]" })

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)

		jestExpect(Scheduler).toHaveYielded({})

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushAndYield({ "Did destroy [0]" })
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)

	it("always fires effects if no dependencies are provided", function()
		local function effect()
			Scheduler.unstable_yieldValue("Did create")
			return function()
				Scheduler.unstable_yieldValue("Did destroy")
			end
		end
		local function Counter(props)
			useEffect(effect)
			return React.createElement(
				Text,
				{ text = "Count: " .. tostring(props.count) }
			)
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did create" })

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did destroy", "Did create" })

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushAndYield({ "Did destroy" })
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)

	it("skips effect if inputs have not changed", function()
		local function Counter(props)
			local text = tostring(props.label) .. ": " .. tostring(props.count)
			useEffect(function()
				Scheduler.unstable_yieldValue("Did create [" .. text .. "]")
				return function()
					Scheduler.unstable_yieldValue("Did destroy [" .. text .. "]")
				end
			end, {
				props.label,
				props.count,
			})
			return React.createElement(Text, { text = text })
		end
		act(function()
			ReactNoop.render(
				React.createElement(Counter, { label = "Count", count = 0 }),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did create [Count: 0]" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })

		act(function()
			ReactNoop.render(
				React.createElement(Counter, { label = "Count", count = 1 }),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			-- Count changed
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [Count: 0]",
			"Did create [Count: 1]",
		})

		act(function()
			ReactNoop.render(
				React.createElement(Counter, { label = "Count", count = 1 }),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			-- Nothing changed, so no effect should have fired
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
		end)

		jestExpect(Scheduler).toHaveYielded({})
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })

		act(function()
			ReactNoop.render(
				React.createElement(Counter, { label = "Total", count = 1 }),
				function()
					Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			-- Label changed
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Total: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Total: 1") })
		end)

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [Count: 1]",
			"Did create [Total: 1]",
		})
	end)

	-- ROBLOX deviation START: Test that deps can include nil values
	it("skips or reruns effects correctly when deps have nil values", function()
		local function Counter(props)
			local deps = {}
			-- Create a list of deps for each non-'.' character, like:
			-- { "A", nil, nil, nil, nil } or { nil, nil, nil, nil, "E" }
			for i, char in string.split(props.deps, "") do
				deps[i] = if char ~= "." then char else nil
			end
			useEffect(function()
				Scheduler.unstable_yieldValue("Did create [" .. props.deps .. "]")
				return function()
					Scheduler.unstable_yieldValue("Did destroy [" .. props.deps .. "]")
				end
			end, deps)
			return React.createElement(Text, { text = props.deps })
		end
		jestExpect(function()
			act(function()
				ReactNoop.render(
					React.createElement(Counter, { deps = "A...." }),
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"A....",
					"Sync effect",
				})
			end)
		end).toErrorDev({--\[\[no errors\]\]
		})

		jestExpect(Scheduler).toHaveYielded({ "Did create [A....]" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("A....") })

		jestExpect(function()
			act(function()
				ReactNoop.render(
					React.createElement(Counter, { deps = "A...E" }),
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"A...E",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span("A...E") })
			end)
		end).toErrorDev({--\[\[no errors\]\]
		})

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [A....]",
			"Did create [A...E]",
		})

		jestExpect(function()
			act(function()
				ReactNoop.render(
					React.createElement(Counter, { deps = "ABCDE" }),
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"ABCDE",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span("ABCDE") })
			end)
		end).toErrorDev({--\[\[no errors\]\]
		})

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [A...E]",
			"Did create [ABCDE]",
		})

		jestExpect(function()
			act(function()
				ReactNoop.render(
					React.createElement(Counter, { deps = "....E" }),
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"....E",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span("....E") })
			end)
		end).toErrorDev({--\[\[no errors\]\]
		})

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [ABCDE]",
			"Did create [....E]",
		})

		jestExpect(function()
			act(function()
				ReactNoop.render(
					React.createElement(Counter, { deps = "..C.." }),
					function()
						Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"..C..",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span("..C..") })
			end)
		end).toErrorDev({--\[\[no errors\]\]
		})

		jestExpect(Scheduler).toHaveYielded({
			"Did destroy [....E]",
			"Did create [..C..]",
		})
	end)
	-- ROBLOX deviation END

	it("multiple effects", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					"Did commit 1 [" .. tostring(props.count) .. "]"
				)
			end)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					"Did commit 2 [" .. tostring(props.count) .. "]"
				)
			end)
			return React.createElement(
				Text,
				{ text = "Count: " .. tostring(props.count) }
			)
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Did commit 1 [0]", "Did commit 2 [0]" })

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)
		jestExpect(Scheduler).toHaveYielded({ "Did commit 1 [1]", "Did commit 2 [1]" })
	end)

	it("unmounts all previous effects before creating any new ones", function()
		-- ROBLOX FIXME Luau: inference should know the prop shape based on string concat below and narrowed by createElement later
		local function Counter(props: { count: number })
			useEffect(function()
				Scheduler.unstable_yieldValue("Mount A [" .. props.count .. "]")
				return function()
					Scheduler.unstable_yieldValue("Unmount A [" .. props.count .. "]")
				end
			end)
			useEffect(function()
				Scheduler.unstable_yieldValue("Mount B [" .. props.count .. "]")
				return function()
					Scheduler.unstable_yieldValue("Unmount B [" .. props.count .. "]")
				end
			end)
			return React.createElement(Text, { text = "Count: " .. props.count })
		end
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 0", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Mount A [0]", "Mount B [0]" })

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Count: 1", "Sync effect" })
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Unmount A [0]",
			"Unmount B [0]",
			"Mount A [1]",
			"Mount B [1]",
		})
	end)

	it(
		"unmounts all previous effects between siblings before creating any new ones",
		function()
			local function Counter(props)
				local count, label = props.count, props.label

				useEffect(function()
					Scheduler.unstable_yieldValue(
						string.format("Mount %s [%d]", label, count)
					)

					return function()
						Scheduler.unstable_yieldValue(
							string.format("Unmount %s [%d]", label, count)
						)
					end
				end)

				return React.createElement(Text, {
					text = string.format("%s %d", label, count),
				})
			end

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Counter, {
							label = "A",
							count = 0,
						}),
						React.createElement(Counter, {
							label = "B",
							count = 0,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"A 0",
					"B 0",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({
					span("A 0"),
					span("B 0"),
				})
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Mount A [0]",
				"Mount B [0]",
			})
			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Counter, {
							label = "A",
							count = 1,
						}),
						React.createElement(Counter, {
							label = "B",
							count = 1,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"A 1",
					"B 1",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({
					span("A 1"),
					span("B 1"),
				})
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Unmount A [0]",
				"Unmount B [0]",
				"Mount A [1]",
				"Mount B [1]",
			})
			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Counter, {
							label = "B",
							count = 2,
						}),
						React.createElement(Counter, {
							label = "C",
							count = 0,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"B 2",
					"C 0",
					"Sync effect",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({
					span("B 2"),
					span("C 0"),
				})
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Unmount A [1]",
				"Unmount B [1]",
				"Mount B [2]",
				"Mount C [0]",
			})
		end
	)
	it("handles errors in create on mount", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(string.format("Mount A [%d]", props.count))

				return function()
					Scheduler.unstable_yieldValue(
						string.format("Unmount A [%d]", props.count)
					)
				end
			end)
			useEffect(function()
				Scheduler.unstable_yieldValue("Oops!")
				error("Oops!")
				-- deviation: upstream notes that following code is unreachable.
				-- Scheduler.unstable_yieldValue(string.format('Mount B [%s]', props.count))
				-- return function()
				--     Scheduler.unstable_yieldValue(string.format('Unmount B [%s]', props.count))
				-- end
			end)

			return React.createElement(Text, {
				text = "Count: " .. props.count,
			})
		end

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: 0",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 0"),
			})
			jestExpect(function()
				return ReactNoop.flushPassiveEffects()
			end).toThrow("Oops")
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Mount A [0]",
			"Oops!",
			"Unmount A [0]",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)
	it("handles errors in create on update", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(string.format("Mount A [%d]", props.count))

				return function()
					Scheduler.unstable_yieldValue(
						string.format("Unmount A [%d]", props.count)
					)
				end
			end)
			useEffect(function()
				if props.count == 1 then
					Scheduler.unstable_yieldValue("Oops!")
					error("Oops!")
				end

				Scheduler.unstable_yieldValue(string.format("Mount B [%d]", props.count))

				return function()
					Scheduler.unstable_yieldValue(
						string.format("Unmount B [%d]", props.count)
					)
				end
			end)

			return React.createElement(Text, {
				text = "Count: " .. props.count,
			})
		end

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: 0",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 0"),
			})
			ReactNoop.flushPassiveEffects()
			jestExpect(Scheduler).toHaveYielded({
				"Mount A [0]",
				"Mount B [0]",
			})
		end)
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: 1",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 1"),
			})
			jestExpect(function()
				return ReactNoop.flushPassiveEffects()
			end).toThrow("Oops")

			jestExpect(Scheduler).toHaveYielded({
				"Unmount A [0]",
				"Unmount B [0]",
				"Mount A [1]",
				"Oops!",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({})
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Unmount A [1]",
		})
	end)
	it("handles errors in destroy on update", function()
		local function Counter(props)
			useEffect(function()
				Scheduler.unstable_yieldValue(string.format("Mount A [%d]", props.count))

				return function()
					Scheduler.unstable_yieldValue("Oops!")

					if props.count == 0 then
						error("Oops!")
					end
				end
			end)
			useEffect(function()
				Scheduler.unstable_yieldValue(string.format("Mount B [%d]", props.count))

				return function()
					Scheduler.unstable_yieldValue(
						string.format("Unmount B [%d]", props.count)
					)
				end
			end)

			return React.createElement(Text, {
				text = "Count: " .. props.count,
			})
		end

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: 0",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 0"),
			})
			ReactNoop.flushPassiveEffects()
			jestExpect(Scheduler).toHaveYielded({
				"Mount A [0]",
				"Mount B [0]",
			})
		end)
		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Count: 1",
				"Sync effect",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Count: 1"),
			})
			jestExpect(function()
				return ReactNoop.flushPassiveEffects()
			end).toThrow("Oops")
			jestExpect(Scheduler).toHaveYielded({
				"Oops!",
				"Unmount B [0]",
				"Mount A [1]",
				"Mount B [1]",
			})
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Oops!",
			"Unmount B [1]",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)

	it("works with memo", function()
		local function Counter(props)
			local count = props.count

			useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Mount: " .. count)

				return function()
					return Scheduler.unstable_yieldValue("Unmount: " .. count)
				end
			end)

			return React.createElement(Text, {
				text = "Count: " .. count,
			})
		end

		-- ROBLOX TODO: contribute this rename upstream, it makes the code/types sane
		local CounterMemo = memo(Counter)

		ReactNoop.render(React.createElement(CounterMemo, { count = 0 }), function()
			return Scheduler.unstable_yieldValue("Sync effect")
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Count: 0",
			"Mount: 0",
			"Sync effect",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 0"),
		})
		ReactNoop.render(React.createElement(CounterMemo, { count = 1 }), function()
			return Scheduler.unstable_yieldValue("Sync effect")
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Count: 1",
			"Unmount: 0",
			"Mount: 1",
			"Sync effect",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Count: 1"),
		})
		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Unmount: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({})
	end)

	-- ROBLOX FIXME: Error Boundaries are implemented now, most of these should now pass
	--   describe('errors thrown in passive destroy function within unmounted trees', function()
	--     local BrokenUseEffectCleanup
	--     local ErrorBoundary
	--     local DerivedStateOnlyErrorBoundary
	--     local LogOnlyErrorBoundary

	--     beforeEach(function()
	--       BrokenUseEffectCleanup = function()
	--         useEffect(function()
	--           Scheduler.unstable_yieldValue('BrokenUseEffectCleanup useEffect')
	--           return function()
	--             Scheduler.unstable_yieldValue(
	--               'BrokenUseEffectCleanup useEffect destroy',
	--             )
	--             throw new Error('Expected error')
	--           end
	--         }, [])

	--         return 'inner child'
	--       end

	--       ErrorBoundary = class extends React.Component {
	--         state = {error: nil}
	--         static getDerivedStateFromError(error)
	--           Scheduler.unstable_yieldValue(
	--             `ErrorBoundary static getDerivedStateFromError`,
	--           )
	--           return {error}
	--         end
	--         componentDidCatch(error, info)
	--           Scheduler.unstable_yieldValue(`ErrorBoundary componentDidCatch`)
	--         end
	--         render()
	--           if this.state.error)
	--             Scheduler.unstable_yieldValue('ErrorBoundary render error')
	--             return <span prop="ErrorBoundary fallback" />
	--           end
	--           Scheduler.unstable_yieldValue('ErrorBoundary render success')
	--           return this.props.children or nil
	--         end
	--       end

	--       DerivedStateOnlyErrorBoundary = class extends React.Component {
	--         state = {error: nil}
	--         static getDerivedStateFromError(error)
	--           Scheduler.unstable_yieldValue(
	--             `DerivedStateOnlyErrorBoundary static getDerivedStateFromError`,
	--           )
	--           return {error}
	--         end
	--         render()
	--           if this.state.error)
	--             Scheduler.unstable_yieldValue(
	--               'DerivedStateOnlyErrorBoundary render error',
	--             )
	--             return <span prop="DerivedStateOnlyErrorBoundary fallback" />
	--           end
	--           Scheduler.unstable_yieldValue(
	--             'DerivedStateOnlyErrorBoundary render success',
	--           )
	--           return this.props.children or nil
	--         end
	--       end

	--       LogOnlyErrorBoundary = class extends React.Component {
	--         componentDidCatch(error, info)
	--           Scheduler.unstable_yieldValue(
	--             `LogOnlyErrorBoundary componentDidCatch`,
	--           )
	--         end
	--         render()
	--           Scheduler.unstable_yieldValue(`LogOnlyErrorBoundary render`)
	--           return this.props.children or nil
	--         end
	--       end
	--     })

	--     -- @gate old
	--     it('should call componentDidCatch() for the nearest unmounted log-only boundary', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <LogOnlyErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </LogOnlyErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={true} />
	--           </ErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'LogOnlyErrorBoundary render',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={false} />
	--           </ErrorBoundary>,
	--         )
	--         jestExpect(Scheduler).toFlushAndYieldThrough([
	--           'ErrorBoundary render success',
	--         ])
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'LogOnlyErrorBoundary componentDidCatch',
	--       ])
	--     })

	--     -- @gate old
	--     it('should call componentDidCatch() for the nearest unmounted logging-capable boundary', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <ErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </ErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={true} />
	--           </ErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={false} />
	--           </ErrorBoundary>,
	--         )
	--         jestExpect(Scheduler).toFlushAndYieldThrough([
	--           'ErrorBoundary render success',
	--         ])
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'ErrorBoundary componentDidCatch',
	--       ])
	--     })

	--     -- @gate old
	--     it('should not call getDerivedStateFromError for unmounted error boundaries', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <ErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </ErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(<Conditional showChildren={true} />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(<Conditional showChildren={false} />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'ErrorBoundary componentDidCatch',
	--       ])
	--     })

	--     -- @gate old
	--     it('should not throw if there are no unmounted logging-capable boundaries to call', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <DerivedStateOnlyErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </DerivedStateOnlyErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(<Conditional showChildren={true} />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'DerivedStateOnlyErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(<Conditional showChildren={false} />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'BrokenUseEffectCleanup useEffect destroy',
	--       ])
	--     })

	--     -- @gate new
	--     it('should use the nearest still-mounted boundary if there are no unmounted boundaries', function()
	--       act(function()
	--         ReactNoop.render(
	--           <LogOnlyErrorBoundary>
	--             <BrokenUseEffectCleanup />
	--           </LogOnlyErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'LogOnlyErrorBoundary render',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(<LogOnlyErrorBoundary />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'LogOnlyErrorBoundary render',
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'LogOnlyErrorBoundary componentDidCatch',
	--       ])
	--     })

	--     -- @gate new
	--     it('should skip unmounted boundaries and use the nearest still-mounted boundary', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <ErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </ErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(
	--           <LogOnlyErrorBoundary>
	--             <Conditional showChildren={true} />
	--           </LogOnlyErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'LogOnlyErrorBoundary render',
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(
	--           <LogOnlyErrorBoundary>
	--             <Conditional showChildren={false} />
	--           </LogOnlyErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'LogOnlyErrorBoundary render',
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'LogOnlyErrorBoundary componentDidCatch',
	--       ])
	--     })

	--     -- @gate new
	--     it('should call getDerivedStateFromError in the nearest still-mounted boundary', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return <BrokenUseEffectCleanup />
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={true} />
	--           </ErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       act(function()
	--         ReactNoop.render(
	--           <ErrorBoundary>
	--             <Conditional showChildren={false} />
	--           </ErrorBoundary>,
	--         )
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect destroy',
	--         'ErrorBoundary static getDerivedStateFromError',
	--         'ErrorBoundary render error',
	--         'ErrorBoundary componentDidCatch',
	--       ])

	--       jestExpect(ReactNoop.getChildren()).toEqual([
	--         span('ErrorBoundary fallback'),
	--       ])
	--     })

	--     -- @gate new
	--     it('should rethrow error if there are no still-mounted boundaries', function()
	--       function Conditional({showChildren})
	--         if showChildren)
	--           return (
	--             <ErrorBoundary>
	--               <BrokenUseEffectCleanup />
	--             </ErrorBoundary>
	--           )
	--         } else {
	--           return nil
	--         end
	--       end

	--       act(function()
	--         ReactNoop.render(<Conditional showChildren={true} />)
	--       })

	--       jestExpect(Scheduler).toHaveYielded([
	--         'ErrorBoundary render success',
	--         'BrokenUseEffectCleanup useEffect',
	--       ])

	--       jestExpect(function()
	--         act(function()
	--           ReactNoop.render(<Conditional showChildren={false} />)
	--         })
	--       }).toThrow('Expected error')

	--       jestExpect(Scheduler).toHaveYielded([
	--         'BrokenUseEffectCleanup useEffect destroy',
	--       ])

	--       jestExpect(ReactNoop.getChildren()).toEqual([])
	--     })
	--   })

	--   it('calls passive effect destroy functions for memoized components', function()
	--     local Wrapper = ({children}) => children
	--     function Child()
	--       React.useEffect(function()
	--         Scheduler.unstable_yieldValue('passive create')
	--         return function()
	--           Scheduler.unstable_yieldValue('passive destroy')
	--         end
	--       }, [])
	--       React.useLayoutEffect(function()
	--         Scheduler.unstable_yieldValue('layout create')
	--         return function()
	--           Scheduler.unstable_yieldValue('layout destroy')
	--         end
	--       }, [])
	--       Scheduler.unstable_yieldValue('render')
	--       return nil
	--     end

	--     local isEqual = (prevProps, nextProps) =>
	--       prevProps.prop == nextProps.prop
	--     local MemoizedChild = React.memo(Child, isEqual)

	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={1} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([
	--       'render',
	--       'layout create',
	--       'passive create',
	--     ])

	--     -- Include at least one no-op (memoized) update to trigger original bug.
	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={1} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([])

	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={2} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([
	--       'render',
	--       'layout destroy',
	--       'layout create',
	--       'passive destroy',
	--       'passive create',
	--     ])

	--     act(function()
	--       ReactNoop.render(null)
	--     })
	--     jestExpect(Scheduler).toHaveYielded(['layout destroy', 'passive destroy'])
	--   })

	--   it('calls passive effect destroy functions for descendants of memoized components', function()
	--     local Wrapper = ({children}) => children
	--     function Child()
	--       return <Grandchild />
	--     end

	--     function Grandchild()
	--       React.useEffect(function()
	--         Scheduler.unstable_yieldValue('passive create')
	--         return function()
	--           Scheduler.unstable_yieldValue('passive destroy')
	--         end
	--       }, [])
	--       React.useLayoutEffect(function()
	--         Scheduler.unstable_yieldValue('layout create')
	--         return function()
	--           Scheduler.unstable_yieldValue('layout destroy')
	--         end
	--       }, [])
	--       Scheduler.unstable_yieldValue('render')
	--       return nil
	--     end

	--     local isEqual = (prevProps, nextProps) =>
	--       prevProps.prop == nextProps.prop
	--     local MemoizedChild = React.memo(Child, isEqual)

	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={1} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([
	--       'render',
	--       'layout create',
	--       'passive create',
	--     ])

	--     -- Include at least one no-op (memoized) update to trigger original bug.
	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={1} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([])

	--     act(function()
	--       ReactNoop.render(
	--         <Wrapper>
	--           <MemoizedChild key={2} />
	--         </Wrapper>,
	--       )
	--     })
	--     jestExpect(Scheduler).toHaveYielded([
	--       'render',
	--       'layout destroy',
	--       'layout create',
	--       'passive destroy',
	--       'passive create',
	--     ])

	--     act(function()
	--       ReactNoop.render(null)
	--     })
	--     jestExpect(Scheduler).toHaveYielded(['layout destroy', 'passive destroy'])
	--   })
end)

describe("useLayoutEffect", function()
	it("fires layout effects after the host has been mutated", function()
		local function getCommittedText()
			local yields = Scheduler.unstable_clearYields()
			local children = ReactNoop.getChildren()
			Scheduler.unstable_yieldValue(yields)
			if children == nil then
				return nil
			end
			return children[1].prop
		end

		local function Counter(props)
			useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Current: " .. tostring(getCommittedText()))
			end)
			return React.createElement(Text, { text = props.count })
		end

		ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
			Scheduler.unstable_yieldValue("Sync effect")
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			{ 0 },
			"Current: 0",
			"Sync effect",
			-- ROBLOX FIXME Luau: Luau needs to support mixed array inference
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(0) })

		ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
			Scheduler.unstable_yieldValue("Sync effect")
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			{ 1 },
			"Current: 1",
			"Sync effect",
			-- ROBLOX FIXME Luau: Luau needs to support mixed array inference
		} :: Array<any>)
		jestExpect(ReactNoop.getChildren()).toEqual({ span(1) })
	end)

	it("force flushes passive effects before firing new layout effects", function()
		local committedText = "(empty)"

		local function Counter(props)
			useLayoutEffect(function()
				-- Normally this would go in a mutation effect, but this test
				-- intentionally omits a mutation effect.
				-- ROBLOX TODO: js2lua should translate `x + ''` to tostring(x)
				committedText = tostring(props.count)

				Scheduler.unstable_yieldValue(
					"Mount layout [current: " .. committedText .. "]"
				)
				return function()
					Scheduler.unstable_yieldValue(
						"Unmount layout [current: " .. committedText .. "]"
					)
				end
			end)
			useEffect(function()
				Scheduler.unstable_yieldValue(
					"Mount normal [current: " .. committedText .. "]"
				)
				return function()
					Scheduler.unstable_yieldValue(
						"Unmount normal [current: " .. committedText .. "]"
					)
				end
			end)
			return nil
		end

		act(function()
			ReactNoop.render(React.createElement(Counter, { count = 0 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Mount layout [current: 0]",
				"Sync effect",
			})
			jestExpect(committedText).toEqual("0")
			ReactNoop.render(React.createElement(Counter, { count = 1 }), function()
				return Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Mount normal [current: 0]",
				"Unmount layout [current: 0]",
				"Mount layout [current: 1]",
				"Sync effect",
			})
			jestExpect(committedText).toEqual("1")
		end)

		jestExpect(Scheduler).toHaveYielded({
			"Unmount normal [current: 1]",
			"Mount normal [current: 1]",
		})
	end)

	-- ROBLOX TODO: this failing, but is it a bug? or this gate not enabled in our config?
	-- @gate skipUnmountedBoundaries
	xit("catches errors thrown in useLayoutEffect", function()
		local ErrorBoundary = React.Component:extend("ErrorBoundary")
		function ErrorBoundary:init()
			self.state = { error = nil }
		end

		function ErrorBoundary.getDerivedStateFromError(errorMsg)
			Scheduler.unstable_yieldValue("ErrorBoundary static getDerivedStateFromError")
			return { error = errorMsg }
		end

		-- deviation: raised to be above where its used
		local function Component(props)
			local id = props.id
			Scheduler.unstable_yieldValue("Component render " .. id)
			return React.createElement(span, { prop = id })
		end

		function ErrorBoundary:render()
			local children = self.props.children
			local id = self.props.id
			local fallbackID = self.props.fallbackID
			local errorMsg = self.state.error
			if errorMsg then
				Scheduler.unstable_yieldValue(id .. " render error")
				return React.createElement(Component, { id = fallbackID })
			end
			Scheduler.unstable_yieldValue(id .. " render success")

			-- deviation: or nil not necessary in Lua
			return children
		end

		local function BrokenLayoutEffectDestroy()
			useLayoutEffect(function()
				return function()
					Scheduler.unstable_yieldValue(
						"BrokenLayoutEffectDestroy useLayoutEffect destroy"
					)
					error("Expected")
				end
			end, {})

			Scheduler.unstable_yieldValue("BrokenLayoutEffectDestroy render")
			return React.createElement(span, { prop = "broken" })
		end

		ReactNoop.render(
			React.createElement(
				ErrorBoundary,
				{ id = "OuterBoundary", fallbackID = "OuterFallback" },
				{
					React.createElement(Component, { id = "sibling" }),
					React.createElement(
						ErrorBoundary,
						{ id = "InnerBoundary", fallbackID = "InnerFallback" },
						React.createElement(BrokenLayoutEffectDestroy)
					),
				}
			)
		)

		jestExpect(Scheduler).toFlushAndYield({
			"OuterBoundary render success",
			"Component render sibling",
			"InnerBoundary render success",
			"BrokenLayoutEffectDestroy render",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			React.createElement(span, { id = "sibling" }),
			React.createElement(span, { id = "broken" }),
		})

		ReactNoop.render(
			React.createElement(
				ErrorBoundary,
				{ id = "OuterBoundary", fallbackID = "OuterFallback" },
				React.createElement(Component, { id = "sibling" })
			)
		)

		-- React should skip over the unmounting boundary and find the nearest still-mounted boundary.
		jestExpect(Scheduler).toFlushAndYield({
			"OuterBoundary render success",
			"Component render sibling",
			"BrokenLayoutEffectDestroy useLayoutEffect destroy",
			"ErrorBoundary static getDerivedStateFromError",
			"OuterBoundary render error",
			"Component render OuterFallback",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({ span("OuterFallback") })
	end)
end)

describe("useCallback", function()
	it("memoizes callback by comparing inputs", function()
		-- ROBLOX deviation: hoist local
		local button = React.createRef()
		local IncrementButton = React.PureComponent:extend("IncrementButton")
		function IncrementButton:increment()
			self.props.increment()
		end
		function IncrementButton:render()
			return React.createElement(Text, { text = "Increment" })
		end

		-- ROBLOX deviation: we need to hold the instance so we can pass it as an explicit self argument, since Lua doesn't have function bindings
		local incrementButtonInstance

		local function Counter(props)
			local incrementBy = props.incrementBy
			local count, updateCount = useState(0)
			local increment = useCallback(function()
				return updateCount(function(c)
					return c + incrementBy
				end)
			end, {
				incrementBy,
			})
			-- ROBLOX deviation: we need to hold the instance so we can pass it as an explicit self argument, since Lua doesn't have function bindings
			-- ROBLOX deviation: we also assign explicit keys to quiet a warning in DEV mode
			incrementButtonInstance = React.createElement(
				IncrementButton,
				{ key = "1", increment = increment, ref = button }
			)
			return React.createElement(React.Fragment, {}, {
				incrementButtonInstance,
				React.createElement(Text, { key = "2", text = "Count: " .. count }),
			})
		end

		ReactNoop.render(React.createElement(Counter, { incrementBy = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Increment", "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 0"),
		})

		-- ROBLOX deviation: call ref increment() with an explicit self argument
		act(function()
			button.current.increment(incrementButtonInstance)
		end)
		jestExpect(Scheduler).toHaveYielded({
			-- Button should not re-render, because its props haven't changed
			-- 'Increment',
			"Count: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 1"),
		})

		-- Increase the increment amount
		ReactNoop.render(React.createElement(Counter, { incrementBy = 10 }))
		jestExpect(Scheduler).toFlushAndYield({
			-- Inputs did change this time
			"Increment",
			"Count: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 1"),
		})

		-- Callback should have updated
		-- ROBLOX deviation: call ref increment() with an explicit self argument
		act(function()
			button.current.increment(incrementButtonInstance)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 11" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 11"),
		})
	end)

	it("correctly interprets input changes with nil values", function()
		local incrementCallback
		local IncrementButton = React.PureComponent:extend("IncrementButton")
		function IncrementButton:render()
			incrementCallback = self.props.increment
			return React.createElement(Text, { text = "Increment" })
		end

		local function Counter(props)
			local deps = {}
			-- Create a list of deps for each non-'.' character, like:
			-- { "A", nil, nil, nil, nil } or { nil, nil, nil, nil, "E" }
			for i, char in string.split(props.input, "") do
				deps[i] = if char ~= "." then char else nil
			end
			local count, updateCount = useState(0)
			local increment = useCallback(function()
				return updateCount(function(c)
					-- normally, we'd make `incrementBy` a dependency in the
					-- array, but this test uses contrived logic
					return c + props.incrementBy
				end)
			end, deps)
			return React.createElement(
				React.Fragment,
				{},
				React.createElement(IncrementButton, { increment = increment }),
				React.createElement(Text, { text = "Count: " .. count })
			)
		end

		ReactNoop.render(
			React.createElement(Counter, { input = "A....", incrementBy = 1 })
		)
		jestExpect(Scheduler).toFlushAndYield({ "Increment", "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 0"),
		})

		act(incrementCallback)
		jestExpect(Scheduler).toHaveYielded({
			-- Button should not re-render, because its props haven't changed
			-- 'Increment',
			"Count: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 1"),
		})

		-- Increase the increment amount
		ReactNoop.render(
			React.createElement(Counter, { input = "A....", incrementBy = 10 })
		)
		jestExpect(Scheduler).toFlushAndYield({
			-- Button should not re-render, because we haven't changed input
			-- "Increment",
			"Count: 1",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 1"),
		})

		-- Callback should not have updated since the input did not
		act(incrementCallback)
		jestExpect(Scheduler).toHaveYielded({ "Count: 2" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 2"),
		})

		-- Increase the increment amount
		ReactNoop.render(
			React.createElement(Counter, { input = "A...E", incrementBy = 10 })
		)
		jestExpect(Scheduler).toFlushAndYield({
			-- Inputs did change this time
			"Increment",
			"Count: 2",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 2"),
		})

		act(incrementCallback)
		jestExpect(Scheduler).toHaveYielded({ "Count: 12" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Increment"),
			span("Count: 12"),
		})
	end)
end)

describe("useMemo", function()
	it("memoizes value by comparing to previous inputs", function()
		local function CapitalizedText(props)
			-- ROBLOX FIXME Luau: remove string annotation below once Luau infers .. text -> props: { text: string }
			local text: string = props.text
			local capitalizedText = useMemo(function()
				Scheduler.unstable_yieldValue("Capitalize '" .. text .. "'")
				return string.upper(text)
			end, {
				text,
			})
			return React.createElement(Text, { text = capitalizedText })
		end

		ReactNoop.render(React.createElement(CapitalizedText, { text = "hello" }))
		jestExpect(Scheduler).toFlushAndYield({ "Capitalize 'hello'", "HELLO" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("HELLO") })

		ReactNoop.render(React.createElement(CapitalizedText, { text = "hi" }))
		jestExpect(Scheduler).toFlushAndYield({ "Capitalize 'hi'", "HI" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("HI") })

		ReactNoop.render(React.createElement(CapitalizedText, { text = "hi" }))
		jestExpect(Scheduler).toFlushAndYield({ "HI" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("HI") })

		ReactNoop.render(React.createElement(CapitalizedText, { text = "goodbye" }))
		jestExpect(Scheduler).toFlushAndYield({ "Capitalize 'goodbye'", "GOODBYE" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("GOODBYE") })
	end)

	-- ROBLOX deviation START: multi-return is a luau language feature
	it("returns multiple input values", function()
		local function Doubler(props: { x: number, y: number })
			local x = props.x
			local y = props.y
			local xMinusY, xPlusY = useMemo(function()
				local a = x - y
				local b = x + y
				Scheduler.unstable_yieldValue(
					"x - y = " .. tostring(a) .. ", x + y = " .. tostring(b)
				)
				return a, b
			end, {
				x,
				y,
			})
			return React.createElement(
				Text,
				{ text = tostring(xMinusY) .. tostring(xPlusY) }
			)
		end

		ReactNoop.render(React.createElement(Doubler, { x = 1, y = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "x - y = -1, x + y = 3", "-13" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("-13") })

		ReactNoop.render(React.createElement(Doubler, { x = 4, y = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "x - y = 2, x + y = 6", "26" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("26") })

		ReactNoop.render(React.createElement(Doubler, { x = 4, y = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "26" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("26") })

		ReactNoop.render(React.createElement(Doubler, { x = 8, y = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "x - y = 6, x + y = 10", "610" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("610") })
	end)
	-- ROBLOX deviation END

	it("always re-computes if no inputs are provided", function()
		local function LazyCompute(props)
			local computed = useMemo(props.compute)
			return React.createElement(Text, { text = computed })
		end

		local function computeA()
			Scheduler.unstable_yieldValue("compute A")
			return "A"
		end

		local function computeB()
			Scheduler.unstable_yieldValue("compute B")
			return "B"
		end

		ReactNoop.render(React.createElement(LazyCompute, { compute = computeA }))
		jestExpect(Scheduler).toFlushAndYield({ "compute A", "A" })

		ReactNoop.render(React.createElement(LazyCompute, { compute = computeA }))
		jestExpect(Scheduler).toFlushAndYield({ "compute A", "A" })

		ReactNoop.render(React.createElement(LazyCompute, { compute = computeA }))
		jestExpect(Scheduler).toFlushAndYield({ "compute A", "A" })

		ReactNoop.render(React.createElement(LazyCompute, { compute = computeB }))
		jestExpect(Scheduler).toFlushAndYield({ "compute B", "B" })
	end)

	it(
		"should not invoke memoized function during re-renders unless inputs change",
		function()
			local function LazyCompute(props)
				local computed = useMemo(function()
					return props.compute(props.input)
				end, { props.input })
				local count, setCount = useState(0)
				if count < 3 then
					setCount(count + 1)
				end
				return React.createElement(Text, { text = computed })
			end

			local function compute(val)
				Scheduler.unstable_yieldValue("compute " .. val)
				return val
			end

			ReactNoop.render(
				React.createElement(LazyCompute, { compute = compute, input = "A" })
			)
			jestExpect(Scheduler).toFlushAndYield({ "compute A", "A" })

			ReactNoop.render(
				React.createElement(LazyCompute, { compute = compute, input = "A" })
			)
			jestExpect(Scheduler).toFlushAndYield({ "A" })

			ReactNoop.render(
				React.createElement(LazyCompute, { compute = compute, input = "B" })
			)
			jestExpect(Scheduler).toFlushAndYield({ "compute B", "B" })
		end
	)

	-- ROBLOX deviation START: Test that deps can include nil values
	it("correctly interprets input changes with nil values", function()
		local function LazyCompute(props)
			local deps = {}
			-- Create a list of deps for each non-'.' character, like:
			-- { "A", nil, nil, nil, nil } or { nil, nil, nil, nil, "E" }
			for i, char in string.split(props.input, "") do
				deps[i] = if char ~= "." then char else nil
			end
			local computed = useMemo(function()
				return props.compute(props.input)
			end, deps)
			return React.createElement(Text, { text = computed })
		end

		local function compute(val)
			Scheduler.unstable_yieldValue("compute " .. val)
			return val
		end

		ReactNoop.render(
			React.createElement(LazyCompute, { compute = compute, input = "A...." })
		)
		jestExpect(Scheduler).toFlushAndYield({ "compute A....", "A...." })

		ReactNoop.render(
			React.createElement(LazyCompute, { compute = compute, input = "A...E" })
		)
		jestExpect(Scheduler).toFlushAndYield({ "compute A...E", "A...E" })

		ReactNoop.render(
			React.createElement(LazyCompute, { compute = compute, input = "ABCDE" })
		)
		jestExpect(Scheduler).toFlushAndYield({ "compute ABCDE", "ABCDE" })

		ReactNoop.render(
			React.createElement(LazyCompute, { compute = compute, input = "....E" })
		)
		jestExpect(Scheduler).toFlushAndYield({ "compute ....E", "....E" })

		ReactNoop.render(
			React.createElement(LazyCompute, { compute = compute, input = "..C.." })
		)
		jestExpect(Scheduler).toFlushAndYield({ "compute ..C..", "..C.." })
	end)
	-- ROBLOX deviation END
end)

describe("useRef", function()
	-- ROBLOX TODO: clearTimeout: attempt to index number with userdata (LUAFDN-293)
	it("creates a ref object initialized with the provided value", function()
		local function useDebouncedCallback(callback, ms, inputs)
			-- ROBLOX FIXME: Our setTimeout returns a table that doesn't convert into a number, resolve this
			local timeoutID = useRef(setTimeout(function() end, 0))
			useEffect(function()
				return function()
					if typeof(timeoutID.current) == "table" then
						clearTimeout(timeoutID.current)
					end
				end
			end, {})
			local debouncedCallback = useCallback(function(...)
				if typeof(timeoutID.current) == "table" then
					clearTimeout(timeoutID.current)
				end
				timeoutID.current = setTimeout(callback, ms, ...)
			end, {
				callback,
				ms,
			} :: Array<any>)
			return useCallback(debouncedCallback, inputs)
		end

		local ping
		local function App()
			ping = useDebouncedCallback(function(value)
				Scheduler.unstable_yieldValue("ping: " .. value)
			end, 100, {})
			return nil
		end

		act(function()
			ReactNoop.render(React.createElement(App))
		end)
		jestExpect(Scheduler).toHaveYielded({})

		ping(1)
		ping(2)
		ping(3)

		jestExpect(Scheduler).toHaveYielded({})

		jest.advanceTimersByTime(100)

		jestExpect(Scheduler).toHaveYielded({ "ping: 3" })

		ping(4)
		jest.advanceTimersByTime(20)
		jestExpect(Scheduler).toHaveYielded({})
		ping(5)
		jestExpect(Scheduler).toHaveYielded({})
		ping(6)
		jestExpect(Scheduler).toHaveYielded({})
		jest.advanceTimersByTime(80)

		jestExpect(Scheduler).toHaveYielded({})

		jest.advanceTimersByTime(20)
		jestExpect(Scheduler).toHaveYielded({ "ping: 6" })
	end)

	it("should return the same ref during re-renders", function()
		local function Counter()
			local ref = useRef("val")
			local count, setCount = useState(0)
			local firstRef = useState(ref)

			if firstRef ~= ref then
				error("should never change")
			end

			if count < 3 then
				setCount(count + 1)
			end

			return React.createElement(Text, { text = ref.current })
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "val" })

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "val" })
	end)
end)

-- ROBLOX deviation START: binding support (these tests mimic the ref tests)
describe("useBinding", function()
	-- ROBLOX TODO: clearTimeout: attempt to index number with userdata (LUAFDN-293)
	it("creates a binding object initialized with the provided value", function()
		local function useDebouncedCallback(callback, ms, inputs)
			-- ROBLOX FIXME: Our setTimeout returns a table that doesn't convert into a number, resolve this
			local timeoutID, updateTimeout = useBinding(setTimeout(function() end, 0))
			useEffect(function()
				return function()
					if typeof(timeoutID:getValue()) == "table" then
						clearTimeout(timeoutID:getValue())
					end
				end
			end, {})
			local debouncedCallback = useCallback(function(...)
				if typeof(timeoutID:getValue()) == "table" then
					clearTimeout(timeoutID:getValue())
				end
				updateTimeout(setTimeout(callback, ms, ...))
			end, {
				callback,
				ms,
			} :: Array<any>)
			return useCallback(debouncedCallback, inputs)
		end

		local ping
		local function App()
			ping = useDebouncedCallback(function(value)
				Scheduler.unstable_yieldValue("ping: " .. value)
			end, 100, {})
			return nil
		end

		act(function()
			ReactNoop.render(React.createElement(App))
		end)
		jestExpect(Scheduler).toHaveYielded({})

		ping(1)
		ping(2)
		ping(3)

		jestExpect(Scheduler).toHaveYielded({})

		jest.advanceTimersByTime(100)

		jestExpect(Scheduler).toHaveYielded({ "ping: 3" })

		ping(4)
		jest.advanceTimersByTime(20)
		jestExpect(Scheduler).toHaveYielded({})
		ping(5)
		jestExpect(Scheduler).toHaveYielded({})
		ping(6)
		jestExpect(Scheduler).toHaveYielded({})
		jest.advanceTimersByTime(80)

		jestExpect(Scheduler).toHaveYielded({})

		jest.advanceTimersByTime(20)
		jestExpect(Scheduler).toHaveYielded({ "ping: 6" })
	end)

	it("should return the same binding value during re-renders", function()
		local function Counter()
			local binding, _updater = useBinding("val")
			local count, setCount = useState(0)
			local firstBinding = useState(binding)

			if firstBinding ~= binding then
				error("should never change")
			end

			if count < 3 then
				setCount(count + 1)
			end

			return React.createElement(Text, { text = binding:getValue() })
		end

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "val" })

		ReactNoop.render(React.createElement(Counter))
		jestExpect(Scheduler).toFlushAndYield({ "val" })
	end)
end)
-- ROBLOX deviation END

describe("useImperativeHandle", function()
	it("does not update when deps are the same", function()
		local INCREMENT = "INCREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == INCREMENT then
				return state + 1
			else
				return state
			end
		end

		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				return { count = count, dispatch = dispatch }
			end, {})
			return React.createElement(Text, { text = "Count: " .. count })
		end

		-- ROBLOX TODO: upstream this rename to make code/types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, {
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		jestExpect(counter.current.count).toEqual(0)

		act(function()
			counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		-- Intentionally not updated because of [] deps:
		jestExpect(counter.current.count).toEqual(0)
	end)

	-- Regression test for https://github.com/facebook/react/issues/14782
	it("automatically updates when deps are not specified", function()
		local INCREMENT = "INCREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == INCREMENT then
				return state + 1
			else
				return state
			end
		end

		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				return { count = count, dispatch = dispatch }
			end)
			return React.createElement(Text, { text = "Count: " .. count })
		end

		-- ROBLOX TODO: upstream this rename to make code/types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, {
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		jestExpect(counter.current.count).toEqual(0)

		act(function()
			counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		jestExpect(counter.current.count).toEqual(1)
	end)

	it("updates when deps are different", function()
		local INCREMENT = "INCREMENT"

		-- ROBLOX FIXME Luau: based on useReducer() call below, we should know that state is a number without an annotation
		local function reducer_(state: number, action)
			if action == INCREMENT then
				return state + 1
			else
				return state
			end
		end

		local totalRefUpdates = 0
		local function Counter(props, ref)
			local count, dispatch = useReducer(reducer_, 0)
			useImperativeHandle(ref, function()
				totalRefUpdates = totalRefUpdates + 1
				return { count = count, dispatch = dispatch }
			end, {
				count,
			})
			return React.createElement(Text, { text = "Count: " .. count })
		end

		-- ROBLOX TODO: upstream this rename to make code/types more sane
		local CounterRef = forwardRef(Counter)
		local counter = React.createRef()
		ReactNoop.render(React.createElement(CounterRef, {
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 0") })
		jestExpect(counter.current.count).toEqual(0)
		jestExpect(totalRefUpdates).toEqual(1)

		act(function()
			counter.current.dispatch(INCREMENT)
		end)
		jestExpect(Scheduler).toHaveYielded({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		jestExpect(counter.current.count).toEqual(1)
		jestExpect(totalRefUpdates).toEqual(2)

		-- Update that doesn't change the ref dependencies
		ReactNoop.render(React.createElement(CounterRef, {
			ref = counter,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "Count: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Count: 1") })
		jestExpect(counter.current.count).toEqual(1)
		jestExpect(totalRefUpdates).toEqual(2) -- Should not increase since last time
	end)
end)
-- describe('useTransition', function()
--   -- @gate experimental
--   it('delays showing loading state until after timeout', async function()
--     local transition
--     function App()
--       local [show, setShow] = useState(false)
--       local [startTransition, isPending] = useTransition({
--         timeoutMs: 1000,
--       })
--       transition = function()
--         startTransition(function()
--           setShow(true)
--         })
--       end
--       return (
--         <Suspense
--           fallback={<Text text={`Loading... Pending: ${isPending}`} />}>
--           {show ? (
--             <AsyncText text={`After... Pending: ${isPending}`} />
--           ) : (
--             <Text text={`Before... Pending: ${isPending}`} />
--           )}
--         </Suspense>
--       )
--     end
--     ReactNoop.render(<App />)
--     jestExpect(Scheduler).toFlushAndYield(['Before... Pending: false'])
--     jestExpect(ReactNoop.getChildren()).toEqual([
--       span('Before... Pending: false'),
--     ])

--     await act(async function()
--       Scheduler.unstable_runWithPriority(
--         Scheduler.unstable_UserBlockingPriority,
--         transition,
--       )

--       jestExpect(Scheduler).toFlushAndYield([
--         'Before... Pending: true',
--         'Suspend! [After... Pending: false]',
--         'Loading... Pending: false',
--       ])
--       jestExpect(ReactNoop.getChildren()).toEqual([
--         span('Before... Pending: true'),
--       ])
--       Scheduler.unstable_advanceTime(500)
--       await advanceTimers(500)

--       -- Even after a long amount of time, we still don't show a placeholder.
--       Scheduler.unstable_advanceTime(100000)
--       await advanceTimers(100000)
--       jestExpect(ReactNoop.getChildren()).toEqual([
--         span('Before... Pending: true'),
--       ])

--       await resolveText('After... Pending: false')
--       jestExpect(Scheduler).toHaveYielded([
--         'Promise resolved [After... Pending: false]',
--       ])
--       jestExpect(Scheduler).toFlushAndYield(['After... Pending: false'])
--       jestExpect(ReactNoop.getChildren()).toEqual([
--         span('After... Pending: false'),
--       ])
--     })
--   })
-- })

-- describe('useDeferredValue', function()
--   -- @gate experimental
--   it('defers text value', async function()
--     function TextBox({text})
--       return <AsyncText text={text} />
--     end

--     local _setText
--     function App()
--       local [text, setText] = useState('A')
--       local deferredText = useDeferredValue(text, {
--         timeoutMs: 500,
--       })
--       _setText = setText
--       return (
--         <>
--           <Text text={text} />
--           <Suspense fallback={<Text text={'Loading'} />}>
--             <TextBox text={deferredText} />
--           </Suspense>
--         </>
--       )
--     end

--     act(function()
--       ReactNoop.render(<App />)
--     })

--     jestExpect(Scheduler).toHaveYielded(['A', 'Suspend! [A]', 'Loading'])
--     jestExpect(ReactNoop.getChildren()).toEqual([span('A'), span('Loading')])

--     await resolveText('A')
--     jestExpect(Scheduler).toHaveYielded(['Promise resolved [A]'])
--     jestExpect(Scheduler).toFlushAndYield(['A'])
--     jestExpect(ReactNoop.getChildren()).toEqual([span('A'), span('A')])

--     await act(async function()
--       _setText('B')
--       jestExpect(Scheduler).toFlushAndYield([
--         'B',
--         'A',
--         'B',
--         'Suspend! [B]',
--         'Loading',
--       ])
--       jestExpect(Scheduler).toFlushAndYield([])
--       jestExpect(ReactNoop.getChildren()).toEqual([span('B'), span('A')])
--     })

--     await act(async function()
--       Scheduler.unstable_advanceTime(250)
--       await advanceTimers(250)
--     })
--     jestExpect(Scheduler).toHaveYielded([])
--     jestExpect(ReactNoop.getChildren()).toEqual([span('B'), span('A')])

--     -- Even after a long amount of time, we don't show a fallback
--     Scheduler.unstable_advanceTime(100000)
--     await advanceTimers(100000)
--     jestExpect(Scheduler).toFlushAndYield([])
--     jestExpect(ReactNoop.getChildren()).toEqual([span('B'), span('A')])

--     await act(async function()
--       await resolveText('B')
--     })
--     jestExpect(Scheduler).toHaveYielded(['Promise resolved [B]', 'B', 'B'])
--     jestExpect(ReactNoop.getChildren()).toEqual([span('B'), span('B')])
--   })
-- })

describe("progressive enhancement (not supported)", function()
	it("mount additional state", function()
		local updateA
		local updateB
		-- local updateC

		local function App(props)
			local A, _updateA = useState(0)
			local B, _updateB = useState(0)
			updateA = _updateA
			updateB = _updateB

			local C
			if props.loadC then
				useState(0)
			else
				C = "[not loaded]"
			end

			return React.createElement(Text, {
				text = string.format(
					"A: %s, B: %s, C: %s",
					tostring(A),
					tostring(B),
					tostring(C)
				),
			})
		end

		ReactNoop.render(React.createElement(App, { loadC = false }))
		jestExpect(Scheduler).toFlushAndYield({ "A: 0, B: 0, C: [not loaded]" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("A: 0, B: 0, C: [not loaded]"),
		})

		act(function()
			updateA(2)
			updateB(3)
		end)

		jestExpect(Scheduler).toHaveYielded({ "A: 2, B: 3, C: [not loaded]" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("A: 2, B: 3, C: [not loaded]"),
		})

		ReactNoop.render(React.createElement(App, { loadC = true }))
		jestExpect(function()
			jestExpect(function()
				jestExpect(Scheduler).toFlushAndYield({ "A: 2, B: 3, C: 0" })
			end).toThrow("Rendered more hooks than during the previous render")
		end).toErrorDev({
			"Warning: React has detected a change in the order of Hooks called by App. "
				.. "This will lead to bugs and errors if not fixed. For more information, "
				.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
				.. "   Previous render            Next render\n"
				.. "   ------------------------------------------------------\n"
				.. "1. useState                   useState\n"
				.. "2. useState                   useState\n"
				.. "3. undefined                  useState\n"
				.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n",
		})

		-- Uncomment if/when we support this again
		-- jestExpect(ReactNoop.getChildren()).toEqual([span('A: 2, B: 3, C: 0')])

		-- updateC(4)
		-- jestExpect(Scheduler).toFlushAndYield(['A: 2, B: 3, C: 4'])
		-- jestExpect(ReactNoop.getChildren()).toEqual([span('A: 2, B: 3, C: 4')])
	end)

	it("unmount state", function()
		local updateA
		local updateB
		local updateC

		local function App(props)
			local A, _updateA = useState(0)
			local B, _updateB = useState(0)
			updateA = _updateA
			updateB = _updateB

			-- ROBLOX FIXME Luau: Luau should infer this annotation
			local C: string | number
			if props.loadC then
				local _C, _updateC = useState(0)
				C = _C
				updateC = _updateC
			else
				C = "[not loaded]"
			end

			return React.createElement(Text, {
				text = string.format(
					"A: %s, B: %s, C: %s",
					tostring(A),
					tostring(B),
					tostring(C)
				),
			})
		end

		ReactNoop.render(React.createElement(App, { loadC = true }))
		jestExpect(Scheduler).toFlushAndYield({ "A: 0, B: 0, C: 0" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("A: 0, B: 0, C: 0") })
		act(function()
			updateA(2)
			updateB(3)
			updateC(4)
		end)
		jestExpect(Scheduler).toHaveYielded({ "A: 2, B: 3, C: 4" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("A: 2, B: 3, C: 4") })
		ReactNoop.render(React.createElement(App, { loadC = false }))
		jestExpect(Scheduler).toFlushAndThrow(
			"Rendered fewer hooks than expected. This may be caused by an "
				.. "accidental early return statement."
		)
	end)

	it("unmount effects", function()
		local function App(props)
			useEffect(function()
				Scheduler.unstable_yieldValue("Mount A")
				return function()
					Scheduler.unstable_yieldValue("Unmount A")
				end
			end, {})

			if props.showMore then
				useEffect(function()
					Scheduler.unstable_yieldValue("Mount B")
					return function()
						Scheduler.unstable_yieldValue("Unmount B")
					end
				end, {})
			end

			return nil
		end

		act(function()
			ReactNoop.render(React.createElement(App, { showMore = false }), function()
				Scheduler.unstable_yieldValue("Sync effect")
			end)
			jestExpect(Scheduler).toFlushAndYieldThrough({ "Sync effect" })
		end)

		jestExpect(Scheduler).toHaveYielded({ "Mount A" })

		act(function()
			ReactNoop.render(React.createElement(App, { showMore = true }))
			jestExpect(function()
				jestExpect(function()
					jestExpect(Scheduler).toFlushAndYield({})
				end).toThrow("Rendered more hooks than during the previous render")
			end).toErrorDev({
				"Warning: React has detected a change in the order of Hooks called by App. "
					.. "This will lead to bugs and errors if not fixed. For more information, "
					.. "read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
					.. "   Previous render            Next render\n"
					.. "   ------------------------------------------------------\n"
					.. "1. useEffect                  useEffect\n"
					.. "2. undefined                  useEffect\n"
					.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n",
			})
		end)

		-- Uncomment if/when we support this again
		-- ReactNoop.flushPassiveEffects()
		-- jestExpect(Scheduler).toHaveYielded(['Mount B'])

		-- ReactNoop.render(<App showMore={false} />)
		-- jestExpect(Scheduler).toFlushAndThrow(
		--   'Rendered fewer hooks than expected. This may be caused by an ' ..
		--     'accidental early return statement.',
		-- )
	end)
end)

it(
	"eager bailout optimization should always compare to latest rendered reducer",
	function()
		-- Edge case based on a bug report
		local counter, setCounter

		local function Component(props)
			-- ROBLOX deviation: can't destructure list in Lua function arguments
			local count = props.count
			-- ROBLOX Luau FIXME: I have to explicit add _action: nil, but it should be inferred: https://jira.rbx.com/browse/CLI-49121
			local state, dispatch = useReducer(function(_, _action: nil)
				-- This reducer closes over a value from props. If the reducer is not
				-- properly updated, the eager reducer will compare to an old value
				-- and bail out incorrectly.
				Scheduler.unstable_yieldValue("Reducer: " .. tostring(count))
				return count
			end, -1)
			useEffect(function()
				Scheduler.unstable_yieldValue("Effect: " .. tostring(count))
				dispatch()
			end, {
				count,
			})
			Scheduler.unstable_yieldValue("Render: " .. state)
			return count
		end

		local function App()
			counter, setCounter = useState(1)
			return React.createElement(Component, { count = counter })
		end

		act(function()
			ReactNoop.render(React.createElement(App))
			jestExpect(Scheduler).toFlushAndYield({
				"Render: -1",
				"Effect: 1",
				"Reducer: 1",
				"Reducer: 1",
				"Render: 1",
			})

			jestExpect(ReactNoop).toMatchRenderedOutput("1")
		end)

		act(function()
			setCounter(2)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Render: 1",
			"Effect: 2",
			"Reducer: 2",
			"Reducer: 2",
			"Render: 2",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput("2")
	end
)

-- ROBLOX FIXME: this test needs to be enabled
-- Regression test. Covers a case where an internal state variable
-- (`didReceiveUpdate`) is not reset properly.
-- it('state bail out edge case (#16359)', async function()
--   local setCounterA
--   local setCounterB

--   function CounterA()
--     local [counter, setCounter] = useState(0)
--     setCounterA = setCounter
--     Scheduler.unstable_yieldValue('Render A: ' .. counter)
--     useEffect(function()
--       Scheduler.unstable_yieldValue('Commit A: ' .. counter)
--     })
--     return counter
--   end

--   function CounterB()
--     local [counter, setCounter] = useState(0)
--     setCounterB = setCounter
--     Scheduler.unstable_yieldValue('Render B: ' .. counter)
--     useEffect(function()
--       Scheduler.unstable_yieldValue('Commit B: ' .. counter)
--     })
--     return counter
--   end

--   local root = ReactNoop.createRoot(null)
--   await ReactNoop.act(async function()
--     root.render(
--       <>
--         <CounterA />
--         <CounterB />
--       </>,
--     )
--   })
--   jestExpect(Scheduler).toHaveYielded([
--     'Render A: 0',
--     'Render B: 0',
--     'Commit A: 0',
--     'Commit B: 0',
--   ])

--   await ReactNoop.act(async function()
--     setCounterA(1)

--     -- In the same batch, update B twice. To trigger the condition we're
--     -- testing, the first update is necessary to bypass the early
--     -- bailout optimization.
--     setCounterB(1)
--     setCounterB(0)
--   })
--   jestExpect(Scheduler).toHaveYielded([
--     'Render A: 1',
--     'Render B: 0',
--     'Commit A: 1',
--     -- B should not fire an effect because the update bailed out
--     -- 'Commit B: 0',
--   ])
-- })

it(
	"should update latest rendered reducer when a preceding state receives a render phase update",
	function()
		-- Similar to previous test, except using a preceding render phase update
		-- instead of new props.
		local shadow, dispatch
		local function App()
			local step, setStep = useState(0)
			-- ROBLOX Luau FIXME: I have to explicit add _action: nil, but it should be inferred: https://jira.rbx.com/browse/CLI-49121
			shadow, dispatch = useReducer(function(_, __: nil)
				return step
			end, step)

			if step < 5 then
				setStep(step + 1)
			end

			Scheduler.unstable_yieldValue("Step: " .. step .. ", Shadow: " .. shadow)
			return shadow
		end

		ReactNoop.render(React.createElement(App))
		jestExpect(Scheduler).toFlushAndYield({
			"Step: 0, Shadow: 0",
			"Step: 1, Shadow: 0",
			"Step: 2, Shadow: 0",
			"Step: 3, Shadow: 0",
			"Step: 4, Shadow: 0",
			"Step: 5, Shadow: 0",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput("0")

		act(function()
			return dispatch()
		end)
		jestExpect(Scheduler).toHaveYielded({ "Step: 5, Shadow: 5" })
		jestExpect(ReactNoop).toMatchRenderedOutput("5")
	end
)

it("should process the rest pending updates after a render phase update", function()
	-- Similar to previous test, except using a preceding render phase update
	-- instead of new props.
	local updateA
	local updateC
	local function App()
		local a, setA = useState(false)
		local b, setB = useState(false)
		if a ~= b then
			setB(a)
		end
		-- Even though we called setB above,
		-- we should still apply the changes to C,
		-- during this render pass.
		local c, setC = useState(false)
		updateA = setA
		updateC = setC
		return string.format(
			"%s%s%s",
			a and "A" or "a",
			b and "B" or "b",
			c and "C" or "c"
		)
	end

	act(function()
		ReactNoop.render(React.createElement(App))
	end)
	jestExpect(ReactNoop).toMatchRenderedOutput("abc")

	act(function()
		updateA(true)
		-- This update should not get dropped.
		updateC(true)
	end)
	jestExpect(ReactNoop).toMatchRenderedOutput("ABC")
end)

it("regression test: don't unmount effects on siblings of deleted nodes", function()
	local root = ReactNoop.createRoot()

	local function Child(props)
		local label = props.label
		useLayoutEffect(function()
			Scheduler.unstable_yieldValue("Mount layout " .. label)
			return function()
				Scheduler.unstable_yieldValue("Unmount layout " .. label)
			end
		end, { label })
		useEffect(function()
			Scheduler.unstable_yieldValue("Mount passive " .. label)
			return function()
				Scheduler.unstable_yieldValue("Unmount passive " .. label)
			end
		end, { label })
		return label
	end

	act(function()
		root.render(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(Child, { key = "A", label = "A" }),
				React.createElement(Child, { key = "B", label = "B" })
			)
		)
	end)
	jestExpect(Scheduler).toHaveYielded({
		"Mount layout A",
		"Mount layout B",
		"Mount passive A",
		"Mount passive B",
	})

	-- Delete A. This should only unmount the effect on A. In the regression,
	-- B's effect would also unmount.
	act(function()
		root.render(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(Child, { key = "B", label = "B" })
			)
		)
	end)
	jestExpect(Scheduler).toHaveYielded({ "Unmount layout A", "Unmount passive A" })

	-- Now delete and unmount B.
	act(function()
		root.render(nil)
	end)
	jestExpect(Scheduler).toHaveYielded({ "Unmount layout B", "Unmount passive B" })
end)

it("regression: deleting a tree and unmounting its effects after a reorder", function()
	local root = ReactNoop.createRoot()

	local function Child(props)
		local label = props.label
		useEffect(function()
			Scheduler.unstable_yieldValue("Mount " .. label)
			return function()
				Scheduler.unstable_yieldValue("Unmount " .. label)
			end
		end, { label })
		return label
	end

	act(function()
		root.render(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(Child, { key = "A", label = "A" }),
				React.createElement(Child, { key = "B", label = "B" })
			)
		)
	end)
	jestExpect(Scheduler).toHaveYielded({
		"Mount A",
		"Mount B",
	})

	act(function()
		root.render(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(Child, { key = "B", label = "B" }),
				React.createElement(Child, { key = "A", label = "A" })
			)
		)
	end)
	jestExpect(Scheduler).toHaveYielded({})

	act(function()
		root.render(nil)
	end)
	jestExpect(Scheduler).toHaveYielded({
		"Unmount B",
		-- In the regression, the reorder would cause Child A to "forget" that it
		-- contains passive effects. Then when we deleted the tree, A's unmount
		-- effect would not fire.
		"Unmount A",
	})
end)

it("effect dependencies are persisted after a render phase update", function()
	local handleClick
	local function Test()
		local count, setCount = useState(0)
		useEffect(function()
			Scheduler.unstable_yieldValue("Effect: " .. count)
		end, { count })

		if count > 0 then
			setCount(0)
		end

		handleClick = function()
			return setCount(2)
		end

		return React.createElement(Text, { text = string.format("Render: %d", count) })
	end

	act(function()
		ReactNoop.render(React.createElement(Test))
	end)

	jestExpect(Scheduler).toHaveYielded({ "Render: 0", "Effect: 0" })

	act(function()
		handleClick()
	end)

	jestExpect(Scheduler).toHaveYielded({ "Render: 0" })

	act(function()
		handleClick()
	end)

	jestExpect(Scheduler).toHaveYielded({ "Render: 0" })

	act(function()
		handleClick()
	end)

	jestExpect(Scheduler).toHaveYielded({ "Render: 0" })
end) ]]
eC.Children._413d64539a9781f212eeee6a9bb7eb3b=e8
local e9

local fa={ClassName="ModuleScript",Children={},Properties={}}
fa.Name="ReactIdentity.spec"
fa.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/__tests__/ReactIdentity-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]

-- ROBLOX deviation: This test file was adapted from `react-dom` and ported to roblox-renderer
local React, Scheduler
local ReactRoblox, reactRobloxRoot

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	React = require(Packages.React)
	ReactRoblox = require(Packages.Dev.ReactRoblox)
	Scheduler = require(Packages.Scheduler)
	local parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
end)

-- ROBLOX deviation: This test can hit succeed erroneously in luau, since
-- table iteration order is unpredictable; with only two elements and no
-- guaranteed order, react might happen to assign the right values even if key
-- behavior isn't working.
-- it("should allow key property to express identity", function()
--   local ref = React.createRef()
--   local function Component(props)
--     return React.createElement("Frame", {ref=ref},
--       React.createElement("Frame", {key=props.swap and "banana" or "apple", prop="Hello"}),
--       React.createElement("Frame", {key=props.swap and "apple" or "banana", prop="World"})
--     )
--   end

--   local function childrenByProp(children)
--     local byProp = {}
--     for _, instance in children do
--       byProp[instance.prop] = instance
--     end
--     return byProp
--   end

--   -- ROBLOX deviation: Use react-noop + act instead of rendering into document
--   ReactNoop.act(function()
--     ReactNoop.render(React.createElement(Component))
--   end)
--   local origChildren = childrenByProp(ref.current.children)
--   ReactNoop.act(function()
--     ReactNoop.render(React.createElement(Component, {swap=true}))
--   end)
--   local newChildren = childrenByProp(ref.current.children)

--   -- After rendering with `swap=true`, the keys will have switched and the
--   -- prop values will correspond to the opposite children
--   jestExpect(origChildren["Hello"]).toBe(newChildren["World"])
--   jestExpect(origChildren["World"]).toBe(newChildren["Hello"])
-- end)

-- ROBLOX deviation START: Replaces the above test. This new test verifies the
-- behavior expected above, but uses enough table keys to greatly reduce the
-- likelihood of coincidental success.
it("should allow key property to express identity", function()
	local ref = React.createRef()
	local function Component(props)
		local children = {}
		for i = 1, 500 do
			local key = props.invert and tostring(51 - i) or tostring(i)
			children[key] = React.createElement("TextLabel", { Text = i })
		end

		return React.createElement("Frame", { ref = ref }, unpack(children))
	end

	local function childrenByProp(children)
		local byProp = {}
		for _, instance in children do
			byProp[instance.Text] = instance
		end
		return byProp
	end

	reactRobloxRoot:render(React.createElement(Component))
	Scheduler.unstable_flushAllWithoutAsserting()

	local origChildren = childrenByProp(ref.current:GetChildren())

	reactRobloxRoot:render(React.createElement(Component, { invert = true }))
	Scheduler.unstable_flushAllWithoutAsserting()

	local newChildren = childrenByProp(ref.current:GetChildren())

	-- After rendering with `invert=true`, the keys will have switched and the
	-- prop values will correspond to the opposite children
	for i = 1, 500 do
		jestExpect(origChildren[i]).toBe(newChildren[51 - i])
		jestExpect(origChildren[51 - i]).toBe(newChildren[i])
	end
end)
-- ROBLOX deviation END

-- ROBLOX deviation: Verify equivalent behavior with table keys, an adaptation
-- to be compatible with currently-released Roact
it("should allow table key to express identity", function()
	local ref = React.createRef()
	local function Component(props)
		local children = {}
		for i = 1, 50 do
			local key = props.invert and tostring(51 - i) or tostring(i)
			children[key] = React.createElement("TextLabel", { Text = i })
		end

		return React.createElement("Frame", { ref = ref }, children)
	end

	local function childrenByProp(children)
		local byProp = {}
		for _, instance in children do
			byProp[instance.Text] = instance
		end
		return byProp
	end

	reactRobloxRoot:render(React.createElement(Component))
	Scheduler.unstable_flushAllWithoutAsserting()

	local origChildren = childrenByProp(ref.current:GetChildren())

	reactRobloxRoot:render(React.createElement(Component, { invert = true }))
	Scheduler.unstable_flushAllWithoutAsserting()

	local newChildren = childrenByProp(ref.current:GetChildren())

	-- After rendering with `invert=true`, the keys will have switched and the
	-- prop values will correspond to the opposite children
	for i = 1, 50 do
		jestExpect(origChildren[i]).toBe(newChildren[51 - i])
		jestExpect(origChildren[51 - i]).toBe(newChildren[i])
	end
end)

-- ROBLOX deviation: Verify equivalent behavior with table keys, an adaptation
-- to be compatible with currently-released Roact
it("should use table key to express identity when updating children type", function()
	local ref = React.createRef()

	local function Component(props)
		local children = {}
		for i = 1, props.count do
			children[tostring(i)] =
				React.createElement("TextLabel", { Text = tostring(i) })
		end

		if props.count == 0 then
			children["Test"] = React.createElement("Frame")
		end

		return React.createElement("Frame", { ref = ref }, children)
	end

	reactRobloxRoot:render(React.createElement(Component, {
		count = 0,
	}))
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(ref.current:FindFirstChild(tostring("Test"))).never.toBe(nil)

	reactRobloxRoot:render(React.createElement(Component, {
		count = 15,
		complexComponents = false,
	}))
	Scheduler.unstable_flushAllWithoutAsserting()

	for i = 1, 15 do
		jestExpect(ref.current:FindFirstChild(tostring(i))).never.toBe(nil)
	end
end)

it("should defer to provided key if both are present", function()
	local ref = React.createRef()
	local function Component(props)
		local children = {}
		for i = 1, 50 do
			local key = props.invert and tostring(51 - i) or tostring(i)
			-- provide both explicit key and table key, where table-key does not
			-- obey the `invert` prop and should not be the one that's used.
			children[tostring(i)] =
				React.createElement("TextLabel", { key = key, Text = i })
		end

		return React.createElement("Frame", { ref = ref }, children)
	end

	local function childrenByProp(children)
		local byProp = {}
		for _, instance in children do
			byProp[instance.Text] = instance
		end
		return byProp
	end

	jestExpect(function()
		reactRobloxRoot:render(React.createElement(Component))
		Scheduler.unstable_flushAllWithoutAsserting()
	end).toErrorDev({
		-- We expect to see warnings caused by using both kinds of key
		'Please provide only one key definition. When both are present, the "key" prop will take precedence.',
	})

	local origChildren = childrenByProp(ref.current:GetChildren())

	reactRobloxRoot:render(React.createElement(Component, { invert = true }))
	Scheduler.unstable_flushAllWithoutAsserting()

	local newChildren = childrenByProp(ref.current:GetChildren())

	-- After rendering with `invert=true`, the keys will have switched and the
	-- prop values will correspond to the opposite children
	for i = 1, 50 do
		jestExpect(origChildren[i]).toBe(newChildren[51 - i])
		jestExpect(origChildren[51 - i]).toBe(newChildren[i])
	end
end)

it("should use composite identity", function()
	local Wrapper = React.Component:extend("Wrapper")
	function Wrapper:render()
		return React.createElement("Frame", nil, self.props.children)
	end

	local ref1 = React.createRef()
	local ref2 = React.createRef()

	reactRobloxRoot:render(
		React.createElement(
			Wrapper,
			{ key = "wrap1" },
			React.createElement("Frame", { ref = ref1 })
		)
	)
	Scheduler.unstable_flushAllWithoutAsserting()

	reactRobloxRoot:render(
		React.createElement(
			Wrapper,
			{ key = "wrap2" },
			React.createElement("Frame", { ref = ref2 })
		)
	)
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(ref1.current).never.toBe(ref2.current)
end)

local function renderAComponentWithKeyIntoContainer(key, container)
	local ref = React.createRef()

	local Wrapper = React.Component:extend("Wrapper")
	function Wrapper:render()
		return React.createElement(
			"Frame",
			nil,
			React.createElement("Frame", { ref = ref, key = key })
		)
	end

	reactRobloxRoot:render(React.createElement(Wrapper), container)
	Scheduler.unstable_flushAllWithoutAsserting()

	local span = ref.current
	jestExpect(span).never.toBe(nil)
end

it("should allow any character as a key, in a detached parent", function()
	local detachedContainer = React.createElement("Frame")
	renderAComponentWithKeyIntoContainer("<'WEIRD/&\\key'>", detachedContainer)
end)

it("should allow any character as a key, in an attached parent", function()
	-- This test exists to protect against implementation details that
	-- incorrectly query escaped IDs using DOM tools like getElementById.
	local attachedContainer = React.createElement("Frame")
	reactRobloxRoot:render(attachedContainer)
	Scheduler.unstable_flushAllWithoutAsserting()

	renderAComponentWithKeyIntoContainer("<'WEIRD/&\\key'>", attachedContainer)
end)

-- ROBLOX deviation: this test not relevant to Roblox or reconciler, since
-- script execution doesn't work this way to begin with
-- it('should not allow scripts in keys to execute', function()
--   local h4x0rKey =
--     '"><script>window[\'YOUVEBEENH4X0RED\']=true;</script><div id="'

--   local attachedContainer = document.createElement('div')
--   document.body.appendChild(attachedContainer)

--   renderAComponentWithKeyIntoContainer(h4x0rKey, attachedContainer)

--   document.body.removeChild(attachedContainer)

--   -- If we get this far, make sure we haven't executed the code
--   jestExpect(window.YOUVEBEENH4X0RED).toBe(undefined)
-- end)

it("should let restructured components retain their uniqueness", function()
	local instance0 = React.createElement("Frame")
	local instance1 = React.createElement("Frame")
	local instance2 = React.createElement("Frame")

	local TestComponent = React.Component:extend("TestComponent")
	function TestComponent:render()
		return React.createElement(
			"Frame",
			nil,
			instance2,
			self.props.children[1],
			self.props.children[2]
		)
	end

	local TestContainer = React.Component:extend("TestContainer")
	function TestContainer:render()
		return React.createElement(TestComponent, nil, instance0, instance1)
	end

	jestExpect(function()
		reactRobloxRoot:render(React.createElement(TestContainer))
		Scheduler.unstable_flushAllWithoutAsserting()
	end).never.toThrow()
end)

it("should let nested restructures retain their uniqueness", function()
	local instance0 = React.createElement("Frame")
	local instance1 = React.createElement("Frame")
	local instance2 = React.createElement("Frame")

	local TestComponent = React.Component:extend("TestComponent")
	function TestComponent:render()
		return React.createElement(
			"Frame",
			nil,
			instance2,
			self.props.children[1],
			self.props.children[2]
		)
	end

	local TestContainer = React.Component:extend("TestContainer")
	function TestContainer:render()
		return React.createElement(
			"Frame",
			nil,
			React.createElement(TestComponent, nil, instance0, instance1)
		)
	end

	jestExpect(function()
		reactRobloxRoot:render(React.createElement(TestContainer))
		Scheduler.unstable_flushAllWithoutAsserting()
	end).never.toThrow()
end)

-- ROBLOX deviaton: Roblox game engine doesn't support raw text nodes
xit("should let text nodes retain their uniqueness", function()
	local TestComponent = React.Component:extend("TestComponent")
	function TestComponent:render()
		return React.createElement(
			"Frame",
			nil,
			self.props.children,
			React.createElement("Frame")
		)
	end

	local TestContainer = React.Component:extend("TestContainer")
	function TestContainer:render()
		return React.createElement(
			TestComponent,
			nil,
			React.createElement("Frame"),
			nil,
			{ "second" }
		)
	end

	jestExpect(function()
		reactRobloxRoot:render(React.createElement(TestContainer))
		Scheduler.unstable_flushAllWithoutAsserting()
	end).never.toThrow()
end)

it("should retain key during updates in composite components", function()
	local ref = React.createRef()
	local swap

	local TestComponent = React.Component:extend("TestComponent")
	function TestComponent:render()
		return React.createElement("Frame", { ref = ref }, self.props.children)
	end

	local TestContainer = React.Component:extend("TestContainer")
	function TestContainer:init()
		self.state = { swapped = false }

		swap = function()
			self:setState({ swapped = true })
		end
	end

	function TestContainer:render()
		return React.createElement(
			TestComponent,
			nil,
			self.state.swapped and self.props.second or self.props.first,
			self.state.swapped and self.props.first or self.props.second
		)
	end

	local instance0 = React.createElement("TextLabel", { key = "A", Text = "Hello" })
	local instance1 = React.createElement("TextLabel", { key = "B", Text = "World" })

	local function childrenByProp(children)
		local byProp = {}
		for _, instance in children do
			byProp[instance.Text] = instance
		end
		return byProp
	end

	reactRobloxRoot:render(
		React.createElement(TestContainer, { first = instance0, second = instance1 })
	)
	Scheduler.unstable_flushAllWithoutAsserting()

	local originalChildren = childrenByProp(ref.current:GetChildren())
	swap()
	local newChildren = childrenByProp(ref.current:GetChildren())

	jestExpect(originalChildren["Hello"]).toBe(newChildren["Hello"])
	jestExpect(originalChildren["World"]).toBe(newChildren["World"])
end)

it("should not allow implicit and explicit keys to collide", function()
	local component = function(_props)
		return React.createElement(
			"Frame",
			nil,
			React.createElement("Frame"),
			React.createElement("Frame", { key = "1" })
		)
	end

	jestExpect(function()
		reactRobloxRoot:render(React.createElement(component))
		Scheduler.unstable_flushAllWithoutAsserting()
	end).never.toThrow()
end) ]]
eC.Children._468d98032f638eec753482ce1a965ca4=fa
local fb

local fc={ClassName="ModuleScript",Children={},Properties={}}
fc.Name="ReactIncremental.spec"
fc.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncremental-test.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local React
local ReactNoop
local Scheduler
local PropTypes
local HttpService = game:GetService("HttpService")

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

-- ROBLOX deviation START: inline simplified PropTypes logic
-- ROBLOX FIXME luau: if not annotated, gets 'Failed ot unify type packs'
local function propTypes(value, expectedType): any
	if value == nil then
		return nil
	end
	if type(value) ~= expectedType then
		return Error("expected " .. expectedType)
	end
	return nil
end
PropTypes = {
	number = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "number")
	end,
	string = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "string")
	end,
}
-- ROBLOX deviation END

describe("ReactIncremental", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	-- Note: This is based on a similar component we use in www. We can delete
	-- once the extra div wrapper is no longer necessary.
	local function LegacyHiddenDiv(props)
		local children, mode = props.children, props.mode

		return React.createElement(
			"div",
			{
				hidden = mode == "hidden",
			},
			React.createElement(React.unstable_LegacyHidden, {
				mode = (function()
					if mode == "hidden" then
						return "unstable-defer-without-hiding"
					end

					return mode
				end)(),
			}, children)
		)
	end

	-- deviation: upstream JSON.stringify returns {} given an empty input, but
	-- Lua's JSONEncode returns [].
	local function JSONStringify(value)
		local res = HttpService:JSONEncode(value)
		if res == "[]" then
			res = "{}"
		end
		return res
	end

	it("should render a simple component", function()
		local function Bar()
			return React.createElement("div", nil, "Hello World")
		end
		local function Foo()
			return React.createElement(Bar, { isBar = true })
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
	end)
	it("should render a simple component, in steps if needed", function()
		local function Bar()
			Scheduler.unstable_yieldValue("Bar")

			return React.createElement(
				"span",
				nil,
				React.createElement("div", nil, "Hello World")
			)
		end
		local function Foo()
			Scheduler.unstable_yieldValue("Foo")

			return {
				-- ROBLOX FIXME Luau: Luau needs to allow mixed arrays and/or normalize these two things to a common ancestor
				React.createElement(Bar, {
					key = "a",
					isBar = true,
				}) :: any,
				React.createElement(Bar, {
					key = "b",
					isBar = true,
				}),
			}
		end

		ReactNoop.render(React.createElement(Foo), function()
			Scheduler.unstable_yieldValue("callback")
		end)

		-- Do one step of work.
		jestExpect(ReactNoop.flushNextYield()).toEqual({
			"Foo",
		})

		-- Do the rest of the work.
		jestExpect(Scheduler).toFlushAndYield({
			"Bar",
			"Bar",
			"callback",
		})
	end)
	it("updates a previous render", function()
		local function Header()
			Scheduler.unstable_yieldValue("Header")

			return React.createElement("h1", nil, "Hi")
		end
		local function Content(props)
			Scheduler.unstable_yieldValue("Content")

			return React.createElement("div", nil, props.children)
		end
		local function Footer()
			Scheduler.unstable_yieldValue("Footer")

			return React.createElement("footer", nil, "Bye")
		end

		local header = React.createElement(Header)
		local footer = React.createElement(Footer)

		local function Foo(props)
			Scheduler.unstable_yieldValue("Foo")

			return React.createElement(
				"div",
				nil,
				header,
				React.createElement(Content, nil, props.text),
				footer
			)
		end

		ReactNoop.render(
			React.createElement(Foo, {
				text = "foo",
			}),
			function()
				return Scheduler.unstable_yieldValue("renderCallbackCalled")
			end
		)
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Header",
			"Content",
			"Footer",
			"renderCallbackCalled",
		})
		ReactNoop.render(
			React.createElement(Foo, {
				text = "bar",
			}),
			function()
				return Scheduler.unstable_yieldValue("firstRenderCallbackCalled")
			end
		)
		ReactNoop.render(
			React.createElement(Foo, {
				text = "bar",
			}),
			function()
				return Scheduler.unstable_yieldValue("secondRenderCallbackCalled")
			end
		)

		-- TODO: Test bail out of host components. This is currently unobservable.

		-- Since this is an update, it should bail out and reuse the work from
		-- Header and Content.
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Content",
			"firstRenderCallbackCalled",
			"secondRenderCallbackCalled",
		})
	end)
	it("can cancel partially rendered work and restart", function()
		local function Bar(props)
			Scheduler.unstable_yieldValue("Bar")

			return React.createElement("div", nil, props.children)
		end
		local function Foo(props)
			Scheduler.unstable_yieldValue("Foo")

			return React.createElement(
				"div",
				nil,
				React.createElement(Bar, nil, props.text),
				React.createElement(Bar, nil, props.text)
			)
		end

		-- Init
		ReactNoop.render(React.createElement(Foo, {
			text = "foo",
		}))
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
			"Bar",
		})
		ReactNoop.render(React.createElement(Foo, {
			text = "bar",
		}))
		-- Flush part of the work
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Foo",
			"Bar",
		})

		-- This will abort the previous work and restart
		ReactNoop.flushSync(function()
			return ReactNoop.render(nil)
		end)
		ReactNoop.render(React.createElement(Foo, {
			text = "baz",
		}))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Foo",
			"Bar",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Bar",
		})
	end)
	it("should call callbacks even if updates are aborted", function()
		local inst
		local Foo = React.Component:extend("Foo")

		function Foo:init()
			self.state = {
				text = "foo",
				text2 = "foo",
			}
			inst = self
		end
		function Foo:render()
			return React.createElement(
				"div",
				nil,
				React.createElement("div", nil, self.state.text),
				React.createElement("div", nil, self.state.text2)
			)
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()

		-- Flush part of the work
		inst:setState(function()
			Scheduler.unstable_yieldValue("setState1")

			return {
				text = "bar",
			}
		end, function()
			return Scheduler.unstable_yieldValue("callback1")
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"setState1",
		})

		-- This will abort the previous work and restart
		ReactNoop.flushSync(function()
			return ReactNoop.render(React.createElement(Foo))
		end)
		inst:setState(function()
			Scheduler.unstable_yieldValue("setState2")

			return {
				text2 = "baz",
			}
		end, function()
			return Scheduler.unstable_yieldValue("callback2")
		end)

		-- Flush the rest of the work which now includes the low priority
		jestExpect(Scheduler).toFlushAndYield({
			"setState1",
			"setState2",
			"callback1",
			"callback2",
		})
		jestExpect(inst.state).toEqual({
			text = "bar",
			text2 = "baz",
		})
	end)
	-- @gate experimental
	it("can deprioritize unfinished work and resume it later", function()
		local function Bar(props)
			Scheduler.unstable_yieldValue("Bar")
			return React.createElement("div", nil, props.children)
		end

		local function Middle(props)
			Scheduler.unstable_yieldValue("Middle")
			return React.createElement("span", nil, props.children)
		end

		local function Foo(props)
			Scheduler.unstable_yieldValue("Foo")
			return React.createElement(
				"div",
				nil,
				React.createElement(Bar, nil, props.text),
				React.createElement(
					LegacyHiddenDiv,
					{ mode = "hidden" },
					React.createElement(Middle, nil, props.text)
				),
				React.createElement(Bar, nil, props.text),
				React.createElement(
					LegacyHiddenDiv,
					{ mode = "hidden" },
					React.createElement(Middle, nil, "Footer")
				)
			)
		end

		-- Init
		ReactNoop.render(React.createElement(Foo, {
			text = "foo",
		}))
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
			"Bar",
			"Middle",
			"Middle",
		})

		-- Render part of the work. This should be enough to flush everything except
		-- the middle which has lower priority.
		ReactNoop.render(React.createElement(Foo, {
			text = "bar",
		}))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Foo",
			"Bar",
			"Bar",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Middle",
			"Middle",
		})
	end)

	-- @gate experimental
	it("can deprioritize a tree from without dropping work", function()
		local function Bar(props)
			Scheduler.unstable_yieldValue("Bar")

			return React.createElement("div", nil, props.children)
		end
		local function Middle(props)
			Scheduler.unstable_yieldValue("Middle")

			return React.createElement("span", nil, props.children)
		end
		local function Foo(props)
			Scheduler.unstable_yieldValue("Foo")

			return React.createElement(
				"div",
				nil,
				React.createElement(Bar, nil, props.text),
				React.createElement(LegacyHiddenDiv, {
					mode = "hidden",
				}, React.createElement(Middle, nil, props.text)),
				React.createElement(Bar, nil, props.text),
				React.createElement(LegacyHiddenDiv, {
					mode = "hidden",
				}, React.createElement(Middle, nil, "Footer"))
			)
		end

		-- Init
		ReactNoop.flushSync(function()
			ReactNoop.render(React.createElement(Foo, {
				text = "foo",
			}))
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Foo",
			"Bar",
			"Bar",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Middle",
			"Middle",
		})

		-- Render the high priority work (everything except the hidden trees).
		ReactNoop.flushSync(function()
			ReactNoop.render(React.createElement(Foo, {
				text = "foo",
			}))
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Foo",
			"Bar",
			"Bar",
		})

		-- The hidden content was deprioritized from high to low priority. A low
		-- priority callback should have been scheduled. Flush it now.
		jestExpect(Scheduler).toFlushAndYield({
			"Middle",
			"Middle",
		})
	end)

	-- ROBLOX: xited upstream
	-- xit('can resume work in a subtree even when a parent bails out', function()
	--     local function Bar(props)
	--         Scheduler.unstable_yieldValue('Bar')

	--         return React.createElement('div', nil, props.children)
	--     end
	--     local function Tester()
	--         Scheduler.unstable_yieldValue('Tester')

	--         return React.createElement('div')
	--     end
	--     local function Middle(props)
	--         Scheduler.unstable_yieldValue('Middle')

	--         return React.createElement('span', nil, props.children)
	--     end

	--     local middleContent = React.createElement('aaa', nil, React.createElement(Tester), React.createElement('bbb', {hidden = true}, React.createElement('ccc', nil, React.createElement(Middle, nil, 'Hi'))))

	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return React.createElement('div', nil, React.createElement(Bar, nil, props.text), middleContent, React.createElement(Bar, nil, props.text))
	--     end

	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--     }))
	--     ReactNoop.flushDeferredPri(52)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--         'Tester',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'bar',
	--     }))
	--     ReactNoop.flushDeferredPri(45 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--         'Bar',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Middle',
	--     })
	-- end)
	-- xit('can resume work in a bailed subtree within one pass', function()
	--     local function Bar(props)
	--         Scheduler.unstable_yieldValue('Bar')

	--         return React.createElement('div', nil, props.children)
	--     end

	--     local Tester = {}
	--     local TesterMetatable = {__index = Tester}

	--     function Tester:shouldComponentUpdate()
	--         return false
	--     end
	--     function Tester:render()
	--         Scheduler.unstable_yieldValue('Tester')

	--         return React.createElement('div')
	--     end

	--     local function Middle(props)
	--         Scheduler.unstable_yieldValue('Middle')

	--         return React.createElement('span', nil, props.children)
	--     end

	--     local Content = {}
	--     local ContentMetatable = {__index = Content}

	--     function Content:shouldComponentUpdate()
	--         return false
	--     end
	--     function Content:render()
	--         return{
	--             React.createElement(Tester, {
	--                 key = 'a',
	--                 unused = self.props.unused,
	--             }),
	--             React.createElement('bbb', {
	--                 key = 'b',
	--                 hidden = true,
	--             }, React.createElement('ccc', nil, React.createElement(Middle, nil, 'Hi'))),
	--         }
	--     end

	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return React.createElement('div', {
	--             hidden = props.text == 'bar',
	--         }, React.createElement(Bar, nil, props.text), React.createElement(Content, {
	--             unused = props.text,
	--         }), React.createElement(Bar, nil, props.text))
	--     end

	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--     }))
	--     ReactNoop.flushDeferredPri(52 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--         'Tester',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'bar',
	--     }))
	--     ReactNoop.flushDeferredPri(15)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Bar',
	--         'Middle',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--     }))
	--     ReactNoop.flushDeferredPri(40)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'bar',
	--     }))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Foo',
	--         'Bar',
	--         'Bar',
	--     })
	-- end)
	-- xit('can resume mounting a class component', function()
	--     local foo
	--     local Parent = {}
	--     local ParentMetatable = {__index = Parent}

	--     function Parent:shouldComponentUpdate()
	--         return false
	--     end
	--     function Parent:render()
	--         return React.createElement(Foo, {
	--             prop = self.props.prop,
	--         })
	--     end

	--     local Foo = {}
	--     local FooMetatable = {__index = Foo}

	--     function Foo:init(props)
	--         local self = setmetatable({}, FooMetatable)

	--         Scheduler.unstable_yieldValue('Foo constructor: ' .. props.prop)
	--     end
	--     function Foo:render()
	--         foo = self

	--         Scheduler.unstable_yieldValue('Foo')

	--         return React.createElement(Bar)
	--     end

	--     local function Bar()
	--         Scheduler.unstable_yieldValue('Bar')

	--         return React.createElement('div')
	--     end

	--     ReactNoop.render(React.createElement(Parent, {
	--         prop = 'foo',
	--     }))
	--     ReactNoop.flushDeferredPri(20)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo constructor: foo',
	--         'Foo',
	--     })
	--     foo:setState({
	--         value = 'bar',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Foo',
	--         'Bar',
	--     })
	-- end)
	-- xit('reuses the same instance when resuming a class instance', function()
	--     local foo
	--     local Parent = {}
	--     local ParentMetatable = {__index = Parent}

	--     function Parent:shouldComponentUpdate()
	--         return false
	--     end
	--     function Parent:render()
	--         return React.createElement(Foo, {
	--             prop = self.props.prop,
	--         })
	--     end

	--     local constructorCount = 0
	--     local Foo = {}
	--     local FooMetatable = {__index = Foo}

	--     function Foo:init(props)
	--         local self = setmetatable({}, FooMetatable)

	--         Scheduler.unstable_yieldValue('constructor: ' .. props.prop)

	--         constructorCount = constructorCount + 1
	--     end
	--     function Foo:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue('componentWillMount: ' .. self.props.prop)
	--     end
	--     function Foo:UNSAFE_componentWillReceiveProps()
	--         Scheduler.unstable_yieldValue('componentWillReceiveProps: ' .. self.props.prop)
	--     end
	--     function Foo:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount: ' .. self.props.prop)
	--     end
	--     function Foo:UNSAFE_componentWillUpdate()
	--         Scheduler.unstable_yieldValue('componentWillUpdate: ' .. self.props.prop)
	--     end
	--     function Foo:componentDidUpdate()
	--         Scheduler.unstable_yieldValue('componentDidUpdate: ' .. self.props.prop)
	--     end
	--     function Foo:render()
	--         foo = self

	--         Scheduler.unstable_yieldValue('render: ' .. self.props.prop)

	--         return React.createElement(Bar)
	--     end

	--     local function Bar()
	--         Scheduler.unstable_yieldValue('Foo did complete')

	--         return React.createElement('div')
	--     end

	--     ReactNoop.render(React.createElement(Parent, {
	--         prop = 'foo',
	--     }))
	--     ReactNoop.flushDeferredPri(25)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'constructor: foo',
	--         'componentWillMount: foo',
	--         'render: foo',
	--         'Foo did complete',
	--     })
	--     foo:setState({
	--         value = 'bar',
	--     })
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     jestExpect(constructorCount).toEqual(1)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'componentWillMount: foo',
	--         'render: foo',
	--         'Foo did complete',
	--         'componentDidMount: foo',
	--     })
	-- end)
	-- xit('can reuse work done after being preempted', function()
	--     local function Bar(props)
	--         Scheduler.unstable_yieldValue('Bar')

	--         return React.createElement('div', nil, props.children)
	--     end
	--     local function Middle(props)
	--         Scheduler.unstable_yieldValue('Middle')

	--         return React.createElement('span', nil, props.children)
	--     end

	--     local middleContent = React.createElement('div', nil, React.createElement(Middle, nil, 'Hello'), React.createElement(Bar, nil, '-'), React.createElement(Middle, nil, 'World'))
	--     local step0 = React.createElement('div', nil, React.createElement(Middle, nil, 'Hi'), React.createElement(Bar, nil, 'Foo'), React.createElement(Middle, nil, 'There'))

	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return React.createElement('div', nil, React.createElement(Bar, nil, props.text2), React.createElement('div', {hidden = true}, (function(
	--         )
	--             if props.step == 0 then
	--                 return step0
	--             end

	--             return middleContent
	--         end)()))
	--     end

	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--         text2 = 'foo',
	--         step = 0,
	--     }))
	--     ReactNoop.flushDeferredPri(55 + 25 + 5 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--         'Middle',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--         text2 = 'bar',
	--         step = 0,
	--     }))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--         'Middle',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'bar',
	--         text2 = 'bar',
	--         step = 1,
	--     }))
	--     ReactNoop.flushDeferredPri(30 + 25 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--     })
	--     ReactNoop.flushDeferredPri(30 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Middle',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--         text2 = 'bar',
	--         step = 1,
	--     }))
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Middle',
	--     })
	-- end)
	-- xit('can reuse work that began but did not complete, after being preempted', function()
	--     local child
	--     local sibling

	--     local function GreatGrandchild()
	--         Scheduler.unstable_yieldValue('GreatGrandchild')

	--         return React.createElement('div')
	--     end
	--     local function Grandchild()
	--         Scheduler.unstable_yieldValue('Grandchild')

	--         return React.createElement(GreatGrandchild)
	--     end

	--     local Child = {}
	--     local ChildMetatable = {__index = Child}

	--     function Child:init()
	--         local self = setmetatable({}, ChildMetatable)
	--         local _temp

	--         return
	--     end
	--     function Child:render()
	--         child = self

	--         Scheduler.unstable_yieldValue('Child')

	--         return React.createElement(Grandchild)
	--     end

	--     local Sibling = {}
	--     local SiblingMetatable = {__index = Sibling}

	--     function Sibling:render()
	--         Scheduler.unstable_yieldValue('Sibling')

	--         sibling = self

	--         return React.createElement('div')
	--     end

	--     local function Parent()
	--         Scheduler.unstable_yieldValue('Parent')

	--         return{
	--             React.createElement('div', {
	--                 key = 'a',
	--             }, React.createElement(Child)),
	--             React.createElement(Sibling, {
	--                 key = 'b',
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement(Parent))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     child:setState({step = 1})
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Child',
	--         'Grandchild',
	--     })
	--     ReactNoop.flushSync(function()
	--         sibling:setState({})
	--     end)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Sibling',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'GreatGrandchild',
	--     })
	-- end)
	-- xit('can reuse work if shouldComponentUpdate is false, after being preempted', function()
	--     local function Bar(props)
	--         Scheduler.unstable_yieldValue('Bar')

	--         return React.createElement('div', nil, props.children)
	--     end

	--     local Middle = {}
	--     local MiddleMetatable = {__index = Middle}

	--     function Middle:shouldComponentUpdate(nextProps)
	--         return self.props.children ~= nextProps.children
	--     end
	--     function Middle:render()
	--         Scheduler.unstable_yieldValue('Middle')

	--         return React.createElement('span', nil, self.props.children)
	--     end

	--     local Content = {}
	--     local ContentMetatable = {__index = Content}

	--     function Content:shouldComponentUpdate(nextProps)
	--         return self.props.step ~= nextProps.step
	--     end
	--     function Content:render()
	--         Scheduler.unstable_yieldValue('Content')

	--         return React.createElement('div', nil, React.createElement(Middle, nil, (function()
	--             if self.props.step == 0 then
	--                 return'Hi'
	--             end

	--             return'Hello'
	--         end)()), React.createElement(Bar, nil, (function()
	--             if self.props.step == 0 then
	--                 return self.props.text
	--             end

	--             return'-'
	--         end)()), React.createElement(Middle, nil, (function()
	--             if self.props.step == 0 then
	--                 return'There'
	--             end

	--             return'World'
	--         end)()))
	--     end

	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return React.createElement('div', nil, React.createElement(Bar, nil, props.text), React.createElement('div', {hidden = true}, React.createElement(Content, {
	--             step = props.step,
	--             text = props.text,
	--         })))
	--     end

	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--         step = 0,
	--     }))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Foo',
	--         'Bar',
	--         'Content',
	--         'Middle',
	--         'Bar',
	--         'Middle',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'bar',
	--         step = 1,
	--     }))
	--     ReactNoop.flushDeferredPri(30 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--     })
	--     ReactNoop.flushDeferredPri(30 + 25 + 5)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Content',
	--         'Middle',
	--         'Bar',
	--     })
	--     ReactNoop.render(React.createElement(Foo, {
	--         text = 'foo',
	--         step = 1,
	--     }))
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Middle',
	--     })
	-- end)
	it("memoizes work even if shouldComponentUpdate returns false", function()
		local Foo = React.Component:extend("Foo")

		function Foo:shouldComponentUpdate(nextProps)
			-- this.props is the memoized props. So this should return true for
			-- every update except the first one.
			local shouldUpdate = self.props.step ~= 1

			Scheduler.unstable_yieldValue(
				"shouldComponentUpdate: " .. tostring(shouldUpdate)
			)

			return shouldUpdate
		end
		function Foo:render()
			Scheduler.unstable_yieldValue("render")

			return React.createElement("div")
		end

		ReactNoop.render(React.createElement(Foo, { step = 1 }))
		jestExpect(Scheduler).toFlushAndYield({
			"render",
		})
		ReactNoop.render(React.createElement(Foo, { step = 2 }))
		jestExpect(Scheduler).toFlushAndYield({
			"shouldComponentUpdate: false",
		})
		ReactNoop.render(React.createElement(Foo, { step = 3 }))
		jestExpect(Scheduler).toFlushAndYield({
			-- If the memoized props were not updated during last bail out, sCU will
			-- keep returning false.
			"shouldComponentUpdate: true",
			"render",
		})
	end)
	it("can update in the middle of a tree using setState", function()
		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:init()
			self.state = {
				a = "a",
			}
			instance = self
		end
		function Bar:render()
			return React.createElement("div", nil, self.props.children)
		end

		local function Foo()
			return React.createElement("div", nil, React.createElement(Bar))
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state).toEqual({
			a = "a",
		})
		instance:setState({
			b = "b",
		})
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state).toEqual({
			a = "a",
			b = "b",
		})
	end)
	it("can queue multiple state updates", function()
		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:init()
			self.state = {
				a = "a",
			}
			instance = self
		end
		function Bar:render()
			return React.createElement("div", nil, self.props.children)
		end

		local function Foo()
			return React.createElement("div", nil, React.createElement(Bar))
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		-- Call setState multiple times before flushing
		instance:setState({
			b = "b",
		})
		instance:setState({
			c = "c",
		})
		instance:setState({
			d = "d",
		})
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state).toEqual({
			a = "a",
			b = "b",
			c = "c",
			d = "d",
		})
	end)
	it("can use updater form of setState", function()
		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:init()
			self.state = { num = 1 }
			instance = self
		end
		function Bar:render()
			return React.createElement("div", nil, self.props.children)
		end

		local function Foo(ref)
			return React.createElement(
				"div",
				nil,
				React.createElement(Bar, { multiplier = ref.multiplier })
			)
		end

		-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
		local function updater(state: { num: number }, props)
			-- ROBLOX deviation END
			return {
				num = state.num * props.multiplier,
			}
		end

		ReactNoop.render(React.createElement(Foo, { multiplier = 2 }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state.num).toEqual(1)
		instance:setState(updater)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state.num).toEqual(2)
		instance:setState(updater)
		ReactNoop.render(React.createElement(Foo, { multiplier = 3 }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state.num).toEqual(6)
	end)
	it("can call setState inside update callback", function()
		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:init()
			self.state = { num = 1 }
			instance = self
		end
		function Bar:render()
			return React.createElement("div", nil, self.props.children)
		end

		local function Foo(_ref3)
			local multiplier = _ref3.multiplier

			return React.createElement(
				"div",
				nil,
				React.createElement(Bar, { multiplier = multiplier })
			)
		end

		-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
		local function updater(state: { num: number }, props)
			-- ROBLOX deviation END
			return {
				num = state.num * props.multiplier,
			}
		end
		local function callback()
			instance:setState({ called = true })
		end

		ReactNoop.render(React.createElement(Foo, { multiplier = 2 }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		instance:setState(updater)
		instance:setState(updater, callback)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state.num).toEqual(4)
		jestExpect(instance.state.called).toEqual(true)
	end)
	it("can replaceState", function()
		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:render()
			instance = self

			return React.createElement("div", nil, self.props.children)
		end

		local function Foo()
			return React.createElement("div", nil, React.createElement(Bar))
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		instance:setState({
			b = "b",
		})
		instance:setState({
			c = "c",
		})
		instance.__updater.enqueueReplaceState(instance, {
			d = "d",
		})
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(instance.state).toEqual({
			d = "d",
		})
	end)
	it("can forceUpdate", function()
		local function Baz()
			Scheduler.unstable_yieldValue("Baz")

			return React.createElement("div")
		end

		local instance
		local Bar = React.Component:extend("Bar")

		function Bar:init()
			instance = self
		end
		function Bar:shouldComponentUpdate()
			return false
		end
		function Bar:render()
			Scheduler.unstable_yieldValue("Bar")

			return React.createElement(Baz)
		end

		local function Foo()
			Scheduler.unstable_yieldValue("Foo")

			return React.createElement("div", nil, React.createElement(Bar))
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
			"Baz",
		})
		instance:forceUpdate()
		jestExpect(Scheduler).toFlushAndYield({
			"Bar",
			"Baz",
		})
	end)

	it("should clear forceUpdate after update is flushed", function()
		local a = 0
		local Foo = React.PureComponent:extend("Foo")

		function Foo:render()
			local msg = string.format("A: %s, B: %s", tostring(a), self.props.b)

			Scheduler.unstable_yieldValue(msg)
			return msg
		end

		local foo = React.createRef()

		ReactNoop.render(React.createElement(Foo, {
			ref = foo,
			b = 0,
		}))
		jestExpect(Scheduler).toFlushAndYield({
			"A: 0, B: 0",
		})

		a = 1

		foo.current:forceUpdate()
		jestExpect(Scheduler).toFlushAndYield({
			"A: 1, B: 0",
		})
		ReactNoop.render(React.createElement(Foo, {
			ref = foo,
			b = 0,
		}))
		jestExpect(Scheduler).toFlushAndYield({})
	end)

	-- ROBLOX: xited upstream
	-- xit('can call sCU while resuming a partly mounted component', function()
	--     local instances = Set()
	--     local Bar = {}
	--     local BarMetatable = {__index = Bar}

	--     function Bar:init()
	--         local self = setmetatable({}, BarMetatable)

	--         self.state = {
	--             y = 'A',
	--         }

	--         instances.add(self)
	--     end
	--     function Bar:shouldComponentUpdate(newProps, newState)
	--         return self.props.x ~= newProps.x or self.state.y ~= newState.y
	--     end
	--     function Bar:render()
	--         Scheduler.unstable_yieldValue('Bar:' .. self.props.x)

	--         return React.createElement('span', {
	--             prop = '' .. (self.props.x == self.state.y),
	--         })
	--     end

	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return{
	--             React.createElement(Bar, {
	--                 key = 'a',
	--                 x = 'A',
	--             }),
	--             React.createElement(Bar, {
	--                 key = 'b',
	--                 x = (function()
	--                     if props.step == 0 then
	--                         return'B'
	--                     end

	--                     return'B2'
	--                 end)(),
	--             }),
	--             React.createElement(Bar, {
	--                 key = 'c',
	--                 x = 'C',
	--             }),
	--             React.createElement(Bar, {
	--                 key = 'd',
	--                 x = 'D',
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement(Foo, {step = 0}))
	--     ReactNoop.flushDeferredPri(40)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar:A',
	--         'Bar:B',
	--         'Bar:C',
	--     })
	--     jestExpect(instances.size).toBe(3)
	--     ReactNoop.render(React.createElement(Foo, {step = 1}))
	--     ReactNoop.flushDeferredPri(50)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar:B2',
	--         'Bar:D',
	--     })
	--     jestExpect(instances.size).toBe(4)
	-- end)
	-- xit('gets new props when setting state on a partly updated component', function()
	--     local instances = {}
	--     local Bar = {}
	--     local BarMetatable = {__index = Bar}

	--     function Bar:init()
	--         local self = setmetatable({}, BarMetatable)

	--         self.state = {
	--             y = 'A',
	--         }

	--         instances.push(self)
	--     end
	--     function Bar:performAction()
	--         self:setState({
	--             y = 'B',
	--         })
	--     end
	--     function Bar:render()
	--         Scheduler.unstable_yieldValue('Bar:' .. self.props.x .. '-' .. self.props.step)

	--         return React.createElement('span', {
	--             prop = '' .. (self.props.x == self.state.y),
	--         })
	--     end

	--     local function Baz()
	--         Scheduler.unstable_yieldValue('Baz')

	--         return React.createElement('div')
	--     end
	--     local function Foo(props)
	--         Scheduler.unstable_yieldValue('Foo')

	--         return{
	--             React.createElement(Bar, {
	--                 key = 'a',
	--                 x = 'A',
	--                 step = props.step,
	--             }),
	--             React.createElement(Bar, {
	--                 key = 'b',
	--                 x = 'B',
	--                 step = props.step,
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement('div', nil, React.createElement(Foo, {step = 0}), React.createElement(Baz), React.createElement(Baz)))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     ReactNoop.render(React.createElement('div', nil, React.createElement(Foo, {step = 1}), React.createElement(Baz), React.createElement(Baz)))
	--     ReactNoop.flushDeferredPri(45)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Foo',
	--         'Bar:A-1',
	--         'Bar:B-1',
	--         'Baz',
	--     })
	--     instances[0].performAction()
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Bar:A-1',
	--         'Baz',
	--     })
	-- end)
	-- xit('calls componentWillMount twice if the initial render is aborted', function()
	--     local LifeCycle = {}
	--     local LifeCycleMetatable = {__index = LifeCycle}

	--     function LifeCycle:init()
	--         local self = setmetatable({}, LifeCycleMetatable)
	--         local _temp3

	--         return
	--     end
	--     function LifeCycle:UNSAFE_componentWillReceiveProps(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillReceiveProps:' .. self.state.x .. '-' .. nextProps.x)
	--         self:setState({
	--             x = nextProps.x,
	--         })
	--     end
	--     function LifeCycle:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue('componentWillMount:' .. self.state.x .. '-' .. self.props.x)
	--     end
	--     function LifeCycle:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount:' .. self.state.x .. '-' .. self.props.x)
	--     end
	--     function LifeCycle:render()
	--         return React.createElement('span')
	--     end

	--     local function Trail()
	--         Scheduler.unstable_yieldValue('Trail')

	--         return nil
	--     end
	--     local function App(props)
	--         Scheduler.unstable_yieldValue('App')

	--         return React.createElement('div', nil, React.createElement(LifeCycle, {
	--             x = props.x,
	--         }), React.createElement(Trail))
	--     end

	--     ReactNoop.render(React.createElement(App, {x = 0}))
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'App',
	--         'componentWillMount:0-0',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 1}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'App',
	--         'componentWillReceiveProps:0-1',
	--         'componentWillMount:1-1',
	--         'Trail',
	--         'componentDidMount:1-1',
	--     })
	-- end)
	-- xit('uses state set in componentWillMount even if initial render was aborted', function()
	--     local LifeCycle = {}
	--     local LifeCycleMetatable = {__index = LifeCycle}

	--     function LifeCycle:init(props)
	--         local self = setmetatable({}, LifeCycleMetatable)

	--         self.state = {
	--             x = self.props.x .. '(ctor)',
	--         }
	--     end
	--     function LifeCycle:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue('componentWillMount:' .. self.state.x)
	--         self:setState({
	--             x = self.props.x .. '(willMount)',
	--         })
	--     end
	--     function LifeCycle:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount:' .. self.state.x)
	--     end
	--     function LifeCycle:render()
	--         Scheduler.unstable_yieldValue('render:' .. self.state.x)

	--         return React.createElement('span')
	--     end

	--     local function App(props)
	--         Scheduler.unstable_yieldValue('App')

	--         return React.createElement(LifeCycle, {
	--             x = props.x,
	--         })
	--     end

	--     ReactNoop.render(React.createElement(App, {x = 0}))
	--     ReactNoop.flushDeferredPri(20)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'App',
	--         'componentWillMount:0(ctor)',
	--         'render:0(willMount)',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 1}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'App',
	--         'componentWillMount:0(willMount)',
	--         'render:1(willMount)',
	--         'componentDidMount:1(willMount)',
	--     })
	-- end)
	-- xit('calls componentWill* twice if an update render is aborted', function()
	--     local LifeCycle = {}
	--     local LifeCycleMetatable = {__index = LifeCycle}

	--     function LifeCycle:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue('componentWillMount:' .. self.props.x)
	--     end
	--     function LifeCycle:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount:' .. self.props.x)
	--     end
	--     function LifeCycle:UNSAFE_componentWillReceiveProps(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillReceiveProps:' .. self.props.x .. '-' .. nextProps.x)
	--     end
	--     function LifeCycle:shouldComponentUpdate(nextProps)
	--         Scheduler.unstable_yieldValue('shouldComponentUpdate:' .. self.props.x .. '-' .. nextProps.x)

	--         return true
	--     end
	--     function LifeCycle:UNSAFE_componentWillUpdate(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillUpdate:' .. self.props.x .. '-' .. nextProps.x)
	--     end
	--     function LifeCycle:componentDidUpdate(prevProps)
	--         Scheduler.unstable_yieldValue('componentDidUpdate:' .. self.props.x .. '-' .. prevProps.x)
	--     end
	--     function LifeCycle:render()
	--         Scheduler.unstable_yieldValue('render:' .. self.props.x)

	--         return React.createElement('span')
	--     end

	--     local function Sibling()
	--         Scheduler.unstable_yieldValue('Sibling')

	--         return React.createElement('span')
	--     end
	--     local function App(props)
	--         Scheduler.unstable_yieldValue('App')

	--         return{
	--             React.createElement(LifeCycle, {
	--                 key = 'a',
	--                 x = props.x,
	--             }),
	--             React.createElement(Sibling, {
	--                 key = 'b',
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement(App, {x = 0}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'App',
	--         'componentWillMount:0',
	--         'render:0',
	--         'Sibling',
	--         'componentDidMount:0',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 1}))
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'App',
	--         'componentWillReceiveProps:0-1',
	--         'shouldComponentUpdate:0-1',
	--         'componentWillUpdate:0-1',
	--         'render:1',
	--         'Sibling',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 2}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'App',
	--         'componentWillReceiveProps:1-2',
	--         'shouldComponentUpdate:1-2',
	--         'componentWillUpdate:1-2',
	--         'render:2',
	--         'Sibling',
	--         'componentDidUpdate:2-0',
	--     })
	-- end)
	it("calls getDerivedStateFromProps even for state-only updates", function()
		local instance
		local LifeCycle = React.Component:extend("LifeCycle")

		function LifeCycle:init()
			self:setState({})
		end
		function LifeCycle.getDerivedStateFromProps(props, prevState)
			Scheduler.unstable_yieldValue("getDerivedStateFromProps")

			return {
				foo = "foo",
			}
		end
		function LifeCycle:changeState()
			self:setState({
				foo = "bar",
			})
		end
		function LifeCycle:componentDidUpdate()
			Scheduler.unstable_yieldValue("componentDidUpdate")
		end
		function LifeCycle:render()
			Scheduler.unstable_yieldValue("render")

			instance = self

			return nil
		end

		ReactNoop.render(React.createElement(LifeCycle))
		jestExpect(Scheduler).toFlushAndYield({
			"getDerivedStateFromProps",
			"render",
		})
		jestExpect(instance.state).toEqual({
			foo = "foo",
		})
		instance:changeState()
		jestExpect(Scheduler).toFlushAndYield({
			"getDerivedStateFromProps",
			"render",
			"componentDidUpdate",
		})
		jestExpect(instance.state).toEqual({
			foo = "foo",
		})
	end)
	it(
		"does not call getDerivedStateFromProps if neither state nor props have changed",
		function()
			local Child = React.Component:extend("Child")

			function Child:render()
				Scheduler.unstable_yieldValue("Child")

				return self.props.parentRenders
			end

			local child = React.createRef()

			local Parent = React.Component:extend("Parent")

			function Parent:init()
				self.state = { parentRenders = 0 }
			end

			function Parent.getDerivedStateFromProps(props, prevState)
				Scheduler.unstable_yieldValue("getDerivedStateFromProps")

				return {
					parentRenders = prevState.parentRenders .. 1,
				}
			end
			function Parent:render()
				Scheduler.unstable_yieldValue("Parent")

				return React.createElement(Child, {
					parentRenders = self.state.parentRenders,
					ref = child,
				})
			end

			ReactNoop.render(React.createElement(Parent))
			jestExpect(Scheduler).toFlushAndYield({
				"getDerivedStateFromProps",
				"Parent",
				"Child",
			})

			-- Schedule an update on the child. The parent should not re-render.
			child.current:setState({})
			jestExpect(Scheduler).toFlushAndYield({
				"Child",
			})
		end
	)
	-- ROBLOX deviation: xited upstream, so leave commented out
	-- xit('does not call componentWillReceiveProps for state-only updates', function()
	--     local instances = {}
	--     local LifeCycle = {}
	--     local LifeCycleMetatable = {__index = LifeCycle}

	--     function LifeCycle:init()
	--         local self = setmetatable({}, LifeCycleMetatable)
	--         local _temp6

	--         return
	--     end
	--     function LifeCycle:tick()
	--         self:setState({
	--             x = self.state.x + 1,
	--         })
	--     end
	--     function LifeCycle:UNSAFE_componentWillMount()
	--         instances.push(self)
	--         Scheduler.unstable_yieldValue('componentWillMount:' .. self.state.x)
	--     end
	--     function LifeCycle:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount:' .. self.state.x)
	--     end
	--     function LifeCycle:UNSAFE_componentWillReceiveProps(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillReceiveProps')
	--     end
	--     function LifeCycle:shouldComponentUpdate(nextProps, nextState)
	--         Scheduler.unstable_yieldValue('shouldComponentUpdate:' .. self.state.x .. '-' .. nextState.x)

	--         return true
	--     end
	--     function LifeCycle:UNSAFE_componentWillUpdate(nextProps, nextState)
	--         Scheduler.unstable_yieldValue('componentWillUpdate:' .. self.state.x .. '-' .. nextState.x)
	--     end
	--     function LifeCycle:componentDidUpdate(prevProps, prevState)
	--         Scheduler.unstable_yieldValue('componentDidUpdate:' .. self.state.x .. '-' .. prevState.x)
	--     end
	--     function LifeCycle:render()
	--         Scheduler.unstable_yieldValue('render:' .. self.state.x)

	--         return React.createElement('span')
	--     end

	--     local Wrap = {}
	--     local WrapMetatable = {__index = Wrap}

	--     function Wrap:init()
	--         local self = setmetatable({}, WrapMetatable)
	--         local _temp7

	--         return
	--     end
	--     function Wrap:UNSAFE_componentWillMount()
	--         instances.push(self)
	--     end
	--     function Wrap:tick()
	--         self:setState({
	--             y = self.state.y + 1,
	--         })
	--     end
	--     function Wrap:render()
	--         Scheduler.unstable_yieldValue('Wrap')

	--         return React.createElement(LifeCycle, {
	--             y = self.state.y,
	--         })
	--     end

	--     local function Sibling()
	--         Scheduler.unstable_yieldValue('Sibling')

	--         return React.createElement('span')
	--     end
	--     local function App(props)
	--         Scheduler.unstable_yieldValue('App')

	--         return{
	--             React.createElement(Wrap, {
	--                 key = 'a',
	--             }),
	--             React.createElement(Sibling, {
	--                 key = 'b',
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement(App, {y = 0}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'App',
	--         'Wrap',
	--         'componentWillMount:0',
	--         'render:0',
	--         'Sibling',
	--         'componentDidMount:0',
	--     })
	--     instances[1].tick()
	--     ReactNoop.flushDeferredPri(25)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'shouldComponentUpdate:0-1',
	--         'componentWillUpdate:0-1',
	--         'render:1',
	--     })
	--     instances[1].tick()
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'shouldComponentUpdate:1-2',
	--         'componentWillUpdate:1-2',
	--         'render:2',
	--         'componentDidUpdate:2-0',
	--     })
	--     instances[0].tick()
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Wrap',
	--         'componentWillReceiveProps',
	--         'shouldComponentUpdate:2-2',
	--         'componentWillUpdate:2-2',
	--         'render:2',
	--     })
	--     instances[1].tick()
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'shouldComponentUpdate:2-3',
	--         'componentWillUpdate:2-3',
	--         'render:3',
	--         'componentDidUpdate:3-2',
	--     })
	-- end)
	-- xit('skips will/DidUpdate when bailing unless an update was already in progress', function()
	--     local LifeCycle = {}
	--     local LifeCycleMetatable = {__index = LifeCycle}

	--     function LifeCycle:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue('componentWillMount')
	--     end
	--     function LifeCycle:componentDidMount()
	--         Scheduler.unstable_yieldValue('componentDidMount')
	--     end
	--     function LifeCycle:UNSAFE_componentWillReceiveProps(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillReceiveProps')
	--     end
	--     function LifeCycle:shouldComponentUpdate(nextProps)
	--         Scheduler.unstable_yieldValue('shouldComponentUpdate')

	--         return self.props.x ~= nextProps.x
	--     end
	--     function LifeCycle:UNSAFE_componentWillUpdate(nextProps)
	--         Scheduler.unstable_yieldValue('componentWillUpdate')
	--     end
	--     function LifeCycle:componentDidUpdate(prevProps)
	--         Scheduler.unstable_yieldValue('componentDidUpdate')
	--     end
	--     function LifeCycle:render()
	--         Scheduler.unstable_yieldValue('render')

	--         return React.createElement('span')
	--     end

	--     local function Sibling()
	--         Scheduler.unstable_yieldValue('render sibling')

	--         return React.createElement('span')
	--     end
	--     local function App(props)
	--         return{
	--             React.createElement(LifeCycle, {
	--                 key = 'a',
	--                 x = props.x,
	--             }),
	--             React.createElement(Sibling, {
	--                 key = 'b',
	--             }),
	--         }
	--     end

	--     ReactNoop.render(React.createElement(App, {x = 0}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'componentWillMount',
	--         'render',
	--         'render sibling',
	--         'componentDidMount',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 0}))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'componentWillReceiveProps',
	--         'shouldComponentUpdate',
	--         'render sibling',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 1}))
	--     ReactNoop.flushDeferredPri(30)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'componentWillReceiveProps',
	--         'shouldComponentUpdate',
	--         'componentWillUpdate',
	--         'render',
	--         'render sibling',
	--     })
	--     ReactNoop.render(React.createElement(App, {x = 1}))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     jestExpect(Scheduler).toHaveYielded({
	--         'componentWillReceiveProps',
	--         'shouldComponentUpdate',
	--         'render sibling',
	--         'componentDidUpdate',
	--     })
	-- end)
	it("can nest batchedUpdates", function()
		local instance
		local Foo = React.Component:extend("Foo")

		function Foo:render()
			instance = self

			return React.createElement("div")
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		ReactNoop.flushSync(function()
			ReactNoop.batchedUpdates(function()
				instance:setState({ n = 1 }, function()
					return Scheduler.unstable_yieldValue("setState 1")
				end)
				instance:setState({ n = 2 }, function()
					return Scheduler.unstable_yieldValue("setState 2")
				end)
				ReactNoop.batchedUpdates(function()
					instance:setState({ n = 3 }, function()
						return Scheduler.unstable_yieldValue("setState 3")
					end)
					instance:setState({ n = 4 }, function()
						return Scheduler.unstable_yieldValue("setState 4")
					end)
					Scheduler.unstable_yieldValue("end inner batchedUpdates")
				end)
				Scheduler.unstable_yieldValue("end outer batchedUpdates")
			end)
		end)

		-- ReactNoop.flush() not needed because updates are synchronous

		jestExpect(Scheduler).toHaveYielded({
			"end inner batchedUpdates",
			"end outer batchedUpdates",
			"setState 1",
			"setState 2",
			"setState 3",
			"setState 4",
		})
		jestExpect(instance.state.n).toEqual(4)
	end)

	it("can handle if setState callback throws", function()
		local instance
		local Foo = React.Component:extend("Foo")

		function Foo:init()
			self.state = { n = 0 }
		end

		function Foo:render()
			instance = self
			return React.createElement("div")
		end

		-- ROBLOX Test Noise: in upstream, jest setup config makes these
		-- tests hide the error boundary warnings they trigger
		-- (scripts/jest/setupTests.js:72)
		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()

		-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
		local function updater(prevState: { n: number })
			local n = prevState.n

			return {
				n = n + 1,
			}
		end

		instance:setState(updater, function()
			return Scheduler.unstable_yieldValue("first callback")
		end)
		instance:setState(updater, function()
			Scheduler.unstable_yieldValue("second callback")
			error("callback error")
		end)
		instance:setState(updater, function()
			return Scheduler.unstable_yieldValue("third callback")
		end)
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toThrow("callback error")

		-- The third callback isn't called because the second one throws
		jestExpect(Scheduler).toHaveYielded({
			"first callback",
			"second callback",
		})
		jestExpect(instance.state.n).toEqual(3)
	end)

	-- ROBLOX TODO: this test only fails in Studio, debug it once jest TestService is outputting normally again
	it.skip("merges and masks context", function()
		local Intl = React.Component:extend("Intl")

		function Intl:getChildContext()
			return {
				locale = self.props.locale,
			}
		end
		function Intl:render()
			Scheduler.unstable_yieldValue("Intl " .. JSONStringify(self.context))

			return self.props.children
		end

		-- ROBLOX deviation: PropTypes workaround
		Intl.childContextTypes = {
			locale = "",
		}

		local Router = React.Component:extend("Router")

		function Router:getChildContext()
			return {
				route = self.props.route,
			}
		end
		function Router:render()
			Scheduler.unstable_yieldValue("Router " .. JSONStringify(self.context))

			return self.props.children
		end

		-- ROBLOX deviation: PropTypes workaround
		Router.childContextTypes = {
			route = "",
		}

		local ShowLocale = React.Component:extend("ShowLocale")

		function ShowLocale:render()
			Scheduler.unstable_yieldValue("ShowLocale " .. JSONStringify(self.context))

			return self.context.locale
		end

		-- ROBLOX deviation: PropTypes workaround
		ShowLocale.contextTypes = {
			locale = "",
		}

		local ShowRoute = React.Component:extend("ShowRoute")

		function ShowRoute:render()
			Scheduler.unstable_yieldValue("ShowRoute " .. JSONStringify(self.context))
			return self.context.route
		end

		-- ROBLOX deviation: PropTypes workaround
		ShowRoute.contextTypes = {
			route = "",
		}

		-- ROBLOX TODO: use pure class component so we can attach contextTypes
		local function ShowBoth(props, context)
			Scheduler.unstable_yieldValue("ShowBoth " .. JSONStringify(context))
			-- deviation: cannot set PropTypes for function component in Lua
			context.locale = context.locale or ""
			context.route = context.route or ""

			return string.format("%s in %s", context.route, context.locale)
		end
		-- ShowBoth.contextTypes = {
		-- 	locale = PropTypes.string,
		-- 	route = PropTypes.string,
		-- }

		local ShowNeither = React.Component:extend("ShowNeither")

		function ShowNeither:render()
			Scheduler.unstable_yieldValue("ShowNeither " .. JSONStringify(self.context))

			return nil
		end

		local Indirection = React.Component:extend("Indirection")

		function Indirection:render()
			Scheduler.unstable_yieldValue("Indirection " .. JSONStringify(self.context))

			return {
				React.createElement(ShowLocale, {
					key = "a",
				}),
				React.createElement(ShowRoute, {
					key = "b",
				}),
				React.createElement(ShowNeither, {
					key = "c",
				}),
				React.createElement(Intl, {
					key = "d",
					locale = "ru",
				}, React.createElement(ShowBoth, nil)),
				React.createElement(ShowBoth, {
					key = "e",
				}),
			}
		end

		ReactNoop.render(
			React.createElement(
				Intl,
				{
					locale = "fr",
				},
				React.createElement(ShowLocale),
				React.createElement("div", nil, React.createElement(ShowBoth))
			)
		)
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"Intl {}",
				'ShowLocale {"locale":"fr"}',
				'ShowBoth {"locale":"fr"}',
			})
		end).toErrorDev(
			"Warning: Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				-- ROBLOX TODO: ShowBoth is missing because we didn't put contextTypes on it, otherwise this is accurate
				-- .. "Please update the following components: Intl, ShowBoth, ShowLocale"
				.. "Please update the following components: Intl, ShowLocale"
		)
		ReactNoop.render(
			React.createElement(
				Intl,
				{
					locale = "de",
				},
				React.createElement(ShowLocale),
				React.createElement("div", nil, React.createElement(ShowBoth))
			)
		)
		jestExpect(Scheduler).toFlushAndYield({
			"Intl {}",
			'ShowLocale {"locale":"de"}',
			'ShowBoth {"locale":"de"}',
		})
		ReactNoop.render(
			React.createElement(
				Intl,
				{
					locale = "sv",
				},
				React.createElement(ShowLocale),
				React.createElement("div", nil, React.createElement(ShowBoth))
			)
		)
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Intl {}",
		})
		ReactNoop.render(React.createElement(
			Intl,
			{
				locale = "en",
			},
			React.createElement(ShowLocale),
			React.createElement(Router, {
				route = "/about",
			}, React.createElement(Indirection)),
			React.createElement(ShowBoth)
		))
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				'ShowLocale {"locale":"sv"}',
				'ShowBoth {"locale":"sv"}',
				"Intl {}",
				'ShowLocale {"locale":"en"}',
				"Router {}",
				"Indirection {}",
				'ShowLocale {"locale":"en"}',
				'ShowRoute {"route":"/about"}',
				"ShowNeither {}",
				"Intl {}",
				-- ROBLOX deviation: JSON results flipped
				'ShowBoth {"route":"/about","locale":"ru"}',
				'ShowBoth {"route":"/about","locale":"en"}',
				'ShowBoth {"locale":"en"}',
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Router, ShowRoute"
		)
	end)

	it("does not leak own context into context provider", function()
		local Recurse = React.Component:extend("Recurse")

		function Recurse:getChildContext()
			return {
				n = (self.context.n or 3) - 1,
			}
		end
		function Recurse:render()
			Scheduler.unstable_yieldValue("Recurse " .. JSONStringify(self.context))

			if self.context.n == 0 then
				return nil
			end

			return React.createElement(Recurse)
		end

		Recurse.contextTypes = {
			n = PropTypes.number,
		}
		Recurse.childContextTypes = {
			n = PropTypes.number,
		}

		ReactNoop.render(React.createElement(Recurse))
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"Recurse {}",
				'Recurse {"n":2}',
				'Recurse {"n":1}',
				'Recurse {"n":0}',
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Recurse"
		)
	end)

	if not ReactFeatureFlags.disableModulePatternComponents then
		-- ROBLOX TODO: PropTypes
		xit(
			"does not leak own context into context provider (factory components)",
			function()
				local function Recurse(props, context)
					return {
						getChildContext = function()
							return {
								n = (context.n or 3) - 1,
							}
						end,
						-- ROBLOX FIXME Luau: should infer this as nil | ReactElement<Recurse>
						render = function(): any
							Scheduler.unstable_yieldValue(
								"Recurse " .. JSONStringify(context)
							)

							if context.n == 0 then
								return nil
							end

							return React.createElement(Recurse)
						end,
					}
				end
				-- ROBLOX TODO: indexing into function?
				-- Recurse.contextTypes = {
				--     n = PropTypes.number,
				-- }

				-- ROBLOX TODO: indexing into function?
				-- Recurse.childContextTypes = {
				--     n = PropTypes.number,
				-- }

				ReactNoop.render(React.createElement(Recurse))
				jestExpect(function()
					return jestExpect(Scheduler).toFlushAndYield({
						"Recurse {}",
						'Recurse {"n":2}',
						'Recurse {"n":1}',
						'Recurse {"n":0}',
					})
				end).toErrorDev({
					"Warning: The <Recurse /> component appears to be a function component that returns a class instance. "
						.. "Change Recurse to a class that extends React.Component instead. "
						.. "If you can't use a class try assigning the prototype on the function as a workaround. "
						.. "`Recurse.prototype = React.Component.prototype`. "
						.. "Don't use an arrow function since it cannot be called with `new` by React.",
					"Legacy context API has been detected within a strict-mode tree.\n\n"
						.. "The old API will be supported in all 16.x releases, but applications "
						.. "using it should migrate to the new version.\n\n"
						.. "Please update the following components: Recurse",
				})
			end
		)
	end

	-- @gate experimental
	it("provides context when reusing work", function()
		local Intl = React.Component:extend("Intl")

		function Intl:getChildContext()
			return {
				locale = self.props.locale,
			}
		end
		function Intl:render()
			Scheduler.unstable_yieldValue("Intl " .. JSONStringify(self.context))

			return self.props.children
		end

		Intl.childContextTypes = {
			locale = PropTypes.string,
		}

		local ShowLocale = React.Component:extend("ShowLocale")

		function ShowLocale:render()
			Scheduler.unstable_yieldValue("ShowLocale " .. JSONStringify(self.context))

			return self.context.locale
		end

		ShowLocale.contextTypes = {
			locale = PropTypes.string,
		}

		ReactNoop.render(React.createElement(
			Intl,
			{
				locale = "fr",
			},
			React.createElement(ShowLocale),
			React.createElement(
				LegacyHiddenDiv,
				{
					mode = "hidden",
				},
				React.createElement(ShowLocale),
				React.createElement(Intl, {
					locale = "ru",
				}, React.createElement(ShowLocale))
			),
			React.createElement(ShowLocale)
		))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Intl {}",
			'ShowLocale {"locale":"fr"}',
			'ShowLocale {"locale":"fr"}',
		})
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				'ShowLocale {"locale":"fr"}',
				"Intl {}",
				'ShowLocale {"locale":"ru"}',
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Intl, ShowLocale"
		)
	end)
	-- ROBLOX TODO: PropTypes
	xit("reads context when setState is below the provider", function()
		local statefulInst
		local Intl = React.Component:extend("Intl")

		function Intl:getChildContext()
			local childContext = {
				locale = self.props.locale,
			}

			Scheduler.unstable_yieldValue("Intl:provide " .. JSONStringify(childContext))

			return childContext
		end
		function Intl:render()
			Scheduler.unstable_yieldValue("Intl:read " .. JSONStringify(self.context))

			return self.props.children
		end

		Intl.childContextTypes = {
			-- deviation: PropTypes workaround
			locale = "",
		}

		local ShowLocaleClass = React.Component:extend("ShowLocaleClass")

		function ShowLocaleClass:render()
			Scheduler.unstable_yieldValue(
				"ShowLocaleClass:read " .. JSONStringify(self.context)
			)

			return self.context.locale
		end

		ShowLocaleClass.contextTypes = {
			-- deviation: PropTypes workaround
			locale = "",
		}

		local function ShowLocaleFn(props, context)
			-- deviation: PropTypes workaround
			context.locale = context.locale or ""
			Scheduler.unstable_yieldValue("ShowLocaleFn:read " .. JSONStringify(context))

			return context.locale
		end

		local Stateful = React.Component:extend("Stateful")

		function Stateful:render()
			statefulInst = self

			return self.props.children
		end

		local function IndirectionFn(props, context)
			Scheduler.unstable_yieldValue("IndirectionFn " .. JSONStringify(context))

			return props.children
		end

		local IndirectionClass = React.Component:extend("IndirectionClass")

		function IndirectionClass:render()
			Scheduler.unstable_yieldValue(
				"IndirectionClass " .. JSONStringify(self.context)
			)

			return self.props.children
		end

		ReactNoop.render(
			React.createElement(
				Intl,
				{
					locale = "fr",
				},
				React.createElement(
					IndirectionFn,
					nil,
					React.createElement(
						IndirectionClass,
						nil,
						React.createElement(
							Stateful,
							nil,
							React.createElement(ShowLocaleClass),
							React.createElement(ShowLocaleFn)
						)
					)
				)
			)
		)
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"Intl:read {}",
				'Intl:provide {"locale":"fr"}',
				"IndirectionFn {}",
				"IndirectionClass {}",
				'ShowLocaleClass:read {"locale":"fr"}',
				'ShowLocaleFn:read {"locale":"fr"}',
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Intl, ShowLocaleClass, ShowLocaleFn"
		)
		statefulInst:setState({ x = 1 })
		jestExpect(Scheduler).toFlushWithoutYielding()
		-- All work has been memoized because setState()
		-- happened below the context and could not have affected it.
		jestExpect(Scheduler).toHaveYielded({})
	end)
	-- ROBLOX TODO: received[3] (IndirectionFn {"locale":"fr"}) ~= expected[3] (IndirectionFn {})
	-- could be PropsType workaround is causing issues.
	xit("reads context when setState is above the provider", function()
		local statefulInst
		local Intl = React.Component:extend("Intl")

		function Intl:getChildContext()
			local childContext = {
				locale = self.props.locale,
			}

			Scheduler.unstable_yieldValue("Intl:provide " .. JSONStringify(childContext))

			return childContext
		end
		function Intl:render()
			Scheduler.unstable_yieldValue("Intl:read " .. JSONStringify(self.context))

			return self.props.children
		end

		Intl.childContextTypes = {
			-- deviation: PropTypes workaround
			locale = "",
		}

		local ShowLocaleClass = React.Component:extend("ShowLocaleClass")

		function ShowLocaleClass:render()
			Scheduler.unstable_yieldValue(
				"ShowLocaleClass:read " .. JSONStringify(self.context)
			)

			return self.context.locale
		end

		ShowLocaleClass.contextTypes = {
			-- deviation: PropTypes workaround
			locale = "",
		}

		local function ShowLocaleFn(props, context)
			context.locale = context.locale or ""
			Scheduler.unstable_yieldValue("ShowLocaleFn:read " .. JSONStringify(context))

			return context.locale
		end

		-- ROBLOX TODO: indexing into function?
		-- ShowLocaleFn.contextTypes = {
		--     locale = PropTypes.string,
		-- }

		local function IndirectionFn(props, context)
			Scheduler.unstable_yieldValue("IndirectionFn " .. JSONStringify(context))

			return props.children
		end

		local IndirectionClass = React.Component:extend("IndirectionClass")

		function IndirectionClass:render()
			Scheduler.unstable_yieldValue(
				"IndirectionClass " .. JSONStringify(self.context)
			)

			return self.props.children
		end

		local Stateful = React.Component:extend("Stateful")
		function Stateful:init()
			self.state = { locale = "fr" }
		end
		function Stateful:render()
			statefulInst = self

			return React.createElement(Intl, {
				locale = self.state.locale,
			}, self.props.children)
		end

		ReactNoop.render(
			React.createElement(
				Stateful,
				nil,
				React.createElement(
					IndirectionFn,
					nil,
					React.createElement(
						IndirectionClass,
						nil,
						React.createElement(ShowLocaleClass),
						React.createElement(ShowLocaleFn)
					)
				)
			)
		)
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"Intl:read {}",
				'Intl:provide {"locale":"fr"}',
				"IndirectionFn {}",
				"IndirectionClass {}",
				'ShowLocaleClass:read {"locale":"fr"}',
				'ShowLocaleFn:read {"locale":"fr"}',
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Intl, ShowLocaleClass, ShowLocaleFn"
		)
		statefulInst:setState({
			locale = "gr",
		})
		jestExpect(Scheduler).toFlushAndYield({
			-- Intl is below setState() so it might have been
			-- affected by it. Therefore we re-render and recompute
			-- its child context.
			"Intl:read {}",
			'Intl:provide {"locale":"gr"}',
			-- TODO: it's unfortunate that we can't reuse work on
			-- these components even though they don't depend on context.
			"IndirectionFn {}",
			"IndirectionClass {}",
			-- These components depend on context:
			'ShowLocaleClass:read {"locale":"gr"}',
			'ShowLocaleFn:read {"locale":"gr"}',
		})
	end)
	it(
		"maintains the correct context when providers bail out due to low priority",
		function()
			-- Child must be a context provider to trigger the bug
			local Child = React.Component:extend("Child")
			function Child:getChildContext()
				return {}
			end
			function Child:render()
				return React.createElement("div")
			end

			local instance
			local Middle = React.Component:extend("Middle")

			function Middle:init(props, context)
				instance = self
			end

			function Middle:shouldComponentUpdate()
				-- Return false so that our child will get a NoWork priority (and get bailed out)
				return false
			end
			function Middle:render()
				return React.createElement(Child)
			end

			local Root = React.Component:extend("Root")

			function Root:render()
				return React.createElement(Middle, self.props)
			end

			Child.childContextTypes = {}

			-- Init
			ReactNoop.render(React.createElement(Root))
			jestExpect(function()
				return jestExpect(Scheduler).toFlushWithoutYielding()
			end).toErrorDev(
				"Legacy context API has been detected within a strict-mode tree.\n\n"
					.. "The old API will be supported in all 16.x releases, but applications "
					.. "using it should migrate to the new version.\n\n"
					.. "Please update the following components: Child"
			)

			-- Trigger an update in the middle of the tree
			instance:setState({})
			jestExpect(Scheduler).toFlushWithoutYielding()
		end
	)

	it(
		"maintains the correct context when unwinding due to an error in render",
		function()
			-- ROBLOX deviation: hoist declaration so correct value is captured
			local ContextProvider = React.Component:extend("ContextProvider")
			local Root = React.Component:extend("Root")

			function Root:componentDidCatch(_error)
				-- If context is pushed/popped correctly,
				-- This method will be used to handle the intentionally-thrown Error.
			end

			function Root:render()
				return React.createElement(ContextProvider, { depth = 1 })
			end

			local instance

			function ContextProvider:init(props, context)
				self.state = {}

				if props.depth == 1 then
					instance = self
				end
			end
			ContextProvider.childContextTypes = {}
			function ContextProvider:getChildContext()
				return {}
			end
			function ContextProvider:render()
				if self.state.throwError then
					error(Error.new())
				end

				return (function()
					if self.props.depth < 4 then
						return React.createElement(ContextProvider, {
							depth = self.props.depth + 1,
						})
					end

					return React.createElement(function()
						return nil
					end)
				end)()
			end

			-- Init
			ReactNoop.render(React.createElement(Root))
			jestExpect(function()
				return jestExpect(Scheduler).toFlushWithoutYielding()
			end).toErrorDev(
				"Legacy context API has been detected within a strict-mode tree.\n\n"
					.. "The old API will be supported in all 16.x releases, but applications "
					.. "using it should migrate to the new version.\n\n"
					.. "Please update the following components: ContextProvider"
			)

			-- Trigger an update in the middle of the tree
			-- This is necessary to reproduce the error as it currently exists.
			instance:setState({ throwError = true })
			jestExpect(function()
				return jestExpect(Scheduler).toFlushWithoutYielding()
			end).toErrorDev(
				"Error boundaries should implement getDerivedStateFromError()"
			)
		end
	)

	it("should not recreate masked context unless inputs have changed", function()
		local scuCounter = 0
		local MyComponent = React.Component:extend("MyComponent")
		MyComponent.contextTypes = {}

		function MyComponent:componentDidMount()
			Scheduler.unstable_yieldValue("componentDidMount")
			self:setState({ setStateInCDU = true })
		end
		function MyComponent:componentDidUpdate(prevProps, prevState)
			Scheduler.unstable_yieldValue("componentDidUpdate")

			if self.state.setStateInCDU then
				self:setState({ setStateInCDU = false })
			end
		end
		function MyComponent:UNSAFE_componentWillReceiveProps(nextProps)
			Scheduler.unstable_yieldValue("componentWillReceiveProps")
			self:setState({ setStateInCDU = true })
		end
		function MyComponent:render()
			Scheduler.unstable_yieldValue("render")
			return nil
		end
		function MyComponent:shouldComponentUpdate(nextProps, nextState)
			Scheduler.unstable_yieldValue("shouldComponentUpdate")
			-- deviation: can't one line the return with ++ like in JS
			local ret = scuCounter < 5
			scuCounter += 1
			return ret -- Don't let test hang
		end

		ReactNoop.render(React.createElement(MyComponent))
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"render",
				"componentDidMount",
				"shouldComponentUpdate",
				"render",
				"componentDidUpdate",
				"shouldComponentUpdate",
				"render",
				"componentDidUpdate",
			})
		end).toErrorDev({
			"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: MyComponent",
		}, {
			withoutStack = 1,
		})
	end)
	-- ROBLOX: xited upstream
	-- xit('should reuse memoized work if pointers are updated before calling lifecycles', function()
	--     local cduNextProps = {}
	--     local cduPrevProps = {}
	--     local scuNextProps = {}
	--     local scuPrevProps = {}
	--     local renderCounter = 0

	--     local function SecondChild(props)
	--         return React.createElement('span', nil, props.children)
	--     end

	--     local FirstChild = {}
	--     local FirstChildMetatable = {__index = FirstChild}

	--     function FirstChild:componentDidUpdate(prevProps, prevState)
	--         cduNextProps.push(self.props)
	--         cduPrevProps.push(prevProps)
	--     end
	--     function FirstChild:shouldComponentUpdate(nextProps, nextState)
	--         scuNextProps.push(nextProps)
	--         scuPrevProps.push(self.props)

	--         return self.props.children ~= nextProps.children
	--     end
	--     function FirstChild:render()
	--         renderCounter = renderCounter + 1

	--         return React.createElement('span', nil, self.props.children)
	--     end

	--     local Middle = {}
	--     local MiddleMetatable = {__index = Middle}

	--     function Middle:render()
	--         return React.createElement('div', nil, React.createElement(FirstChild, nil, self.props.children), React.createElement(SecondChild, nil, self.props.children))
	--     end

	--     local function Root(props)
	--         return React.createElement('div', {hidden = true}, React.createElement(Middle, props))
	--     end

	--     ReactNoop.render(React.createElement(Root, nil, 'A'))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     jestExpect(renderCounter).toBe(1)
	--     ReactNoop.render(React.createElement(Root, nil, 'B'))
	--     ReactNoop.flushDeferredPri(20 + 30 + 5)
	--     jestExpect(renderCounter).toBe(2)
	--     jestExpect(scuPrevProps).toEqual({
	--         {
	--             children = 'A',
	--         },
	--     })
	--     jestExpect(scuNextProps).toEqual({
	--         {
	--             children = 'B',
	--         },
	--     })
	--     jestExpect(cduPrevProps).toEqual({})
	--     jestExpect(cduNextProps).toEqual({})
	--     ReactNoop.render(React.createElement(Root, nil, 'B'))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     jestExpect(renderCounter).toBe(2)
	--     jestExpect(scuPrevProps).toEqual({
	--         {
	--             children = 'A',
	--         },
	--         {
	--             children = 'B',
	--         },
	--     })
	--     jestExpect(scuNextProps).toEqual({
	--         {
	--             children = 'B',
	--         },
	--         {
	--             children = 'B',
	--         },
	--     })
	--     jestExpect(cduPrevProps).toEqual({
	--         {
	--             children = 'A',
	--         },
	--     })
	--     jestExpect(cduNextProps).toEqual({
	--         {
	--             children = 'B',
	--         },
	--     })
	-- end)
	-- ROBLOX TODO: PropTypes
	xit("updates descendants with new context values", function()
		local instance
		local TopContextProvider = React.Component:extend("TopContextProvider")

		function TopContextProvider:init()
			self.getChildContext = function()
				return {
					count = self.state.count,
				}
			end
			self.render = function()
				return self.props.children
			end
			self.updateCount = function()
				-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
				return self:setState(function(state: { count: number })
					-- ROBLOX deviation END
					return {
						count = state.count + 1,
					}
				end)
			end
			self.state = { count = 0 }
			instance = self
		end

		TopContextProvider.childContextTypes = {
			count = PropTypes.number,
		}

		local Middle = React.Component:extend("Middle")

		local Child = React.Component:extend("Child")

		Child.contextTypes = {
			count = PropTypes.number,
		}

		ReactNoop.render(
			React.createElement(
				TopContextProvider,
				nil,
				React.createElement(Middle, nil, React.createElement(Child))
			)
		)
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"count:0",
			})
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: Child, TopContextProvider"
		)
		instance.updateCount()
		jestExpect(Scheduler).toFlushAndYield({
			"count:1",
		})
	end)
	-- ROBLOX TODO: PropTypes
	xit(
		"updates descendants with multiple context-providing ancestors with new context values",
		function()
			local instance
			local TopContextProvider = React.Component:extend("TopContextProvider")

			function TopContextProvider:init()
				self.getChildContext = function()
					return {
						count = self.state.count,
					}
				end
				self.render = function()
					return self.props.children
				end
				self.updateCount = function()
					-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
					return self:setState(function(state: { count: number })
						-- ROBLOX deviation END
						return {
							count = state.count + 1,
						}
					end)
				end
				self.state = { count = 0 }
				instance = self
			end

			TopContextProvider.childContextTypes = {
				count = PropTypes.number,
			}

			local MiddleContextProvider = React.Component:extend("MiddleContextProvider")

			MiddleContextProvider.childContextTypes = {
				name = PropTypes.string,
			}

			local Child = React.Component:extend("Child")

			Child.contextTypes = {
				count = PropTypes.number,
			}

			ReactNoop.render(
				React.createElement(
					TopContextProvider,
					nil,
					React.createElement(
						MiddleContextProvider,
						nil,
						React.createElement(Child)
					)
				)
			)
			jestExpect(function()
				return jestExpect(Scheduler).toFlushAndYield({
					"count:0",
				})
			end).toErrorDev(
				"Legacy context API has been detected within a strict-mode tree.\n\n"
					.. "The old API will be supported in all 16.x releases, but applications "
					.. "using it should migrate to the new version.\n\n"
					.. "Please update the following components: Child, MiddleContextProvider, TopContextProvider"
			)
			instance.updateCount()
			jestExpect(Scheduler).toFlushAndYield({
				"count:1",
			})
		end
	)
	-- ROBLOX TODO: PropTypes
	xit(
		"should not update descendants with new context values if shouldComponentUpdate returns false",
		function()
			local instance
			local TopContextProvider = React.Component:extend("TopContextProvider")

			function TopContextProvider:init()
				self.getChildContext = function()
					return {
						count = self.state.count,
					}
				end
				self.render = function()
					return self.props.children
				end
				self.updateCount = function()
					-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
					return self:setState(function(state: { count: number })
						-- ROBLOX deviation END
						return {
							count = state.count + 1,
						}
					end)
				end
				self.state = { count = 0 }
				instance = self
			end

			TopContextProvider.childContextTypes = {
				count = PropTypes.number,
			}

			local MiddleScu = React.Component:extend("MiddleScu")

			function MiddleScu:shouldComponentUpdate()
				return false
			end

			local MiddleContextProvider = React.Component:extend("MiddleContextProvider")

			MiddleContextProvider.childContextTypes = {
				name = PropTypes.string,
			}

			local Child = React.Component:extend("Child")

			Child.contextTypes = {
				count = PropTypes.number,
			}

			ReactNoop.render(
				React.createElement(
					TopContextProvider,
					nil,
					React.createElement(
						MiddleScu,
						nil,
						React.createElement(
							MiddleContextProvider,
							nil,
							React.createElement(Child)
						)
					)
				)
			)
			jestExpect(function()
				return jestExpect(Scheduler).toFlushAndYield({
					"count:0",
				})
			end).toErrorDev(
				"Legacy context API has been detected within a strict-mode tree.\n\n"
					.. "The old API will be supported in all 16.x releases, but applications "
					.. "using it should migrate to the new version.\n\n"
					.. "Please update the following components: Child, MiddleContextProvider, TopContextProvider"
			)
			instance.updateCount()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end
	)
	-- ROBLOX TODO: PropTypes
	xit(
		"should update descendants with new context values if setState() is called in the middle of the tree",
		function()
			local middleInstance
			local topInstance
			local TopContextProvider = React.Component:extend("TopContextProvider")

			function TopContextProvider:init()
				self.getChildContext = function()
					return {
						count = self.state.count,
					}
				end
				self.render = function()
					return self.props.children
				end
				self.updateCount = function()
					-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
					return self:setState(function(state: { count: number })
						-- ROBLOX deviation START: Luau requires annotation here to know * opeator is safe
						return {
							count = state.count + 1,
						}
					end)
				end
				self.state = { count = 0 }
				topInstance = self
			end

			TopContextProvider.childContextTypes = {
				count = PropTypes.number,
			}

			local MiddleScu = React.Component:extend("MiddleScu")

			function MiddleScu:shouldComponentUpdate()
				return false
			end

			local MiddleContextProvider = React.Component:extend("MiddleContextProvider")

			function MiddleContextProvider:init()
				self.getChildContext = function()
					return {
						name = self.state.name,
					}
				end
				self.updateName = function(name)
					self:setState({ name = name })
				end
				self.render = function()
					return self.props.children
				end
				self.state = {
					name = "brian",
				}
				middleInstance = self
			end

			MiddleContextProvider.childContextTypes = {
				name = PropTypes.string,
			}

			local Child = React.Component:extend("Child")

			Child.contextTypes = {
				count = PropTypes.number,
				name = PropTypes.string,
			}

			ReactNoop.render(
				React.createElement(
					TopContextProvider,
					nil,
					React.createElement(
						MiddleScu,
						nil,
						React.createElement(
							MiddleContextProvider,
							nil,
							React.createElement(Child)
						)
					)
				)
			)
			jestExpect(function()
				return jestExpect(Scheduler).toFlushAndYield({
					"count:0, name:brian",
				})
			end).toErrorDev(
				"Legacy context API has been detected within a strict-mode tree.\n\n"
					.. "The old API will be supported in all 16.x releases, but applications "
					.. "using it should migrate to the new version.\n\n"
					.. "Please update the following components: Child, MiddleContextProvider, TopContextProvider"
			)
			topInstance.updateCount()
			jestExpect(Scheduler).toFlushWithoutYielding()
			middleInstance.updateName("not brian")
			jestExpect(Scheduler).toFlushAndYield({
				"count:1, name:not brian",
			})
		end
	)
	it("does not interrupt for update at same priority", function()
		local function Child(props)
			Scheduler.unstable_yieldValue("Child: " .. tostring(props.step))
			return nil
		end

		local function Parent(props)
			Scheduler.unstable_yieldValue("Parent: " .. tostring(props.step))

			return React.createElement(Child, {
				step = props.step,
			})
		end

		ReactNoop.render(React.createElement(Parent, { step = 1 }))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Parent: 1",
		})
		ReactNoop.render(React.createElement(Parent, { step = 2 }))
		jestExpect(Scheduler).toFlushAndYield({
			"Child: 1",
			"Parent: 2",
			"Child: 2",
		})
	end)
	it("does not interrupt for update at lower priority", function()
		local function Child(props)
			Scheduler.unstable_yieldValue("Child: " .. tostring(props.step))

			return nil
		end

		local function Parent(props)
			Scheduler.unstable_yieldValue("Parent: " .. tostring(props.step))

			return React.createElement(Child, {
				step = props.step,
			})
		end

		ReactNoop.render(React.createElement(Parent, { step = 1 }))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Parent: 1",
		})

		-- Interrupt at lower priority
		ReactNoop.expire(2000)
		ReactNoop.render(React.createElement(Parent, { step = 2 }))
		jestExpect(Scheduler).toFlushAndYield({
			"Child: 1",
			"Parent: 2",
			"Child: 2",
		})
	end)
	it("does interrupt for update at higher priority", function()
		local function Child(props)
			Scheduler.unstable_yieldValue("Child: " .. tostring(props.step))
			return nil
		end

		local function Parent(props)
			Scheduler.unstable_yieldValue("Parent: " .. tostring(props.step))

			return React.createElement(Child, {
				step = props.step,
			})
		end

		ReactNoop.render(React.createElement(Parent, { step = 1 }))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Parent: 1",
		})

		-- Interrupt at higher priority
		ReactNoop.flushSync(function()
			return ReactNoop.render(React.createElement(Parent, { step = 2 }))
		end)
		jestExpect(Scheduler).toHaveYielded({
			"Parent: 2",
			"Child: 2",
		})
		jestExpect(Scheduler).toFlushAndYield({})
	end)

	-- ROBLOX TODO: sort out default map.set reassignment.
	-- We sometimes use Maps with Fibers as keys.
	-- xit('does not break with a bad Map polyfill', function()
	--     --     local realMapSet = Map.prototype.set

	--     local function triggerCodePathThatUsesFibersAsMapKeys()
	--         local function Thing()
	--             error('No.')
	--         end -- This class uses legacy context, which triggers warnings,
	--         -- the procedures for which use a Map to store fibers.
	--         local Boundary = React.Component:extend("Boundary")

	--         function Boundary:componentDidCatch()
	--             self:setState({didError = true})
	--         end
	--         function Boundary:render()
	--             return(function()
	--                 if self.state.didError then
	--                     return nil
	--                 end

	--                 return React.createElement(Thing)
	--             end)
	--         end

	--         Boundary.contextTypes = {
	--             color = function()
	--                 return nil
	--             end,
	--         }

	--         ReactNoop.render(React.createElement(Boundary))
	--         jestExpect(function()
	--             jestExpect(Scheduler).toFlushWithoutYielding()
	--         end).toErrorDev({
	--             'Legacy context API has been detected within a strict-mode tree',
	--         })
	--     end
	--     -- First, verify that this code path normally receives Fibers as keys,
	--     -- and that they're not extensible.
	--     jest.resetModules()

	--     local receivedNonExtensibleObjects -- eslint-disable-next-line no-extend-native

	--     Map.prototype.set = function(key)
	--         if typeof(key) == 'object' and key ~= nil then
	--             if not Object.isExtensible(key) then
	--                 receivedNonExtensibleObjects = true
	--             end
	--         end

	--         return realMapSet.apply(self, arguments)
	--     end
	--     React = require('react')
	--     ReactNoop = require('react-noop-renderer')
	--     Scheduler = require('scheduler')

	--     jestExpect(receivedNonExtensibleObjects).toBe(__DEV__)
	--     jest.resetModules()

	--     Map.prototype.set = function(key, value)
	--         if typeof(key) == 'object' and key ~= nil then
	--             key.__internalValueSlot = value
	--         end

	--         return realMapSet.apply(self, arguments)
	--     end
	--     React = require('react')
	--     ReactNoop = require('react-noop-renderer')
	--     Scheduler = require('scheduler')
	-- end)
end) ]]
eC.Children._2a85f7cb8e41796ac1dba3ffe5120a81=fc
local fd

local fe={ClassName="ModuleScript",Children={},Properties={}}
fe.Name="ReactIncrementalErrorReplay.spec"
fe.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncrementalErrorReplay-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 --\]\]
--!strict

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local it = JestGlobals.it

beforeEach(function()
	jest.resetModules()

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
end)

-- ROBLOX deviation: this test doesn't make sense in not JSX
-- it('should fail gracefully on error in the host environment', () => {
--     ReactNoop.render(<errorInBeginPhase />);
--     jestExpect(Scheduler).toFlushAndThrow('Error in host config.');
--   });

it("should ignore error if it doesn't throw on retry", function()
	local didInit = false

	local function badLazyInit()
		local needsInit = not didInit
		didInit = true
		if needsInit then
			error("Hi")
		end
	end

	local App = React.Component:extend("App")
	function App:render()
		badLazyInit()
		return React.createElement("TextLabel", { Text = "Hello" })
	end
	ReactNoop.render(React.createElement(App))
	jestExpect(Scheduler).toFlushWithoutYielding()
end) ]]
eC.Children._88c2715627750c1b40866979e212c7ab=fe
local ff

local fg={ClassName="ModuleScript",Children={},Properties={}}
fg.Name="ReactIncrementalReflection.spec"
fg.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncrementalReflection-test.js
-- * Copyright (c) Facebook, Inc. and its affiliates.
-- *
-- * This source code is licensed under the MIT license found in the
-- * LICENSE file in the root directory of this source tree.
-- *
-- * @emails react-core
-- * @jest-environment node
--

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler
local console = require(Packages.Shared).console

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

describe("ReactIncrementalReflection", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	local function div(...)
		local _, _, children = ...
		-- deviation: commented out unused children processing logic
		-- children = children.map(function(c)
		--     return(function()
		--         if typeof(c) == 'string' then
		--             return{
		--                 text = c,
		--                 hidden = false,
		--             }
		--         end

		--         return c
		--     end)()
		-- end)

		return {
			type = "div",
			children = children,
			prop = nil,
			hidden = false,
		}
	end
	local function span(prop)
		return {
			type = "span",
			children = {},
			prop = prop,
			hidden = false,
		}
	end

	it("handles isMounted even when the initial render is deferred", function()
		local instances = {}
		local Component = React.Component:extend("Component")

		function Component:_isMounted()
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			return self.__updater.isMounted(self)
		end
		function Component:UNSAFE_componentWillMount()
			table.insert(instances, self)
			Scheduler.unstable_yieldValue(
				"componentWillMount: " .. tostring(self:_isMounted())
			)
		end
		function Component:componentDidMount()
			Scheduler.unstable_yieldValue(
				"componentDidMount: " .. tostring(self:_isMounted())
			)
		end
		function Component:render()
			return React.createElement("span")
		end

		local function Foo()
			return React.createElement(Component)
		end

		ReactNoop.render(React.createElement(Foo))

		-- Render part way through but don't yet commit the updates.
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"componentWillMount: false",
		})
		jestExpect(instances[1]:_isMounted()).toBe(false)

		-- Render the rest and commit the updates.
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"componentDidMount: true",
			})
		end).toErrorDev(
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			{ withoutStack = true }
		)
		jestExpect(instances[1]:_isMounted()).toBe(true)
	end)

	it("handles isMounted when an unmount is deferred", function()
		local instances = {}
		local Component = React.Component:extend("Component")

		function Component:init()
			self.state = {}
		end

		function Component:_isMounted()
			return self.__updater.isMounted(self)
		end
		function Component:UNSAFE_componentWillMount()
			table.insert(instances, self)
		end
		function Component:componentWillUnmount()
			Scheduler.unstable_yieldValue(
				"componentWillUnmount: " .. tostring(self:_isMounted())
			)
		end
		function Component:render()
			Scheduler.unstable_yieldValue("Component")
			return React.createElement("span")
		end

		local function Other()
			Scheduler.unstable_yieldValue("Other")
			return React.createElement("span")
		end

		local function Foo(props)
			if props.mount then
				return React.createElement(Component)
			end
			return React.createElement(Other)
		end

		ReactNoop.render(React.createElement(Foo, { mount = true }))
		jestExpect(function()
			return jestExpect(Scheduler).toFlushAndYield({
				"Component",
			})
		end).toErrorDev(
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			{ withoutStack = true }
		)

		jestExpect(instances[1]:_isMounted()).toBe(true)

		ReactNoop.render(React.createElement(Foo, { mount = false }))
		-- Render part way through but don't yet commit the updates so it is not
		-- fully unmounted yet.
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Other",
		})

		jestExpect(instances[1]:_isMounted()).toBe(true)

		-- Finish flushing the unmount.
		jestExpect(Scheduler).toFlushAndYield({
			"componentWillUnmount: true",
		})
		jestExpect(instances[1]:_isMounted()).toBe(false)
	end)
	-- ROBLOX TODO: 292: gets "componentDidMount", but not the inner span. maybe ReactFeatureFlags need alignment for tests?
	xit("finds no node before insertion and correct node before deletion", function()
		local classInstance = nil
		local function findInstance(inst)
			-- We ignore warnings fired by findInstance because we are testing
			-- that the actual behavior still works as expected even though it
			-- is deprecated.
			local oldConsoleError = console.error
			console.error = nil
			local ok, result = pcall(function()
				-- ROBLOX FIXME: always returns nil because subtreeFlags don't match upstream while finding fiber in getNearestMountedFiber
				return ReactNoop.findInstance(inst)
			end)
			console.error = oldConsoleError
			if ok then
				return result
			else
				error(result)
			end
		end

		local Component = React.Component:extend("Component")

		function Component:UNSAFE_componentWillMount()
			classInstance = self
			Scheduler.unstable_yieldValue({
				"componentWillMount",
				findInstance(self),
			})
		end
		function Component:componentDidMount()
			Scheduler.unstable_yieldValue({
				"componentDidMount",
				findInstance(self),
			})
		end
		function Component:UNSAFE_componentWillUpdate()
			Scheduler.unstable_yieldValue({
				"componentWillUpdate",
				findInstance(self),
			})
		end
		function Component:componentDidUpdate()
			Scheduler.unstable_yieldValue({
				"componentDidUpdate",
				findInstance(self),
			})
		end
		function Component:componentWillUnmount()
			Scheduler.unstable_yieldValue({
				"componentWillUnmount",
				findInstance(self),
			})
		end
		function Component:render()
			Scheduler.unstable_yieldValue("render")
			return function()
				if self.props.step < 2 then
					return React.createElement(span, {
						ref = function(ref)
							self.span = ref
							return ref
						end,
					})
				elseif self.props.step == 2 then
					return React.createElement(div, {
						ref = function(ref)
							self.div = ref
							return ref
						end,
					})
				elseif self.props.step == 3 then
					return nil
				elseif self.props.step == 4 then
					return React.createElement(div, {
						ref = function(ref)
							self.span = ref
							return ref
						end,
					})
				else
					return nil
				end
			end
		end

		local function Sibling()
			-- Sibling is used to assert that we've rendered past the first component.
			Scheduler.unstable_yieldValue("render sibling")
			return React.createElement(span)
		end

		local function Foo(props)
			return {
				React.createElement(Component, {
					key = "a",
					step = props.step,
				}),
				React.createElement(Sibling, {
					key = "b",
				}),
			}
		end

		ReactNoop.render(React.createElement(Foo, { step = 0 }))
		-- Flush past Component but don't complete rendering everything yet.
		jestExpect(Scheduler).toFlushAndYieldThrough({
			{
				"componentWillMount",
				nil,
			},
			"render",
			"render sibling",
		})

		jestExpect(classInstance).toBeDefined()
		-- The instance has been complete but is still not committed so it should
		-- not find any host nodes in it.
		jestExpect(findInstance(classInstance)).toBe(nil)
		jestExpect(function()
			-- ROBLOX FIXME: toFlushAndYield gets an empty array
			return jestExpect(Scheduler).toFlushAndYield({
				{
					"componentDidMount",
					span(),
				},
			})
		end).toErrorDev({
			"Using UNSAFE_componentWillMount in strict mode is not recommended",
			"Using UNSAFE_componentWillUpdate in strict mode is not recommended",
		}, { withoutStack = true })

		local hostSpan = classInstance.span
		jestExpect(hostSpan).toBeDefined()

		jestExpect(findInstance(classInstance)).toBe(hostSpan)

		-- Flush next step which will cause an update but not yet render a new host
		-- node.
		ReactNoop.render(React.createElement(Foo, { step = 1 }))
		jestExpect(Scheduler).toFlushAndYield({
			{
				"componentWillUpdate",
				hostSpan,
			},
			"render",
			"render sibling",
			{
				"componentDidUpdate",
				hostSpan,
			},
		})

		jestExpect(ReactNoop.findInstance(classInstance)).toBe(hostSpan)

		-- The next step will render a new host node but won't get committed yet.
		-- We expect this to mutate the original Fiber.
		ReactNoop.render(React.createElement(Foo, { step = 2 }))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			{
				"componentWillUpdate",
				hostSpan,
			},
			"render",
			"render sibling",
		})

		-- This should still be the host span.
		jestExpect(ReactNoop.findInstance(classInstance)).toBe(hostSpan)

		-- When we finally flush the tree it will get committed.
		jestExpect(Scheduler).toFlushAndYield({
			{
				"componentDidUpdate",
				div(),
			},
		})

		local hostDiv = classInstance.div
		jestExpect(hostDiv).toBeDefined()
		jestExpect(hostSpan).never.toBe(hostDiv)

		-- We should now find the new host node.
		jestExpect(ReactNoop.findInstance(classInstance)).toBe(hostDiv)

		-- Render to null but don't commit it yet.
		ReactNoop.render(React.createElement(Foo, { step = 3 }))
		jestExpect(Scheduler).toFlushAndYieldThrough({
			{
				"componentWillUpdate",
				hostDiv,
			},
			"render",
			"render sibling",
		})

		-- This should still be the host div since the deletion is not committed.
		jestExpect(ReactNoop.findInstance(classInstance)).toBe(hostDiv)

		jestExpect(Scheduler).toFlushAndYield({
			{
				"componentDidUpdate",
				nil,
			},
		})

		-- This should still be the host div since the deletion is not committed.
		jestExpect(ReactNoop.findInstance(classInstance)).toBe(nil)

		-- Render a div again
		ReactNoop.render(React.createElement(Foo, { step = 4 }))
		jestExpect(Scheduler).toFlushAndYield({
			{
				"componentWillUpdate",
				nil,
			},
			"render",
			"render sibling",
			{
				"componentDidUpdate",
				div(),
			},
		})

		-- Unmount the component.
		ReactNoop.render({})
		jestExpect(Scheduler).toFlushAndYield({
			{
				"componentWillUnmount",
				hostDiv,
			},
		})
	end)
end) ]]
eC.Children._0a1ae98ae22c336161a295e4b665aad4=fg
local fh

local fi={ClassName="ModuleScript",Children={},Properties={}}
fi.Name="ReactIncrementalScheduling.spec"
fi.Properties.Source=[[ --\[\[*
 * Upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncrementalScheduling-test.js
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 --\]\]
--!strict
local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

describe("ReactIncrementalScheduling", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	local function span(prop)
		return {
			type = "span",
			children = {},
			prop = prop,
			hidden = false,
		}
	end

	it("schedules and flushes deferred work", function()
		ReactNoop.render(React.createElement("span", {
			prop = "1",
		}))
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = "1" })
		)
	end)
	it("searches for work on other roots once the current root completes", function()
		ReactNoop.renderToRootWithID(
			React.createElement("span", {
				prop = "a:1",
			}),
			"a"
		)
		ReactNoop.renderToRootWithID(
			React.createElement("span", {
				prop = "b:1",
			}),
			"b"
		)
		ReactNoop.renderToRootWithID(
			React.createElement("span", {
				prop = "c:1",
			}),
			"c"
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren("a")).toEqual({
			span("a:1"),
		})
		jestExpect(ReactNoop.getChildren("b")).toEqual({
			span("b:1"),
		})
		jestExpect(ReactNoop.getChildren("c")).toEqual({
			span("c:1"),
		})
	end)
	it("schedules top-level updates in order of priority", function()
		ReactNoop.render(React.createElement("span", { prop = 1 }))
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 1 })
		)

		ReactNoop.batchedUpdates(function()
			ReactNoop.render(React.createElement("span", { prop = 5 }))
			ReactNoop.flushSync(function()
				ReactNoop.render(React.createElement("span", { prop = 2 }))
				ReactNoop.render(React.createElement("span", { prop = 3 }))
				ReactNoop.render(React.createElement("span", { prop = 4 }))
			end)
		end)

		-- The sync updates flush first.

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 4 })
		)

		-- The terminal value should be the last update that was scheduled,
		-- regardless of priority. In this case, that's the last sync update.
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 4 })
		)
	end)
	it("schedules top-level updates with same priority in order of insertion", function()
		-- Initial render.
		ReactNoop.render(React.createElement("span", { prop = 1 }))
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 1 })
		)

		ReactNoop.render(React.createElement("span", { prop = 2 }))
		ReactNoop.render(React.createElement("span", { prop = 3 }))
		ReactNoop.render(React.createElement("span", { prop = 4 }))
		ReactNoop.render(React.createElement("span", { prop = 5 }))
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 5 })
		)
	end)
	it("works on deferred roots in the order they were scheduled", function()
		local useEffect = React.useEffect

		local function Text(props)
			local text = props.text

			useEffect(function()
				Scheduler.unstable_yieldValue(text)
			end, { text })

			return text
		end

		ReactNoop.act(function()
			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "a:1",
				}),
				"a"
			)
			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "b:1",
				}),
				"b"
			)
			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "c:1",
				}),
				"c"
			)
		end)
		jestExpect(Scheduler).toHaveYielded({
			"a:1",
			"b:1",
			"c:1",
		})

		-- deviation: getChildrenAsJSX() method which is used in upstream replaced with
		-- equivalent getChildren() evaluations because Roact doesn't support JSX.

		jestExpect(ReactNoop.getChildren("a")[1].text).toEqual("a:1")
		jestExpect(ReactNoop.getChildren("b")[1].text).toEqual("b:1")
		jestExpect(ReactNoop.getChildren("c")[1].text).toEqual("c:1")
		jestExpect(#ReactNoop.getChildren("a")).toEqual(1)
		jestExpect(#ReactNoop.getChildren("b")).toEqual(1)
		jestExpect(#ReactNoop.getChildren("c")).toEqual(1)

		-- Schedule deferred work in the reverse order
		ReactNoop.act(function()
			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "c:2",
				}),
				"c"
			)
			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "b:2",
				}),
				"b"
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"c:2",
			})
			jestExpect(ReactNoop.getChildren("a")[1].text).toEqual("a:1")
			jestExpect(ReactNoop.getChildren("b")[1].text).toEqual("b:1")
			jestExpect(ReactNoop.getChildren("c")[1].text).toEqual("c:2")
			jestExpect(#ReactNoop.getChildren("a")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("b")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("c")).toEqual(1)
			-- Schedule last bit of work, it will get processed the last

			ReactNoop.renderToRootWithID(
				React.createElement(Text, {
					text = "a:2",
				}),
				"a"
			)

			-- Keep performing work in the order it was scheduled
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"b:2",
			})
			jestExpect(ReactNoop.getChildren("a")[1].text).toEqual("a:1")
			jestExpect(ReactNoop.getChildren("b")[1].text).toEqual("b:2")
			jestExpect(ReactNoop.getChildren("c")[1].text).toEqual("c:2")
			jestExpect(#ReactNoop.getChildren("a")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("b")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("c")).toEqual(1)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:2",
			})
			jestExpect(ReactNoop.getChildren("a")[1].text).toEqual("a:2")
			jestExpect(ReactNoop.getChildren("b")[1].text).toEqual("b:2")
			jestExpect(ReactNoop.getChildren("c")[1].text).toEqual("c:2")
			jestExpect(#ReactNoop.getChildren("a")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("b")).toEqual(1)
			jestExpect(#ReactNoop.getChildren("c")).toEqual(1)
		end)
	end)
	it("schedules sync updates when inside componentDidMount/Update", function()
		local instance

		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = { tick = 0 }
		end

		function Foo:componentDidMount()
			Scheduler.unstable_yieldValue(
				"componentDidMount (before setState): " .. self.state.tick
			)
			self:setState({
				tick = 1,
			})
			-- We're in a batch. Update hasn't flushed yet.

			Scheduler.unstable_yieldValue(
				"componentDidMount (after setState): " .. self.state.tick
			)
		end

		function Foo:componentDidUpdate()
			Scheduler.unstable_yieldValue("componentDidUpdate: " .. self.state.tick)

			if self.state.tick == 2 then
				Scheduler.unstable_yieldValue(
					"componentDidUpdate (before setState): " .. self.state.tick
				)
				self:setState({
					tick = 3,
				})
				Scheduler.unstable_yieldValue(
					"componentDidUpdate (after setState): " .. self.state.tick
				) -- We're in a batch. Update hasn't flushed yet.
				-- We're in a batch. Update hasn't flushed yet.
			end
		end

		function Foo:render()
			Scheduler.unstable_yieldValue("render: " .. self.state.tick)
			instance = self
			return React.createElement("span", {
				prop = self.state.tick,
			})
		end

		ReactNoop.render(React.createElement(Foo))
		-- Render without committing
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"render: 0",
		})

		-- Do one more unit of work to commit
		jestExpect(ReactNoop.flushNextYield()).toEqual({
			"componentDidMount (before setState): 0",
			"componentDidMount (after setState): 0",
			-- If the setState inside componentDidMount were deferred, there would be
			-- no more ops. Because it has Task priority, we get these ops, too:
			"render: 1",
			"componentDidUpdate: 1",
		})
		instance:setState({ tick = 2 })
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"render: 2",
		})
		jestExpect(ReactNoop.flushNextYield()).toEqual({
			"componentDidUpdate: 2",
			"componentDidUpdate (before setState): 2",
			"componentDidUpdate (after setState): 2",
			-- If the setState inside componentDidUpdate were deferred, there would be
			-- no more ops. Because it has Task priority, we get these ops, too:
			"render: 3",
			"componentDidUpdate: 3",
		})
	end)
	it("can opt-in to async scheduling inside componentDidMount/Update", function()
		local instance

		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = { tick = 0 }
		end
		function Foo:componentDidMount()
			local _this = self
			ReactNoop.deferredUpdates(function()
				Scheduler.unstable_yieldValue(
					"componentDidMount (before setState): " .. _this.state.tick
				)

				_this:setState({
					tick = 1,
				})

				Scheduler.unstable_yieldValue(
					"componentDidMount (after setState): " .. _this.state.tick
				)
			end)
		end

		function Foo:componentDidUpdate()
			local _this2 = self

			ReactNoop.deferredUpdates(function()
				Scheduler.unstable_yieldValue("componentDidUpdate: " .. _this2.state.tick)

				if _this2.state.tick == 2 then
					Scheduler.unstable_yieldValue(
						"componentDidUpdate (before setState): " .. _this2.state.tick
					)

					_this2:setState({
						tick = 3,
					})

					Scheduler.unstable_yieldValue(
						"componentDidUpdate (after setState): " .. _this2.state.tick
					)
				end
			end)
		end

		function Foo:render()
			Scheduler.unstable_yieldValue("render: " .. self.state.tick)
			instance = self
			return React.createElement("span", {
				prop = self.state.tick,
			})
		end
		ReactNoop.flushSync(function()
			ReactNoop.render(React.createElement(Foo))
		end)
		-- The cDM update should not have flushed yet because it has async priority.
		jestExpect(Scheduler).toHaveYielded({
			"render: 0",
			"componentDidMount (before setState): 0",
			"componentDidMount (after setState): 0",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 0 })
		)

		-- Now flush the cDM update.
		jestExpect(Scheduler).toFlushAndYield({
			"render: 1",
			"componentDidUpdate: 1",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 1 })
		)

		-- Increment the tick to 2. This will trigger an update inside cDU. Flush
		-- the first update without flushing the second one.
		instance:setState({ tick = 2 })
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"render: 2",
			"componentDidUpdate: 2",
			"componentDidUpdate (before setState): 2",
			"componentDidUpdate (after setState): 2",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 2 })
		)

		-- Now flush the cDU update.
		jestExpect(Scheduler).toFlushAndYield({
			"render: 3",
			"componentDidUpdate: 3",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 3 })
		)
	end)
	it("performs Task work even after time runs out", function()
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = { step = 1 }
		end

		function Foo:componentDidMount()
			local _this3 = self
			self:setState({
				step = 2,
			}, function()
				_this3:setState({
					step = 3,
				}, function()
					_this3:setState({
						step = 4,
					}, function()
						_this3:setState({
							step = 5,
						})
					end)
				end)
			end)
		end

		function Foo:render()
			Scheduler.unstable_yieldValue("Foo")
			return React.createElement("span", {
				prop = self.state.step,
			})
		end
		ReactNoop.render(React.createElement(Foo))
		-- This should be just enough to complete all the work, but not enough to
		-- commit it.
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"Foo",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(nil)

		-- Do one more unit of work.
		ReactNoop.flushNextYield()

		-- The updates should all be flushed with Task priority
		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 5 })
		)
	end)
	it("can opt-out of batching using unbatchedUpdates", function()
		ReactNoop.flushSync(function()
			ReactNoop.render(React.createElement("span", { prop = 0 }))
			jestExpect(ReactNoop.getChildren()).toEqual({})
			-- Should not have flushed yet because we're still batching

			-- unbatchedUpdates reverses the effect of batchedUpdates, so sync
			-- updates are not batched
			ReactNoop.unbatchedUpdates(function()
				ReactNoop.render(React.createElement("span", { prop = 1 }))

				jestExpect(ReactNoop).toMatchRenderedOutput(
					React.createElement("span", { prop = 1 })
				)

				ReactNoop.render(React.createElement("span", { prop = 2 }))

				jestExpect(ReactNoop).toMatchRenderedOutput(
					React.createElement("span", { prop = 2 })
				)
			end)
			ReactNoop.render(React.createElement("span", { prop = 3 }))
			-- Remaining update is now flushed

			jestExpect(ReactNoop).toMatchRenderedOutput(
				React.createElement("span", { prop = 2 })
			)
		end)
		-- Remaining update is now flushed

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 3 })
		)
	end)
	it("nested updates are always deferred, even inside unbatchedUpdates", function()
		local instance
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {
				step = 0,
			}
		end
		function Foo:componentDidUpdate()
			local _this4 = self
			Scheduler.unstable_yieldValue("componentDidUpdate: " .. self.state.step)

			if self.state.step == 1 then
				ReactNoop.unbatchedUpdates(function()
					-- This is a nested state update, so it should not be
					-- flushed synchronously, even though we wrapped it
					-- in unbatchedUpdates.
					_this4:setState({
						step = 2,
					})
				end)
				jestExpect(Scheduler).toHaveYielded({
					"render: 1",
					"componentDidUpdate: 1",
				})

				jestExpect(ReactNoop).toMatchRenderedOutput(
					React.createElement("span", { prop = 1 })
				)
			end
		end

		function Foo:render()
			Scheduler.unstable_yieldValue("render: " .. self.state.step)
			instance = self
			return React.createElement("span", {
				prop = self.state.step,
			})
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushAndYield({
			"render: 0",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 0 })
		)

		ReactNoop.flushSync(function()
			instance:setState({ step = 1 })
		end)
		jestExpect(Scheduler).toHaveYielded({
			"render: 2",
			"componentDidUpdate: 2",
		})

		jestExpect(ReactNoop).toMatchRenderedOutput(
			React.createElement("span", { prop = 2 })
		)
	end)
end) ]]
eC.Children._0bb38de5cbd8e1c6ddb026b3ad497908=fi
local fj

local fk={ClassName="ModuleScript",Children={},Properties={}}
fk.Name="ReactIncrementalSideEffects.spec"
fk.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 \]\]

-- 'use strict'

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local it = JestGlobals.it
local beforeEach = JestGlobals.beforeEach

describe("ReactIncrementalSideEffects", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	local function div(...)
		local _, _, children = ...
		-- ROBLOX DEVIATION: commented out unused children processing logic
		-- children = children.map(function(c)
		--         return(function()
		--                 if typeof(c) == 'string' then
		--                         return{
		--                                 text = c,
		--                                 hidden = false,
		--                         }
		--                 end

		--                 return c
		--         end)()
		-- end)

		return {
			type = "div",
			children = children or {},
			prop = nil,
			hidden = false,
		}
	end

	local function span(prop)
		return {
			type = "span",
			children = {},
			prop = prop,
			hidden = false,
		}
	end

	local function text(t)
		return {
			text = t,
			hidden = false,
		}
	end

	--     -- Note: This is based on a similar component we use in www. We can delete
	--     -- once the extra div wrapper is no longer necessary.
	--     function LegacyHiddenDiv({children, mode})
	--         return (
	--             <div hidden={mode == 'hidden'}>
	--                 <React.unstable_LegacyHidden
	--                     mode={mode == 'hidden' ? 'unstable-defer-without-hiding' : mode}>
	--                     {children}
	--                 </React.unstable_LegacyHidden>
	--             </div>
	--         )
	--     }

	--     it('can update child nodes of a host instance', () => {
	--         function Bar(props)
	--             return <span>{props.text}</span>
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     <Bar text={props.text} />
	--                     {props.text == 'World' ? <Bar text={props.text} /> : nil}
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo text="Hello" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span())])

	--         ReactNoop.render(<Foo text="World" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span(), span())])
	--     })

	--     it('can update child nodes of a fragment', function()
	--         function Bar(props)
	--             return <span>{props.text}</span>
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     <Bar text={props.text} />
	--                     {props.text == 'World'
	--                         ? [<Bar key="a" text={props.text} />, <div key="b" />]
	--                         : props.text == 'Hi'
	--                         ? [<div key="b" />, <Bar key="a" text={props.text} />]
	--                         : nil}
	--                     <span prop="test" />
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo text="Hello" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span(), span('test'))])

	--         ReactNoop.render(<Foo text="World" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(span(), span(), div(), span('test')),
	--         ])

	--         ReactNoop.render(<Foo text="Hi" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(span(), div(), span(), span('test')),
	--         ])
	--     })

	--     it('can update child nodes rendering into text nodes', function()
	--         function Bar(props)
	--             return props.text
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     <Bar text={props.text} />
	--                     {props.text == 'World'
	--                         ? [<Bar key="a" text={props.text} />, '!']
	--                         : nil}
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo text="Hello" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div('Hello')])

	--         ReactNoop.render(<Foo text="World" />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div('World', 'World', '!')])
	--     })

	--     it('can deletes children either components, host or text', function()
	--         function Bar(props)
	--             return <span prop={props.children} />
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     {props.show
	--                         ? [<div key="a" />, <Bar key="b">Hello</Bar>, 'World']
	--                         : []}
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo show={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(div(), span('Hello'), 'World'),
	--         ])

	--         ReactNoop.render(<Foo show={false} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div()])
	--     })

	--     it('can delete a child that changes type - implicit keys', function()
	--         local unmounted = false

	--         class ClassComponent extends React.Component {
	--             componentWillUnmount()
	--                 unmounted = true
	--             }
	--             render()
	--                 return <span prop="Class" />
	--             }
	--         }

	--         function FunctionComponent(props)
	--             return <span prop="Function" />
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     {props.useClass ? (
	--                         <ClassComponent />
	--                     ) : props.useFunction ? (
	--                         <FunctionComponent />
	--                     ) : props.useText ? (
	--                         'Text'
	--                     ) : nil}
	--                     Trail
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo useClass={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')])

	--         expect(unmounted).toBe(false)

	--         ReactNoop.render(<Foo useFunction={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')])

	--         expect(unmounted).toBe(true)

	--         ReactNoop.render(<Foo useText={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div('Text', 'Trail')])

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div('Trail')])
	--     })

	--     it('can delete a child that changes type - explicit keys', function()
	--         local unmounted = false

	--         class ClassComponent extends React.Component {
	--             componentWillUnmount()
	--                 unmounted = true
	--             }
	--             render()
	--                 return <span prop="Class" />
	--             }
	--         }

	--         function FunctionComponent(props)
	--             return <span prop="Function" />
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     {props.useClass ? (
	--                         <ClassComponent key="a" />
	--                     ) : props.useFunction ? (
	--                         <FunctionComponent key="a" />
	--                     ) : nil}
	--                     Trail
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo useClass={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span('Class'), 'Trail')])

	--         expect(unmounted).toBe(false)

	--         ReactNoop.render(<Foo useFunction={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div(span('Function'), 'Trail')])

	--         expect(unmounted).toBe(true)

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([div('Trail')])
	--     })

	it("can delete a child when it unmounts inside a portal", function()
		local function Bar(props)
			return React.createElement("span", {
				prop = props.children,
			})
		end

		local portalContainer = ReactNoop.getOrCreateRootContainer("portalContainer")

		local function Foo(props)
			return ReactNoop.createPortal(props.show and {
				React.createElement("div", { key = "a" }),
				React.createElement(Bar, { key = "b" }, "Hello"),
				"World",
			}, portalContainer)
		end

		ReactNoop.render(
			React.createElement("div", {}, React.createElement(Foo, { show = true }))
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({ div() })
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({
			div(),
			span("Hello"),
			text("World"),
		})

		ReactNoop.render(
			React.createElement("div", {}, React.createElement(Foo, { show = false }))
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({ div() })
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})

		ReactNoop.render(
			React.createElement("div", {}, React.createElement(Foo, { show = true }))
		)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({ div() })
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({
			div(),
			span("Hello"),
			text("World"),
		})

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})

		ReactNoop.render(React.createElement(Foo, { show = false }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})

		ReactNoop.render(React.createElement(Foo, { show = true }))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({
			div(),
			span("Hello"),
			text("World"),
		})

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})
	end)

	it("can delete a child when it unmounts with a portal", function()
		local function Bar(props)
			return React.createElement("span", { prop = props.children })
		end

		local portalContainer = ReactNoop.getOrCreateRootContainer("portalContainer")

		local function Foo(props)
			return ReactNoop.createPortal({
				React.createElement("div", { key = "a" }),
				React.createElement(Bar, { key = "b" }, "Hello"),
				"World",
			}, portalContainer)
		end

		ReactNoop.render(React.createElement("div", {}, React.createElement(Foo)))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({ div() })
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({
			div(),
			span("Hello"),
			text("World"),
		})

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({
			div(),
			span("Hello"),
			text("World"),
		})

		ReactNoop.render(nil)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(ReactNoop.getChildren()).toEqual({})
		jestExpect(ReactNoop.getChildren("portalContainer")).toEqual({})
	end)

	--     it('does not update child nodes if a flush is aborted', () => {
	--         function Bar(props)
	--             Scheduler.unstable_yieldValue('Bar')
	--             return <span prop={props.text} />
	--         }

	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return (
	--                 <div>
	--                     <div>
	--                         <Bar text={props.text} />
	--                         {props.text == 'Hello' ? <Bar text={props.text} /> : nil}
	--                     </div>
	--                     <Bar text="Yo" />
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo text="Hello" />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar'])
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(div(span('Hello'), span('Hello')), span('Yo')),
	--         ])

	--         ReactNoop.render(<Foo text="World" />)

	--         -- Flush some of the work without committing
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar'])
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(div(span('Hello'), span('Hello')), span('Yo')),
	--         ])
	--     })

	--     -- @gate experimental
	--     it('preserves a previously rendered node when deprioritized', () => {
	--         function Middle(props)
	--             Scheduler.unstable_yieldValue('Middle')
	--             return <span prop={props.children} />
	--         }

	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return (
	--                 <div>
	--                     <LegacyHiddenDiv mode="hidden">
	--                         <Middle>{props.text}</Middle>
	--                     </LegacyHiddenDiv>
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo text="foo" />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Middle'])

	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 <div hidden={true}>
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         ReactNoop.render(<Foo text="bar" />, () =>
	--             Scheduler.unstable_yieldValue('commit'),
	--         )
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 <div hidden={true}>
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         expect(Scheduler).toFlushAndYield(['Middle'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 <div hidden={true}>
	--                     <span prop="bar" />
	--                 </div>
	--             </div>,
	--         )
	--     })

	--     -- @gate experimental
	--     it('can reuse side-effects after being preempted', () => {
	--         function Bar(props)
	--             Scheduler.unstable_yieldValue('Bar')
	--             return <span prop={props.children} />
	--         }

	--         local middleContent = (
	--             <div>
	--                 <Bar>Hello</Bar>
	--                 <Bar>World</Bar>
	--             </div>
	--         )

	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return (
	--                 <LegacyHiddenDiv mode="hidden">
	--                     {props.step == 0 ? (
	--                         <div>
	--                             <Bar>Hi</Bar>
	--                             <Bar>{props.text}</Bar>
	--                         </div>
	--                     ) : (
	--                         middleContent
	--                     )}
	--                 </LegacyHiddenDiv>
	--             )
	--         }

	--         -- Init
	--         ReactNoop.render(<Foo text="foo" step={0} />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar'])

	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hi" />
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         -- Make a quick update which will schedule low priority work to
	--         -- update the middle content.
	--         ReactNoop.render(<Foo text="bar" step={1} />, () =>
	--             Scheduler.unstable_yieldValue('commit'),
	--         )
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo', 'commit', 'Bar'])

	--         -- The tree remains unchanged.
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hi" />
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         -- The first Bar has already completed its update but we'll interrupt it to
	--         -- render some higher priority work. The middle content will bailout so
	--         -- it remains untouched which means that it should reuse it next time.
	--         ReactNoop.render(<Foo text="foo" step={1} />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar'])

	--         -- Since we did nothing to the middle subtree during the interruption,
	--         -- we should be able to reuse the reconciliation work that we already did
	--         -- without restarting. The side-effects should still be replayed.

	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hello" />
	--                     <span prop="World" />
	--                 </div>
	--             </div>,
	--         )
	--     })

	--     -- @gate experimental
	--     it('can reuse side-effects after being preempted, if shouldComponentUpdate is false', () => {
	--         class Bar extends React.Component {
	--             shouldComponentUpdate(nextProps)
	--                 return this.props.children ~= nextProps.children
	--             }
	--             render()
	--                 Scheduler.unstable_yieldValue('Bar')
	--                 return <span prop={this.props.children} />
	--             }
	--         }

	--         class Content extends React.Component {
	--             shouldComponentUpdate(nextProps)
	--                 return this.props.step ~= nextProps.step
	--             }
	--             render()
	--                 Scheduler.unstable_yieldValue('Content')
	--                 return (
	--                     <div>
	--                         <Bar>{this.props.step == 0 ? 'Hi' : 'Hello'}</Bar>
	--                         <Bar>{this.props.step == 0 ? this.props.text : 'World'}</Bar>
	--                     </div>
	--                 )
	--             }
	--         }

	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return (
	--                 <LegacyHiddenDiv mode="hidden">
	--                     <Content step={props.step} text={props.text} />
	--                 </LegacyHiddenDiv>
	--             )
	--         }

	--         -- Init
	--         ReactNoop.render(<Foo text="foo" step={0} />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar'])

	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hi" />
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         -- Make a quick update which will schedule low priority work to
	--         -- update the middle content.
	--         ReactNoop.render(<Foo text="bar" step={1} />)
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Content', 'Bar'])

	--         -- The tree remains unchanged.
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hi" />
	--                     <span prop="foo" />
	--                 </div>
	--             </div>,
	--         )

	--         -- The first Bar has already completed its update but we'll interrupt it to
	--         -- render some higher priority work. The middle content will bailout so
	--         -- it remains untouched which means that it should reuse it next time.
	--         ReactNoop.render(<Foo text="foo" step={1} />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Content', 'Bar', 'Bar'])

	--         -- Since we did nothing to the middle subtree during the interruption,
	--         -- we should be able to reuse the reconciliation work that we already did
	--         -- without restarting. The side-effects should still be replayed.

	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <div>
	--                     <span prop="Hello" />
	--                     <span prop="World" />
	--                 </div>
	--             </div>,
	--         )
	--     })

	--     it('can update a completed tree before it has a chance to commit', () => {
	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return <span prop={props.step} />
	--         }
	--         ReactNoop.render(<Foo step={1} />)
	--         -- This should be just enough to complete the tree without committing it
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(null)
	--         -- To confirm, perform one more unit of work. The tree should now
	--         -- be flushed.
	--         ReactNoop.flushNextYield()
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />)

	--         ReactNoop.render(<Foo step={2} />)
	--         -- This should be just enough to complete the tree without committing it
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />)
	--         -- This time, before we commit the tree, we update the root component with
	--         -- new props
	--         ReactNoop.render(<Foo step={3} />)
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={1} />)
	--         -- Now let's commit. We already had a commit that was pending, which will
	--         -- render 2.
	--         ReactNoop.flushNextYield()
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={2} />)
	--         -- If we flush the rest of the work, we should get another commit that
	--         -- renders 3. If it renders 2 again, that means an update was dropped.
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(<span prop={3} />)
	--     })

	--     -- @gate experimental
	--     it('updates a child even though the old props is empty', () => {
	--         function Foo(props)
	--             return (
	--                 <LegacyHiddenDiv mode="hidden">
	--                     <span prop={1} />
	--                 </LegacyHiddenDiv>
	--             )
	--         }

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div hidden={true}>
	--                 <span prop={1} />
	--             </div>,
	--         )
	--     })

	--     xit('can defer side-effects and resume them later on', () => {
	--         class Bar extends React.Component {
	--             shouldComponentUpdate(nextProps)
	--                 return this.props.idx ~= nextProps.idx
	--             }
	--             render()
	--                 return <span prop={this.props.idx} />
	--             }
	--         }
	--         function Foo(props)
	--             return (
	--                 <div>
	--                     <span prop={props.tick} />
	--                     <div hidden={true}>
	--                         <Bar idx={props.idx} />
	--                         <Bar idx={props.idx + 1} />
	--                     </div>
	--                 </div>
	--             )
	--         }
	--         ReactNoop.render(<Foo tick={0} idx={0} />)
	--         ReactNoop.flushDeferredPri(40 + 25)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(0),
	--                 div(--\[\[the spans are down-prioritized and not rendered yet\]\]),
	--             ),
	--         ])
	--         ReactNoop.render(<Foo tick={1} idx={0} />)
	--         ReactNoop.flushDeferredPri(35 + 25)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(span(1), div(--\[\[still not rendered yet\]\])),
	--         ])
	--         ReactNoop.flushDeferredPri(30 + 25)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(1),
	--                 div(
	--                     -- Now we had enough time to finish the spans.
	--                     span(0),
	--                     span(1),
	--                 ),
	--             ),
	--         ])
	--         local innerSpanA = ReactNoop.getChildren()[0].children[1].children[1]
	--         ReactNoop.render(<Foo tick={2} idx={1} />)
	--         ReactNoop.flushDeferredPri(30 + 25)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(2),
	--                 div(
	--                     -- Still same old numbers.
	--                     span(0),
	--                     span(1),
	--                 ),
	--             ),
	--         ])
	--         ReactNoop.render(<Foo tick={3} idx={1} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(3),
	--                 div(
	--                     -- New numbers.
	--                     span(1),
	--                     span(2),
	--                 ),
	--             ),
	--         ])

	--         local innerSpanB = ReactNoop.getChildren()[0].children[1].children[1]
	--         -- This should have been an update to an existing instance, not recreation.
	--         -- We verify that by ensuring that the child instance was the same as
	--         -- before.
	--         expect(innerSpanA).toBe(innerSpanB)
	--     })

	--     xit('can defer side-effects and reuse them later - complex', function()
	--         local ops = []

	--         class Bar extends React.Component {
	--             shouldComponentUpdate(nextProps)
	--                 return this.props.idx ~= nextProps.idx
	--             }
	--             render()
	--                 ops.push('Bar')
	--                 return <span prop={this.props.idx} />
	--             }
	--         }
	--         class Baz extends React.Component {
	--             shouldComponentUpdate(nextProps)
	--                 return this.props.idx ~= nextProps.idx
	--             }
	--             render()
	--                 ops.push('Baz')
	--                 return [
	--                     <Bar key="a" idx={this.props.idx} />,
	--                     <Bar key="b" idx={this.props.idx} />,
	--                 ]
	--             }
	--         }
	--         function Foo(props)
	--             ops.push('Foo')
	--             return (
	--                 <div>
	--                     <span prop={props.tick} />
	--                     <div hidden={true}>
	--                         <Baz idx={props.idx} />
	--                         <Baz idx={props.idx} />
	--                         <Baz idx={props.idx} />
	--                     </div>
	--                 </div>
	--             )
	--         }
	--         ReactNoop.render(<Foo tick={0} idx={0} />)
	--         ReactNoop.flushDeferredPri(65 + 5)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(0),
	--                 div(--\[\[the spans are down-prioritized and not rendered yet\]\]),
	--             ),
	--         ])

	--         expect(ops).toEqual(['Foo', 'Baz', 'Bar'])
	--         ops = []

	--         ReactNoop.render(<Foo tick={1} idx={0} />)
	--         ReactNoop.flushDeferredPri(70)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(span(1), div(--\[\[still not rendered yet\]\])),
	--         ])

	--         expect(ops).toEqual(['Foo'])
	--         ops = []

	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(1),
	--                 div(
	--                     -- Now we had enough time to finish the spans.
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                 ),
	--             ),
	--         ])

	--         expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar', 'Bar'])
	--         ops = []

	--         -- Now we're going to update the index but we'll only local it finish half
	--         -- way through.
	--         ReactNoop.render(<Foo tick={2} idx={1} />)
	--         ReactNoop.flushDeferredPri(95)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(2),
	--                 div(
	--                     -- Still same old numbers.
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                 ),
	--             ),
	--         ])

	--         -- We local it finish half way through. That means we'll have one fully
	--         -- completed Baz, one half-way completed Baz and one fully incomplete Baz.
	--         expect(ops).toEqual(['Foo', 'Baz', 'Bar', 'Bar', 'Baz', 'Bar'])
	--         ops = []

	--         -- We'll update again, without letting the new index update yet. Only half
	--         -- way through.
	--         ReactNoop.render(<Foo tick={3} idx={1} />)
	--         ReactNoop.flushDeferredPri(50)
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(3),
	--                 div(
	--                     -- Old numbers.
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                     span(0),
	--                 ),
	--             ),
	--         ])

	--         expect(ops).toEqual(['Foo'])
	--         ops = []

	--         -- We should now be able to reuse some of the work we've already done
	--         -- and replay those side-effects.
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([
	--             div(
	--                 span(3),
	--                 div(
	--                     -- New numbers.
	--                     span(1),
	--                     span(1),
	--                     span(1),
	--                     span(1),
	--                     span(1),
	--                     span(1),
	--                 ),
	--             ),
	--         ])

	--         expect(ops).toEqual(['Bar', 'Baz', 'Bar', 'Bar'])
	--     })

	--     -- @gate experimental
	--     it('deprioritizes setStates that happens within a deprioritized tree', () => {
	--         local barInstances = []

	--         class Bar extends React.Component {
	--             constructor()
	--                 super()
	--                 this.state = {active: false}
	--             }
	--             activate()
	--                 this.setState({active: true})
	--             }
	--             render()
	--                 barInstances.push(this)
	--                 Scheduler.unstable_yieldValue('Bar')
	--                 return <span prop={this.state.active ? 'X' : this.props.idx} />
	--             }
	--         }
	--         function Foo(props)
	--             Scheduler.unstable_yieldValue('Foo')
	--             return (
	--                 <div>
	--                     <span prop={props.tick} />
	--                     <LegacyHiddenDiv mode="hidden">
	--                         <Bar idx={props.idx} />
	--                         <Bar idx={props.idx} />
	--                         <Bar idx={props.idx} />
	--                     </LegacyHiddenDiv>
	--                 </div>
	--             )
	--         }
	--         ReactNoop.render(<Foo tick={0} idx={0} />)
	--         expect(Scheduler).toFlushAndYield(['Foo', 'Bar', 'Bar', 'Bar'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 <span prop={0} />
	--                 <div hidden={true}>
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                 </div>
	--             </div>,
	--         )

	--         ReactNoop.render(<Foo tick={1} idx={1} />)
	--         expect(Scheduler).toFlushAndYieldThrough(['Foo', 'Bar', 'Bar'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 {--\[\[ Updated \]\]}
	--                 <span prop={1} />
	--                 <div hidden={true}>
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                 </div>
	--             </div>,
	--         )

	--         barInstances[0].activate()

	--         -- This should not be enough time to render the content of all the hidden
	--         -- items. Including the set state since that is deprioritized.
	--         -- ReactNoop.flushDeferredPri(35)
	--         expect(Scheduler).toFlushAndYieldThrough(['Bar'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 {--\[\[ Updated \]\]}
	--                 <span prop={1} />
	--                 <div hidden={true}>
	--                     {--\[\[ Still not updated \]\]}
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                     <span prop={0} />
	--                 </div>
	--             </div>,
	--         )

	--         -- However, once we render fully, we will have enough time to finish it all
	--         -- at once.
	--         expect(Scheduler).toFlushAndYield(['Bar', 'Bar'])
	--         expect(ReactNoop.getChildrenAsJSX()).toEqual(
	--             <div>
	--                 <span prop={1} />
	--                 <div hidden={true}>
	--                     {--\[\[ Now we had enough time to finish the spans. \]\]}
	--                     <span prop="X" />
	--                     <span prop={1} />
	--                     <span prop={1} />
	--                 </div>
	--             </div>,
	--         )
	--     })
	--     -- TODO: Test that side-effects are not cut off when a work in progress node
	--     -- moves to "current" without flushing due to having lower priority. Does this
	--     -- even happen? Maybe a child doesn't get processed because it is lower prio?

	--     it('calls callback after update is flushed', () => {
	--         local instance
	--         class Foo extends React.Component {
	--             constructor()
	--                 super()
	--                 instance = this
	--                 this.state = {text: 'foo'}
	--             }
	--             render()
	--                 return <span prop={this.state.text} />
	--             }
	--         }

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([span('foo')])
	--         local called = false
	--         instance.setState({text: 'bar'}, () => {
	--             expect(ReactNoop.getChildren()).toEqual([span('bar')])
	--             called = true
	--         })
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(called).toBe(true)
	--     })

	--     it('calls setState callback even if component bails out', () => {
	--         local instance
	--         class Foo extends React.Component {
	--             constructor()
	--                 super()
	--                 instance = this
	--                 this.state = {text: 'foo'}
	--             }
	--             shouldComponentUpdate(nextProps, nextState)
	--                 return this.state.text ~= nextState.text
	--             }
	--             render()
	--                 return <span prop={this.state.text} />
	--             }
	--         }

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ReactNoop.getChildren()).toEqual([span('foo')])
	--         local called = false
	--         instance.setState({}, () => {
	--             called = true
	--         })
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(called).toBe(true)
	--     })

	--     -- TODO: Test that callbacks are not lost if an update is preempted.

	--     it('calls componentWillUnmount after a deletion, even if nested', () => {
	--         local ops = []

	--         class Bar extends React.Component {
	--             componentWillUnmount()
	--                 ops.push(this.props.name)
	--             }
	--             render()
	--                 return <span />
	--             }
	--         }

	--         class Wrapper extends React.Component {
	--             componentWillUnmount()
	--                 ops.push('Wrapper')
	--             }
	--             render()
	--                 return <Bar name={this.props.name} />
	--             }
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     {props.show
	--                         ? [
	--                                 <Bar key="a" name="A" />,
	--                                 <Wrapper key="b" name="B" />,
	--                                 <div key="cd">
	--                                     <Bar name="C" />
	--                                     <Wrapper name="D" />,
	--                                 </div>,
	--                                 [<Bar key="e" name="E" />, <Bar key="f" name="F" />],
	--                             ]
	--                         : []}
	--                     <div>{props.show ? <Bar key="g" name="G" /> : nil}</div>
	--                     <Bar name="this should not unmount" />
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo show={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([])

	--         ReactNoop.render(<Foo show={false} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([
	--             'A',
	--             'Wrapper',
	--             'B',
	--             'C',
	--             'Wrapper',
	--             'D',
	--             'E',
	--             'F',
	--             'G',
	--         ])
	--     })

	--     it('calls componentDidMount/Update after insertion/update', () => {
	--         local ops = []

	--         class Bar extends React.Component {
	--             componentDidMount()
	--                 ops.push('mount:' + this.props.name)
	--             }
	--             componentDidUpdate()
	--                 ops.push('update:' + this.props.name)
	--             }
	--             render()
	--                 return <span />
	--             }
	--         }

	--         class Wrapper extends React.Component {
	--             componentDidMount()
	--                 ops.push('mount:wrapper-' + this.props.name)
	--             }
	--             componentDidUpdate()
	--                 ops.push('update:wrapper-' + this.props.name)
	--             }
	--             render()
	--                 return <Bar name={this.props.name} />
	--             }
	--         }

	--         function Foo(props)
	--             return (
	--                 <div>
	--                     <Bar key="a" name="A" />
	--                     <Wrapper key="b" name="B" />
	--                     <div key="cd">
	--                         <Bar name="C" />
	--                         <Wrapper name="D" />
	--                     </div>
	--                     {[<Bar key="e" name="E" />, <Bar key="f" name="F" />]}
	--                     <div>
	--                         <Bar key="g" name="G" />
	--                     </div>
	--                 </div>
	--             )
	--         }

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([
	--             'mount:A',
	--             'mount:B',
	--             'mount:wrapper-B',
	--             'mount:C',
	--             'mount:D',
	--             'mount:wrapper-D',
	--             'mount:E',
	--             'mount:F',
	--             'mount:G',
	--         ])

	--         ops = []

	--         ReactNoop.render(<Foo />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([
	--             'update:A',
	--             'update:B',
	--             'update:wrapper-B',
	--             'update:C',
	--             'update:D',
	--             'update:wrapper-D',
	--             'update:E',
	--             'update:F',
	--             'update:G',
	--         ])
	--     })

	--     it('invokes ref callbacks after insertion/update/unmount', () => {
	--         local classInstance = nil

	--         local ops = []

	--         class ClassComponent extends React.Component {
	--             render()
	--                 classInstance = this
	--                 return <span />
	--             }
	--         }

	--         function FunctionComponent(props)
	--             return <span />
	--         }

	--         function Foo(props)
	--             return props.show ? (
	--                 <div>
	--                     <ClassComponent ref={n => ops.push(n)} />
	--                     <FunctionComponent ref={n => ops.push(n)} />
	--                     <div ref={n => ops.push(n)} />
	--                 </div>
	--             ) : nil
	--         }

	--         ReactNoop.render(<Foo show={true} />)
	--         expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
	--             'Warning: Function components cannot be given refs. ' +
	--                 'Attempts to access this ref will fail. ' +
	--                 'Did you mean to use React.forwardRef()?\n\n' +
	--                 'Check the render method ' +
	--                 'of `Foo`.\n' +
	--                 '        in FunctionComponent (at **)\n' +
	--                 '        in div (at **)\n' +
	--                 '        in Foo (at **)',
	--         )
	--         expect(ops).toEqual([
	--             classInstance,
	--             -- no call for function components
	--             div(),
	--         ])

	--         ops = []

	--         -- Refs that switch function instances get reinvoked
	--         ReactNoop.render(<Foo show={true} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([
	--             -- detach all refs that switched handlers first.
	--             nil,
	--             nil,
	--             -- reattach as a separate phase
	--             classInstance,
	--             div(),
	--         ])

	--         ops = []

	--         ReactNoop.render(<Foo show={false} />)
	--         expect(Scheduler).toFlushWithoutYielding()
	--         expect(ops).toEqual([
	--             -- unmount
	--             nil,
	--             nil,
	--         ])
	--     })

	--     -- TODO: Test that mounts, updates, refs, unmounts and deletions happen in the
	--     -- expected way for aborted and resumed render life-cycles.

	--     it('supports string refs', () => {
	--         local fooInstance = nil

	--         class Bar extends React.Component {
	--             componentDidMount()
	--                 this.test = 'test'
	--             }
	--             render()
	--                 return <div />
	--             }
	--         }

	--         class Foo extends React.Component {
	--             render()
	--                 fooInstance = this
	--                 return <Bar ref="bar" />
	--             }
	--         }

	--         ReactNoop.render(<Foo />)
	--         expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
	--             'Warning: A string ref, "bar", has been found within a strict mode tree.',
	--         )

	--         expect(fooInstance.refs.bar.test).toEqual('test')
	--     })
end) ]]
eC.Children._85c9ad090580195ee5ab6f7a6d26f99f=fk
local fl

local fm={ClassName="ModuleScript",Children={},Properties={}}
fm.Name="ReactIncrementalUpdates.spec"
fm.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local React
local ReactNoop
local Scheduler
local InputContinuousLanePriority = 10
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

describe("ReactIncrementalUpdates", function()
	local function gate(fn)
		return fn(ReactFeatureFlags)
	end
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	local function span(prop)
		return {
			type = "span",
			children = {},
			prop = prop,
			hidden = false,
		}
	end

	it("applies updates in order of priority", function()
		local state
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end
		function Foo:componentDidMount()
			local _this = self
			Scheduler.unstable_yieldValue("commit")
			ReactNoop.deferredUpdates(function()
				-- Has low priority
				_this:setState({ b = "b" })
				_this:setState({ c = "c" })
			end)
			-- Has Task priority
			self:setState({ a = "a" })
		end

		function Foo:render()
			state = self.state
			return React.createElement("div")
		end
		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushAndYieldThrough({ "commit" })
		jestExpect(state).toEqual({
			a = "a",
		})
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(state).toEqual({
			a = "a",
			b = "b",
			c = "c",
		})
	end)
	it("applies updates with equal priority in insertion order", function()
		local state
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end
		function Foo:componentDidMount()
			-- All have Task priority
			self:setState({ a = "a" })
			self:setState({ b = "b" })
			self:setState({ c = "c" })
		end

		function Foo:render()
			state = self.state
			return React.createElement("div")
		end
		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(state).toEqual({
			a = "a",
			b = "b",
			c = "c",
		})
	end)
	it(
		"only drops updates with equal or lesser priority when replaceState is called",
		function()
			local instance
			local Foo = React.Component:extend("Foo")
			function Foo:init()
				self.state = {}
			end

			function Foo:componentDidMount()
				Scheduler.unstable_yieldValue("componentDidMount")
			end

			function Foo:componentDidUpdate()
				Scheduler.unstable_yieldValue("componentDidUpdate")
			end

			function Foo:render()
				Scheduler.unstable_yieldValue("render")
				instance = self
				return React.createElement("div")
			end

			ReactNoop.render(React.createElement(Foo))
			jestExpect(Scheduler).toFlushAndYield({
				"render",
				"componentDidMount",
			})
			ReactNoop.flushSync(function()
				ReactNoop.deferredUpdates(function()
					instance:setState({
						x = "x",
					})
					instance:setState({
						y = "y",
					})
				end)
				instance:setState({
					a = "a",
				})
				instance:setState({
					b = "b",
				})
				ReactNoop.deferredUpdates(function()
					instance.__updater.enqueueReplaceState(instance, {
						c = "c",
					})
					instance:setState({
						d = "d",
					})
				end)
			end)
			-- Even though a replaceState has been already scheduled, it hasn't been
			-- flushed yet because it has async priority.

			jestExpect(instance.state).toEqual({
				a = "a",
				b = "b",
			})
			jestExpect(Scheduler).toHaveYielded({
				"render",
				"componentDidUpdate",
			})
			jestExpect(Scheduler).toFlushAndYield({
				"render",
				"componentDidUpdate",
			})
			-- Now the rest of the updates are flushed, including the replaceState.
			jestExpect(instance.state).toEqual({
				c = "c",
				d = "d",
			})
		end
	)
	-- Test fails due to update priority bug
	it("can abort an update, schedule additional updates, and resume", function()
		local instance
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end

		function Foo:render()
			instance = self
			local keylist = Object.keys(self.state)
			table.sort(keylist)
			return React.createElement("span", {
				prop = table.concat(keylist, ""),
			})
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()

		local function createUpdate(letter)
			return function()
				Scheduler.unstable_yieldValue(letter)
				return { [letter] = letter }
			end
		end
		-- Schedule some async updates

		instance:setState(createUpdate("a"))
		instance:setState(createUpdate("b"))
		instance:setState(createUpdate("c")) -- // Begin the updates but don't flush them yet
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"a",
			"b",
			"c",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span(""),
		}) -- Schedule some more updates at different priorities
		instance:setState(createUpdate("d"))
		ReactNoop.flushSync(function()
			instance:setState(createUpdate("e"))
			instance:setState(createUpdate("f"))
		end)
		instance:setState(createUpdate("g")) -- The sync updates should have flushed, but not the async ones
		jestExpect(Scheduler).toHaveYielded({
			"e",
			"f",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("ef"),
		})
		-- Now flush the remaining work. Even though e and f were already processed,
		-- they should be processed again, to ensure that the terminal state
		-- is deterministic.
		jestExpect(Scheduler).toFlushAndYield({
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"g",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("abcdefg"),
		})
	end)
	-- Test fails due to update priority bug
	it("can abort an update, schedule a replaceState, and resume", function()
		local instance

		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end

		function Foo:render()
			instance = self
			local keylist = Object.keys(self.state)
			table.sort(keylist)
			return React.createElement("span", {
				prop = table.concat(keylist, ""),
			})
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()

		local function createUpdate(letter)
			return function()
				Scheduler.unstable_yieldValue(letter)
				return { [letter] = letter }
			end
		end

		-- Schedule some async updates
		instance:setState(createUpdate("a"))
		instance:setState(createUpdate("b"))
		instance:setState(createUpdate("c"))

		-- Begin the updates but don't flush them yet
		jestExpect(Scheduler).toFlushAndYieldThrough({
			"a",
			"b",
			"c",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span(""),
		})

		-- Schedule some more updates at different priorities
		instance:setState(createUpdate("d"))
		ReactNoop.flushSync(function()
			instance:setState(createUpdate("e"))
			instance.__updater.enqueueReplaceState(instance, createUpdate("f"))
		end)
		instance:setState(createUpdate("g"))

		-- The sync updates should have flushed, but not the async ones
		jestExpect(Scheduler).toHaveYielded({
			"e",
			"f",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("f"),
		})
		-- Now flush the remaining work. Even though e and f were already processed,
		-- they should be processed again, to ensure that the terminal state
		-- is deterministic.
		jestExpect(Scheduler).toFlushAndYield({
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"g",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("fg"),
		})
	end)
	-- ROBLOX deviation START: same as above, but tests > 1000 updates
	it("can abort an update, schedule a replaceState, and resume many times", function()
		local instance

		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end

		function Foo:render()
			instance = self
			local keylist = Object.keys(self.state)
			table.sort(keylist)
			return React.createElement("span", {
				prop = table.concat(keylist, ""),
			})
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushWithoutYielding()

		local function createUpdate(letter)
			return function()
				Scheduler.unstable_yieldValue(letter)
				return { [letter] = letter }
			end
		end

		-- Schedule many async updates
		for _ = 1, 500 do
			instance:setState(createUpdate("a"))
			instance:setState(createUpdate("b"))
			instance:setState(createUpdate("c"))
		end
		jestExpect(ReactNoop.getChildren()).toEqual({
			span(""),
		})

		-- Schedule some more updates at different priorities
		instance:setState(createUpdate("d"))
		ReactNoop.flushSync(function()
			instance:setState(createUpdate("e"))
			instance.__updater.enqueueReplaceState(instance, createUpdate("f"))
		end)
		instance:setState(createUpdate("g"))

		-- The sync updates should have flushed, but not the async ones
		jestExpect(Scheduler).toHaveYielded({
			"e",
			"f",
		})
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("f"),
		})
		-- Now flush the remaining work.
		ReactNoop.flushSync(function()
			instance:setState(createUpdate("g"))
		end)
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("fg"),
		})
	end)
	-- ROBLOX deviation END
	it(
		"passes accumulation of previous updates to replaceState updater function",
		function()
			local instance
			local Foo = React.Component:extend("Foo")
			function Foo:init()
				self.state = {}
			end

			function Foo:render()
				instance = self
				return React.createElement("span")
			end

			ReactNoop.render(React.createElement(Foo))
			jestExpect(Scheduler).toFlushWithoutYielding()
			instance:setState({ a = "a" })
			instance:setState({ b = "b" })
			-- No longer a public API, but we can test that it works internally by
			-- reaching into the updater.
			instance.__updater.enqueueReplaceState(instance, function(previousState)
				return { previousState = previousState }
			end)
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(instance.state.previousState).toEqual({
				a = "a",
				b = "b",
			})
		end
	)
	it(
		"does not call callbacks that are scheduled by another callback until a later commit",
		function()
			local Foo = React.Component:extend("Foo")
			function Foo:init()
				self.state = {}
			end

			function Foo:componentDidMount()
				local _this2 = self
				Scheduler.unstable_yieldValue("did mount")
				self:setState({
					a = "a",
				}, function()
					Scheduler.unstable_yieldValue("callback a")
					_this2:setState({
						b = "b",
					}, function()
						Scheduler.unstable_yieldValue("callback b")
					end)
				end)
			end

			function Foo:render()
				Scheduler.unstable_yieldValue("render")
				return React.createElement("div")
			end

			ReactNoop.render(React.createElement(Foo))
			jestExpect(Scheduler).toFlushAndYield({
				"render",
				"did mount",
				"render",
				"callback a",
				"render",
				"callback b",
			})
		end
	)
	it(
		"gives setState during reconciliation the same priority as whatever level is currently reconciling",
		function()
			local instance

			local Foo = React.Component:extend("Foo")
			function Foo:init()
				self.state = {}
			end

			function Foo:UNSAFE_componentWillReceiveProps()
				Scheduler.unstable_yieldValue("componentWillReceiveProps")
				self:setState({
					b = "b",
				})
			end

			function Foo:render()
				Scheduler.unstable_yieldValue("render")
				instance = self
				return React.createElement("div")
			end

			ReactNoop.render(React.createElement(Foo))
			jestExpect(function()
				return jestExpect(Scheduler).toFlushAndYield({
					"render",
				})
			end).toErrorDev(
				"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended",
				{ withoutStack = true }
			)
			ReactNoop.flushSync(function()
				instance:setState({
					a = "a",
				})
				ReactNoop.render(React.createElement(Foo))
				return "test"
			end)
			jestExpect(instance.state).toEqual({
				a = "a",
				b = "b",
			})
			jestExpect(Scheduler).toHaveYielded({
				"componentWillReceiveProps",
				"render",
			})
		end
	)
	it("updates triggered from inside a class setState updater", function()
		local instance
		local Foo = React.Component:extend("Foo")
		function Foo:init()
			self.state = {}
		end

		function Foo:render()
			Scheduler.unstable_yieldValue("render")
			instance = self
			return React.createElement("div")
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushAndYield({
			-- Initial render
			"render",
		})
		instance:setState(function()
			Scheduler.unstable_yieldValue("setState updater")
			instance:setState({
				b = "b",
			})
			return {
				a = "a",
			}
		end)
		jestExpect(function()
			-- ROBLOX deviation: using local defined gate which references ReactFeatureFlags as
			-- opposed to upstream's gate() which is defined in setupTests in Jest files
			return jestExpect(Scheduler).toFlushAndYield(gate(function(flags)
				if flags.deferRenderPhaseUpdateToNextBatch then
					return {
						"setState updater", -- In the new reconciler, updates inside the render phase are
						-- treated as if they came from an event, so the update gets
						-- shifted to a subsequent render.
						"render",
						"render",
					}
				end

				return {
					"setState updater", -- In the old reconciler, updates in the render phase receive
					-- the currently rendering expiration time, so the update
					-- flushes immediately in the same render.
					"render",
				}
			end))
		end).toErrorDev(
			"An update (setState, replaceState, or forceUpdate) was scheduled "
				.. "from inside an update function. Update functions should be pure, "
				.. "with zero side-effects. Consider using componentDidUpdate or a "
				.. "callback."
		)
		jestExpect(instance.state).toEqual({
			a = "a",
			b = "b",
		}) -- Test deduplication (no additional warnings expected)
		instance:setState(function()
			instance:setState({
				a = "a",
			})
			return {
				b = "b",
			}
		end)
		jestExpect(Scheduler).toFlushAndYield(gate(function(flags)
			return (function()
				if flags.deferRenderPhaseUpdateToNextBatch then
					return { -- In the new reconciler, updates inside the render phase are
						-- treated as if they came from an event, so the update gets shifted
						-- to a subsequent render.
						"render",
						"render",
					}
				end

				return {
					"render",
				}
			end)()
		end))
	end)
	it(
		"getDerivedStateFromProps should update base state of updateQueue (based on product bug)",
		function()
			-- Based on real-world bug.
			local foo
			local bar

			local Bar = React.Component:extend("Bar")
			function Bar:render()
				bar = self
				return nil
			end

			local Foo = React.Component:extend("Foo")
			function Foo:init()
				self.state = { value = "initial state" }
			end
			function Foo:getDerivedStateFromProps()
				return { value = "derived state" }
			end
			function Foo:render()
				foo = self
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement("span", {
						prop = self.state.value,
					}),
					React.createElement(Bar)
				)
			end
			ReactNoop.flushSync(function()
				-- Triggers getDerivedStateFromProps again
				ReactNoop.render(React.createElement(Foo))
				-- The noop callback is needed to trigger the specific internal path that
				-- led to this bug. Removing it causes it to "accidentally" work.
			end)
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("derived state"),
			})
			ReactNoop.flushSync(function()
				ReactNoop.render(React.createElement(Foo))
				foo:setState({
					value = "update state",
				}, function() end)
			end)
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("derived state"),
			})
			ReactNoop.flushSync(function()
				bar:setState({})
			end)
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("derived state"),
			})
		end
	)
	it(
		"regression: does not expire soon due to layout effects in the last batch",
		function()
			local useState = React.useState
			local useLayoutEffect = React.useLayoutEffect

			local setCount
			local function App()
				local count, setCountTemp = useState(0)
				setCount = setCountTemp

				Scheduler.unstable_yieldValue("Render: " .. count)
				useLayoutEffect(function()
					setCount(function(prevCount)
						return prevCount + 1
					end)
					Scheduler.unstable_yieldValue("Commit: " .. count)
				end, {})
				return nil
			end

			ReactNoop.act(function()
				ReactNoop.render(React.createElement(App))
				jestExpect(Scheduler).toFlushExpired({})
				jestExpect(Scheduler).toFlushAndYield({
					"Render: 0",
					"Commit: 0",
					"Render: 1",
				})
				Scheduler.unstable_advanceTime(10000)
				setCount(2)
				jestExpect(Scheduler).toFlushExpired({})
			end)
		end
	)
	it("regression: does not expire soon due to previous flushSync", function()
		local function Text(_ref)
			local text = _ref.text
			Scheduler.unstable_yieldValue(text)
			return text
		end

		ReactNoop.flushSync(function()
			ReactNoop.render(React.createElement(Text, {
				text = "A",
			}))
		end)
		jestExpect(Scheduler).toHaveYielded({
			"A",
		})
		Scheduler.unstable_advanceTime(10000)
		ReactNoop.render(React.createElement(Text, {
			text = "B",
		}))
		jestExpect(Scheduler).toFlushExpired({})
	end)
	it("regression: does not expire soon due to previous expired work", function()
		local function Text(_ref2)
			local text = _ref2.text

			Scheduler.unstable_yieldValue(text)

			return text
		end

		ReactNoop.render(React.createElement(Text, {
			text = "A",
		}))
		Scheduler.unstable_advanceTime(10000)
		jestExpect(Scheduler).toFlushExpired({
			"A",
		})
		Scheduler.unstable_advanceTime(10000)
		ReactNoop.render(React.createElement(Text, {
			text = "B",
		}))
		jestExpect(Scheduler).toFlushExpired({})
	end)

	it(
		"when rebasing, does not exclude updates that were already committed, regardless of priority",
		function()
			local useState = React.useState
			local useLayoutEffect = React.useLayoutEffect
			local pushToLog

			local function App()
				local log, setLog = useState("")
				pushToLog = function(msg)
					return setLog(function(prevLog)
						return prevLog .. msg
					end)
				end

				useLayoutEffect(function()
					Scheduler.unstable_yieldValue("Committed: " .. log)

					if log == "B" then
						-- Right after B commits, schedule additional updates.
						-- TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
						ReactNoop.unstable_runWithPriority(
							InputContinuousLanePriority,
							function()
								return Scheduler.unstable_runWithPriority(
									Scheduler.unstable_UserBlockingPriority,
									function()
										pushToLog("C")
									end
								)
							end
						)
						setLog(function(prevLog)
							return prevLog .. "D"
						end)
					end
				end, {
					log,
				})

				return log
			end

			local root = ReactNoop.createRoot()
			ReactNoop.act(function()
				root.render(React.createElement(App))
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Committed: ",
			})

			jestExpect(root).toMatchRenderedOutput("")

			ReactNoop.act(function()
				pushToLog("A")

				-- TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
				ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, function()
					return Scheduler.unstable_runWithPriority(
						Scheduler.unstable_UserBlockingPriority,
						function()
							pushToLog("B")
						end
					)
				end)
			end)
			jestExpect(Scheduler).toHaveYielded({
				-- A and B are pending. B is higher priority, so we'll render that first.
				"Committed: B",
				-- Because A comes first in the queue, we're now in rebase mode. B must
				-- be rebased on top of A. Also, in a layout effect, we received two new
				-- updates: C and D. C is user-blocking and D is synchronous.
				--
				-- First render the synchronous update. What we're testing here is that
				-- B *is not dropped* even though it has lower than sync priority. That's
				-- because we already committed it. However, this render should not
				-- include C, because that update wasn't already committed.
				"Committed: BD",
				"Committed: BCD",
				"Committed: ABCD",
			})

			jestExpect(root).toMatchRenderedOutput("ABCD")
		end
	)
	-- ROBLOX FIXME: fails with incorrect values
	xit(
		"when rebasing, does not exclude updates that were already committed, regardless of priority (classes)",
		function()
			local instance
			local App = React.Component:extend("App")
			function App:init()
				self.state = { log = "" }
			end
			function App:pushToLog(msg)
				self:setState(function(prevState)
					return { log = prevState.state.log .. msg }
				end)
			end

			function App:componentDidUpdate()
				Scheduler.unstable_yieldValue("Committed: " .. self.state.log)
				if self.state.log == "B" then
					-- Right after B commits, schedule additional updates.
					-- TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
					ReactNoop.unstable_runWithPriority(
						InputContinuousLanePriority,
						function()
							Scheduler.unstable_runWithPriority(
								Scheduler.unstable_UserBlockingPriority,
								function()
									self:pushToLog("C")
								end
							)
						end
					)
					self:pushToLog("D")
				end
			end

			function App:render()
				instance = self
				return self.state.log
			end

			local root = ReactNoop.createRoot()
			local app = React.createElement(App)
			-- ROBLOX FIXME: fails probably due to this not being as Promise as in upstream
			ReactNoop.act(function()
				root.render(app)
			end)
			jestExpect(Scheduler).toHaveYielded({})

			jestExpect(root).toMatchRenderedOutput("")

			ReactNoop.act(function()
				instance:pushToLog("A")
				-- TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
				ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, function()
					Scheduler.unstable_runWithPriority(
						Scheduler.unstable_UserBlockingPriority,
						function()
							instance:pushToLog("B")
						end
					)
				end)
			end)
			jestExpect(Scheduler).toHaveYielded({
				-- A and B are pending. B is higher priority, so we'll render that first.
				"Committed: B",
				-- Because A comes first in the queue, we're now in rebase mode. B must
				-- be rebased on top of A. Also, in a layout effect, we received two new
				-- updates: C and D. C is user-blocking and D is synchronous.
				--
				-- First render the synchronous update. What we're testing here is that
				-- B *is not dropped* even though it has lower than sync priority. That's
				-- because we already committed it. However, this render should not
				-- include C, because that update wasn't already committed.
				"Committed: BD",
				"Committed: BCD",
				"Committed: ABCD",
			})
			jestExpect(root).toMatchRenderedOutput("ABCD")
		end
	)
	it(
		"base state of update queue is initialized to its fiber's memoized state",
		function()
			local app
			local App = React.Component:extend("App")
			function App:init()
				self.state = {
					prevProp = "A",
					count = 0,
				}
			end

			function App.getDerivedStateFromProps(props, state)
				-- Add 100 whenever the label prop changes. The prev label is stored
				-- in state. If the state is dropped incorrectly, we'll fail to detect
				-- prop changes.
				if props.prop ~= state.prevProp then
					return {
						prevProp = props.prop,
						count = state.count + 100,
					}
				end

				return nil
			end

			function App:render()
				app = self
				return self.state.count
			end

			local root = ReactNoop.createRoot()
			ReactNoop.act(function()
				root.render(React.createElement(App, { prop = "A" }))
			end)

			jestExpect(root).toMatchRenderedOutput("0") -- Changing the prop causes the count to increase by 100

			ReactNoop.act(function()
				root.render(React.createElement(App, { prop = "B" }))
			end)
			jestExpect(root).toMatchRenderedOutput("100")
			-- Now increment the count by 1 with a state update. And, in the same
			-- batch, change the prop back to its original value.

			ReactNoop.act(function()
				root.render(React.createElement(App, { prop = "A" }))
				app:setState(function(state)
					return {
						count = state.count + 1,
					}
				end)
			end) -- There were two total prop changes, plus an increment

			jestExpect(root).toMatchRenderedOutput("201")
		end
	)
end) ]]
eC.Children._9a628e3dd4e95192c8ce555f2a73e90c=fm
local fn

local fo={ClassName="ModuleScript",Children={},Properties={}}
fo.Name="ReactIncrementalUpdatesMinimalism.spec"
fo.Properties.Source=[[ -- Upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactIncrementalUpdatesMinimalism-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 --\]\]
--!strict
local React
local ReactNoop
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jest = JestGlobals.jest
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

describe("ReactIncrementalUpdatesMinimalism", function()
	beforeEach(function()
		jest.resetModules()
		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	end)
	it("should render a simple component", function()
		local function Child()
			return React.createElement("div", nil, "Hello World")
		end
		local function Parent()
			return React.createElement(Child)
		end

		ReactNoop.render(React.createElement(Parent))
		local x = ReactNoop.flushWithHostCounters()
		jestExpect(x).toEqual({
			hostDiffCounter = 0,
			hostUpdateCounter = 0,
		})
		ReactNoop.render(React.createElement(Parent))
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			hostDiffCounter = 1,
			hostUpdateCounter = 1,
		})
	end)
	it("should not diff referentially equal host elements", function()
		local function Leaf(props)
			return React.createElement(
				"span",
				nil,
				"hello",
				React.createElement("b"),
				props.name
			)
		end

		local constEl = React.createElement(
			"div",
			nil,
			React.createElement(Leaf, {
				name = "world",
			})
		)

		local function Child()
			return constEl
		end
		local function Parent()
			return React.createElement(Child)
		end

		ReactNoop.render(React.createElement(Parent))
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			hostDiffCounter = 0,
			hostUpdateCounter = 0,
		})
		ReactNoop.render(React.createElement(Parent))
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			hostDiffCounter = 0,
			hostUpdateCounter = 0,
		})
	end)
	it("should not diff parents of setState targets", function()
		local childInst

		local function Leaf(props)
			return React.createElement(
				"span",
				nil,
				"hello",
				React.createElement("b"),
				props.name
			)
		end

		local Child = React.Component:extend("Child")
		function Child:init()
			self.state = { name = "Batman" }
		end
		function Child:render()
			childInst = self
			return React.createElement(
				"div",
				nil,
				React.createElement(Leaf, { name = self.state.name })
			)
		end

		local function Parent()
			return React.createElement(
				"section",
				nil,
				React.createElement(
					"div",
					nil,
					React.createElement(Leaf, {
						name = "world",
					}),
					React.createElement(Child),
					React.createElement("hr"),
					React.createElement(Leaf, {
						name = "world",
					})
				)
			)
		end

		ReactNoop.render(React.createElement(Parent))
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			hostDiffCounter = 0,
			hostUpdateCounter = 0,
		})
		childInst:setState({
			name = "Robin",
		})
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			-- Child > div
			-- Child > Leaf > span
			-- Child > Leaf > span > b
			hostDiffCounter = 3,
			-- Child > div
			-- Child > Leaf > span
			-- Child > Leaf > span > b
			-- Child > Leaf > span > #text
			hostUpdateCounter = 4,
		})
		ReactNoop.render(React.createElement(Parent))
		jestExpect(ReactNoop.flushWithHostCounters()).toEqual({
			-- Parent > section
			-- Parent > section > div
			-- Parent > section > div > Leaf > span
			-- Parent > section > div > Leaf > span > b
			-- Parent > section > div > Child > div
			-- Parent > section > div > Child > div > Leaf > span
			-- Parent > section > div > Child > div > Leaf > span > b
			-- Parent > section > div > hr
			-- Parent > section > div > Leaf > span
			-- Parent > section > div > Leaf > span > b
			hostDiffCounter = 10,
			hostUpdateCounter = 10,
		})
	end)
end) ]]
eC.Children._6e9a52b7b25eee502b6e4692e06c0eb7=fo
local fp

local fq={ClassName="ModuleScript",Children={},Properties={}}
fq.Name="ReactLazy-internal.spec"
fq.Properties.Source=[[ -- local PropTypes
local React
local ReactTestRenderer
local Scheduler
local ReactFeatureFlags
local Suspense
local lazy

local Packages = script.Parent.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local setTimeout = LuauPolyfill.setTimeout
local Promise = require(Packages.Promise)
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest

local function normalizeCodeLocInfo(str)
	if typeof(str) ~= "string" then
		return str
	end

	str = string.gsub(str, "Check your code at .*:%d+", "Check your code at **")
	-- ROBLOX deviation: In roblox/luau, we're using the stack frame from luau,
	-- which looks like:
	--     in Component (at ModulePath.FileName.lua:123)
	return (string.gsub(str, "\n    in ([%w%-%._]+)[^\n]*", "\n    in %1 (at **)"))
end

-- ROBLOX Test Noise: in upstream, jest setup config makes these tests hide
-- the error boundary warnings they trigger (scripts/jest/setupTests.js:72)
describe("ReactLazy", function()
	beforeEach(function()
		jest.resetModules()

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		-- PropTypes = require('prop-types');
		React = require(Packages.React)
		Suspense = React.Suspense
		lazy = React.lazy
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	-- local verifyInnerPropTypesAreChecked = _async(function(Add)
	--     local LazyAdd = lazy(function()
	--         return fakeImport(Add)
	--     end)

	--     jestExpect(function()
	--         LazyAdd.propTypes = {}
	--     end).toErrorDev('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.', {withoutStack = true})

	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyAdd, {
	--         inner = '2',
	--         outer = '2',
	--     })), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('22')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(function()
	--             Scheduler.unstable_flushAll()
	--         end).toErrorDev({
	--             'Invalid prop `inner` of type `string` supplied to `Add`, expected `number`.',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('22')
	--         jestExpect(function()
	--             root.update(React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(LazyAdd, {
	--                 inner = false,
	--                 outer = false,
	--             })))
	--             jestExpect(Scheduler).toFlushWithoutYielding()
	--         end).toErrorDev('Invalid prop `inner` of type `boolean` supplied to `Add`, expected `number`.')
	--         jestExpect(root).toMatchRenderedOutput('0')
	--     end)
	-- end)

	local fakeImport = function(result)
		-- ROBLOX FIXME: delay(0) because resolved promises are andThen'd on the same tick cycle
		-- remove once addressed in polyfill
		return Promise.delay(0):andThen(function()
			return { default = result }
		end)
	end

	local function Text(props)
		Scheduler.unstable_yieldValue(props.text)

		return props.text
	end

	local delay_ = function(ms)
		return Promise.new(function(resolve)
			return setTimeout(function()
				return resolve()
			end, ms)
		end)
	end

	it("suspends until module has loaded", function()
		local LazyText = lazy(function()
			return fakeImport(Text)
		end)
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(LazyText, {
					text = "Hi",
				})
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})

		jestExpect(root).never.toMatchRenderedOutput("Hi")

		-- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
		Promise.delay(0):await()

		jestExpect(Scheduler).toFlushAndYield({
			"Hi",
		})
		jestExpect(root).toMatchRenderedOutput("Hi")

		-- Should not suspend on update
		root.update(React.createElement(
			Suspense,
			{
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			},
			React.createElement(LazyText, {
				text = "Hi again",
			})
		))
		jestExpect(Scheduler).toFlushAndYield({
			"Hi again",
		})
		jestExpect(root).toMatchRenderedOutput("Hi again")
	end)
	it("can resolve synchronously without suspending", function()
		local LazyText = lazy(function()
			return {
				andThen = function(self, cb)
					cb({ default = Text })
				end,
			}
		end)
		local root = ReactTestRenderer.create(React.createElement(
			Suspense,
			{
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			},
			React.createElement(LazyText, {
				text = "Hi",
			})
		))

		jestExpect(Scheduler).toHaveYielded({
			"Hi",
		})
		jestExpect(root).toMatchRenderedOutput("Hi")
	end)
	it("can reject synchronously without suspending", function()
		local LazyText = lazy(function()
			return {
				andThen = function(self, resolve, reject)
					reject(Error("oh no"))
				end,
			}
		end)
		local ErrorBoundary = React.Component:extend("ErrorBoundary")

		function ErrorBoundary:init()
			self.state = {}
		end
		function ErrorBoundary.getDerivedStateFromError(error_)
			return {
				message = error_.message,
			}
		end
		function ErrorBoundary:render()
			if self.state.message then
				return string.format("Error: %s", self.state.message)
			end
			return self.props.children
		end

		local root = ReactTestRenderer.create(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					},
					React.createElement(LazyText, {
						text = "Hi",
					})
				)
			)
		)

		jestExpect(Scheduler).toHaveYielded({})
		jestExpect(root).toMatchRenderedOutput("Error: oh no")
	end)
	it("multiple lazy components", function()
		local function Foo()
			return React.createElement(Text, {
				text = "Foo",
			})
		end
		local function Bar()
			return React.createElement(Text, {
				text = "Bar",
			})
		end

		local promiseForFoo = delay_(100):andThen(function()
			return fakeImport(Foo)
		end)
		local promiseForBar = delay_(500):andThen(function()
			return fakeImport(Bar)
		end)
		local LazyFoo = lazy(function()
			return promiseForFoo
		end)
		local LazyBar = lazy(function()
			return promiseForBar
		end)
		local root = ReactTestRenderer.create(
			React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, React.createElement(LazyFoo), React.createElement(LazyBar)),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput("FooBar")
		-- ROBLOX deviation START: not needed
		-- jest.advanceTimersByTime(100)
		-- ROBLOX deviation END

		promiseForFoo:await()
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
		})
		jestExpect(root).never.toMatchRenderedOutput("FooBar")
		-- ROBLOX deviation START: not needed
		-- jest.advanceTimersByTime(500)
		-- ROBLOX deviation END

		promiseForBar:await()

		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
		})
		jestExpect(root).toMatchRenderedOutput("FooBar")
	end)
	-- it('does not support arbitrary promises, only module objects', _async(function()
	--     spyOnDev(console, 'error')

	--     local LazyText = lazy(function()
	--         return _await(Text)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyText, {
	--         text = 'Hi',
	--     })), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Hi')

	--     return _await(Promise.resolve(), function()
	--         if __DEV__ then
	--             jestExpect(console.error).toHaveBeenCalledTimes(1)
	--             jestExpect(console.error.calls.argsFor(0)[0]).toContain('Expected the result of a dynamic import() call')
	--         end

	--         jestExpect(Scheduler).toFlushAndThrow('Element type is invalid')
	--     end)
	-- end))
	it("throws if promise rejects", function()
		local badImport = function()
			-- ROBLOX FIXME: delay(0) because resolved promises are andThen'd on the same tick cycle
			-- remove once addressed in polyfill
			return Promise.delay(0):andThen(function()
				error(Error("Bad network"))
			end)
		end
		local LazyText = lazy(badImport)
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(LazyText, {
					text = "Hi",
				})
			),
			{ unstable_isConcurrent = true }
		)

		-- ROBLOX TODO: this gets the 'Bad Network' error, Suspense fallback 'Loading...' not rendered first
		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput("Hi")

		local _, _ = pcall(function()
			-- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
			Promise.delay(0):await()
		end)

		jestExpect(Scheduler).toFlushAndThrow("Bad network")
	end)

	it("mount and reorder", function()
		local Child = React.Component:extend("Child")

		function Child:componentDidMount()
			Scheduler.unstable_yieldValue("Did mount: " .. self.props.label)
		end
		function Child:componentDidUpdate()
			Scheduler.unstable_yieldValue("Did update: " .. self.props.label)
		end
		function Child:render()
			return React.createElement(Text, {
				text = self.props.label,
			})
		end

		local LazyChildA = lazy(function()
			return fakeImport(Child)
		end)
		local LazyChildB = lazy(function()
			return fakeImport(Child)
		end)

		local function Parent(props)
			local children
			if props.swap then
				children = {
					React.createElement(LazyChildB, {
						key = "B",
						label = "B",
					}),
					React.createElement(LazyChildA, {
						key = "A",
						label = "A",
					}),
				}
			else
				children = {
					React.createElement(LazyChildA, {
						key = "A",
						label = "A",
					}),
					React.createElement(LazyChildB, {
						key = "B",
						label = "B",
					}),
				}
			end
			return React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, children)
		end

		local root = ReactTestRenderer.create(
			React.createElement(Parent, { swap = false }),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput("AB")

		-- ROBLOX FIXME: these are not Promises, so I'm not sure what usptream awaiting them means
		-- LazyChildA:await()
		-- LazyChildB:await()
		-- ROBLOX FIXME: these awaits let the test get further, but values in mountLazyComponent() are way off
		Promise.delay(0):await()
		Promise.delay(0):await()

		jestExpect(Scheduler).toFlushAndYield({
			"A",
			"B",
			"Did mount: A",
			"Did mount: B",
		})
		jestExpect(root).toMatchRenderedOutput("AB")

		-- Swap the potsition of A and B
		root.update(React.createElement(Parent, { swap = true }))
		jestExpect(Scheduler).toFlushAndYield({
			"B",
			"A",
			"Did update: B",
			"Did update: A",
		})
		jestExpect(root).toMatchRenderedOutput("BA")
	end)
	-- it('resolves defaultProps, on mount and update', _async(function()
	--     local function T(props)
	--         return React.createElement(Text, props)
	--     end

	--     T.defaultProps = {
	--         text = 'Hi',
	--     }

	--     local LazyText = lazy(function()
	--         return fakeImport(T)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyText)), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Hi')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Hi',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Hi')

	--         T.defaultProps = {
	--             text = 'Hi again',
	--         }

	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyText)))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Hi again',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Hi again')
	--     end)
	-- end))
	-- it('resolves defaultProps without breaking memoization', _async(function()
	--     local function LazyImpl(props)
	--         Scheduler.unstable_yieldValue('Lazy')

	--         return React.createElement(React.Fragment, nil, React.createElement(Text, {
	--             text = props.siblingText,
	--         }), props.children)
	--     end

	--     LazyImpl.defaultProps = {
	--         siblingText = 'Sibling',
	--     }

	--     local Lazy = lazy(function()
	--         return fakeImport(LazyImpl)
	--     end)
	--     local Stateful = {}
	--     local StatefulMetatable = {__index = Stateful}

	--     function Stateful.new()
	--         local self = setmetatable({}, StatefulMetatable)
	--         local _temp2

	--         return
	--     end
	--     function Stateful:render()
	--         return React.createElement(Text, {
	--             text = self.state.text,
	--         })
	--     end

	--     local stateful = React.createRef()
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(Lazy, nil, React.createElement(Stateful, {ref = stateful}))), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('SiblingA')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Lazy',
	--             'Sibling',
	--             'A',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('SiblingA')
	--         stateful.current.setState({
	--             text = 'B',
	--         })
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'B',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('SiblingB')
	--     end)
	-- end))
	-- it('resolves defaultProps without breaking bailout due to unchanged props and state, #17151', _async(function()
	--     local LazyImpl = {}
	--     local LazyImplMetatable = {__index = LazyImpl}

	--     function LazyImpl:render()
	--         local text = string.format('%s: %s', self.props.label, self.props.value)

	--         return React.createElement(Text, {text = text})
	--     end

	--     LazyImpl.defaultProps = {value = 0}

	--     local Lazy = lazy(function()
	--         return fakeImport(LazyImpl)
	--     end)
	--     local instance1 = React.createRef()
	--     local instance2 = React.createRef()
	--     local root = ReactTestRenderer.create(React.createElement(React.Fragment, nil, React.createElement(LazyImpl, {
	--         ref = instance1,
	--         label = 'Not lazy',
	--     }), React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(Lazy, {
	--         ref = instance2,
	--         label = 'Lazy',
	--     }))), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Not lazy: 0',
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Not lazy: 0Lazy: 0')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Lazy: 0',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--         instance1.current.setState(nil)
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--         instance2.current.setState(nil)
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--     end)
	-- end))
	-- it('resolves defaultProps without breaking bailout in PureComponent, #17151', _async(function()
	--     local LazyImpl = {}
	--     local LazyImplMetatable = {__index = LazyImpl}

	--     function LazyImpl.new()
	--         local self = setmetatable({}, LazyImplMetatable)
	--         local _temp3

	--         return
	--     end
	--     function LazyImpl:render()
	--         local text = string.format('%s: %s', self.props.label, self.props.value)

	--         return React.createElement(Text, {text = text})
	--     end

	--     LazyImpl.defaultProps = {value = 0}

	--     local Lazy = lazy(function()
	--         return fakeImport(LazyImpl)
	--     end)
	--     local instance1 = React.createRef()
	--     local instance2 = React.createRef()
	--     local root = ReactTestRenderer.create(React.createElement(React.Fragment, nil, React.createElement(LazyImpl, {
	--         ref = instance1,
	--         label = 'Not lazy',
	--     }), React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(Lazy, {
	--         ref = instance2,
	--         label = 'Lazy',
	--     }))), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Not lazy: 0',
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Not lazy: 0Lazy: 0')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Lazy: 0',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--         instance1.current.setState({})
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--         instance2.current.setState({})
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jestExpect(root).toMatchRenderedOutput('Not lazy: 0Lazy: 0')
	--     end)
	-- end))
	-- it('sets defaultProps for modern lifecycles', _async(function()
	--     local C = {}
	--     local CMetatable = {__index = C}

	--     function C.getDerivedStateFromProps(props)
	--         Scheduler.unstable_yieldValue(string.format('getDerivedStateFromProps: %s', props.text))

	--         return nil
	--     end
	--     function C.new(props)
	--         local self = setmetatable({}, CMetatable)

	--         self.state = {}

	--         Scheduler.unstable_yieldValue(string.format('constructor: %s', self.props.text))
	--     end
	--     function C:componentDidMount()
	--         Scheduler.unstable_yieldValue(string.format('componentDidMount: %s', self.props.text))
	--     end
	--     function C:componentDidUpdate(prevProps)
	--         Scheduler.unstable_yieldValue(string.format('componentDidUpdate: %s -> %s', prevProps.text, self.props.text))
	--     end
	--     function C:componentWillUnmount()
	--         Scheduler.unstable_yieldValue(string.format('componentWillUnmount: %s', self.props.text))
	--     end
	--     function C:shouldComponentUpdate(nextProps)
	--         Scheduler.unstable_yieldValue(string.format('shouldComponentUpdate: %s -> %s', self.props.text, nextProps.text))

	--         return true
	--     end
	--     function C:getSnapshotBeforeUpdate(prevProps)
	--         Scheduler.unstable_yieldValue(string.format('getSnapshotBeforeUpdate: %s -> %s', prevProps.text, self.props.text))

	--         return nil
	--     end
	--     function C:render()
	--         return React.createElement(Text, {
	--             text = self.props.text + self.props.num,
	--         })
	--     end

	--     C.defaultProps = {
	--         text = 'A',
	--     }

	--     local LazyClass = lazy(function()
	--         return fakeImport(C)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyClass, {num = 1})), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('A1')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'constructor: A',
	--             'getDerivedStateFromProps: A',
	--             'A1',
	--             'componentDidMount: A',
	--         })
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyClass, {num = 2})))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'getDerivedStateFromProps: A',
	--             'shouldComponentUpdate: A -> A',
	--             'A2',
	--             'getSnapshotBeforeUpdate: A -> A',
	--             'componentDidUpdate: A -> A',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('A2')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyClass, {num = 3})))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'getDerivedStateFromProps: A',
	--             'shouldComponentUpdate: A -> A',
	--             'A3',
	--             'getSnapshotBeforeUpdate: A -> A',
	--             'componentDidUpdate: A -> A',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('A3')
	--     end)
	-- end))
	-- it('sets defaultProps for legacy lifecycles', _async(function()
	--     local C = {}
	--     local CMetatable = {__index = C}

	--     function C.new()
	--         local self = setmetatable({}, CMetatable)
	--         local _temp4

	--         return
	--     end
	--     function C:UNSAFE_componentWillMount()
	--         Scheduler.unstable_yieldValue(string.format('UNSAFE_componentWillMount: %s', self.props.text))
	--     end
	--     function C:UNSAFE_componentWillUpdate(nextProps)
	--         Scheduler.unstable_yieldValue(string.format('UNSAFE_componentWillUpdate: %s -> %s', self.props.text, nextProps.text))
	--     end
	--     function C:UNSAFE_componentWillReceiveProps(nextProps)
	--         Scheduler.unstable_yieldValue(string.format('UNSAFE_componentWillReceiveProps: %s -> %s', self.props.text, nextProps.text))
	--     end
	--     function C:render()
	--         return React.createElement(Text, {
	--             text = self.props.text + self.props.num,
	--         })
	--     end

	--     C.defaultProps = {
	--         text = 'A',
	--     }

	--     local LazyClass = lazy(function()
	--         return fakeImport(C)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyClass, {num = 1})))

	--     jestExpect(Scheduler).toHaveYielded({
	--         'Loading...',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({})
	--     jestExpect(root).toMatchRenderedOutput('Loading...')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toHaveYielded({})
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyClass, {num = 2})))
	--         jestExpect(Scheduler).toHaveYielded({
	--             'UNSAFE_componentWillMount: A',
	--             'A2',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('A2')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyClass, {num = 3})))
	--         jestExpect(Scheduler).toHaveYielded({
	--             'UNSAFE_componentWillReceiveProps: A -> A',
	--             'UNSAFE_componentWillUpdate: A -> A',
	--             'A3',
	--         })
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jestExpect(root).toMatchRenderedOutput('A3')
	--     end)
	-- end))
	-- it('resolves defaultProps on the outer wrapper but warns', _async(function()
	--     local function T(props)
	--         Scheduler.unstable_yieldValue(props.inner + ' ' + props.outer)

	--         return props.inner + ' ' + props.outer
	--     end

	--     T.defaultProps = {
	--         inner = 'Hi',
	--     }

	--     local LazyText = lazy(function()
	--         return fakeImport(T)
	--     end)

	--     jestExpect(function()
	--         LazyText.defaultProps = {
	--             outer = 'Bye',
	--         }
	--     end).toErrorDev('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.', {withoutStack = true})

	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyText)), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Hi Bye')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Hi Bye',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Hi Bye')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyText, {
	--             outer = 'World',
	--         })))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Hi World',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Hi World')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyText, {
	--             inner = 'Friends',
	--         })))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Friends Bye',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Friends Bye')
	--     end)
	-- end))
	it("throws with a useful error when wrapping invalid type with lazy()", function()
		local BadLazy = lazy(function()
			return fakeImport(42)
		end)
		local root = ReactTestRenderer.create(
			React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, React.createElement(BadLazy)),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})

		Promise.delay(0):await()

		root.update(React.createElement(Suspense, {
			fallback = React.createElement(Text, {
				text = "Loading...",
			}),
		}, React.createElement(BadLazy)))
		jestExpect(Scheduler).toFlushAndThrow(
			"Element type is invalid. Received a promise that resolves to: 42. "
				.. "Lazy element type must resolve to a class or function."
		)
	end)
	it("throws with a useful error when wrapping lazy() multiple times", function()
		local Lazy1 = lazy(function()
			return fakeImport(Text)
		end)
		local Lazy2 = lazy(function()
			return fakeImport(Lazy1)
		end)
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(Lazy2, {
					text = "Hello",
				})
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput("Hello")

		-- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
		Promise.delay(0):await()

		root.update(React.createElement(
			Suspense,
			{
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			},
			React.createElement(Lazy2, {
				text = "Hello",
			})
		))

		local moreThanOnce = _G.__DEV__
				and " Did you wrap a component in React.lazy() more than once?"
			or ""

		-- ROBLOX FIXME: Using substring of error, not RegExp because currently missing from LuauPolyfill.
		-- Still tests optional dev error and substring of main error, but missing the first sentence below
		-- 'Element type is invalid. Received a promise that resolves to: table: '
		jestExpect(Scheduler).toFlushAndThrow(
			"Lazy element type must resolve to a class or function." .. moreThanOnce
		)
	end)
	it("warns about defining propTypes on the outer wrapper", function()
		local LazyText = lazy(function()
			return fakeImport(Text)
		end)

		jestExpect(function()
			LazyText.propTypes = {
				hello = function() end,
			}
		end).toErrorDev(
			"React.lazy(...): It is not supported to assign `propTypes` to "
				.. "a lazy component import. Either specify them where the component "
				.. "is defined, or create a wrapping component around it.",
			{ withoutStack = true }
		)
	end)
	-- it('respects propTypes on function component with defaultProps', _async(function()
	--     local function Add(props)
	--         jestExpect(props.innerWithDefault).toBe(42)

	--         return props.inner + props.outer
	--     end

	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--         innerWithDefault = PropTypes.number.isRequired,
	--     }
	--     Add.defaultProps = {innerWithDefault = 42}

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on function component without defaultProps', _async(function()
	--     local function Add(props)
	--         return props.inner + props.outer
	--     end

	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--     }

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on class component with defaultProps', _async(function()
	--     local Add = {}
	--     local AddMetatable = {__index = Add}

	--     function Add:render()
	--         jestExpect(self.props.innerWithDefault).toBe(42)

	--         return self.props.inner + self.props.outer
	--     end

	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--         innerWithDefault = PropTypes.number.isRequired,
	--     }
	--     Add.defaultProps = {innerWithDefault = 42}

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on class component without defaultProps', _async(function()
	--     local Add = {}
	--     local AddMetatable = {__index = Add}

	--     function Add:render()
	--         return self.props.inner + self.props.outer
	--     end

	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--     }

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on forwardRef component with defaultProps', _async(function()
	--     local Add = React.forwardRef(function(props, ref)
	--         jestExpect(props.innerWithDefault).toBe(42)

	--         return props.inner + props.outer
	--     end)

	--     Add.displayName = 'Add'
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--         innerWithDefault = PropTypes.number.isRequired,
	--     }
	--     Add.defaultProps = {innerWithDefault = 42}

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on forwardRef component without defaultProps', _async(function()
	--     local Add = React.forwardRef(function(props, ref)
	--         return props.inner + props.outer
	--     end)

	--     Add.displayName = 'Add'
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--     }

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on outer memo component with defaultProps', _async(function()
	--     local Add = function(props)
	--         jestExpect(props.innerWithDefault).toBe(42)

	--         return props.inner + props.outer
	--     end

	--     Add = React.memo(Add)
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--         innerWithDefault = PropTypes.number.isRequired,
	--     }
	--     Add.defaultProps = {innerWithDefault = 42}

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on outer memo component without defaultProps', _async(function()
	--     local Add = function(props)
	--         return props.inner + props.outer
	--     end

	--     Add = React.memo(Add)
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--     }

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(Add))
	-- end))
	-- it('respects propTypes on inner memo component with defaultProps', _async(function()
	--     local Add = function(props)
	--         jestExpect(props.innerWithDefault).toBe(42)

	--         return props.inner + props.outer
	--     end

	--     Add.displayName = 'Add'
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--         innerWithDefault = PropTypes.number.isRequired,
	--     }
	--     Add.defaultProps = {innerWithDefault = 42}

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(React.memo(Add)))
	-- end))
	-- it('respects propTypes on inner memo component without defaultProps', _async(function()
	--     local Add = function(props)
	--         return props.inner + props.outer
	--     end

	--     Add.displayName = 'Add'
	--     Add.propTypes = {
	--         inner = PropTypes.number.isRequired,
	--     }

	--     return _awaitIgnored(verifyInnerPropTypesAreChecked(React.memo(Add)))
	-- end))
	-- it('uses outer resolved props for validating propTypes on memo', _async(function()
	--     local T = function(props)
	--         return React.createElement(Text, {
	--             text = props.text,
	--         })
	--     end

	--     T.defaultProps = {
	--         text = 'Inner default text',
	--     }
	--     T = React.memo(T)
	--     T.propTypes = {
	--         text = PropTypes.string.isRequired,
	--     }

	--     local LazyText = lazy(function()
	--         return fakeImport(T)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyText)), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('Inner default text')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(function()
	--             jestExpect(Scheduler).toFlushAndYield({
	--                 'Inner default text',
	--             })
	--         end).toErrorDev('The prop `text` is marked as required in `T`, but its value is `undefined`')
	--         jestExpect(root).toMatchRenderedOutput('Inner default text')
	--         jestExpect(function()
	--             root.update(React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(LazyText, {text = nil})))
	--             jestExpect(Scheduler).toFlushAndYield({nil})
	--         end).toErrorDev('The prop `text` is marked as required in `T`, but its value is `null`')
	--         jestExpect(root).toMatchRenderedOutput(nil)
	--     end)
	-- end))

	-- ROBLOX TODO: wrong component stack, not resolving past Suspense/Lazy wrappers
	xit("includes lazy-loaded component in warning stack", function()
		local LazyFoo = lazy(function()
			Scheduler.unstable_yieldValue("Started loading")

			local Foo = function(props)
				return React.createElement("div", nil, {
					React.createElement(Text, {
						text = "A",
					}),
					React.createElement(Text, {
						text = "B",
					}),
				})
			end

			return fakeImport(Foo)
		end)
		local root = ReactTestRenderer.create(
			React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, React.createElement(LazyFoo)),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Started loading",
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput(
			React.createElement("div", nil, "AB")
		)

		Promise.delay(0):await()

		jestExpect(function()
			jestExpect(Scheduler).toFlushAndYield({
				"A",
				"B",
			})
		end).toErrorDev("    in Text (at **)\n" .. "    in Foo (at **)")
		jestExpect(root).toMatchRenderedOutput(React.createElement("div", nil, "AB"))
	end)

	it("supports class and forwardRef components", function()
		local LazyClass = lazy(function()
			local Foo = React.Component:extend("Foo")

			function Foo:render()
				return React.createElement(Text, {
					text = "Foo",
				})
			end

			return fakeImport(Foo)
		end)

		local LazyForwardRef = lazy(function()
			local Bar = React.Component:extend("Bar")

			function Bar:render()
				return React.createElement(Text, {
					text = "Bar",
				})
			end

			return fakeImport(React.forwardRef(function(props, ref)
				Scheduler.unstable_yieldValue("forwardRef")

				return React.createElement(Bar, { ref = ref })
			end))
		end)

		local ref = React.createRef()
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(LazyClass),
				React.createElement(LazyForwardRef, { ref = ref })
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})
		jestExpect(root).never.toMatchRenderedOutput("FooBar")
		jestExpect(ref.current).toBe(nil)

		-- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
		Promise.delay(0):await()

		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"forwardRef",
			"Bar",
		})
		jestExpect(root).toMatchRenderedOutput("FooBar")
		jestExpect(ref.current).never.toBe(nil)
	end)
	-- it('supports defaultProps defined on the memo() return value', _async(function()
	--     local Add = React.memo(function(props)
	--         return props.inner + props.outer
	--     end)

	--     Add.defaultProps = {inner = 2}

	--     local LazyAdd = lazy(function()
	--         return fakeImport(Add)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyAdd, {outer = 2})), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('4')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('4')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {outer = 2})))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('4')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {outer = 3})))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('5')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {outer = 3})))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('5')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {
	--             outer = 1,
	--             inner = 1,
	--         })))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('2')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {
	--             outer = 1,
	--             inner = 1,
	--         })))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('2')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {outer = 1})))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('3')
	--     end)
	-- end))
	-- it('merges defaultProps in the correct order', _async(function()
	--     local Add = React.memo(function(props)
	--         return props.inner + props.outer
	--     end)

	--     Add.defaultProps = {inner = 100}
	--     Add = React.memo(Add)
	--     Add.defaultProps = {
	--         inner = 2,
	--         outer = 0,
	--     }

	--     local LazyAdd = lazy(function()
	--         return fakeImport(Add)
	--     end)
	--     local root = ReactTestRenderer.create(React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(LazyAdd, {outer = 2})), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Loading...',
	--     })
	--     jestExpect(root).not.toMatchRenderedOutput('4')

	--     return _await(Promise.resolve(), function()
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('4')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd, {outer = 3})))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('5')
	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(LazyAdd)))
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jestExpect(root).toMatchRenderedOutput('2')
	--     end)
	-- end))
	it("warns about ref on functions for lazy-loaded components", function()
		local LazyFoo = lazy(function()
			local Foo = function(props)
				return React.createElement("div")
			end
			return fakeImport(Foo)
		end)
		local ref = React.createRef()

		ReactTestRenderer.create(
			React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, React.createElement(LazyFoo, { ref = ref })),
			{ unstable_isConcurrent = true }
		)
		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})

		-- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
		Promise.delay(0):await()

		jestExpect(function()
			jestExpect(Scheduler).toFlushAndYield({})
		end).toErrorDev("Function components cannot be given refs")
	end)
	-- ROBLOX TODO: normalizeCodeLocInfo needs regex
	xit("should error with a component stack naming the resolved component", function()
		local componentStackMessage
		local LazyText = lazy(function()
			return fakeImport(function()
				error(Error("oh no"))
			end)
		end)
		local ErrorBoundary = React.Component:extend("ErrorBoundary")

		function ErrorBoundary:init()
			self.state = { error = nil }
		end
		function ErrorBoundary:componentDidCatch(error_, errMessage)
			componentStackMessage = normalizeCodeLocInfo(errMessage.componentStack)

			self:setState({ error = error_ })
		end
		function ErrorBoundary:render()
			if self.state.error then
				return nil
			else
				return self.props.children
			end
		end

		ReactTestRenderer.create(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					},
					React.createElement(LazyText, {
						text = "Hi",
					})
				)
			),
			{ unstable_isConcurrent = true }
		)
		jestExpect(Scheduler).toFlushAndYield({
			"Loading...",
		})

		_ = pcall(function()
			Promise.delay(0):await()
		end)

		jestExpect(Scheduler).toFlushAndYield({})
		jestExpect(componentStackMessage).toContain("in ResolvedText")
	end)
	-- ROBLOX FIXME: missing stack frame that contains Lazy
	xit("should error with a component stack containing Lazy if unresolved", function()
		local componentStackMessage
		local LazyText = lazy(function()
			return {
				andThen = function(resolve, reject)
					reject(Error("oh no"))
				end,
			}
		end)
		local ErrorBoundary = React.Component:extend("ErrorBoundary")

		function ErrorBoundary:init()
			self.state = {
				error_ = nil,
			}
		end
		function ErrorBoundary:componentDidCatch(error_, errMessage)
			-- ROBLOX FIXME: componentStack is missing LazyText even before normalize
			componentStackMessage = normalizeCodeLocInfo(errMessage.componentStack)

			self:setState({ error_ = error_ })
		end
		function ErrorBoundary:render()
			return (function()
				if self.state.error_ then
					return nil
				end

				return self.props.children
			end)()
		end

		ReactTestRenderer.create(
			React.createElement(
				ErrorBoundary,
				nil,
				React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					},
					React.createElement(LazyText, {
						text = "Hi",
					})
				)
			)
		)
		jestExpect(Scheduler).toHaveYielded({})
		-- ROBLOX TODO: only this final assert fails
		jestExpect(componentStackMessage).toContain("in Lazy")
	end)

	-- @gate enableLazyElements
	-- xit('mount and reorder lazy elements', function()
	--     local Child = React.Component:extend("Child")

	--     function Child:componentDidMount()
	--         Scheduler.unstable_yieldValue('Did mount: ' .. self.props.label)
	--     end
	--     function Child:componentDidUpdate()
	--         Scheduler.unstable_yieldValue('Did update: ' .. self.props.label)
	--     end
	--     function Child:render()
	--         return React.createElement(Text, {
	--             text = self.props.label,
	--         })
	--     end

	--     local lazyChildA = lazy(function()
	--         Scheduler.unstable_yieldValue('Init A')

	--         return fakeImport(React.createElement(Child, {
	--             key = 'A',
	--             label = 'A',
	--         }))
	--     end)
	--     local lazyChildB = lazy(function()
	--         Scheduler.unstable_yieldValue('Init B')

	--         return fakeImport(React.createElement(Child, {
	--             key = 'B',
	--             label = 'B',
	--         }))
	--     end)
	--     local lazyChildA2 = lazy(function()
	--         Scheduler.unstable_yieldValue('Init A2')

	--         return fakeImport(React.createElement(Child, {
	--             key = 'A',
	--             label = 'a',
	--         }))
	--     end)

	--     local lazyChildB2 = lazy(function()
	--         Scheduler.unstable_yieldValue('Init B2')

	--         return fakeImport(React.createElement(Child, {
	--             key = 'B',
	--             label = 'b',
	--         }))
	--     end)

	--     local function Parent(props)
	--         local swap = props.swap

	--         return React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             })},
	--             (function()
	--             if swap then
	--                 return{lazyChildB2, lazyChildA2}
	--             end

	--             return{lazyChildA, lazyChildB}
	--         end)())
	--     end

	--     local root = ReactTestRenderer.create(React.createElement(Parent, {swap = false}), {
	--         unstable_isConcurrent = true
	--     })

	--     -- ROBLOX FIXME: delay by one frame is current best translation of `await Promise.resolve()`
	--     Promise.delay(0):await()

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Init A',
	--         'Loading...',
	--     })
	--     jestExpect(root).never.toMatchRenderedOutput('AB')

	--     return _await(lazyChildA, function()
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Init B',
	--         })

	--         return _await(lazyChildB, function()
	--             jestExpect(Scheduler).toFlushAndYield({
	--                 'A',
	--                 'B',
	--                 'Did mount: A',
	--                 'Did mount: B',
	--             })
	--             jestExpect(root).toMatchRenderedOutput('AB')
	--             root.update(React.createElement(Parent, {swap = true}))
	--             jestExpect(Scheduler).toFlushAndYield({
	--                 'Init B2',
	--                 'Loading...',
	--             })

	--             return _await(lazyChildB2, function()
	--                 jestExpect(Scheduler).toFlushAndYield({
	--                     'Init A2',
	--                     'Loading...',
	--                 })

	--                 return _await(lazyChildA2, function()
	--                     jestExpect(Scheduler).toFlushAndYield({
	--                         'b',
	--                         'a',
	--                         'Did update: b',
	--                         'Did update: a',
	--                     })
	--                     jestExpect(root).toMatchRenderedOutput('ba')
	--                 end)
	--             end)
	--         end)
	--     end)
	-- end)
end) ]]
eC.Children._56535943568907e3ed1d11d16a780fb5=fq
local fr

local fs={ClassName="ModuleScript",Children={},Properties={}}
fs.Name="ReactNewContext.spec"
fs.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-reconciler/src/__tests__/ReactNewContext-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error

local React
local useContext
local ReactNoop
local Scheduler
-- local gen

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest
local it = JestGlobals.it
local describe = JestGlobals.describe

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()

	React = require(Packages.React)
	useContext = React.useContext
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
	-- gen = nil -- require('random-seed')
end)

local function span(prop)
	return { type = "span", prop = prop, children = {}, hidden = false }
end

local function Text(props)
	Scheduler.unstable_yieldValue(props.text)
	return React.createElement("span", {
		prop = props.text,
	})
end

local function readContext(Context, observedBits)
	local dispatcher =
		React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current
	return dispatcher.readContext(Context, observedBits)
end

-- Note: This is based on a similar component we use in www. We can delete
-- once the extra div wrapper is no longer necessary.
local function LegacyHiddenDiv(props)
	local children, mode = props.children, props.mode

	return React.createElement(
		"div",
		{
			hidden = mode == "hidden",
		},
		React.createElement(React.unstable_LegacyHidden, {
			mode = (function()
				if mode == "hidden" then
					return "unstable-defer-without-hiding"
				end

				return mode
			end)(),
		}, children)
	)
end

local function sharedContextTests(label, getConsumer)
	describe("reading context with " .. label, function()
		it("simple mount and update", function()
			local Context = React.createContext(1)
			local Consumer = getConsumer(Context)

			local Indirection = React.Fragment

			local function App(props)
				return React.createElement(
					Context.Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer, nil, function(value)
								return React.createElement(
									"span",
									{ prop = "Result: " .. tostring(value) }
								)
							end)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 3") })
		end)

		it("propagates through shouldComponentUpdate false", function()
			local Context = React.createContext(1)
			local ContextConsumer = getConsumer(Context)

			local function Provider(props)
				Scheduler.unstable_yieldValue("Provider")
				return React.createElement(
					Context.Provider,
					{ value = props.value },
					props.children
				)
			end

			local function Consumer(props)
				Scheduler.unstable_yieldValue("Consumer")
				return React.createElement(ContextConsumer, nil, function(value)
					Scheduler.unstable_yieldValue("Consumer render prop")
					return React.createElement(
						"span",
						{ prop = "Result: " .. tostring(value) }
					)
				end)
			end

			local Indirection = React.Component:extend("Indirection")

			function Indirection:shouldComponentUpdate()
				return false
			end
			function Indirection:render()
				Scheduler.unstable_yieldValue("Indirection")
				return self.props.children
			end

			local function App(props)
				Scheduler.unstable_yieldValue("App")
				return React.createElement(
					Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				"Indirection",
				"Indirection",
				"Consumer",
				"Consumer render prop",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				"Consumer render prop",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 3") })
		end)

		it("consumers bail out if context value is the same", function()
			local Context = React.createContext(1)
			local ContextConsumer = getConsumer(Context)

			local function Provider(props)
				Scheduler.unstable_yieldValue("Provider")
				return React.createElement(
					Context.Provider,
					{ value = props.value },
					props.children
				)
			end

			local function Consumer(props)
				Scheduler.unstable_yieldValue("Consumer")
				return React.createElement(ContextConsumer, nil, function(value)
					Scheduler.unstable_yieldValue("Consumer render prop")
					return React.createElement(
						"span",
						{ prop = "Result: " .. tostring(value) }
					)
				end)
			end

			local Indirection = React.Component:extend("Indirection")

			function Indirection:shouldComponentUpdate()
				return false
			end
			function Indirection:render()
				Scheduler.unstable_yieldValue("Indirection")
				return self.props.children
			end

			local function App(props)
				Scheduler.unstable_yieldValue("App")
				return React.createElement(
					Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				"Indirection",
				"Indirection",
				"Consumer",
				"Consumer render prop",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })

			-- Update with the same context value
			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				-- Don't call render prop again
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })
		end)

		it("nested providers", function()
			local Context = React.createContext(1)
			local Consumer = getConsumer(Context)

			local function Provider(props)
				return React.createElement(Consumer, nil, function(contextValue: number)
					-- Multiply previous context value by 2, unless prop overrides
					return React.createElement(
						Context.Provider,
						{ value = props.value or contextValue * 2 },
						props.children
					)
				end)
			end

			local Indirection = React.Component:extend("Indirection")

			function Indirection:shouldComponentUpdate()
				return false
			end
			function Indirection:render()
				return self.props.children
			end

			local function App(props)
				return React.createElement(
					Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Provider,
							nil,
							React.createElement(
								Indirection,
								nil,
								React.createElement(
									Provider,
									nil,
									React.createElement(
										Indirection,
										nil,
										React.createElement(Consumer, nil, function(value)
											return React.createElement("span", {
												prop = "Result: " .. tostring(value),
											})
										end)
									)
								)
							)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 8") })

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 12") })
		end)

		it(
			"should provide the correct (default) values to consumers outside of a provider",
			function()
				local FooContext = React.createContext({ value = "foo-initial" })
				local BarContext = React.createContext({ value = "bar-initial" })
				local FooConsumer = getConsumer(FooContext)
				local BarConsumer = getConsumer(BarContext)

				local function Verify(props)
					local actual, expected = props[1], props[2]
					jestExpect(expected).toBe(actual)
					return nil
				end

				ReactNoop.render(
					React.Fragment,
					nil,
					React.createElement(
						BarContext.Provider,
						{ value = { value = "bar-updated" } },
						React.createElement(BarConsumer, nil, function(value)
							return React.createElement(
								Verify,
								{ actual = value, expected = "bar-updated" }
							)
						end),
						React.createElement(
							FooContext.Provider,
							{ value = { value = "foo-updated" } },
							React.createElement(FooConsumer, nil, function(value)
								return React.createElement(
									Verify,
									{ actual = value, expected = "foo-updated" }
								)
							end)
						)
					),
					React.createElement(FooConsumer, nil, function(value)
						return React.createElement(
							Verify,
							{ actual = value, expected = "foo-initial" }
						)
					end),
					React.createElement(BarConsumer, nil, function(value)
						return React.createElement(
							Verify,
							{ actual = value, expected = "bar-initial" }
						)
					end)
				)
				jestExpect(Scheduler).toFlushWithoutYielding()
			end
		)

		it("multiple consumers in different branches", function()
			local Context = React.createContext(1)
			local Consumer = getConsumer(Context)

			local function Provider(props)
				return React.createElement(
					Context.Consumer,
					nil,
					function(contextValue: number)
						-- Multiply previous context value by 2, unless prop overrides
						return React.createElement(
							Context.Provider,
							{ value = props.value or contextValue * 2 },
							props.children
						)
					end
				)
			end

			local Indirection = React.Component:extend("Indirection")
			function Indirection:shouldComponentUpdate()
				return false
			end
			function Indirection:render()
				return self.props.children
			end

			local function App(props)
				return React.createElement(
					Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(
								Provider,
								nil,
								React.createElement(Consumer, nil, function(value)
									return React.createElement(
										"span",
										{ prop = "Result: " .. value }
									)
								end)
							)
						),
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer, nil, function(value)
								return React.createElement(
									"span",
									{ prop = "Result: " .. value }
								)
							end)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, { value = 2 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Result: 4"),
				span("Result: 2"),
			})

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Result: 6"),
				span("Result: 3"),
			})

			-- Another update
			ReactNoop.render(React.createElement(App, { value = 4 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Result: 8"),
				span("Result: 4"),
			})
		end)

		it("compares context values with Object.is semantics", function()
			local Context = React.createContext(1)
			local ContextConsumer = getConsumer(Context)

			local function Provider(props)
				Scheduler.unstable_yieldValue("Provider")
				return React.createElement(Context.Provider, {
					value = props.value,
				}, props.children)
			end

			local function Consumer(props)
				Scheduler.unstable_yieldValue("Consumer")
				return React.createElement(ContextConsumer, nil, function(value)
					Scheduler.unstable_yieldValue("Consumer render prop")
					return React.createElement("span", {
						prop = "Result: " .. value,
					})
				end)
			end

			local Indirection = React.Component:extend("Indirection")

			function Indirection:shouldComponentUpdate()
				return false
			end

			function Indirection:render()
				Scheduler.unstable_yieldValue("Indirection")
				return self.props.children
			end

			local function App(props)
				Scheduler.unstable_yieldValue("App")
				return React.createElement(
					Provider,
					{
						value = props.value,
					},
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer)
						)
					)
				)
			end

			ReactNoop.render(React.createElement(App, {
				-- deviation: string NaN in place of NaN
				value = "NaN",
			}))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				"Indirection",
				"Indirection",
				"Consumer",
				"Consumer render prop",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: NaN") })

			-- Update
			ReactNoop.render(React.createElement(App, {
				-- deviation: string NaN in place of NaN
				value = "NaN",
			}))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				-- Consumer should not re-render again
				-- 'Consumer render prop',
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: NaN") })
		end)

		it("context unwinds when interrupted", function()
			local Context = React.createContext("Default")
			local ContextConsumer = getConsumer(Context)

			local function Consumer(props)
				return React.createElement(ContextConsumer, nil, function(value)
					return React.createElement("span", {
						prop = "Result: " .. value,
					})
				end)
			end

			local function BadRender()
				error(Error.new("Bad render"))
			end

			local ErrorBoundary = React.Component:extend("ErrorBoundary")

			-- deviation: Lua nil values in table don't result in entry
			-- deviation: error is a Lua reserved word, converted to error_
			function ErrorBoundary:init()
				self.state = { error_ = "" }
			end

			function ErrorBoundary:componentDidCatch(error_)
				self.setState({
					-- deviation: error is a Lua reserved word, converted to error_
					error_ = error_,
				})
			end

			function ErrorBoundary:render()
				if self.state.error_ then
					return nil
				end

				return self.props.children
			end
			local function App(props)
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(
						Context.Provider,
						{
							value = "Does not unwind",
						},
						React.createElement(
							ErrorBoundary,
							nil,
							React.createElement(Context.Provider, {
								value = "Unwinds after BadRender throws",
							}, React.createElement(BadRender, nil))
						),
						React.createElement(Consumer, nil)
					)
				)
			end

			ReactNoop.render(React.createElement(App, {
				value = "A",
			}))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({
				-- The second provider should use the default value.
				span("Result: Does not unwind"),
			})
		end)

		-- ROBLOX note: deleted two tests relating to unstable_observedBits, which is removed in React 18

		it("does not re-render if there's an update in a child", function()
			local Context = React.createContext(0)
			local Consumer = getConsumer(Context)
			local child

			local Child = React.Component:extend("Child")
			function Child:init()
				self.state = {
					step = 0,
				}
			end

			function Child:render()
				Scheduler.unstable_yieldValue("Child")
				return React.createElement("span", {
					prop = "Context: "
						.. tostring(self.props.context)
						.. ", Step: "
						.. tostring(self.state.step),
				})
			end

			local function App(props)
				return React.createElement(
					Context.Provider,
					{
						value = props.value,
					},
					React.createElement(Consumer, nil, function(value)
						Scheduler.unstable_yieldValue("Consumer render prop")
						return React.createElement(Child, {
							ref = function(inst)
								child = inst
								return child
							end,
							context = value,
						})
					end)
				)
			end

			-- Initial mount
			ReactNoop.render(React.createElement(App, {
				value = 1,
			}))
			jestExpect(Scheduler).toFlushAndYield({ "Consumer render prop", "Child" })
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Context: 1, Step: 0"),
			})
			child:setState({
				step = 1,
			})
			jestExpect(Scheduler).toFlushAndYield({ "Child" })
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("Context: 1, Step: 1"),
			})
		end)

		it(
			"consumer bails out if value is unchanged and something above bailed out",
			function()
				local Context = React.createContext(0)
				local Consumer = getConsumer(Context)

				local function renderChildValue(value)
					Scheduler.unstable_yieldValue("Consumer")
					return React.createElement("span", {
						prop = value,
					})
				end

				local function ChildWithInlineRenderCallback()
					Scheduler.unstable_yieldValue("ChildWithInlineRenderCallback")
					-- Note: we are intentionally passing an inline arrow. Don't refactor.
					return React.createElement(Consumer, nil, function(value)
						return renderChildValue(value)
					end)
				end

				local function ChildWithCachedRenderCallback()
					Scheduler.unstable_yieldValue("ChildWithCachedRenderCallback")
					return React.createElement(Consumer, nil, renderChildValue)
				end

				local PureIndirection = React.PureComponent:extend("PureIndirection")
				function PureIndirection:render()
					Scheduler.unstable_yieldValue("PureIndirection")
					return React.createElement(
						React.Fragment,
						nil,
						React.createElement(ChildWithInlineRenderCallback),
						React.createElement(ChildWithCachedRenderCallback)
					)
				end

				local App = React.Component:extend("App")
				function App:render()
					Scheduler.unstable_yieldValue("App")
					return React.createElement(Context.Provider, {
						value = self.props.value,
					}, React.createElement(PureIndirection, nil))
				end

				-- Initial mount
				ReactNoop.render(React.createElement(App, {
					value = 1,
				}))
				jestExpect(Scheduler).toFlushAndYield({
					"App",
					"PureIndirection",
					"ChildWithInlineRenderCallback",
					"Consumer",
					"ChildWithCachedRenderCallback",
					"Consumer",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span(1), span(1) })

				-- Update (bailout)
				ReactNoop.render(React.createElement(App, {
					value = 1,
				}))
				jestExpect(Scheduler).toFlushAndYield({ "App" })
				jestExpect(ReactNoop.getChildren()).toEqual({ span(1), span(1) })

				-- Update (no bailout)
				ReactNoop.render(React.createElement(App, {
					value = 2,
				}))
				jestExpect(Scheduler).toFlushAndYield({
					"App",
					"Consumer",
					"Consumer",
				})
				jestExpect(ReactNoop.getChildren()).toEqual({ span(2), span(2) })
			end
		)

		-- @gate experimental || www
		it("context consumer doesn't bail out inside hidden subtree", function()
			local Context = React.createContext("dark")
			local Consumer = getConsumer(Context)

			local function App(ref)
				local theme = ref.theme
				return React.createElement(
					Context.Provider,
					{
						value = theme,
					},
					React.createElement(
						LegacyHiddenDiv,
						{
							mode = "hidden",
						},
						React.createElement(Consumer, nil, function(value)
							return React.createElement(Text, {
								text = value,
							})
						end)
					)
				)
			end

			ReactNoop.render(React.createElement(App, {
				theme = "dark",
			}))
			jestExpect(Scheduler).toFlushAndYield({ "dark" })
			-- ROBLOX deviation: noop children are in a different format
			jestExpect(ReactNoop.getChildren()[1].children[1]).toEqual(span("dark"))
			ReactNoop.render(React.createElement(App, {
				theme = "light",
			}))
			jestExpect(Scheduler).toFlushAndYield({ "light" })
			jestExpect(ReactNoop.getChildren()[1].children[1]).toEqual(span("light"))
		end)

		-- This is a regression case for https://github.com/facebook/react/issues/12389.
		it("does not run into an infinite loop", function()
			local Context = React.createContext(nil)
			local Consumer = getConsumer(Context)

			local App = React.Component:extend("App")
			function App:renderItem(id)
				return React.createElement(
					"span",
					{ key = id },
					React.createElement(Consumer, nil, function()
						return React.createElement("span", nil, "inner")
					end),
					React.createElement("span", nil, "outer")
				)
			end
			function App:renderList()
				local list = Array.map({ 1, 2 }, function(id)
					return self:renderItem(id)
				end)
				if self.props.reverse then
					Array.reverse(list)
				end
				return list
			end
			function App:render()
				return React.createElement(
					Context.Provider,
					{ value = {} },
					self:renderList()
				)
			end

			ReactNoop.render(React.createElement(App, { reverse = false }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			ReactNoop.render(React.createElement(App, { reverse = true }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			ReactNoop.render(React.createElement(App, { reverse = false }))
			jestExpect(Scheduler).toFlushWithoutYielding()
		end)

		-- This is a regression case for https://github.com/facebook/react/issues/12686
		it("does not skip some siblings", function()
			local StaticContent, Indirection
			local Context = React.createContext(0)
			local ContextConsumer = getConsumer(Context)

			local App = React.Component:extend("App")
			function App:init()
				self.state = { step = 0 }
			end

			function App:render()
				Scheduler.unstable_yieldValue("App")
				return React.createElement(
					Context.Provider,
					{ value = self.state.step },
					React.createElement(StaticContent),
					self.state.step > 0 and React.createElement(Indirection)
				)
			end

			StaticContent = React.PureComponent:extend("StaticContent")
			function StaticContent:render()
				return React.createElement(
					React.Fragment,
					nil,
					React.createElement(
						React.Fragment,
						nil,
						React.createElement("span", { prop = "static 1" }),
						React.createElement("span", { prop = "static 2" })
					)
				)
			end

			Indirection = React.PureComponent:extend("Indirection")
			function Indirection:render()
				return (
					React.createElement(ContextConsumer, nil, function(value)
						Scheduler.unstable_yieldValue("Consumer")
						return React.createElement("span", { prop = value })
					end)
				)
			end

			-- Initial mount
			local inst
			ReactNoop.render(React.createElement(App, {
				ref = function(ref)
					inst = ref
				end,
			}))
			jestExpect(Scheduler).toFlushAndYield({ "App" })
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("static 1"),
				span("static 2"),
			})
			-- Update the first time
			inst:setState({ step = 1 })
			jestExpect(Scheduler).toFlushAndYield({ "App", "Consumer" })
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("static 1"),
				span("static 2"),
				span(1),
			})
			-- Update the second time
			inst:setState({ step = 2 })
			jestExpect(Scheduler).toFlushAndYield({ "App", "Consumer" })
			jestExpect(ReactNoop.getChildren()).toEqual({
				span("static 1"),
				span("static 2"),
				span(2),
			})
		end)
	end)

	-- ROBLOX deviation: tests for our temporary compatibility with old Roact's ability to use props = {render = <func>}
	describe("Compatibility with old Roact's Context Consumer API", function()
		it("simple mount and update", function()
			local Context = React.createContext(1)
			local Consumer = Context.Consumer

			local Indirection = React.Fragment

			local function App(props)
				return React.createElement(
					Context.Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer, {
								render = function(value)
									return React.createElement(
										"span",
										{ prop = "Result: " .. tostring(value) }
									)
								end,
							})
						)
					)
				)
			end

			jestExpect(function()
				ReactNoop.render(React.createElement(App, { value = 2 }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end).toWarnDev({
				"Your Context.Consumer component is using legacy Roact syntax",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushWithoutYielding()
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 3") })
		end)

		it("propagates through shouldComponentUpdate false", function()
			local Context = React.createContext(1)
			local ContextConsumer = Context.Consumer

			local function Provider(props)
				Scheduler.unstable_yieldValue("Provider")
				return React.createElement(
					Context.Provider,
					{ value = props.value },
					props.children
				)
			end

			local function Consumer(props)
				Scheduler.unstable_yieldValue("Consumer")
				return React.createElement(ContextConsumer, {
					render = function(value)
						Scheduler.unstable_yieldValue("Consumer render prop")
						return React.createElement(
							"span",
							{ prop = "Result: " .. tostring(value) }
						)
					end,
				})
			end

			local Indirection = React.Component:extend("Indirection")

			function Indirection:shouldComponentUpdate()
				return false
			end
			function Indirection:render()
				Scheduler.unstable_yieldValue("Indirection")
				return self.props.children
			end

			local function App(props)
				Scheduler.unstable_yieldValue("App")
				return React.createElement(
					Provider,
					{ value = props.value },
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(Consumer)
						)
					)
				)
			end

			jestExpect(function()
				ReactNoop.render(React.createElement(App, { value = 2 }))
				jestExpect(Scheduler).toFlushAndYield({
					"App",
					"Provider",
					"Indirection",
					"Indirection",
					"Consumer",
					"Consumer render prop",
				})
			end).toWarnDev({
				"Your Context.Consumer component is using legacy Roact syntax",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 2") })

			-- Update
			ReactNoop.render(React.createElement(App, { value = 3 }))
			jestExpect(Scheduler).toFlushAndYield({
				"App",
				"Provider",
				"Consumer render prop",
			})
			jestExpect(ReactNoop.getChildren()).toEqual({ span("Result: 3") })
		end)
	end)
end

-- We have several ways of reading from context. sharedContextTests runs
-- a suite of tests for a given context consumer implementation.
sharedContextTests("Context.Consumer", function(Context)
	return Context.Consumer
end)
sharedContextTests("useContext inside function component", function(Context)
	return function(props)
		local contextValue = useContext(Context)
		local render = props.children
		return render(contextValue)
	end
end)
sharedContextTests("useContext inside forwardRef component", function(Context)
	return React.forwardRef(function(props, ref)
		local contextValue = useContext(Context)
		local render = props.children
		return render(contextValue)
	end)
end)

sharedContextTests("useContext inside memoized function component", function(Context)
	return React.memo(function(props)
		local contextValue = useContext(Context)
		local render = props.children
		return render(contextValue)
	end)
end)
sharedContextTests("readContext(Context) inside class component", function(Context)
	local Consumer = React.Component:extend("Consumer")

	function Consumer:render()
		local contextValue = readContext(Context)
		local render = self.props.children
		return render(contextValue)
	end
	return Consumer
end)
sharedContextTests("readContext(Context) inside pure class component", function(Context)
	local Consumer = React.PureComponent:extend("Consumer")

	function Consumer:render()
		local contextValue = readContext(Context)
		local render = self.props.children
		return render(contextValue)
	end
	return Consumer
end)

describe("Context.Provider", function()
	it("warns if no value prop provided", function()
		local Context = React.createContext()

		ReactNoop.render(
			React.createElement(
				Context.Provider,
				{ anyPropNameOtherThanValue = "value could be anything" }
			)
		)

		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toErrorDev(
			"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?",
			{
				withoutStack = true,
			}
		)
	end)

	it("warns if multiple renderers concurrently render the same context", function()
		local Context = React.createContext(0)

		local function Foo(props)
			Scheduler.unstable_yieldValue("Foo")
			return nil
		end

		local function App(props)
			return (
				React.createElement(Context.Provider, { value = props.value }, {
					-- ROBLOX deviation: add key prop so we get the correct warning
					React.createElement(Foo, { key = 1 }),
					React.createElement(Foo, { key = 2 }),
				})
			)
		end

		ReactNoop.render(React.createElement(App, { value = 1 }))
		-- Render past the Provider, but don't commit yet
		jestExpect(Scheduler).toFlushAndYieldThrough({ "Foo" })

		-- Get a new copy of ReactNoop
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)

		-- Render the provider again using a different renderer
		ReactNoop.render(React.createElement(App, { value = 1 }))

		-- ROBLOX deviation: use toErrorDev
		jestExpect(function()
			jestExpect(Scheduler).toFlushAndYield({ "Foo", "Foo" })
		end).toErrorDev(
			"Detected multiple renderers concurrently rendering the same "
				.. "context provider. This is currently unsupported"
		)
	end)

	it("provider bails out if children and value are unchanged (like sCU)", function()
		local Context = React.createContext(0)

		local function Child()
			Scheduler.unstable_yieldValue("Child")
			return React.createElement("span", { prop = "Child" })
		end

		local children = React.createElement(Child)

		local function App(props)
			Scheduler.unstable_yieldValue("App")
			return React.createElement(
				Context.Provider,
				{ value = props.value },
				children
			)
		end

		-- Initial mount
		ReactNoop.render(React.createElement(App, { value = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "App", "Child" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })

		-- Update
		ReactNoop.render(React.createElement(App, { value = 1 }))
		jestExpect(Scheduler).toFlushAndYield({
			"App",
			-- Child does not re-render
		})
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })
	end)

	it("provider does not bail out if legacy context changed above", function()
		local Context = React.createContext(0)

		local function Child()
			Scheduler.unstable_yieldValue("Child")
			return React.createElement("span", { prop = "Child" })
		end

		local children = React.createElement(Child)

		local LegacyProvider = React.Component:extend("LegacyProvider")
		LegacyProvider.childContextTypes = {
			legacyValue = function()
				return nil
			end,
		}
		function LegacyProvider:init()
			self.state = { legacyValue = 1 }
		end
		function LegacyProvider:getChildContext()
			return { legacyValue = self.state.legacyValue }
		end
		function LegacyProvider:render()
			Scheduler.unstable_yieldValue("LegacyProvider")
			return self.props.children
		end

		local App = React.Component:extend("App")
		function App:init()
			self.state = { value = 1 }
		end
		function App:render()
			Scheduler.unstable_yieldValue("App")
			return React.createElement(
				Context.Provider,
				{ value = self.state.value },
				self.props.children
			)
		end

		local legacyProviderRef = React.createRef()
		local appRef = React.createRef()

		-- Initial mount
		ReactNoop.render(
			React.createElement(
				LegacyProvider,
				{ ref = legacyProviderRef },
				React.createElement(App, { ref = appRef, value = 1 }, children)
			)
		)
		jestExpect(function()
			jestExpect(Scheduler).toFlushAndYield({ "LegacyProvider", "App", "Child" })
		end).toErrorDev(
			"Legacy context API has been detected within a strict-mode tree.\n\n"
				.. "The old API will be supported in all 16.x releases, but applications "
				.. "using it should migrate to the new version.\n\n"
				.. "Please update the following components: LegacyProvider"
		)
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })

		-- Update App with same value (should bail out)
		appRef.current:setState({ value = 1 })
		jestExpect(Scheduler).toFlushAndYield({ "App" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })

		-- Update LegacyProvider (should not bail out)
		legacyProviderRef.current:setState({ value = 1 })
		jestExpect(Scheduler).toFlushAndYield({ "LegacyProvider", "App", "Child" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })

		-- Update App with same value (should bail out)
		appRef.current:setState({ value = 1 })
		jestExpect(Scheduler).toFlushAndYield({ "App" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Child") })
	end)
end)

describe("Context.Consumer", function()
	it("warns if child is not a function", function()
		-- spyOnDev(console, 'error')
		local Context = React.createContext(0)
		ReactNoop.render(React.createElement(Context.Consumer))
		-- ROBLOX deviation: This line is relying on a default JS error
		-- message containing "is not a function"; for us, the relevant
		-- error message is "attempt to call a nil value"
		jestExpect(Scheduler).toFlushAndThrow("attempt to call a nil value")
		-- ROBLOX Test Noise: Warning is logged (verified in debugger), but
		-- toErrorDev doesn't match; use `spyOnDev` when available
		-- if _G.__DEV__ then
		-- 	jestExpect(console.error.calls.argsFor(0)({ 0 })).toContain(
		-- 		"A context consumer was rendered with multiple children, or a child " .. "that isn't a function"
		-- 	)
		-- end
	end)

	it("can read other contexts inside consumer render prop", function()
		local FooContext = React.createContext(0)
		local BarContext = React.createContext(0)

		local function FooAndBar()
			return React.createElement(FooContext.Consumer, nil, function(foo)
				local bar = readContext(BarContext)
				return React.createElement(
					Text,
					{ text = "Foo: " .. tostring(foo) .. ", Bar: " .. tostring(bar) }
				)
			end)
		end

		local Indirection = React.Component:extend("Indirection")
		function Indirection:shouldComponentUpdate()
			return false
		end
		function Indirection:render()
			return self.props.children
		end

		local function App(props)
			return React.createElement(
				FooContext.Provider,
				{ value = props.foo },
				React.createElement(
					BarContext.Provider,
					{ value = props.bar },
					React.createElement(Indirection, nil, React.createElement(FooAndBar))
				)
			)
		end

		ReactNoop.render(React.createElement(App, { foo = 1, bar = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 1, Bar: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Foo: 1, Bar: 1") })

		-- Update foo
		ReactNoop.render(React.createElement(App, { foo = 2, bar = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 2, Bar: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Foo: 2, Bar: 1") })

		-- Update bar
		ReactNoop.render(React.createElement(App, { foo = 2, bar = 2 }))
		-- ROBLOX FIXME: Fails here; update doesn't trigger the inner consumer
		-- that's using `readContext`
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 2, Bar: 2" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("Foo: 2, Bar: 2") })
	end)

	-- Context consumer bails out on propagating "deep" updates when `value` hasn't changed.
	-- However, it doesn't bail out from rendering if the component above it re-rendered anyway.
	-- If we bailed out on referential equality, it would be confusing that you
	-- can call this.setState(), but an autobound render callback "blocked" the update.
	-- https://github.com/facebook/react/pull/12470#issuecomment-376917711
	it("consumer does not bail out if there were no bailouts above it", function()
		local Context = React.createContext(0)
		local Consumer = Context.Consumer

		local App = React.Component:extend("App")
		function App:init()
			self.state = {
				text = "hello",
			}
		end

		function App:renderConsumer(context)
			Scheduler.unstable_yieldValue("App#renderConsumer")
			return React.createElement("span", { prop = self.state.text })
		end

		function App:render()
			Scheduler.unstable_yieldValue("App")
			return React.createElement(
				Context.Provider,
				{ value = self.props.value },
				React.createElement(Consumer, nil, function(context)
					return self:renderConsumer(context)
				end)
			)
		end

		-- Initial mount
		local inst
		ReactNoop.render(React.createElement(App, {
			value = 1,
			ref = function(ref)
				inst = ref
			end,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("hello") })

		-- Update
		inst:setState({ text = "goodbye" })
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("goodbye") })
	end)

	-- ROBLOX deviation: tests legacy Roact compatibility feature
	it("warns once if using legacy Roact render prop", function()
		local Context = React.createContext()

		local function renderContext()
			ReactNoop.render(
				React.createElement(
					Context.Provider,
					{ value = 1 },
					React.createElement(Context.Consumer, {
						render = function(value)
							return React.createElement(
								"span",
								{ prop = "Result: " .. tostring(value) }
							)
						end,
					})
				)
			)
		end

		renderContext()
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toWarnDev(
			"Warning: Your Context.Consumer component is using legacy Roact syntax, which won't be supported in future versions of Roact. \n"
				.. "Please provide no props and supply the 'render' function as a child (the 3rd argument of createElement). For example: \n"
				.. "       createElement(ContextConsumer, {render = function(...) end})\n"
				.. "becomes:\n"
				.. "       createElement(ContextConsumer, nil, function(...) end)\n"
				.. "For more info, reference the React documentation here: \n"
				.. "https://reactjs.org/docs/context.html#contextconsumer",
			{ withoutStack = true }
		)
		ReactNoop.render(
			React.createElement(
				Context.Provider,
				{ value = 1 },
				React.createElement(Context.Consumer, {
					render = function(value)
						return React.createElement(
							"span",
							{ prop = "Result: " .. tostring(value) }
						)
					end,
				})
			)
		)

		-- Does not warn a second time
		renderContext()
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toWarnDev({})
	end)
end)

describe("readContext", function()
	-- Unstable changedBits API was removed. Port this test to context selectors
	-- once that exists.
	-- @gate FIXME
	it.skip("can read the same context multiple times in the same function", function()
		local Context = React.createContext({ foo = 0, bar = 0, baz = 0 }, function(a, b)
			local result = 0
			if a.foo ~= b.foo then
				result = bit32.bor(result, 0b001)
			end
			if a.bar ~= b.bar then
				result = bit32.bor(result, 0b010)
			end
			if a.baz ~= b.baz then
				result = bit32.bor(result, 0b100)
			end
			return result
		end)

		local function Provider(props)
			return React.createElement(
				Context.Provider,
				{ value = { foo = props.foo, bar = props.bar, baz = props.baz } },
				props.children
			)
		end

		local function FooAndBar()
			local values = readContext(Context, 0b001)
			local foo = values.foo
			values = readContext(Context, 0b010)
			local bar = values.bar
			return React.createElement(
				Text,
				{ text = "Foo: " .. tostring(foo) .. ", Bar: " .. tostring(bar) }
			)
		end

		local function Baz()
			local values = readContext(Context, 0b001)
			local baz = values.baz
			return React.createElement(Text, { text = "Baz: " .. tostring(baz) })
		end

		local Indirection = React.Component:extend("Indirection")
		function Indirection:shouldComponentUpdate()
			return false
		end
		function Indirection:render()
			return self.props.children
		end

		local function App(props)
			return React.createElement(
				Provider,
				{ foo = props.foo, bar = props.bar, baz = props.baz },
				React.createElement(
					Indirection,
					nil,
					React.createElement(Indirection, nil, React.createElement(FooAndBar)),
					React.createElement(Indirection, nil, React.createElement(Baz))
				)
			)
		end

		ReactNoop.render(React.createElement(App, { foo = 1, bar = 1, baz = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 1, Bar: 1", "Baz: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Foo: 1, Bar: 1"),
			span("Baz: 1"),
		})

		-- Update only foo
		ReactNoop.render(React.createElement(App, { foo = 2, bar = 1, baz = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 2, Bar: 1" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Foo: 2, Bar: 1"),
			span("Baz: 1"),
		})

		-- Update only bar
		ReactNoop.render(React.createElement(App, { foo = 2, bar = 2, baz = 1 }))
		jestExpect(Scheduler).toFlushAndYield({ "Foo: 2, Bar: 2" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Foo: 2, Bar: 2"),
			span("Baz: 1"),
		})

		-- Update only baz
		ReactNoop.render(React.createElement(App, { foo = 2, bar = 2, baz = 2 }))
		jestExpect(Scheduler).toFlushAndYield({ "Baz: 2" })
		jestExpect(ReactNoop.getChildren()).toEqual({
			span("Foo: 2, Bar: 2"),
			span("Baz: 2"),
		})
	end)

	-- Context consumer bails out on propagating "deep" updates when `value` hasn't changed.
	-- However, it doesn't bail out from rendering if the component above it re-rendered anyway.
	-- If we bailed out on referential equality, it would be confusing that you
	-- can call this.setState(), but an autobound render callback "blocked" the update.
	-- https://github.com/facebook/react/pull/12470#issuecomment-376917711
	it("does not bail out if there were no bailouts above it", function()
		local Context = React.createContext(0)
		local Consumer = React.Component:extend("Consumer")
		function Consumer:render()
			local contextValue = readContext(Context)
			return self.props.children(contextValue)
		end

		local App = React.Component:extend("App")

		function App:init()
			self.state = {
				text = "hello",
			}
		end

		function App:renderConsumer(context)
			Scheduler.unstable_yieldValue("App#renderConsumer")
			return React.createElement("span", { prop = self.state.text })
		end

		function App:render()
			Scheduler.unstable_yieldValue("App")
			return React.createElement(
				Context.Provider,
				{ value = self.props.value },
				React.createElement(Consumer, nil, function(context)
					return self:renderConsumer(context)
				end)
			)
		end

		-- Initial mount
		local inst
		ReactNoop.render(React.createElement(App, {
			value = 1,
			ref = function(ref)
				inst = ref
			end,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("hello") })

		-- Update
		inst:setState({ text = "goodbye" })
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("goodbye") })
	end)

	it("warns when reading context inside render phase class setState updater", function()
		local ThemeContext = React.createContext("light")

		local Cls = React.Component:extend("Cls")
		function Cls:init()
			self.state = {}
		end

		function Cls:render()
			self:setState(function()
				readContext(ThemeContext)
			end)
			return nil
		end

		ReactNoop.render(React.createElement(Cls))
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toErrorDev({
			"Context can only be read while React is rendering",
			-- A second warning comes from to setStates being added to the queue.
			"Context can only be read while React is rendering",
			"Cannot update during an existing state transition",
		})
	end)
end)

describe("useContext", function()
	it("throws when used in a class component", function()
		local Context = React.createContext(0)
		local Foo = React.Component:extend("Foo")
		function Foo:render()
			return useContext(Context)
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(Scheduler).toFlushAndThrow(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen"
				.. " for one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
	end)

	it("warns when passed a consumer", function()
		local Context = React.createContext(0)
		local function Foo()
			return useContext(Context.Consumer)
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toErrorDev(
			"Calling useContext(Context.Consumer) is not supported, may cause bugs, "
				.. "and will be removed in a future major release. "
				.. "Did you mean to call useContext(Context) instead?"
		)
	end)

	it("warns when passed a provider", function()
		local Context = React.createContext(0)
		local function Foo()
			useContext(Context.Provider)
			return nil
		end

		ReactNoop.render(React.createElement(Foo))
		jestExpect(function()
			jestExpect(Scheduler).toFlushWithoutYielding()
		end).toErrorDev(
			"Calling useContext(Context.Provider) is not supported. "
				.. "Did you mean to call useContext(Context) instead?"
		)
	end)

	-- Context consumer bails out on propagating "deep" updates when `value` hasn't changed.
	-- However, it doesn't bail out from rendering if the component above it re-rendered anyway.
	-- If we bailed out on referential equality, it would be confusing that you
	-- can call this.setState(), but an autobound render callback "blocked" the update.
	-- https://github.com/facebook/react/pull/12470#issuecomment-376917711
	it("does not bail out if there were no bailouts above it", function()
		local Context = React.createContext(0)

		local function Consumer(props)
			local children = props.children
			local contextValue = useContext(Context)
			return children(contextValue)
		end

		local App = React.Component:extend("App")

		function App:init()
			self.state = {
				text = "hello",
			}
		end

		function App:renderConsumer(context)
			Scheduler.unstable_yieldValue("App#renderConsumer")
			return React.createElement("span", { prop = self.state.text })
		end

		function App:render()
			Scheduler.unstable_yieldValue("App")
			return React.createElement(
				Context.Provider,
				{ value = self.props.value },
				React.createElement(Consumer, nil, function(context)
					return self:renderConsumer(context)
				end)
			)
		end

		-- Initial mount
		local inst
		ReactNoop.render(React.createElement(App, {
			value = 1,
			ref = function(ref)
				inst = ref
			end,
		}))
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("hello") })

		-- Update
		inst:setState({ text = "goodbye" })
		jestExpect(Scheduler).toFlushAndYield({ "App", "App#renderConsumer" })
		jestExpect(ReactNoop.getChildren()).toEqual({ span("goodbye") })
	end)

	-- ROBLOX TODO: figure out how to render an invalid element to make this test pass
	-- it('unwinds after errors in complete phase', () => {
end)

-- ROBLOX TODO: add this test fixture
-- describe('fuzz test', () => {

it("should warn with an error message when using context as a consumer in DEV", function()
	local BarContext = React.createContext({ value = "bar-initial" })
	local BarConsumer = BarContext

	local function Component()
		return React.createElement(
			React.Fragment,
			nil,
			React.createElement(
				BarContext.Provider,
				{ value = "bar-updated" },
				React.createElement(BarConsumer, nil, function(value)
					return React.createElement(
						"div",
						{ actual = value, expected = "bar-updated" }
					)
				end)
			)
		)
	end

	jestExpect(function()
		ReactNoop.render(React.createElement(Component))
		jestExpect(Scheduler).toFlushWithoutYielding()
	end).toErrorDev(
		"Warning: " -- ROBLOX FIXME: remove the Warning: prefix in consoleWithStackDev
			.. "Rendering <Context> directly is not supported and will be removed in "
			.. "a future major release. Did you mean to render <Context.Consumer> instead?"
	)
end)

-- ROBLOX deviation: we don't implement this property at all
-- it('should warn with an error message when using nested context consumers in DEV', () => { ]]
eC.Children._5084bb65489633676b817e3c40c03d0c=fs
local ft

local fu={ClassName="ModuleScript",Children={},Properties={}}
fu.Name="ReactNoopRendererAct.spec"
fu.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d17086c7c813402a550d15a2f56dc43f1dbd1735/packages/react-reconciler/src/__tests__/ReactNoopRendererAct-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @jest-environment node
 \]\]

-- sanity tests for ReactNoop.act()

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler

local JestGlobals = require(Packages.Dev.JestGlobals)
local Promise = require(Packages.Promise)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest

beforeEach(function()
	jest.resetModules()

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
end)

it("can use act to flush effects", function()
	local function App(props)
		React.useEffect(props.callback)
		return nil
	end

	local calledLog = {}
	ReactNoop.act(function()
		ReactNoop.render(React.createElement(App, {
			callback = function()
				table.insert(calledLog, #calledLog)
			end,
		}))
	end)
	jestExpect(Scheduler).toFlushWithoutYielding()
	jestExpect(calledLog).toEqual({ 0 })
end)
it("should work with async/await", function()
	local function App()
		local ctr, setCtr = React.useState(0)
		local function someAsyncFunction()
			Scheduler.unstable_yieldValue("stage 1")
			Scheduler.unstable_yieldValue("stage 2")
			setCtr(1)
		end
		React.useEffect(function()
			someAsyncFunction()
		end, {})
		return ctr
	end
	Promise.try(function()
		ReactNoop.act(function()
			ReactNoop.render(React.createElement(App))
		end)
	end):await()
	jestExpect(Scheduler).toHaveYielded({ "stage 1", "stage 2" })
	jestExpect(Scheduler).toFlushWithoutYielding()
	jestExpect(ReactNoop.getChildren()).toEqual({ { text = "1", hidden = false } })
end) ]]
eC.Children._a9bc765240671ec0507630c3463cea53=fu
local fv

local fw={ClassName="ModuleScript",Children={},Properties={}}
fw.Name="ReactSuspense-internal.spec"
fw.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/ReactSuspense-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local React
local ReactTestRenderer
local ReactFeatureFlags
local Scheduler
local SchedulerTracing
local ReactCache
local Suspense
local _act
local TextResource
local textResourceShouldFail

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local describe = JestGlobals.describe
local jest = JestGlobals.jest

local jestMock = require(Packages.Dev.JestGlobals).jest
local Promise = require(Packages.Promise)
local LuauPolyfill = require(Packages.LuauPolyfill)
local setTimeout = LuauPolyfill.setTimeout
local Error = LuauPolyfill.Error
-- Additional tests can be found in ReactSuspenseWithNoopRenderer. Plan is
-- to gradually migrate those to this file.
describe("ReactSuspense", function()
	-- ROBLOX deviation START: add afterEach to reset to using useRealTimers()
	afterEach(function()
		jest.useRealTimers()
	end)
	-- ROBLOX deviation END

	beforeEach(function()
		jest.resetModules()

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false
		ReactFeatureFlags.enableSchedulerTracing = true
		React = require(Packages.React)
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		_act = ReactTestRenderer.unstable_concurrentAct
		Scheduler = require(Packages.Scheduler)
		SchedulerTracing = Scheduler.tracing
		ReactCache = require(Packages.Dev.ReactCache)
		Suspense = React.Suspense
		TextResource = ReactCache.unstable_createResource(function(input)
			local text, ms = input[1], (input[2] or 0)
			local listeners
			local status = "pending"
			local value = nil

			return {
				andThen = function(_self, resolve, reject)
					-- ROBLOX deviation: if/else in place of switch
					if status == "pending" then
						if listeners == nil then
							listeners = { { resolve = resolve, reject = reject } }
							setTimeout(function()
								if textResourceShouldFail then
									Scheduler.unstable_yieldValue(
										string.format("Promise rejected [%s]", text)
									)
									status = "rejected"
									value = Error.new("Failed to load: " .. text)
									for _, listener in listeners do
										listener.reject(value)
									end
								else
									Scheduler.unstable_yieldValue(
										string.format("Promise resolved [%s]", text)
									)
									status = "resolved"
									value = text
									for _, listener in listeners do
										listener.resolve(value)
									end
								end
							end, ms)
						else
							table.insert(
								listeners,
								{ resolve = resolve, reject = reject }
							)
						end
					elseif status == "resolved" then
						resolve(value)
					elseif status == "rejected" then
						reject(value)
					end
				end,
			}
		end, function(input)
			return input[1]
		end)
		textResourceShouldFail = false
	end)

	local function Text(props)
		Scheduler.unstable_yieldValue(props.text)
		return props.text
	end

	local function AsyncText(props)
		local text = props.text
		local ok, result = pcall(function()
			TextResource.read({ props.text, props.ms })
			Scheduler.unstable_yieldValue(text)
			return text
		end)
		if not ok then
			local promise = result
			if typeof(promise.andThen) == "function" then
				Scheduler.unstable_yieldValue(string.format("Suspend! [%s]", text))
			else
				Scheduler.unstable_yieldValue(string.format("Error! [%s]", text))
			end
			error(promise)
		end
		return result
	end

	it("suspends rendering and continues later", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		local function Bar(props)
			Scheduler.unstable_yieldValue("Bar")
			return props.children
		end

		local function Foo(props)
			local renderBar = props.renderBar

			Scheduler.unstable_yieldValue("Foo")

			return React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				if renderBar
					then React.createElement(
						Bar,
						nil,
						React.createElement(AsyncText, {
							text = "A",
							ms = 100,
						}),
						React.createElement(Text, {
							text = "B",
						})
					)
					else nil
			)
		end

		-- Render an empty shell
		local root = ReactTestRenderer.create(
			React.createElement(Foo),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({ "Foo" })
		jestExpect(root).toMatchRenderedOutput(nil)

		-- Navigate the shell to now render the child content.
		-- This should suspend.
		root.update(React.createElement(Foo, { renderBar = true }))
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
			-- A suspends
			"Suspend! [A]",
			-- But we keep rendering the siblings
			"B",
			"Loading...",
		})
		jestExpect(root).toMatchRenderedOutput(nil)

		-- Flush some of the time
		jest.advanceTimersByTime(50)
		-- Still nothing...
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(root).toMatchRenderedOutput(nil)

		-- Flush the promise completely
		jest.advanceTimersByTime(50)
		-- Renders successfully
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [A]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Foo",
			"Bar",
			"A",
			"B",
		})
		jestExpect(root).toMatchRenderedOutput("AB")
	end)
	it("suspends siblings and later recovers each independently", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		-- Render two sibling Suspense components
		local root = ReactTestRenderer.create(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading A...",
						}),
					},
					React.createElement(AsyncText, {
						text = "A",
						ms = 5000,
					})
				),
				React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading B...",
						}),
					},
					React.createElement(AsyncText, {
						text = "B",
						ms = 6000,
					})
				)
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Suspend! [A]",
			"Loading A...",
			"Suspend! [B]",
			"Loading B...",
		})
		Scheduler.unstable_flushAll()
		jestExpect(root).toMatchRenderedOutput("Loading A...Loading B...")
		-- Advance time by enough that the first Suspense's promise resolves and
		-- switches back to the normal view. The second Suspense should still
		-- show the placeholder
		jest.advanceTimersByTime(5000)
		-- TODO: Should we throw if you forget to call toHaveYielded?
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [A]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"A",
		})
		jestExpect(root).toMatchRenderedOutput("ALoading B...")

		-- Advance time by enough that the second Suspense's promise resolves
		-- and switches back to the normal view
		jest.advanceTimersByTime(1000)
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [B]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"B",
		})
		jestExpect(root).toMatchRenderedOutput("AB")
	end)
	it(
		"interrupts current render if promise resolves before current render phase",
		function()
			local didResolve = false
			local listeners = {}
			local thenable = {
				andThen = function(self, resolve)
					if not didResolve then
						table.insert(listeners, resolve)
					else
						resolve()
					end
				end,
			}

			local function resolveThenable()
				didResolve = true

				-- ROBLOX deviation: for loop in place of forEach
				for _, l in listeners do
					l()
				end
			end
			local function Async()
				if not didResolve then
					Scheduler.unstable_yieldValue("Suspend!")
					error(thenable)
				end

				Scheduler.unstable_yieldValue("Async")

				return "Async"
			end

			local root = ReactTestRenderer.create(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Suspense, {
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					}),
					React.createElement(Text, {
						text = "Initial",
					})
				),
				{ unstable_isConcurrent = true }
			)

			jestExpect(Scheduler).toFlushAndYield({
				"Initial",
			})
			jestExpect(root).toMatchRenderedOutput("Initial")

			-- The update will suspend.
			root.update(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Suspense, {
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					}, React.createElement(Async)),
					React.createElement(Text, {
						text = "After Suspense",
					}),
					React.createElement(Text, {
						text = "Sibling",
					})
				)
			)
			-- Yield past the Suspense boundary but don't complete the last sibling.
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Suspend!",
				"Loading...",
				"After Suspense",
			})

			-- The promise resolves before the current render phase has completed
			resolveThenable()
			jestExpect(Scheduler).toHaveYielded({})
			jestExpect(root).toMatchRenderedOutput("Initial")

			-- Start over from the root, instead of continuing.
			jestExpect(Scheduler).toFlushAndYield({
				-- Async renders again *before* Sibling
				"Async",
				"After Suspense",
				"Sibling",
			})
			jestExpect(root).toMatchRenderedOutput("AsyncAfter SuspenseSibling")
		end
	)

	it(
		"interrupts current render if something already suspended with a "
			.. "delay, and then subsequently there's a lower priority update",
		function()
			local root = ReactTestRenderer.create(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Suspense, {
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					}),
					React.createElement(Text, {
						text = "Initial",
					})
				),
				{ unstable_isConcurrent = true }
			)

			jestExpect(Scheduler).toFlushAndYield({
				"Initial",
			})
			jestExpect(root).toMatchRenderedOutput("Initial")
			-- The update will suspend.
			root.update(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(
						Suspense,
						{
							fallback = React.createElement(Text, {
								text = "Loading...",
							}),
						},
						React.createElement(AsyncText, {
							text = "Async",
							ms = 2000,
						})
					),
					React.createElement(Text, {
						text = "After Suspense",
					}),
					React.createElement(Text, {
						text = "Sibling",
					})
				)
			)
			-- Yield past the Suspense boundary but don't complete the last sibling.
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Suspend! [Async]",
				"Loading...",
				"After Suspense",
			})
			-- Receives a lower priority update before the current render phase
			-- has completed.
			Scheduler.unstable_advanceTime(1000)
			root.update(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Suspense, {
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					}),
					React.createElement(Text, {
						text = "Updated",
					})
				)
			)
			jestExpect(Scheduler).toHaveYielded({})
			jestExpect(root).toMatchRenderedOutput("Initial")
			-- Render the update, instead of continuing
			jestExpect(Scheduler).toFlushAndYield({
				"Updated",
			})
			jestExpect(root).toMatchRenderedOutput("Updated")
		end
	)

	-- -- @gate experimental
	-- it('interrupts current render when something suspends with a ' .. "delay and we've already skipped over a lower priority update in " .. 'a parent', function(
	-- )
	--     local function interrupt()
	--         -- React has a heuristic to batch all updates that occur within the same
	--         -- event. This is a trick to circumvent that heuristic.
	--         ReactTestRenderer.create('whatever')
	--     end
	--     local function App(props)
	--         local shouldSuspend, step = props.shouldSuspend, props.step

	--         return React.createElement(React.Fragment, nil, React.createElement(Text, {
	--             text = string.format('A%s', step),
	--         }), React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, (function()
	--             if shouldSuspend then
	--                 return React.createElement(AsyncText, {
	--                     text = 'Async',
	--                     ms = 2000,
	--                 })
	--             end

	--             return nil
	--         end)()), React.createElement(Text, {
	--             text = string.format('B%s', step),
	--         }), React.createElement(Text, {
	--             text = string.format('C%s', step),
	--         }))
	--     end

	--     local root = ReactTestRenderer.create(nil, {unstable_isConcurrent = true})

	--     root.update(React.createElement(App, {
	--         shouldSuspend = false,
	--         step = 0,
	--     }))
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'A0',
	--         'B0',
	--         'C0',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('A0B0C0')

	--     -- This update will suspend.
	--     root.update(React.createElement(App, {
	--         shouldSuspend = true,
	--         step = 1,
	--     }))

	--     -- Do a bit of work
	--     jestExpect(Scheduler).toFlushAndYieldThrough({
	--         'A1',
	--     })

	--     -- Schedule another update. This will have lower priority because it's
	--     -- a transition.
	--     React.unstable_startTransition(function()
	--         root.update(React.createElement(App, {
	--             shouldSuspend = false,
	--             step = 2,
	--         }))
	--     end)

	--     -- Interrupt to trigger a restart.
	--     interrupt()
	--     jestExpect(Scheduler).toFlushAndYieldThrough({
	--         -- Should have restarted the first update, because of the interruption
	--         'A1',
	--         'Suspend! [Async]',
	--         'Loading...',
	--         'B1',
	--     })

	--     -- Should not have committed loading state
	--     jestExpect(root).toMatchRenderedOutput('A0B0C0')

	--     -- After suspending, should abort the first update and switch to the
	--     -- second update. So, C1 should not appear in the log.
	--     -- TODO: This should work even if React does not yield to the main
	--     -- thread. Should use same mechanism as selective hydration to interrupt
	--     -- the render before the end of the current slice of work.
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'A2',
	--         'B2',
	--         'C2',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('A2B2C2')
	-- end)

	-- -- @gate experimental
	-- ROBLOX TODO: AsyncText component
	-- it('interrupts current render when something suspends with a ' ..
	-- "delay and we've already bailed out lower priority update in " ..
	-- 'a parent', _async(function()
	--     -- This is similar to the previous test case, except this covers when
	--     -- React completely bails out on the parent component, without processing
	--     -- the update queue.

	--     local function interrupt()
	--         -- React has a heuristic to batch all updates that occur within the same
	--         -- event. This is a trick to circumvent that heuristic.
	--         ReactTestRenderer.create('whatever')
	--     end

	--     local _React, useState = React, _React.useState

	--     local function Async()
	--         local _useState, _useState2, shouldSuspend, _setShouldSuspend = useState(false), _slicedToArray(_useState, 2), _useState2[0], _useState2[1]

	--         setShouldSuspend = _setShouldSuspend

	--         return React.createElement(React.Fragment, nil, React.createElement(Text, {
	--             text = 'A',
	--         }), React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, (function()
	--             if shouldSuspend then
	--                 return React.createElement(AsyncText, {
	--                     text = 'Async',
	--                     ms = 2000,
	--                 })
	--             end

	--             return nil
	--         end)()), React.createElement(Text, {
	--             text = 'B',
	--         }), React.createElement(Text, {
	--             text = 'C',
	--         }))
	--     end

	--     local setShouldSuspend

	--     local function App()
	--         local _useState3, _useState4, shouldHideInParent, _setShouldHideInParent = useState(false), _slicedToArray(_useState3, 2), _useState4[0], _useState4[1]

	--         setShouldHideInParent = _setShouldHideInParent

	--         Scheduler.unstable_yieldValue('shouldHideInParent: ' + shouldHideInParent)

	--         return(function()
	--             if shouldHideInParent then
	--                 return React.createElement(Text, {
	--                     text = '(empty)',
	--                 })
	--             end

	--             return React.createElement(Async)
	--         end)()
	--     end

	--     local setShouldHideInParent
	--     local root = ReactTestRenderer.create(nil, {unstable_isConcurrent = true})

	--     return _awaitIgnored(act(_async(function()
	--         root.update(React.createElement(App))
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'shouldHideInParent: false',
	--             'A',
	--             'B',
	--             'C',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('ABC')

	--         -- This update will suspend.
	--         setShouldSuspend(true)

	--         -- Need to move into the next async bucket.
	--         -- Do a bit of work, then interrupt to trigger a restart.
	--         jestExpect(Scheduler).toFlushAndYieldThrough({
	--             'A',
	--         })
	--         interrupt()
	--         -- Should not have committed loading state
	--         jestExpect(root).toMatchRenderedOutput('ABC')

	--         -- Schedule another update. This will have lower priority because it's
	--         -- a transition.
	--         React.unstable_startTransition(function()
	--             setShouldHideInParent(true)
	--         end)
	--         jestExpect(Scheduler).toFlushAndYieldThrough({
	--             -- Should have restarted the first update, because of the interruption
	--             'A',
	--             'Suspend! [Async]',
	--             'Loading...',
	--             'B',
	--         })

	--         -- Should not have committed loading state
	--         jestExpect(root).toMatchRenderedOutput('ABC')

	--         -- After suspending, should abort the first update and switch to the
	--         -- second update.
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'shouldHideInParent: true',
	--             '(empty)',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('(empty)')

	--         return _await()
	--     end)))
	-- end))
	xit(
		"interrupts current render when something suspends with a "
			.. "delay, and a parent received an update after it completed",
		function()
			local function App(props)
				local shouldSuspend, step = props.shouldSuspend, props.step

				return React.createElement(React.Fragment, nil, {
					React.createElement(Text, { text = string.format("A%s", step) }),
					React.createElement(
						Suspense,
						{
							fallback = React.createElement(Text, {
								text = "Loading...",
							}),
						},
						(function()
							if shouldSuspend then
								return React.createElement(AsyncText, {
									text = "Async",
									ms = 2000,
								})
							end

							return nil
						end)()
					),
					React.createElement(Text, { text = string.format("B%s", step) }),
					React.createElement(Text, { text = string.format("C%s", step) }),
				})
			end

			local root = ReactTestRenderer.create(nil, { unstable_isConcurrent = true })

			root.update(React.createElement(App, {
				shouldSuspend = false,
				step = 0,
			}))
			jestExpect(Scheduler).toFlushAndYield({
				"A0",
				"B0",
				"C0",
			})
			jestExpect(root).toMatchRenderedOutput("A0B0C0")

			-- This update will suspend.
			root.update(React.createElement(App, {
				shouldSuspend = true,
				step = 1,
			}))
			-- Flush past the root, but stop before the async component.
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"A1",
			})

			-- Schedule an update on the root, which already completed.
			root.update(React.createElement(App, {
				shouldSuspend = false,
				step = 2,
			}))
			-- We'll keep working on the existing update.
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"Suspend! [Async]",
				"Loading...",
				"B1",
			})
			-- Should not have committed loading state
			jestExpect(root).toMatchRenderedOutput("A0B0C0")

			-- After suspending, should abort the first update and switch to the
			-- second update. So, C1 should not appear in the log.
			-- TODO: This should work even if React does not yield to the main
			-- thread. Should use same mechanism as selective hydration to interrupt
			-- the render before the end of the current slice of work.
			-- ROBLOX FIXME: currently failing right here, gets empty
			jestExpect(Scheduler).toFlushAndYield({
				"A2",
				"B2",
				"C2",
			})
			jestExpect(root).toMatchRenderedOutput("A2B2C2")
		end
	)

	it("mounts a lazy class component in non-concurrent mode", function()
		jest.useRealTimers()
		local fakeImport = function(result)
			-- ROBLOX deviation: delay(0) because resolved promises are andThen'd on the same tick cycle
			-- remove once addressed in polyfill
			return Promise.delay(0):andThen(function()
				return { default = result }
			end)
		end
		local Class = React.Component:extend("Class")

		function Class:componentDidMount()
			Scheduler.unstable_yieldValue("Did mount: " .. self.props.label)
		end
		function Class:componentDidUpdate()
			Scheduler.unstable_yieldValue("Did update: " .. self.props.label)
		end
		function Class:render()
			return React.createElement(Text, {
				text = self.props.label,
			})
		end

		local LazyClass = React.lazy(function()
			return fakeImport(Class)
		end)
		local root = ReactTestRenderer.create(React.createElement(
			Suspense,
			{
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			},
			React.createElement(LazyClass, {
				label = "Hi",
			})
		))

		jestExpect(Scheduler).toHaveYielded({
			"Loading...",
		})
		jestExpect(root).toMatchRenderedOutput("Loading...")

		-- ROBLOX deviation: used to synchronize on the above Promise.delay()
		Promise.delay(0):await()

		jestExpect(Scheduler).toFlushExpired({
			"Hi",
			"Did mount: Hi",
		})
		jestExpect(root).toMatchRenderedOutput("Hi")
	end)

	it("only captures if `fallback` is defined", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		local root = ReactTestRenderer.create(
			React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(
					Suspense,
					nil,
					React.createElement(AsyncText, {
						text = "Hi",
						ms = 5000,
					})
				)
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(Scheduler).toFlushAndYield({
			"Suspend! [Hi]",
			-- The outer fallback should be rendered, because the inner one does not
			-- have a `fallback` prop
			"Loading...",
		})
		jest.advanceTimersByTime(1000)
		jestExpect(Scheduler).toHaveYielded({})
		jestExpect(Scheduler).toFlushAndYield({})
		jestExpect(root).toMatchRenderedOutput("Loading...")
		jest.advanceTimersByTime(5000)
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [Hi]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Hi",
		})
		jestExpect(root).toMatchRenderedOutput("Hi")
	end)
	it(
		"throws if tree suspends and none of the Suspense ancestors have a fallback",
		function()
			ReactTestRenderer.create(
				React.createElement(
					Suspense,
					nil,
					React.createElement(AsyncText, {
						text = "Hi",
						ms = 1000,
					})
				),
				{ unstable_isConcurrent = true }
			)
			-- ROBLOX Test Noise: in upstream, jest setup config makes these
			-- tests hide the error boundary warnings they trigger
			-- (scripts/jest/setupTests.js:72)
			jestExpect(Scheduler).toFlushAndThrow(
				"AsyncText suspended while rendering, but no fallback UI was specified."
			)
			jestExpect(Scheduler).toHaveYielded({
				"Suspend! [Hi]",
				"Suspend! [Hi]",
			})
		end
	)
	it(
		"updates memoized child of suspense component when context updates (simple memo)",
		function()
			-- ROBLOX deviation START: add useFakeTimers()
			jest.useFakeTimers()
			-- ROBLOX deviation END
			local useContext, createContext, useState, memo =
				React.useContext, React.createContext, React.useState, React.memo
			local ValueContext = createContext(nil)
			local MemoizedChild = memo(function()
				local text = useContext(ValueContext)
				local ok, result = pcall(function()
					TextResource.read({ text, 1000 })
					Scheduler.unstable_yieldValue(text)
				end)
				if not ok then
					if typeof(result.andThen) == "function" then
						Scheduler.unstable_yieldValue(
							string.format("Suspend! [%s]", text)
						)
					else
						Scheduler.unstable_yieldValue(string.format("Error! [%s]", text))
					end
					error(result)
				end
				return text
			end)
			local value, setValue

			local function App()
				value, setValue = useState("default")

				return React.createElement(
					ValueContext.Provider,
					{ value = value },
					React.createElement(Suspense, {
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					}, React.createElement(MemoizedChild))
				)
			end

			local root = ReactTestRenderer.create(
				React.createElement(App),
				{ unstable_isConcurrent = true }
			)

			jestExpect(Scheduler).toFlushAndYield({
				"Suspend! [default]",
				"Loading...",
			})
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [default]",
			})
			jestExpect(Scheduler).toFlushAndYield({
				"default",
			})
			jestExpect(root).toMatchRenderedOutput("default")
			ReactTestRenderer.act(function()
				return setValue("new value")
			end)
			jestExpect(Scheduler).toHaveYielded({
				"Suspend! [new value]",
				"Loading...",
			})
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [new value]",
			})
			jestExpect(Scheduler).toFlushAndYield({
				"new value",
			})
			-- ROBLOX FIXME: this last render doesn't flush, so this fails because it receives nil
			jestExpect(root).toMatchRenderedOutput("new value")
		end
	)
	-- it('updates memoized child of suspense component when context updates (manual memo)', function()
	--     local _React3, useContext, createContext, useState, memo = React, _React3.useContext, _React3.createContext, _React3.useState, _React3.memo
	--     local ValueContext = createContext(nil)
	--     local MemoizedChild = memo(function()
	--         local text = useContext(ValueContext)
	--     end, function(prevProps, nextProps)
	--         return true
	--     end)
	--     local setValue

	--     local function App()
	--         local _useState7, _useState8, value, _setValue = useState('default'), _slicedToArray(_useState7, 2), _useState8[0], _useState8[1]

	--         setValue = _setValue

	--         return React.createElement(ValueContext.Provider, {value = value}, React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(MemoizedChild)))
	--     end

	--     local root = ReactTestRenderer.create(React.createElement(App), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Suspend! [default]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [default]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'default',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('default')
	--     act(function()
	--         return setValue('new value')
	--     end)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Suspend! [new value]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [new value]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'new value',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('new value')
	-- end)
	-- it('updates memoized child of suspense component when context updates (function)', function()
	--     local _React4, useContext, createContext, useState = React, _React4.useContext, _React4.createContext, _React4.useState
	--     local ValueContext = createContext(nil)

	--     local function MemoizedChild()
	--         local text = useContext(ValueContext)
	--     end

	--     local setValue

	--     local function App(_ref8)
	--         local children = _ref8.children
	--         local _useState9, _useState10, value, _setValue = useState('default'), _slicedToArray(_useState9, 2), _useState10[0], _useState10[1]

	--         setValue = _setValue

	--         return React.createElement(ValueContext.Provider, {value = value}, children)
	--     end

	--     local root = ReactTestRenderer.create(React.createElement(App, nil, React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(MemoizedChild))), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Suspend! [default]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [default]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'default',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('default')
	--     act(function()
	--         return setValue('new value')
	--     end)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Suspend! [new value]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [new value]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'new value',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('new value')
	-- end)
	-- it('updates memoized child of suspense component when context updates (forwardRef)', function()
	--     local _React5, forwardRef, useContext, createContext, useState = React, _React5.forwardRef, _React5.useContext, _React5.createContext, _React5.useState
	--     local ValueContext = createContext(nil)
	--     local MemoizedChild = forwardRef(function()
	--         local text = useContext(ValueContext)
	--     end)
	--     local setValue

	--     local function App(_ref9)
	--         local children = _ref9.children
	--         local _useState11, _useState12, value, _setValue = useState('default'), _slicedToArray(_useState11, 2), _useState12[0], _useState12[1]

	--         setValue = _setValue

	--         return React.createElement(ValueContext.Provider, {value = value}, children)
	--     end

	--     local root = ReactTestRenderer.create(React.createElement(App, nil, React.createElement(Suspense, {
	--         fallback = React.createElement(Text, {
	--             text = 'Loading...',
	--         }),
	--     }, React.createElement(MemoizedChild))), {unstable_isConcurrent = true})

	--     jestExpect(Scheduler).toFlushAndYield({
	--         'Suspend! [default]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [default]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'default',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('default')
	--     act(function()
	--         return setValue('new value')
	--     end)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Suspend! [new value]',
	--         'Loading...',
	--     })
	--     jest.advanceTimersByTime(1000)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [new value]',
	--     })
	--     jestExpect(Scheduler).toFlushAndYield({
	--         'new value',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('new value')
	-- end)
	-- describe('outside concurrent mode', function()
	-- it('a mounted class component can suspend without losing state', function()
	--     local TextWithLifecycle = React.Component:extend("TextWithLifecycle")

	--     function TextWithLifecycle:componentDidMount()
	--         Scheduler.unstable_yieldValue(string.format('Mount [%s]', self.props.text))
	--     end
	--     function TextWithLifecycle:componentDidUpdate()
	--         Scheduler.unstable_yieldValue(string.format('Update [%s]', self.props.text))
	--     end
	--     function TextWithLifecycle:componentWillUnmount()
	--         Scheduler.unstable_yieldValue(string.format('Unmount [%s]', self.props.text))
	--     end
	--     function TextWithLifecycle:render()
	--         return React.createElement(Text, self.props)
	--     end

	--     local instance
	--     local AsyncTextWithLifecycle = React.Component:extend("AsyncTextWithLifecycle")

	--     function AsyncTextWithLifecycle:init()
	--         self.state = {
	--             step = 1
	--         }
	--     end
	--     function AsyncTextWithLifecycle:componentDidMount()
	--         Scheduler.unstable_yieldValue(string.format('Mount [%s:%s]', self.props.text, self.state.step))
	--     end
	--     function AsyncTextWithLifecycle:componentDidUpdate()
	--         Scheduler.unstable_yieldValue(string.format('Update [%s:%s]', self.props.text, self.state.step))
	--     end
	--     function AsyncTextWithLifecycle:componentWillUnmount()
	--         Scheduler.unstable_yieldValue(string.format('Unmount [%s:%s]', self.props.text, self.state.step))
	--     end
	--     function AsyncTextWithLifecycle:render()
	--         instance = self

	--         local text = string.format('%s:%s', self.props.text, self.state.step)
	--         local ms = self.props.ms

	--         local ok, result = pcall(function()
	--             TextResource.read({text, ms})
	--             Scheduler.unstable_yieldValue(text);
	--             return text;
	--         end)
	--         if not ok then
	--             if typeof(result.andThen) == 'function' then
	--                 Scheduler.unstable_yieldValue("Suspend! [" .. text .. "]")
	--                 else
	--                 Scheduler.unstable_yieldValue("Error! [" .. text .. "]")
	--                 end
	--                 error(result)
	--         end
	--     end

	--     local function App()
	--         return React.createElement(Suspense, {
	--             fallback = React.createElement(TextWithLifecycle, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(TextWithLifecycle, {
	--             text = 'A',
	--         }), React.createElement(AsyncTextWithLifecycle, {
	--             ms = 100,
	--             text = 'B',
	--             ref = instance,
	--         }), React.createElement(TextWithLifecycle, {
	--             text = 'C',
	--         }))
	--     end

	--     local root = ReactTestRenderer.create(React.createElement(App))

	--     jestExpect(Scheduler).toHaveYielded({
	--         'A',
	--         'Suspend! [B:1]',
	--         'C',
	--         'Loading...',
	--         'Mount [A]',
	--         -- B's lifecycle should not fire because it suspended
	--         -- 'Mount [B]',
	--         'Mount [C]',
	--         'Mount [Loading...]',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('Loading...')
	--     jest.advanceTimersByTime(100)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [B:1]',
	--     })
	--     jestExpect(Scheduler).toFlushExpired({
	--         'B:1',
	--         'Unmount [Loading...]',
	--         -- Should be a mount, not an update
	--         'Mount [B:1]',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('AB:1C')
	--     instance.setState({step = 2})
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Suspend! [B:2]',
	--         'Loading...',
	--         'Mount [Loading...]',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('Loading...')
	--     jest.advanceTimersByTime(100)
	--     jestExpect(Scheduler).toHaveYielded({
	--         'Promise resolved [B:2]',
	--     })
	--     jestExpect(Scheduler).toFlushExpired({
	--         'B:2',
	--         'Unmount [Loading...]',
	--         'Update [B:2]',
	--     })
	--     jestExpect(root).toMatchRenderedOutput('AB:2C')
	-- end)
	--     it('bails out on timed-out primary children even if they receive an update', function()
	--         local instance
	--         local Stateful = {}
	--         local StatefulMetatable = {__index = Stateful}

	--         function Stateful.new()
	--             local self = setmetatable({}, StatefulMetatable)
	--             local _temp2

	--             return
	--         end
	--         function Stateful:render()
	--             instance = self

	--             return React.createElement(Text, {
	--                 text = string.format('Stateful: %s', self.state.step),
	--             })
	--         end

	--         local function App(props)
	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(Stateful), React.createElement(AsyncText, {
	--                 ms = 1000,
	--                 text = props.text,
	--             }))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App, {
	--             text = 'A',
	--         }))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Stateful: 1',
	--             'Suspend! [A]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [A]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'A',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Stateful: 1A')
	--         root.update(React.createElement(App, {
	--             text = 'B',
	--         }))
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Stateful: 1',
	--             'Suspend! [B]',
	--             'Loading...',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         instance.setState({step = 2})
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Stateful: 2',

	--             -- The suspended component should suspend again. If it doesn't, the
	--             -- likely mistake is that the suspended fiber wasn't marked with
	--             -- pending work, so it was improperly treated as complete.
	--             'Suspend! [B]',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [B]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'B',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Stateful: 2B')
	--     end)
	it(
		"when updating a timed-out tree, always retries the suspended component",
		function()
			-- ROBLOX deviation START: add useFakeTimers()
			jest.useFakeTimers()
			-- ROBLOX deviation END
			local instance
			local Stateful = React.Component:extend("Stateful")
			function Stateful:init()
				self.state = { step = 1 }
			end
			function Stateful:render()
				instance = self

				return React.createElement(Text, {
					text = string.format("Stateful: %s", self.state.step),
				})
			end

			local Indirection = React.Fragment

			local function App(props)
				return React.createElement(
					Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					},
					React.createElement(Stateful),
					React.createElement(
						Indirection,
						nil,
						React.createElement(
							Indirection,
							nil,
							React.createElement(
								Indirection,
								nil,
								React.createElement(AsyncText, {
									ms = 1000,
									text = props.text,
								})
							)
						)
					)
				)
			end

			local root = ReactTestRenderer.create(React.createElement(App, {
				text = "A",
			}))

			jestExpect(Scheduler).toHaveYielded({
				"Stateful: 1",
				"Suspend! [A]",
				"Loading...",
			})
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [A]",
			})
			jestExpect(Scheduler).toFlushExpired({
				"A",
			})
			jestExpect(root).toMatchRenderedOutput("Stateful: 1A")
			root.update(React.createElement(App, {
				text = "B",
			}))
			jestExpect(Scheduler).toHaveYielded({
				"Stateful: 1",
				"Suspend! [B]",
				"Loading...",
			})
			-- ROBLOX FIXME: test fails here, rendered output is empty
			jestExpect(root).toMatchRenderedOutput("Loading...")
			instance:setState({ step = 2 })
			jestExpect(Scheduler).toHaveYielded({
				"Stateful: 2",
				"Suspend! [B]",
			})
			jestExpect(root).toMatchRenderedOutput("Loading...")
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [B]",
			})
			jestExpect(Scheduler).toFlushExpired({
				"B",
			})
			jestExpect(root).toMatchRenderedOutput("Stateful: 2B")
		end
	)
	it("suspends in a class that has componentWillUnmount and is then deleted", function()
		local AsyncTextWithUnmount = React.Component:extend("AsyncTextWithUnmount")
		function AsyncTextWithUnmount:componentWillUnmount()
			Scheduler.unstable_yieldValue("will unmount")
		end
		function AsyncTextWithUnmount:render()
			local text = self.props.text
			local ms = self.props.ms
			local ok, result = pcall(function()
				TextResource.read({ text, ms })
				Scheduler.unstable_yieldValue(text)
				return text
			end)
			if not ok then
				local promise = result
				if typeof(promise.andThen) == "function" then
					Scheduler.unstable_yieldValue(string.format("Suspend! [%s]", text))
				else
					Scheduler.unstable_yieldValue(string.format("Error! [%s]", text))
				end
				error(promise)
			end
			return result
		end

		local function App(props)
			local text = props.text

			return React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(AsyncTextWithUnmount, {
					text = text,
					ms = 100,
				})
			)
		end

		local root = ReactTestRenderer.create(React.createElement(App, {
			text = "A",
		}))

		jestExpect(Scheduler).toHaveYielded({
			"Suspend! [A]",
			"Loading...",
		})
		root.update(React.createElement(Text, {
			text = "B",
		}))
		-- Should not fire componentWillUnmount
		jestExpect(Scheduler).toHaveYielded({
			"B",
		})
		jestExpect(root).toMatchRenderedOutput("B")
	end)
	it("suspends in a component that also contains useEffect", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		local useLayoutEffect = React.useLayoutEffect

		local function AsyncTextWithEffect(props)
			local text = props.text

			useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Did commit: " .. text)
			end, { text })

			local ok, result = pcall(function()
				TextResource.read({ props.text, props.ms })
				Scheduler.unstable_yieldValue(text)
				return text
			end)
			if not ok then
				local promise = result
				if typeof(promise.andThen) == "function" then
					Scheduler.unstable_yieldValue(string.format("Suspend! [%s]", text))
				else
					Scheduler.unstable_yieldValue(string.format("Error! [%s]", text))
				end
				error(promise)
			end
			return result
		end

		local function App(props)
			local text = props.text

			return React.createElement(
				Suspense,
				{
					fallback = React.createElement(Text, {
						text = "Loading...",
					}),
				},
				React.createElement(AsyncTextWithEffect, {
					text = text,
					ms = 100,
				})
			)
		end

		ReactTestRenderer.create(React.createElement(App, {
			text = "A",
		}))
		jestExpect(Scheduler).toHaveYielded({
			"Suspend! [A]",
			"Loading...",
		})
		jest.advanceTimersByTime(500)
		-- ROBLOX FIXME: when not focused, the test fails by getting *two* 'Promise resolved [A]'
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [A]",
		})
		jestExpect(Scheduler).toFlushExpired({
			"A",
			"Did commit: A",
		})
	end)
	it("retries when an update is scheduled on a timed out tree", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		local instance
		local Stateful = React.Component:extend("Stateful")

		function Stateful:init()
			self.state = { step = 1 }
		end

		function Stateful:render()
			instance = self

			return React.createElement(AsyncText, {
				ms = 1000,
				text = string.format("Step: %s", self.state.step),
			})
		end

		local function App(props)
			return React.createElement(Suspense, {
				fallback = React.createElement(Text, {
					text = "Loading...",
				}),
			}, React.createElement(Stateful))
		end

		local root = ReactTestRenderer.create(
			React.createElement(App),
			{ unstable_isConcurrent = true }
		)

		-- Initial render
		jestExpect(Scheduler).toFlushAndYield({
			"Suspend! [Step: 1]",
			"Loading...",
		})
		jest.advanceTimersByTime(1000)
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [Step: 1]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Step: 1",
		})
		jestExpect(root).toMatchRenderedOutput("Step: 1")

		-- Update that suspends
		instance:setState({ step = 2 })
		jestExpect(Scheduler).toFlushAndYield({
			"Suspend! [Step: 2]",
			"Loading...",
		})
		jest.advanceTimersByTime(500)
		-- ROBLOX FIXME: expect fails because rendered output is nil
		jestExpect(root).toMatchRenderedOutput("Loading...")

		-- Update while still suspended
		instance:setState({ step = 3 })
		jestExpect(Scheduler).toFlushAndYield({
			"Suspend! [Step: 3]",
		})
		jestExpect(root).toMatchRenderedOutput("Loading...")
		jest.advanceTimersByTime(1000)
		jestExpect(Scheduler).toHaveYielded({
			"Promise resolved [Step: 2]",
			"Promise resolved [Step: 3]",
		})
		jestExpect(Scheduler).toFlushAndYield({
			"Step: 3",
		})
		jestExpect(root).toMatchRenderedOutput("Step: 3")
	end)
	--     it('does not remount the fallback while suspended children resolve in legacy mode', function()
	--         local mounts = 0
	--         local ShouldMountOnce = {}
	--         local ShouldMountOnceMetatable = {__index = ShouldMountOnce}

	--         function ShouldMountOnce:componentDidMount()
	--             mounts = mounts + 1
	--         end
	--         function ShouldMountOnce:render()
	--             return React.createElement(Text, {
	--                 text = 'Loading...',
	--             })
	--         end

	--         local function App(props)
	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement(ShouldMountOnce),
	--             }, React.createElement(AsyncText, {
	--                 ms = 1000,
	--                 text = 'Child 1',
	--             }), React.createElement(AsyncText, {
	--                 ms = 2000,
	--                 text = 'Child 2',
	--             }), React.createElement(AsyncText, {
	--                 ms = 3000,
	--                 text = 'Child 3',
	--             }))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App))

	--         -- Initial render
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [Child 1]',
	--             'Suspend! [Child 2]',
	--             'Suspend! [Child 3]',
	--             'Loading...',
	--         })
	--         jestExpect(Scheduler).toFlushAndYield({})
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Child 1]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Child 1',
	--             'Suspend! [Child 2]',
	--             'Suspend! [Child 3]',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Child 2]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Child 2',
	--             'Suspend! [Child 3]',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Child 3]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Child 3',
	--         })
	--         jestExpect(root).toMatchRenderedOutput(({
	--             'Child 1',
	--             'Child 2',
	--             'Child 3',
	--         }).join(''))
	--         jestExpect(mounts).toBe(1)
	--     end)
	--     it('does not get stuck with fallback in concurrent mode for a large delay', function()
	--         local function App(props)
	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(AsyncText, {
	--                 ms = 1000,
	--                 text = 'Child 1',
	--             }), React.createElement(AsyncText, {
	--                 ms = 7000,
	--                 text = 'Child 2',
	--             }))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App), {unstable_isConcurrent = true})

	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Suspend! [Child 1]',
	--             'Suspend! [Child 2]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Child 1]',
	--         })
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Child 1',
	--             'Suspend! [Child 2]',
	--         })
	--         jest.advanceTimersByTime(6000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Child 2]',
	--         })
	--         jestExpect(Scheduler).toFlushAndYield({
	--             'Child 1',
	--             'Child 2',
	--         })
	--         jestExpect(root).toMatchRenderedOutput(({
	--             'Child 1',
	--             'Child 2',
	--         }).join(''))
	--     end)
	--     it('reuses effects, including deletions, from the suspended tree', function()
	--         local _React7, useState = React, _React7.useState
	--         local setTab

	--         local function App()
	--             local _useState13, _useState14, tab, _setTab = useState(0), _slicedToArray(_useState13, 2), _useState14[0], _useState14[1]

	--             setTab = _setTab

	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(AsyncText, {
	--                 key = tab,
	--                 text = 'Tab: ' + tab,
	--                 ms = 1000,
	--             }), React.createElement(Text, {
	--                 key = tab + 'sibling',
	--                 text = ' + sibling',
	--             }))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [Tab: 0]',
	--             ' + sibling',
	--             'Loading...',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Tab: 0]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Tab: 0',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Tab: 0 + sibling')
	--         act(function()
	--             return setTab(1)
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [Tab: 1]',
	--             ' + sibling',
	--             'Loading...',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Tab: 1]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Tab: 1',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Tab: 1 + sibling')
	--         act(function()
	--             return setTab(2)
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [Tab: 2]',
	--             ' + sibling',
	--             'Loading...',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [Tab: 2]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'Tab: 2',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Tab: 2 + sibling')
	--     end)
	--     it('does not warn if an mounted component is pinged', function()
	--         local _React8, useState = React, _React8.useState
	--         local root = ReactTestRenderer.create(nil)
	--         local setStep

	--         local function UpdatingText(_ref12)
	--             local text, ms = _ref12.text, _ref12.ms
	--             local _useState15, _useState16, step, _setStep = useState(0), _slicedToArray(_useState15, 2), _useState16[0], _useState16[1]

	--             setStep = _setStep

	--             local fullText = string.format('%s:%s', text, step)
	--         end

	--         root.update(React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(UpdatingText, {
	--             text = 'A',
	--             ms = 1000,
	--         })))
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [A:0]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [A:0]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'A:0',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('A:0')
	--         act(function()
	--             return setStep(1)
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [A:1]',
	--             'Loading...',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('Loading...')
	--         root.update(nil)
	--         jestExpect(Scheduler).toFlushWithoutYielding()
	--         jest.advanceTimersByTime(1000)
	--     end)
	--     it('memoizes promise listeners per thread ID to prevent redundant renders', function()
	--         local function App()
	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(AsyncText, {
	--                 text = 'A',
	--                 ms = 1000,
	--             }), React.createElement(AsyncText, {
	--                 text = 'B',
	--                 ms = 2000,
	--             }), React.createElement(AsyncText, {
	--                 text = 'C',
	--                 ms = 3000,
	--             }))
	--         end

	--         local root = ReactTestRenderer.create(nil)

	--         root.update(React.createElement(App))
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [A]',
	--             'Suspend! [B]',
	--             'Suspend! [C]',
	--             'Loading...',
	--         })

	--         -- Resolve A
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [A]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'A',
	--             -- The promises for B and C have now been thrown twice
	--             'Suspend! [B]',
	--             'Suspend! [C]',
	--         })

	--         -- Resolve B
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [B]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             -- Even though the promise for B was thrown twice, we should only
	--             -- re-render once.
	--             'B',
	--             -- The promise for C has now been thrown three times
	--             'Suspend! [C]',
	--         })

	--         -- Resolve C
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [C]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             -- Even though the promise for C was thrown three times, we should only
	--             -- re-render once.
	--             'C',
	--         })
	--     end)
	it("should call onInteractionScheduledWorkCompleted after suspending", function()
		-- ROBLOX deviation START: add useFakeTimers()
		jest.useFakeTimers()
		-- ROBLOX deviation END
		-- ROBLOX deviation: mock performance.now
		local performanceNowCounter = 0
		_G.performance = {
			now = function()
				performanceNowCounter += 1
				return performanceNowCounter
			end,
			mark = function() end,
		}
		local subscriber = {
			onInteractionScheduledWorkCompleted = jestMock.fn(),
			onInteractionTraced = jestMock.fn(),
			onWorkCanceled = jestMock.fn(),
			onWorkScheduled = jestMock.fn(),
			onWorkStarted = jestMock.fn(),
			onWorkStopped = jestMock.fn(),
		}

		SchedulerTracing.unstable_subscribe(subscriber)
		SchedulerTracing.unstable_trace("test", _G.performance.now(), function()
			local function App()
				return React.createElement(
					React.Suspense,
					{
						fallback = React.createElement(Text, {
							text = "Loading...",
						}),
					},
					React.createElement(AsyncText, {
						text = "A",
						ms = 1000,
					}),
					React.createElement(AsyncText, {
						text = "B",
						ms = 2000,
					}),
					React.createElement(AsyncText, {
						text = "C",
						ms = 3000,
					})
				)
			end

			local root = ReactTestRenderer.create()

			root.update(React.createElement(App))
			jestExpect(Scheduler).toHaveYielded({
				"Suspend! [A]",
				"Suspend! [B]",
				"Suspend! [C]",
				"Loading...",
			})

			-- Resolve A
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [A]",
			})
			jestExpect(Scheduler).toFlushExpired({
				"A",
				-- The promises for B and C have now been thrown twice
				"Suspend! [B]",
				"Suspend! [C]",
			})

			-- Resolve B
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [B]",
			})
			jestExpect(Scheduler).toFlushExpired({
				-- Even though the promise for B was thrown twice, we should only
				-- re-render once.
				"B",
				-- The promise for C has now been thrown three times
				"Suspend! [C]",
			})

			-- Resolve C
			jest.advanceTimersByTime(1000)
			jestExpect(Scheduler).toHaveYielded({
				"Promise resolved [C]",
			})
			jestExpect(Scheduler).toFlushAndYield({
				-- Even though the promise for C was thrown three times, we should only
				-- re-render once.
				"C",
			})
		end)
		jestExpect(subscriber.onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(
			1
		)
	end)
	--     it('#14162', function()
	--         local fetchComponent = _async(function()
	--             return Promise(function(r)
	--                 -- simulating a delayed import() call
	--                 setTimeout(r, 1000, {default = Hello})
	--             end)
	--         end)
	--         local _React9, lazy = React, _React9.lazy

	--         local function Hello()
	--             return React.createElement('span', nil, 'hello')
	--         end

	--         local LazyHello = lazy(fetchComponent)
	--         local App = {}
	--         local AppMetatable = {__index = App}

	--         function App.new()
	--             local self = setmetatable({}, AppMetatable)
	--             local _temp5

	--             return
	--         end
	--         function App:componentDidMount()
	--             local _this = self

	--             setTimeout(function()
	--                 return _this.setState({render = true})
	--             end)
	--         end
	--         function App:render()
	--             return React.createElement(Suspense, {
	--                 fallback = React.createElement('span', nil, 'loading...'),
	--             }, self.state.render and React.createElement(LazyHello))
	--         end

	--         local root = ReactTestRenderer.create(nil)

	--         root.update(React.createElement(App, {
	--             name = 'world',
	--         }))
	--         jest.advanceTimersByTime(1000)
	--     end)
	--     it('updates memoized child of suspense component when context updates (simple memo)', function()
	--         local _React10, useContext, createContext, useState, memo = React, _React10.useContext, _React10.createContext, _React10.useState, _React10.memo
	--         local ValueContext = createContext(nil)
	--         local MemoizedChild = memo(function()
	--             local text = useContext(ValueContext)
	--         end)
	--         local setValue

	--         local function App()
	--             local _useState17, _useState18, value, _setValue = useState('default'), _slicedToArray(_useState17, 2), _useState18[0], _useState18[1]

	--             setValue = _setValue

	--             return React.createElement(ValueContext.Provider, {value = value}, React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(MemoizedChild)))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [default]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [default]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'default',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('default')
	--         act(function()
	--             return setValue('new value')
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [new value]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [new value]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'new value',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('new value')
	--     end)
	--     it('updates memoized child of suspense component when context updates (manual memo)', function()
	--         local _React11, useContext, createContext, useState, memo = React, _React11.useContext, _React11.createContext, _React11.useState, _React11.memo
	--         local ValueContext = createContext(nil)
	--         local MemoizedChild = memo(function()
	--             local text = useContext(ValueContext)
	--         end, function(prevProps, nextProps)
	--             return true
	--         end)
	--         local setValue

	--         local function App()
	--             local _useState19, _useState20, value, _setValue = useState('default'), _slicedToArray(_useState19, 2), _useState20[0], _useState20[1]

	--             setValue = _setValue

	--             return React.createElement(ValueContext.Provider, {value = value}, React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(MemoizedChild)))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [default]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [default]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'default',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('default')
	--         act(function()
	--             return setValue('new value')
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [new value]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [new value]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'new value',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('new value')
	--     end)
	--     it('updates memoized child of suspense component when context updates (function)', function()
	--         local _React12, useContext, createContext, useState = React, _React12.useContext, _React12.createContext, _React12.useState
	--         local ValueContext = createContext(nil)

	--         local function MemoizedChild()
	--             local text = useContext(ValueContext)
	--         end

	--         local setValue

	--         local function App(_ref13)
	--             local children = _ref13.children
	--             local _useState21, _useState22, value, _setValue = useState('default'), _slicedToArray(_useState21, 2), _useState22[0], _useState22[1]

	--             setValue = _setValue

	--             return React.createElement(ValueContext.Provider, {value = value}, children)
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App, nil, React.createElement(Suspense, {
	--             fallback = React.createElement(Text, {
	--                 text = 'Loading...',
	--             }),
	--         }, React.createElement(MemoizedChild))))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [default]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [default]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'default',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('default')
	--         act(function()
	--             return setValue('new value')
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [new value]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [new value]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'new value',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('new value')
	--     end)
	--     it('updates memoized child of suspense component when context updates (forwardRef)', function()
	--         local _React13, forwardRef, useContext, createContext, useState = React, _React13.forwardRef, _React13.useContext, _React13.createContext, _React13.useState
	--         local ValueContext = createContext(nil)
	--         local MemoizedChild = forwardRef(function()
	--             local text = useContext(ValueContext)
	--         end)
	--         local setValue

	--         local function App()
	--             local _useState23, _useState24, value, _setValue = useState('default'), _slicedToArray(_useState23, 2), _useState24[0], _useState24[1]

	--             setValue = _setValue

	--             return React.createElement(ValueContext.Provider, {value = value}, React.createElement(Suspense, {
	--                 fallback = React.createElement(Text, {
	--                     text = 'Loading...',
	--                 }),
	--             }, React.createElement(MemoizedChild)))
	--         end

	--         local root = ReactTestRenderer.create(React.createElement(App))

	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [default]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [default]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'default',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('default')
	--         act(function()
	--             return setValue('new value')
	--         end)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Suspend! [new value]',
	--             'Loading...',
	--         })
	--         jest.advanceTimersByTime(1000)
	--         jestExpect(Scheduler).toHaveYielded({
	--             'Promise resolved [new value]',
	--         })
	--         jestExpect(Scheduler).toFlushExpired({
	--             'new value',
	--         })
	--         jestExpect(root).toMatchRenderedOutput('new value')
	--     end)
	-- end)
end) ]]
eC.Children._f2cf9d9ad3d239d3e8bb936732196d28=fw
local fx

local fy={ClassName="ModuleScript",Children={},Properties={}}
fy.Name="ReactTopLevelFragment.spec"
fy.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/69060e1da6061af845162dcf6854a5d9af28350a/packages/react-reconciler/src/__tests__/ReactTopLevelFragment-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]
--!strict

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
local React
local ReactNoop
local Scheduler

-- This is a new feature in Fiber so I put it in its own test file. It could
-- probably move to one of the other test files once it is official.

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest

beforeEach(function()
	jest.resetModules()

	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
end)

it("should render a simple fragment at the top of a component", function()
	local function Fragment()
		return {
			React.createElement("TextLabel", {
				key = "a",
				Text = "Hello",
			}),
			React.createElement("TextLabel", {
				key = "b",
				Text = "World",
			}),
			-- ROBLOX FIXME luau: this isn't seen as iterable for some reason unless
			-- we cast it
		} :: Array<any>
	end
	ReactNoop.render(React.createElement(Fragment))
	jestExpect(Scheduler).toFlushWithoutYielding()
end)

it("should preserve state when switching from a single child", function()
	local instance = nil

	local Stateful = React.Component:extend("Stateful")
	function Stateful:render()
		instance = self
		return React.createElement("TextLabel", { Text = "Hello" })
	end

	-- ROBLOX FIXME Luau: should infer this as Element<Stateful> | { Element<Stateful>, ...}
	local function Fragment(props): any
		if props.condition then
			return React.createElement(Stateful, { key = "a" })
		else
			return {
				React.createElement(Stateful, { key = "a" }),
				React.createElement(
					"Frame",
					{ key = "b" },
					React.createElement("TextLabel", { Text = "World" })
				),
			}
		end
	end

	ReactNoop.render(React.createElement(Fragment))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceA = instance

	jestExpect(instanceA).never.toBe(nil)

	ReactNoop.render(React.createElement(Fragment, { condition = true }))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceB = instance

	jestExpect(instanceB).toBe(instanceA)
end)

it("should not preserve state when switching to a nested array", function()
	local instance = nil

	local Stateful = React.Component:extend("Stateful")
	function Stateful:render()
		instance = self
		return React.createElement("TextLabel", { Text = "Hello" })
	end

	-- ROBLOX FIXME Luau: should infer this as Element<Stateful> | { Element<Stateful>, ...}
	local function Fragment(props): any
		if props.condition then
			return React.createElement(Stateful, { key = "a" })
		else
			return {
				{
					React.createElement(Stateful, { key = "a" }),
					React.createElement(
						"Frame",
						{ key = "b" },
						React.createElement("TextLabel", { Text = "World" })
					),
				},
				React.createElement("Frame", { key = "c" }),
			}
		end
	end

	ReactNoop.render(React.createElement(Fragment))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceA = instance
	jestExpect(instanceA).never.toBe(nil)

	ReactNoop.render(React.createElement(Fragment, { condition = true }))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceB = instance

	jestExpect(instanceB).never.toBe(instanceA)
end)

it("preserves state if an implicit key slot switches from/to nil", function()
	local instance = nil

	local Stateful = React.Component:extend("Stateful")
	function Stateful:render()
		instance = self
		return React.createElement("TextLabel", { Text = "World" })
	end

	local function Fragment(props)
		if props.condition then
			return {
				nil,
				React.createElement(Stateful, { key = "a" }),
				-- ROBLOX FIXME Luau: Luau *must* infer mixed arrays
			} :: Array<any>
		else
			return {
				React.createElement(
					"Frame",
					{ key = "b" },
					React.createElement("TextLabel", { Text = "Hello" })
				),
				React.createElement(Stateful, { key = "a" }),
				-- ROBLOX FIXME Luau: Luau *must* infer mixed arrays
			} :: Array<any>
		end
	end

	ReactNoop.render(React.createElement(Fragment))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceA = instance

	jestExpect(instanceA).never.toBe(nil)

	ReactNoop.render(React.createElement(Fragment, { condition = true }))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceB = instance

	jestExpect(instanceB).toBe(instanceA)

	ReactNoop.render(React.createElement(Fragment, { condition = false }))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceC = instance

	jestExpect(instanceC).toBe(instanceA)
end)

it("should preserve state in a reorder", function()
	local instance = nil

	local Stateful = React.Component:extend("Stateful")
	function Stateful:render()
		instance = self
		return React.createElement("TextLabel", { Text = "Hello" })
	end

	local function Fragment(props)
		if props.condition then
			return {
				{
					-- ROBLOX FIXME Luau: Luau needs to allow mixed arrays and/or normalize these two things to a common ancestor
					React.createElement(
						"Frame",
						{ key = "b" },
						React.createElement("TextLabel", { Text = "World" })
					) :: any,
					React.createElement(Stateful, { key = "a" }),
				},
			}
		else
			return {
				{
					-- ROBLOX FIXME Luau: Luau needs to allow mixed arrays and/or normalize these two things to a common ancestor
					React.createElement(Stateful, { key = "a" }) :: any,
					React.createElement(
						"Frame",
						{ key = "b" },
						React.createElement("TextLabel", { Text = "World" })
					),
				} :: any,
				React.createElement("Frame", { key = "c" }),
			}
		end
	end

	ReactNoop.render(React.createElement(Fragment))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceA = instance
	jestExpect(instanceA).never.toBe(nil)

	ReactNoop.render(React.createElement(Fragment, { condition = true }))
	jestExpect(Scheduler).toFlushWithoutYielding()

	local instanceB = instance

	jestExpect(instanceB).toBe(instanceA)
end) ]]
eC.Children._f99737ecb569cfa627dcab5cd4b63b8a=fy
local fz

local fA={ClassName="ModuleScript",Children={},Properties={}}
fA.Name="ReactTopLevelText.spec"
fA.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/69060e1da6061af845162dcf6854a5d9af28350a/packages/react-reconciler/src/__tests__/ReactTopLevelText-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]
--!strict

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler

-- This is a new feature in Fiber so I put it in its own test file. It could
-- probably move to one of the other test files once it is official.
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest
local describe = JestGlobals.describe

describe("ReactTopLevelText", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)
		Scheduler = require(Packages.Scheduler)
	end)

	it("should render a component returning strings directly from render", function()
		local Text = function(props)
			return props.value
		end
		ReactNoop.render(React.createElement(Text, { value = "foo" }))
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput("foo")
	end)

	it("should render a component returning numbers directly from renderß", function()
		local Text = function(props)
			return props.value
		end
		ReactNoop.render(React.createElement(Text, { value = 10 }))
		jestExpect(Scheduler).toFlushWithoutYielding()

		jestExpect(ReactNoop).toMatchRenderedOutput("10")
	end)
end) ]]
eC.Children._2013dd2d16ec7fa8be0bbfabd3e37e24=fA
local fB

local fC={ClassName="ModuleScript",Children={},Properties={}}
fC.Name="ReactUpdateQueue.roblox.spec"
fC.Properties.Source=[[ --\[\[*
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest
local describe = JestGlobals.describe

local React

local ReactUpdateQueue, Fiber, FiberLane
local fundamentalFiber, component, update, lane, setStateCallbackWasCalled, workInProgress

local updateTime = 0
local nextProps = { userName = "Dan" }
local updatePayload = { myVariable = 90210 }

beforeEach(function()
	jest.resetModules()

	React = require(Packages.React)
	ReactUpdateQueue = require(script.Parent.Parent["ReactUpdateQueue.new"])
	Fiber = require(script.Parent.Parent["ReactFiber.new"])
	FiberLane = require(script.Parent.Parent.ReactFiberLane)

	component = React.Component:extend("fundamental")
	fundamentalFiber = Fiber.createFiberFromFundamental(component)

	lane = FiberLane.NoLane
	update = ReactUpdateQueue.createUpdate(updateTime, lane)
	setStateCallbackWasCalled = false
	update.payload = updatePayload
	update.callback = function()
		setStateCallbackWasCalled = true
	end
	update.lane = lane
end)

describe("new ReactUpdateQueue", function()
	it("does not have force update", function()
		jestExpect(ReactUpdateQueue.checkHasForceUpdateAfterProcessing()).toEqual(false)
	end)

	it("enqueue before initialize is a no-op", function()
		workInProgress = Fiber.createWorkInProgress(fundamentalFiber, {})
		ReactUpdateQueue.enqueueUpdate(workInProgress, update)
		jestExpect(workInProgress.updateQueue).toEqual(nil)
	end)
end)

describe("initialized ReactUpdateQueue", function()
	beforeEach(function()
		ReactUpdateQueue.initializeUpdateQueue(workInProgress)
	end)

	it("initializes fiber", function()
		jestExpect(workInProgress.updateQueue).toBeDefined()
	end)

	it("enqueues first update", function()
		jestExpect(update.tag).toBe(0)

		ReactUpdateQueue.enqueueUpdate(workInProgress, update)
		jestExpect(update.next).toBe(update)
		jestExpect(workInProgress.updateQueue.shared.pending).toBe(update)
	end)

	it("enqueues same update twice", function()
		ReactUpdateQueue.enqueueUpdate(workInProgress, update)
		ReactUpdateQueue.enqueueUpdate(workInProgress, update)

		jestExpect(update.next).toBe(update)
		jestExpect(update.next.next).toBe(update)
		jestExpect(workInProgress.updateQueue.shared.pending).toBe(update)
	end)
end)

describe("processUpdateQueue", function()
	beforeEach(function()
		ReactUpdateQueue.initializeUpdateQueue(fundamentalFiber)
		workInProgress = Fiber.createWorkInProgress(fundamentalFiber, nextProps)
	end)

	it("with empty queue", function()
		ReactUpdateQueue.processUpdateQueue(
			workInProgress,
			nextProps,
			component,
			FiberLane.NoLanes
		)

		jestExpect(workInProgress.memoizedState).toBe(nil)
	end)

	it("with non-empty queue", function()
		ReactUpdateQueue.enqueueUpdate(workInProgress, update)
		jestExpect(workInProgress.memoizedState).toBe(nil)

		ReactUpdateQueue.processUpdateQueue(
			workInProgress,
			nextProps,
			component,
			FiberLane.NoLanes
		)

		jestExpect(setStateCallbackWasCalled).toBe(false)
		jestExpect(workInProgress.memoizedState).toEqual(updatePayload)
	end)
end)

describe("commitUpdateQueue", function()
	beforeEach(function()
		lane = FiberLane.SomeRetryLane
		update = ReactUpdateQueue.createUpdate(updateTime, lane)
		setStateCallbackWasCalled = false
		update.payload = updatePayload
		update.callback = function()
			setStateCallbackWasCalled = true
		end
		update.lane = lane
		ReactUpdateQueue.initializeUpdateQueue(fundamentalFiber)
		workInProgress = Fiber.createWorkInProgress(fundamentalFiber, nextProps)
	end)

	it("with non-empty queue", function()
		-- our update is Retry, since NoLane means the callback was already committed
		ReactUpdateQueue.enqueueUpdate(workInProgress, update)
		jestExpect(workInProgress.memoizedState).toBe(nil)

		-- we use RetryLanes here because the update lane needs to be a subset of that
		ReactUpdateQueue.processUpdateQueue(
			workInProgress,
			nextProps,
			component,
			FiberLane.RetryLanes
		)
		jestExpect(fundamentalFiber.updateQueue.effects).never.toBe(nil)

		ReactUpdateQueue.commitUpdateQueue(
			workInProgress,
			fundamentalFiber.updateQueue,
			component
		)

		jestExpect(setStateCallbackWasCalled).toBe(true)
	end)
end)

describe("enqueueCapturedUpdate", function()
	beforeEach(function()
		lane = FiberLane.NoLane
		update = ReactUpdateQueue.createUpdate(updateTime, lane)
		update.tag = ReactUpdateQueue.CaptureUpdate
		update.lane = lane
		ReactUpdateQueue.initializeUpdateQueue(fundamentalFiber)
		workInProgress = Fiber.createWorkInProgress(fundamentalFiber, nextProps)
		local ReactFiberFlags = require(script.Parent.Parent.ReactFiberFlags)
		workInProgress.flags = bit32.bor(0, ReactFiberFlags.ShouldCapture)
	end)

	it("sets lastBaseUpdate", function()
		ReactUpdateQueue.enqueueCapturedUpdate(workInProgress, update)

		jestExpect(workInProgress.updateQueue.lastBaseUpdate).toEqual(update)
	end)
end) ]]
eC.Children._0723cf70d059620f92a8e150f0b3216d=fC
local fD

local fE={ClassName="ModuleScript",Children={},Properties={}}
fE.Name="ReactUseRef.roblox.spec"
fE.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local React
local ReactRoblox
local Scheduler

--ROBLOX NOTE: Tests for the Bindings-based useRef approach
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local useRef

describe("useRef", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactRoblox = require(Packages.Dev.ReactRoblox)
		Scheduler = require(Packages.Scheduler)
		useRef = React.useRef
	end)

	it("should assign initial value to the ref", function()
		local refNumber
		local refString
		local function component()
			refNumber = useRef(123)
			refString = useRef("HelloRef")
			return nil
		end

		local container = Instance.new("Folder")
		local root = ReactRoblox.createRoot(container)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		jestExpect(refNumber).toBeDefined()
		jestExpect(refNumber.current).toBe(123)
		jestExpect(refString).toBeDefined()
		jestExpect(refString.current).toBe("HelloRef")

		root:unmount()
	end)

	it("should allow current value to be updated", function()
		local refNumber
		local function component()
			refNumber = useRef(123)

			React.useEffect(function()
				refNumber.current = 456
			end, {})

			return nil
		end

		local container = Instance.new("Folder")
		local root = ReactRoblox.createRoot(container)

		root:render(React.createElement(component))

		-- ROBLOX Test Noise: jest setup config hides "act not enabled in
		-- prod" warnings (scripts/jest/setupTests.js:72)
		Scheduler.unstable_flushAll()

		jestExpect(refNumber).toBeDefined()
		jestExpect(refNumber.current).toBe(456)
	end)

	it("should remember current value between renders", function()
		local countRef
		local function component()
			countRef = useRef(0)
			countRef.current += 1
			return nil
		end

		local container = Instance.new("Folder")
		local root = ReactRoblox.createRoot(container)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		jestExpect(countRef).toBeDefined()
		local count1 = countRef.current
		jestExpect(count1).toBeGreaterThan(0)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		local count2 = countRef.current
		jestExpect(count2).toBeGreaterThan(count1)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		local count3 = countRef.current
		jestExpect(count3).toBeGreaterThan(count2)

		root:unmount()
	end)

	it("should bind to NextSelection props without error", function()
		local bottomRef
		local function component()
			bottomRef = useRef(nil)

			return React.createElement(React.Fragment, {}, {
				Top = React.createElement("Frame", {
					Size = UDim2.fromScale(1, 0.5),
					NextSelectionUp = bottomRef,
					NextSelectionDown = bottomRef,
					NextSelectionLeft = bottomRef,
					NextSelectionRight = bottomRef,
				}),
				Bottom = React.createElement("Frame", {
					Size = UDim2.fromScale(1, 0.5),
					Position = UDim2.fromScale(0, 0.5),
					ref = bottomRef,
				}),
			})
		end

		local container = Instance.new("Folder")
		local root = ReactRoblox.createRoot(container)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		jestExpect(bottomRef).toBeDefined()
		jestExpect(bottomRef.current).toMatchInstance({
			Name = "Bottom",
		})

		root:unmount()
	end)

	it("should stringify refs correctly", function()
		local frameRef
		local function component()
			frameRef = useRef(nil)

			return React.createElement("Frame", {
				Size = UDim2.new(1, 0, 1, 0),
				ref = frameRef,
			})
		end

		local container = Instance.new("Folder")
		local root = ReactRoblox.createRoot(container)

		root:render(React.createElement(component))

		Scheduler.unstable_flushAll()

		jestExpect(frameRef).toBeDefined()
		jestExpect(tostring(frameRef)).toEqual("Ref(Frame)")

		root:unmount()
	end)
end) ]]
eC.Children._f3fe2bdd889b3847a6cd2255baa92421=fE
local fF

local fG={ClassName="ModuleScript",Children={},Properties={}}
fG.Name="SchedulingProfiler-internal.spec"
fG.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/8af27aeedbc6b00bc2ef49729fc84f116c70a27c/packages/react-reconciler/src/__tests__/SchedulingProfiler-test.internal.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */
local Packages = script.Parent.Parent.Parent
local ReactVersion = require(Packages.Shared).ReactVersion
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local jest = JestGlobals.jest
local describe = JestGlobals.describe
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Promise = require(Packages.Promise)

describe("SchedulingProfiler", function()
	local React
	local ReactTestRenderer
	local ReactNoop
	local Scheduler

	local marks

	local function createUserTimingPolyfill()
		-- This is not a true polyfill, but it gives us enough to capture marks.
		-- Reference: https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API
		return {
			mark = function(markName)
				table.insert(marks, markName)
			end,
		}
	end

	beforeEach(function()
		jest.resetModules()
		_G.performance = createUserTimingPolyfill()
		marks = {}

		local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.enableSchedulingProfiler = true
		ReactFeatureFlags.enableProfilerTimer = true
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = true
		ReactFeatureFlags.enableSuspenseServerRenderer = true
		ReactFeatureFlags.decoupleUpdatePriorityFromScheduler = true

		ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false
		ReactFeatureFlags.enableDebugTracing = false
		ReactFeatureFlags.warnAboutDeprecatedLifecycles = true
		ReactFeatureFlags.enableProfilerCommitHooks = false
		ReactFeatureFlags.enableSelectiveHydration = false
		ReactFeatureFlags.enableBlocksAPI = false
		ReactFeatureFlags.enableLazyElements = false
		ReactFeatureFlags.disableJavaScriptURLs = false
		ReactFeatureFlags.disableInputAttributeSyncing = false
		ReactFeatureFlags.enableSchedulerDebugging = false
		ReactFeatureFlags.enableFundamentalAPI = false
		ReactFeatureFlags.enableScopeAPI = false
		ReactFeatureFlags.enableCreateEventHandleAPI = false
		ReactFeatureFlags.warnAboutUnmockedScheduler = false
		ReactFeatureFlags.enableSuspenseCallback = false
		ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents = false
		ReactFeatureFlags.warnAboutStringRefs = false
		ReactFeatureFlags.disableLegacyContext = false
		ReactFeatureFlags.disableSchedulerTimeoutBasedOnReactExpirationTime = false
		ReactFeatureFlags.enableTrustedTypesIntegration = false
		ReactFeatureFlags.disableTextareaChildren = false
		ReactFeatureFlags.disableModulePatternComponents = false
		ReactFeatureFlags.warnUnstableRenderSubtreeIntoContainer = false
		ReactFeatureFlags.warnAboutSpreadingKeyToJSX = false
		ReactFeatureFlags.enableComponentStackLocations = true
		ReactFeatureFlags.enableLegacyFBSupport = false
		ReactFeatureFlags.enableFilterEmptyStringAttributesDOM = false
		ReactFeatureFlags.skipUnmountedBoundaries = false

		ReactFeatureFlags.enableNewReconciler = false
		ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch = true
		ReactFeatureFlags.enableDiscreteEventFlushingChange = false
		ReactFeatureFlags.enableEagerRootListeners = true

		ReactFeatureFlags.enableDoubleInvokingEffects = false

		React = require(Packages.React)

		-- ReactNoop must be imported after ReactTestRenderer!
		ReactTestRenderer = require(Packages.Dev.ReactTestRenderer)
		ReactNoop = require(Packages.Dev.ReactNoopRenderer)

		Scheduler = require(Packages.Scheduler)
	end)

	afterEach(function()
		_G.performance = nil
	end)

	-- @gate !enableSchedulingProfiler
	xit("should not mark if enableSchedulingProfiler is false", function()
		ReactTestRenderer.create(React.createElement("div"))
		jestExpect(marks).toEqual({})
	end)

	-- @gate enableSchedulingProfiler
	it("should log React version on initialization", function()
		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark sync render without suspends or state updates", function()
		ReactTestRenderer.create(React.createElement("div"))

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-1",
			"--render-start-1",
			"--render-stop",
			"--commit-start-1",
			"--layout-effects-start-1",
			"--layout-effects-stop",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark concurrent render without suspends or state updates", function()
		ReactTestRenderer.create(
			React.createElement("div"),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--layout-effects-stop",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark render yields", function()
		local function Bar()
			Scheduler.unstable_yieldValue("Bar")
			return nil
		end

		local function Foo()
			Scheduler.unstable_yieldValue("Foo")
			return React.createElement(Bar)
		end

		ReactNoop.render(React.createElement(Foo))
		-- Do one step of work.
		jestExpect(ReactNoop.flushNextYield()).toEqual({ "Foo" })

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
			"--render-start-512",
			"--render-yield",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark sync render with suspense that resolves", function()
		-- ROBLOX deviation: can't just Promise.resolve() due to evaera Promise issue
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			return true
		end)
		local function Example()
			error(fakeSuspensePromise)
		end

		ReactTestRenderer.create(React.createElement(
			React.Suspense,
			-- ROBLOX deviation: Lua can't express 'empty' fallback with nil, so we use empty array
			{ fallback = {} },
			React.createElement(Example)
		))

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-1",
			"--render-start-1",
			"--suspense-suspend-0-Example",
			"--render-stop",
			"--commit-start-1",
			"--layout-effects-start-1",
			"--layout-effects-stop",
			"--commit-stop",
		})

		Array.splice(marks, 1)

		fakeSuspensePromise:await()
		jestExpect(marks).toEqual({ "--suspense-resolved-0-Example" })
	end)

	-- @gate enableSchedulingProfiler
	it("should mark sync render with suspense that rejects", function()
		-- ROBLOX deviation: can't just Promise.reject() due to evaera Promise issue
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			error(Error.new("error"))
		end)
		local function Example()
			error(fakeSuspensePromise)
		end

		ReactTestRenderer.create(React.createElement(
			React.Suspense,
			-- ROBLOX deviation: Lua can't express 'empty' fallback with nil, so we use empty array
			{ fallback = {} },
			React.createElement(Example)
		))

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-1",
			"--render-start-1",
			"--suspense-suspend-0-Example",
			"--render-stop",
			"--commit-start-1",
			"--layout-effects-start-1",
			"--layout-effects-stop",
			"--commit-stop",
		})

		Array.splice(marks, 1)

		-- ROBLOX deviation: jest-roblox doesn't support these Promise matchers yet
		-- await jestExpect(fakeSuspensePromise).rejects.toThrow()
		jestExpect(function()
			fakeSuspensePromise:expect()
		end).toThrow()

		jestExpect(marks).toEqual({ "--suspense-rejected-0-Example" })
	end)

	-- @gate enableSchedulingProfiler
	it("should mark concurrent render with suspense that resolves", function()
		-- ROBLOX deviation: can't just Promise.resolve() due to evaera Promise issue
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			return true
		end)
		local function Example()
			error(fakeSuspensePromise)
		end

		ReactTestRenderer.create(
			React.createElement(
				React.Suspense,
				-- ROBLOX deviation: Lua can't express 'empty' fallback with nil, so we use empty array
				{ fallback = {} },
				React.createElement(Example)
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--suspense-suspend-0-Example",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--layout-effects-stop",
			"--commit-stop",
		})

		Array.splice(marks, 1)

		fakeSuspensePromise:expect()

		jestExpect(marks).toEqual({ "--suspense-resolved-0-Example" })
	end)

	-- @gate enableSchedulingProfiler
	it("should mark concurrent render with suspense that rejects", function()
		-- ROBLOX deviation: can't just Promise.reject() due to evaera Promise issue
		local fakeSuspensePromise = Promise.delay(0):andThen(function()
			error(Error.new("error"))
		end)

		local function Example()
			error(fakeSuspensePromise)
		end

		ReactTestRenderer.create(
			React.createElement(
				React.Suspense,
				-- ROBLOX deviation: Lua can't express 'empty' fallback with nil, so we use empty array
				{ fallback = {} },
				React.createElement(Example)
			),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--suspense-suspend-0-Example",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--layout-effects-stop",
			"--commit-stop",
		})

		Array.splice(marks, 1)

		-- ROBLOX deviation: jest-roblox doesn't support these Promise matchers yet
		-- await jestExpect(fakeSuspensePromise).rejects.toThrow()
		jestExpect(function()
			fakeSuspensePromise:expect()
		end).toThrow()
		jestExpect(marks).toEqual({ "--suspense-rejected-0-Example" })
	end)

	-- @gate enableSchedulingProfiler
	it("should mark cascading class component state updates", function()
		local Example = React.Component:extend("Example")
		function Example:init()
			self.state = { didMount = false }
		end
		function Example:componentDidMount()
			self:setState({ didMount = true })
		end
		function Example:render()
			return nil
		end

		ReactTestRenderer.create(
			React.createElement(Example),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--schedule-state-update-1-Example",
			"--layout-effects-stop",
			"--render-start-1",
			"--render-stop",
			"--commit-start-1",
			"--commit-stop",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark cascading class component force updates", function()
		local Example = React.Component:extend("Example")
		function Example:componentDidMount()
			self:forceUpdate()
		end
		function Example:render()
			return nil
		end

		ReactTestRenderer.create(
			React.createElement(Example),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--schedule-forced-update-1-Example",
			"--layout-effects-stop",
			"--render-start-1",
			"--render-stop",
			"--commit-start-1",
			"--commit-stop",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark render phase state updates for class component", function()
		local Example = React.Component:extend("Example")
		function Example:init()
			self.state = { didRender = false }
		end
		function Example:render()
			if self.state.didRender == false then
				self:setState({ didRender = true })
			end
			return nil
		end

		ReactTestRenderer.create(
			React.createElement(Example),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toErrorDev("Cannot update during an existing state transition")

		-- ROBLOX FIXME: no way to gate feature tests like upstream
		-- gate(({old}) =>
		--   old
		jestExpect(marks).toContain("--schedule-state-update-1024-Example")
		-- jestExpect(marks).toContain('--schedule-state-update-512-Example')
		-- )
	end)

	-- @gate enableSchedulingProfiler
	it("should mark render phase force updates for class component", function()
		local Example = React.Component:extend("Example")
		function Example:init()
			self.state = { didRender = false }
		end
		function Example:render()
			if self.state.didRender == false then
				self:forceUpdate(function()
					self:setState({ didRender = true })
				end)
			end
			return nil
		end

		ReactTestRenderer.create(
			React.createElement(Example),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(function()
			jestExpect(Scheduler).toFlushUntilNextPaint({})
		end).toErrorDev("Cannot update during an existing state transition")

		-- ROBLOX TODO: we have no way to gate tests on features like upstream
		-- gate(({old}) =>
		--   old
		jestExpect(marks).toContain("--schedule-forced-update-1024-Example")
		-- jestExpect(marks).toContain('--schedule-forced-update-512-Example')
		-- )
	end)

	-- @gate enableSchedulingProfiler
	it("should mark cascading layout updates", function()
		local function Example()
			local didMount, setDidMount = React.useState(false)
			React.useLayoutEffect(function()
				setDidMount(true)
			end, {})
			return didMount
		end

		ReactTestRenderer.create(
			React.createElement(Example),
			{ unstable_isConcurrent = true }
		)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
		})

		Array.splice(marks, 1)

		jestExpect(Scheduler).toFlushUntilNextPaint({})

		jestExpect(marks).toEqual({
			"--render-start-512",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--schedule-state-update-1-Example",
			"--layout-effects-stop",
			"--render-start-1",
			"--render-stop",
			"--commit-start-1",
			"--commit-stop",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark cascading passive updates", function()
		local function Example()
			local didMount, setDidMount = React.useState(false)
			React.useEffect(function()
				setDidMount(true)
			end, {})
			return didMount
		end

		ReactTestRenderer.unstable_concurrentAct(function()
			ReactTestRenderer.create(
				React.createElement(Example),
				{ unstable_isConcurrent = true }
			)
		end)

		jestExpect(marks).toEqual({
			"--react-init-" .. tostring(ReactVersion),
			"--schedule-render-512",
			"--render-start-512",
			"--render-stop",
			"--commit-start-512",
			"--layout-effects-start-512",
			"--layout-effects-stop",
			"--commit-stop",
			"--passive-effects-start-512",
			"--schedule-state-update-1024-Example",
			"--passive-effects-stop",
			"--render-start-1024",
			"--render-stop",
			"--commit-start-1024",
			"--commit-stop",
		})
	end)

	-- @gate enableSchedulingProfiler
	it("should mark render phase updates", function()
		local function Example()
			local didRender, setDidRender = React.useState(false)
			if not didRender then
				setDidRender(true)
			end
			return didRender
		end

		ReactTestRenderer.unstable_concurrentAct(function()
			ReactTestRenderer.create(
				React.createElement(Example),
				{ unstable_isConcurrent = true }
			)
		end)

		-- ROBLOX TODO: we don't have a way to gate tests based on features like upstream does
		-- gate(({old}) =>
		--   old
		jestExpect(marks).toContain("--schedule-state-update-1024-Example")
		--     : jestExpect(marks).toContain('--schedule-state-update-512-Example'),
		-- )
	end)
end) ]]
eC.Children._91cd5b187cf588e3ce49b29231c5187e=fG
local fH

local fI={ClassName="ModuleScript",Children={},Properties={}}
fI.Name="useMutableSource-internal.spec"
fI.Properties.Source=[[ -- Upstream: https://github.com/facebook/react/blob/d13f5b9538e48f74f7c571ef3cde652ca887cca0/packages/react-reconciler/src/__tests__/useMutableSource-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent
local React
local ReactNoop
local Scheduler
local act
local createMutableSource
local useMutableSource

local LuauPolyfill = require(Packages.LuauPolyfill)
local Promise = require(Packages.Promise)
local Array = LuauPolyfill.Array

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit
local describe = JestGlobals.describe

local function loadModules()
	jest.resetModules()
	jest.useFakeTimers()
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.enableSchedulerTracing = true
	ReactFeatureFlags.enableProfilerTimer = true
	React = require(Packages.React)
	ReactNoop = require(Packages.Dev.ReactNoopRenderer)
	Scheduler = require(Packages.Scheduler)
	act = ReactNoop.act
	createMutableSource = React.createMutableSource
	useMutableSource = React.useMutableSource
end

describe("useMutableSource", function()
	local defaultGetSnapshot = function(source)
		return source.value
	end
	local defaultSubscribe = function(source, callback)
		if callback ~= nil then
			return source.subscribe(callback)
		end
		-- ROBLOX deviation: Lua can't insert nils into the callbacks array, so insert a no-op instread
		return source.subscribe(function() end)
	end

	local function createComplexSource(initialValueA, initialValueB)
		local callbacksA = {}
		local callbacksB = {}
		local revision = 1
		local valueA = initialValueA
		local valueB = initialValueB
		local subscribeHelper = function(callbacks, callback)
			if Array.indexOf(callbacks, callback) < 1 then
				table.insert(callbacks, callback)
			end

			return function()
				local index = Array.indexOf(callbacks, callback)

				if index >= 1 then
					Array.splice(callbacks, index, 1)
				end
			end
		end

		local metatable = {
			__index = function(table, key)
				if key == "listenerCountA" then
					return #callbacksA
				elseif key == "listenerCountB" then
					return #callbacksB
				elseif key == "valueA" then
					return valueA
				elseif key == "valueB" then
					return valueB
				elseif key == "version" then
					return revision
				end
				return
			end,
			__newindex = function(table, key, newValue)
				if key == "valueA" then
					revision += 1
					valueA = newValue

					Array.map(callbacksA, function(callback)
						return callback()
					end)
				elseif key == "valueB" then
					revision += 1
					valueB = newValue

					Array.map(callbacksB, function(callback)
						return callback()
					end)
				end
			end,
		}

		local tableToReturn = {
			subscribeA = function(callback)
				return subscribeHelper(callbacksA, callback)
			end,
			subscribeB = function(callback)
				return subscribeHelper(callbacksB, callback)
			end,
		}
		return setmetatable(tableToReturn, metatable)
	end
	local function createSource(initialValue)
		local callbacks = {}
		local revision = 1
		local value = initialValue

		local metatable = {
			__index = function(table, key)
				if key == "value" then
					return value
				elseif key == "version" then
					return revision
				elseif key == "listenerCount" then
					return #callbacks
				end
				return
			end,
			__newindex = function(table, key, newValue)
				if key == "value" then
					revision += 1
					value = newValue

					-- deviation: forEach() translated using Array.map
					Array.map(callbacks, function(callback)
						return callback()
					end)
				end
			end,
		}
		local tableToReturn = {
			subscribe = function(callback)
				if Array.indexOf(callbacks, callback) < 1 then
					table.insert(callbacks, callback)
				end

				return function()
					local index = Array.indexOf(callbacks, callback)

					if index >= 1 then
						Array.splice(callbacks, index, 1)
					end
				end
			end,
		}
		return setmetatable(tableToReturn, metatable)
	end
	local function Component(props)
		local getSnapshot, label, mutableSource, subscribe =
			props.getSnapshot, props.label, props.mutableSource, props.subscribe
		local snapshot = useMutableSource(mutableSource, getSnapshot, subscribe)
		Scheduler.unstable_yieldValue(string.format("%s:%s", label, snapshot))

		return React.createElement("div", nil, string.format("%s:%s", label, snapshot))
	end

	beforeEach(function()
		loadModules()
	end)
	-- @gate experimental
	it("should subscribe to a source and schedule updates when it changes", function()
		local source = createSource("one")
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)

		act(function()
			ReactNoop.renderToRootWithID(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					}),
					React.createElement(Component, {
						label = "b",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					})
				),
				"root",
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:one",
				"b:one",
				"Sync effect",
			})
			-- Subscriptions should be passive
			jestExpect(source.listenerCount).toEqual(0)
			ReactNoop.flushPassiveEffects()
			jestExpect(source.listenerCount).toEqual(2)

			-- Changing values should schedule an update with React
			source.value = "two"

			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:two",
				"b:two",
			})

			-- Umounting a component should remove its subscription.
			ReactNoop.renderToRootWithID(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					})
				),
				"root",
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"a:two",
				"Sync effect",
			})
			ReactNoop.flushPassiveEffects()
			jestExpect(source.listenerCount).toEqual(1)

			-- Umounting a root should remove the remaining event listeners
			ReactNoop.unmountRootWithID("root")
			jestExpect(Scheduler).toFlushAndYield({})
			ReactNoop.flushPassiveEffects()
			jestExpect(source.listenerCount).toEqual(0)

			-- Changes to source should not trigger an updates or warnings.
			source.value = "three"

			jestExpect(Scheduler).toFlushAndYield({})
		end)
	end)
	-- @gate experimental
	it("should restart work if a new source is mutated during render", function()
		local source = createSource("one")
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)

		act(function()
			ReactNoop.render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					}),
					React.createElement(Component, {
						label = "b",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					})
				),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)

			-- Do enough work to read from one component
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:one",
			})
			-- Mutate source before continuing work
			source.value = "two"

			-- Render work should restart and the updated value should be used
			jestExpect(Scheduler).toFlushAndYield({
				"a:two",
				"b:two",
				"Sync effect",
			})
		end)
	end)
	-- @gate experimental
	it(
		"should schedule an update if a new source is mutated between render and commit (subscription)",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)

				-- Finish rendering
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"a:one",
					"b:one",
					"Sync effect",
				})

				-- Mutate source before subscriptions are attached
				jestExpect(source.listenerCount).toEqual(0)

				source.value = "two"

				-- Mutation should be detected, and a new render should be scheduled
				jestExpect(Scheduler).toFlushAndYield({
					"a:two",
					"b:two",
				})
			end)
		end
	)
	-- @gate experimental
	it("should unsubscribe and resubscribe if a new source is used", function()
		local sourceA = createSource("a-one")
		local mutableSourceA = createMutableSource(sourceA, function(param)
			return param.versionA
		end)
		local sourceB = createSource("b-one")
		local mutableSourceB = createMutableSource(sourceB, function(param)
			return param.versionB
		end)

		act(function()
			ReactNoop.render(
				React.createElement(Component, {
					label = "only",
					getSnapshot = defaultGetSnapshot,
					mutableSource = mutableSourceA,
					subscribe = defaultSubscribe,
				}),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"only:a-one",
				"Sync effect",
			})
			ReactNoop.flushPassiveEffects()
			jestExpect(sourceA.listenerCount).toEqual(1)

			-- Changing values should schedule an update with React
			sourceA.value = "a-two"

			jestExpect(Scheduler).toFlushAndYield({
				"only:a-two",
			})

			-- If we re-render with a new source, the old one should be unsubscribed.
			ReactNoop.render(
				React.createElement(Component, {
					label = "only",
					getSnapshot = defaultGetSnapshot,
					mutableSource = mutableSourceB,
					subscribe = defaultSubscribe,
				}),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"only:b-one",
				"Sync effect",
			})
			ReactNoop.flushPassiveEffects()
			jestExpect(sourceA.listenerCount).toEqual(0)
			jestExpect(sourceB.listenerCount).toEqual(1)

			-- Changing to original source should not schedule updates with React
			sourceA.value = "a-three"

			jestExpect(Scheduler).toFlushAndYield({})

			-- Changing new source value should schedule an update with React
			sourceB.value = "b-two"

			jestExpect(Scheduler).toFlushAndYield({
				"only:b-two",
			})
		end)
	end)

	it(
		"should unsubscribe and resubscribe if a new subscribe function is provided",
		function()
			local source = createSource("a-one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			local unsubscribeA = jest.fn()
			local subscribeA = jest.fn(function(s)
				local unsubscribe = defaultSubscribe(s)

				return function()
					unsubscribe()
					unsubscribeA()
				end
			end)

			local unsubscribeB = jest.fn()
			local subscribeB = jest.fn(function(s)
				local unsubscribe = defaultSubscribe(s)

				return function()
					unsubscribe()
					unsubscribeB()
				end
			end)

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Component, {
						label = "only",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = subscribeA,
					}),
					"root",
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"only:a-one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(source.listenerCount).toEqual(1)
				jestExpect(subscribeA).toHaveBeenCalledTimes(1)
				ReactNoop.renderToRootWithID(
					React.createElement(Component, {
						label = "only",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = subscribeB,
					}),
					"root",
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"only:a-one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(source.listenerCount).toEqual(1)
				jestExpect(unsubscribeA).toHaveBeenCalledTimes(1)
				jestExpect(subscribeB).toHaveBeenCalledTimes(1)
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYield({})
				ReactNoop.flushPassiveEffects()
				jestExpect(source.listenerCount).toEqual(0)
				jestExpect(unsubscribeB).toHaveBeenCalledTimes(1)
			end)
		end
	)
	it("should re-use previously read snapshot value when reading is unsafe", function()
		local source = createSource("one")
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)

		act(function()
			ReactNoop.render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					}),
					React.createElement(Component, {
						label = "b",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					})
				),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"a:one",
				"b:one",
				"Sync effect",
			})

			-- Changing values should schedule an update with React.
			-- Start working on this update but don't finish it.
			source.value = "two"

			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:two",
			})

			-- Re-renders that occur before the update is processed
			-- should reuse snapshot so long as the config has not changed
			ReactNoop.flushSync(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"a:one",
				"b:one",
				"Sync effect",
			})
			jestExpect(Scheduler).toFlushAndYield({
				"a:two",
				"b:two",
			})
		end)
	end)
	-- @gate experimental
	it(
		"should read from source on newly mounted subtree if no pending updates are scheduled for source",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"a:one",
					"Sync effect",
				})
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"a:one",
					"b:one",
					"Sync effect",
				})
			end)
		end
	)
	-- @gate experimental
	it(
		"should throw and restart render if source and snapshot are unavailable during an update",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"a:one",
					"b:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				-- Changing values should schedule an update with React.
				-- Start working on this update but don't finish it.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_LowPriority,
					function()
						source.value = "two"

						jestExpect(Scheduler).toFlushAndYieldThrough({
							"a:two",
						})
					end
				)

				local newGetSnapshot = function(s)
					return "new:" .. defaultGetSnapshot(s)
				end

				-- Force a higher priority render with a new config.
				-- This should signal that the snapshot is not safe and trigger a full re-render.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_UserBlockingPriority,
					function()
						ReactNoop.render(
							React.createElement(
								React.Fragment,
								nil,
								React.createElement(Component, {
									label = "a",
									getSnapshot = newGetSnapshot,
									mutableSource = mutableSource,
									subscribe = defaultSubscribe,
								}),
								React.createElement(Component, {
									label = "b",
									getSnapshot = newGetSnapshot,
									mutableSource = mutableSource,
									subscribe = defaultSubscribe,
								})
							),
							function()
								return Scheduler.unstable_yieldValue("Sync effect")
							end
						)
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"a:new:two",
					"b:new:two",
					"Sync effect",
				})
			end)
		end
	)
	-- @gate experimental
	it(
		"should throw and restart render if source and snapshot are unavailable during a sync update",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"a:one",
					"b:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				-- Changing values should schedule an update with React.
				-- Start working on this update but don't finish it.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_LowPriority,
					function()
						source.value = "two"

						jestExpect(Scheduler).toFlushAndYieldThrough({
							"a:two",
						})
					end
				)

				local newGetSnapshot = function(s)
					return "new:" .. defaultGetSnapshot(s)
				end
				-- Force a higher priority render with a new config.
				-- This should signal that the snapshot is not safe and trigger a full re-render.
				ReactNoop.flushSync(function()
					ReactNoop.render(
						React.createElement(
							React.Fragment,
							nil,
							React.createElement(Component, {
								label = "a",
								getSnapshot = newGetSnapshot,
								mutableSource = mutableSource,
								subscribe = defaultSubscribe,
							}),
							React.createElement(Component, {
								label = "b",
								getSnapshot = newGetSnapshot,
								mutableSource = mutableSource,
								subscribe = defaultSubscribe,
							})
						),
						function()
							return Scheduler.unstable_yieldValue("Sync effect")
						end
					)
				end)
				jestExpect(Scheduler).toHaveYielded({
					"a:new:two",
					"b:new:two",
					"Sync effect",
				})
			end)
		end
	)
	-- @gate experimental
	it("should only update components whose subscriptions fire", function()
		local source = createComplexSource("a:one", "b:one")
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)
		-- Subscribe to part of the store.
		local getSnapshotA = function(s)
			return s.valueA
		end
		local subscribeA = function(s, callback)
			return s.subscribeA(callback)
		end
		local getSnapshotB = function(s)
			return s.valueB
		end
		local subscribeB = function(s, callback)
			return s.subscribeB(callback)
		end

		act(function()
			ReactNoop.render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = getSnapshotA,
						mutableSource = mutableSource,
						subscribe = subscribeA,
					}),
					React.createElement(Component, {
						label = "b",
						getSnapshot = getSnapshotB,
						mutableSource = mutableSource,
						subscribe = subscribeB,
					})
				),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"a:a:one",
				"b:b:one",
				"Sync effect",
			})

			-- Changes to part of the store (e.g. A) should not render other parts.
			source.valueA = "a:two"

			jestExpect(Scheduler).toFlushAndYield({
				"a:a:two",
			})

			source.valueB = "b:two"

			jestExpect(Scheduler).toFlushAndYield({
				"b:b:two",
			})
		end)
	end)

	-- @gate experimental
	it("should detect tearing in part of the store not yet subscribed to", function()
		local source = createComplexSource("a:one", "b:one")
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)

		-- Subscribe to part of the store.
		local getSnapshotA = function(s)
			return s.valueA
		end
		local subscribeA = function(s, callback)
			return s.subscribeA(callback)
		end
		local getSnapshotB = function(s)
			return s.valueB
		end
		local subscribeB = function(s, callback)
			return s.subscribeB(callback)
		end

		act(function()
			-- Because the store has not changed yet, there are no pending updates,
			-- so it is considered safe to read from when we start this render.
			ReactNoop.render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = getSnapshotA,
						mutableSource = mutableSource,
						subscribe = subscribeA,
					})
				),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYield({
				"a:a:one",
				"Sync effect",
			})
			ReactNoop.render(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement(Component, {
						label = "a",
						getSnapshot = getSnapshotA,
						mutableSource = mutableSource,
						subscribe = subscribeA,
					}),
					React.createElement(Component, {
						label = "b",
						getSnapshot = getSnapshotB,
						mutableSource = mutableSource,
						subscribe = subscribeB,
					}),
					React.createElement(Component, {
						label = "c",
						getSnapshot = getSnapshotB,
						mutableSource = mutableSource,
						subscribe = subscribeB,
					})
				),
				function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end
			)
			jestExpect(Scheduler).toFlushAndYieldThrough({
				"a:a:one",
				"b:b:one",
			})

			-- Mutating the source should trigger a tear detection on the next read,
			-- which should throw and re-render the entire tree.
			source.valueB = "b:two"

			jestExpect(Scheduler).toFlushAndYield({
				"a:a:one",
				"b:b:two",
				"c:b:two",
				"Sync effect",
			})
		end)
	end)
	-- ROBLOX TODO: jest.fn
	-- @gate experimental
	it(
		"does not schedule an update for subscriptions that fire with an unchanged snapshot",
		function()
			-- ROBLOX TODO: jest.fn, temporarily uses Component in place of jest:fn(Component)
			local MockComponent = Component
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				ReactNoop.render(
					React.createElement(MockComponent, {
						label = "only",
						getSnapshot = defaultGetSnapshot,
						mutableSource = mutableSource,
						subscribe = defaultSubscribe,
					}),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"only:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(source.listenerCount).toEqual(1)

				-- Notify subscribe function but don't change the value
				source.value = "one"

				jestExpect(Scheduler).toFlushWithoutYielding()
			end)
		end
	)
	-- @gate experimental
	it(
		"should throw and restart if getSnapshot changes between scheduled update and re-render",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local newGetSnapshot = function(s)
				return "new:" .. defaultGetSnapshot(s)
			end
			local getSnapshot, updateGetSnapshot

			local function WrapperWithState()
				-- ROBLOX deviation: useState has 2 returns, not tuple
				getSnapshot, updateGetSnapshot = React.useState(function()
					return defaultGetSnapshot
				end)

				return React.createElement(Component, {
					label = "only",
					getSnapshot = getSnapshot,
					mutableSource = mutableSource,
					subscribe = defaultSubscribe,
				})
			end

			act(function()
				ReactNoop.render(React.createElement(WrapperWithState), function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYield({
					"only:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_LowPriority,
					function()
						-- Change the source (and schedule an update).
						source.value = "two"
					end
				)
				-- Schedule a higher priority update that changes getSnapshot.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_UserBlockingPriority,
					function()
						updateGetSnapshot(function()
							return newGetSnapshot
						end)
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"only:new:two",
				})
			end)
		end
	)
	-- @gate experimental
	it(
		"should recover from a mutation during yield when other work is scheduled",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			act(function()
				-- Start a render that uses the mutable source.
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Component, {
							label = "a",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						}),
						React.createElement(Component, {
							label = "b",
							getSnapshot = defaultGetSnapshot,
							mutableSource = mutableSource,
							subscribe = defaultSubscribe,
						})
					)
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"a:one",
				})

				-- Mutate source
				source.value = "two"

				-- Now render something different.
				ReactNoop.render(React.createElement("div"))
				jestExpect(Scheduler).toFlushAndYield({})
			end)
		end
	)
	-- @gate experimental
	it(
		"should not throw if the new getSnapshot returns the same snapshot value",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local onRenderA = jest.fn()
			local onRenderB = jest.fn()
			local getSnapshot, updateGetSnapshot

			local function WrapperWithState()
				getSnapshot, updateGetSnapshot = React.useState(function()
					return defaultGetSnapshot
				end)

				return React.createElement(Component, {
					label = "b",
					getSnapshot = getSnapshot,
					mutableSource = mutableSource,
					subscribe = defaultSubscribe,
				})
			end

			act(function()
				ReactNoop.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(
							React.Profiler,
							{
								id = "a",
								onRender = onRenderA,
							},
							React.createElement(Component, {
								label = "a",
								getSnapshot = defaultGetSnapshot,
								mutableSource = mutableSource,
								subscribe = defaultSubscribe,
							})
						),
						React.createElement(React.Profiler, {
							id = "b",
							onRender = onRenderB,
						}, React.createElement(WrapperWithState))
					),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"a:one",
					"b:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(onRenderA).toHaveBeenCalledTimes(1)
				jestExpect(onRenderB).toHaveBeenCalledTimes(1)

				-- If B's getSnapshot function updates, but the snapshot it returns is the same,
				-- only B should re-render (to update its state).
				updateGetSnapshot(function()
					return function(s)
						return defaultGetSnapshot(s)
					end
				end)
				jestExpect(Scheduler).toFlushAndYield({
					"b:one",
				})
				ReactNoop.flushPassiveEffects()
				jestExpect(onRenderA).toHaveBeenCalledTimes(1)
				jestExpect(onRenderB).toHaveBeenCalledTimes(2)
			end)
		end
	)

	-- @gate experimental
	it(
		"should not throw if getSnapshot changes but the source can be safely read from anyway",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local newGetSnapshot = function(s)
				return "new:" .. defaultGetSnapshot(s)
			end
			local getSnapshot, updateGetSnapshot

			local function WrapperWithState()
				-- ROBLOX deviation: useState has 2 returns
				getSnapshot, updateGetSnapshot = React.useState(function()
					return defaultGetSnapshot
				end)

				return React.createElement(Component, {
					label = "only",
					getSnapshot = getSnapshot,
					mutableSource = mutableSource,
					subscribe = defaultSubscribe,
				})
			end

			act(function()
				ReactNoop.render(React.createElement(WrapperWithState), function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYield({
					"only:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()

				-- Change the source (and schedule an update)
				-- but also change the snapshot function too.
				ReactNoop.batchedUpdates(function()
					source.value = "two"
					updateGetSnapshot(function()
						return newGetSnapshot
					end)
				end)
				jestExpect(Scheduler).toFlushAndYield({
					"only:new:two",
				})
			end)
		end
	)

	-- ROBLOX FIXME: fails with Error: Should have a queue
	-- @gate experimental
	xit(
		"should still schedule an update if an eager selector throws after a mutation",
		function()
			local source = createSource({
				friends = {
					{
						id = 1,
						name = "Foo",
					},
					{
						id = 2,
						name = "Bar",
					},
				},
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			local function Friend(props)
				local id = props.id
				local getSnapshot = React.useCallback(function(props_)
					local value = props_.value
					-- This selector is intentionally written in a way that will throw
					-- if no matching friend exists in the store.
					return Array.find(value.friends, function(friend)
						return friend.id == id
					end).name
				end, { id })
				local name =
					useMutableSource(mutableSource, getSnapshot, defaultSubscribe)

				Scheduler.unstable_yieldValue(string.format("%s:%s", id, name))

				return React.createElement("li", nil, name)
			end

			local function FriendsList()
				local getSnapshot = React.useCallback(function(props)
					local value = props.value

					return Array.from(value.friends)
				end, {})
				local friends =
					useMutableSource(mutableSource, getSnapshot, defaultSubscribe)

				return React.createElement(
					"ul",
					nil,
					Array.map(friends, function(friend)
						return React.createElement(Friend, {
							key = friend.id,
							id = friend.id,
						})
					end)
				)
			end

			act(function()
				ReactNoop.render(React.createElement(FriendsList), function()
					return Scheduler.unstable_yieldValue("Sync effect")
				end)
				jestExpect(Scheduler).toFlushAndYield({
					"1:Foo",
					"2:Bar",
					"Sync effect",
				})

				-- This mutation will cause the "Bar" component to throw,
				-- since its value will no longer be a part of the store.
				-- Mutable source should still schedule an update though,
				-- which should unmount "Bar" and mount "Baz".
				source.value = {
					friends = {
						{
							id = 1,
							name = "Foo",
						},
						{
							id = 3,
							name = "Baz",
						},
					},
				}

				jestExpect(Scheduler).toFlushAndYield({
					"1:Foo",
					"3:Baz",
				})
			end)
		end
	)

	-- @gate experimental
	it(
		"should not warn about updates that fire between unmount and passive unsubscribe",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			local function Wrapper()
				React.useLayoutEffect(function()
					return function()
						Scheduler.unstable_yieldValue("layout unmount")
					end
				end)

				return React.createElement(Component, {
					label = "only",
					getSnapshot = defaultGetSnapshot,
					mutableSource = mutableSource,
					subscribe = defaultSubscribe,
				})
			end

			act(function()
				ReactNoop.renderToRootWithID(
					React.createElement(Wrapper),
					"root",
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYield({
					"only:one",
					"Sync effect",
				})
				ReactNoop.flushPassiveEffects()

				-- Unmounting a root should remove the remaining event listeners in a passive effect
				ReactNoop.unmountRootWithID("root")
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"layout unmount",
				})

				-- Changes to source should not cause a warning,
				-- even though the unsubscribe hasn't run yet (since it's a pending passive effect).
				source.value = "two"

				jestExpect(Scheduler).toFlushAndYield({})
			end)
		end
	)

	-- @gate experimental
	it(
		"should support inline selectors and updates that are processed after selector change",
		function()
			local source = createSource({
				a = "initial",
				b = "initial",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function mutateB(newB)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'b'
				local tempTable = LuauPolyfill.Object.entries(source.value)
				tempTable.b = newB
				source.value = tempTable
			end
			local function App(props)
				local getSnapshot = props.getSnapshot
				local state =
					useMutableSource(mutableSource, getSnapshot, defaultSubscribe)

				return state
			end

			local root = ReactNoop.createRoot()

			act(function()
				root.render(React.createElement(App, { getSnapshot = getSnapshotA }))
			end)

			jestExpect(root).toMatchRenderedOutput("initial")

			act(function()
				mutateB("Updated B")
				root.render(React.createElement(App, { getSnapshot = getSnapshotB }))
			end)

			jestExpect(root).toMatchRenderedOutput("Updated B")

			act(function()
				mutateB("Another update")
			end)

			jestExpect(root).toMatchRenderedOutput("Another update")
		end
	)

	-- @gate experimental
	it(
		"should clear the update queue when getSnapshot changes with pending lower priority updates",
		function()
			local source = createSource({
				a = "initial",
				b = "initial",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function mutateA(newA)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'a'
				local tempTable = LuauPolyfill.Object.assign({}, source.value)
				tempTable.a = newA
				source.value = tempTable
			end
			local function mutateB(newB)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'b'
				local tempTable = LuauPolyfill.Object.assign({}, source.value)
				tempTable.b = newB
				source.value = tempTable
			end
			local function App(props)
				local toggle = props.toggle
				local state = useMutableSource(
					mutableSource,
					(function()
						if toggle then
							return getSnapshotB
						end

						return getSnapshotA
					end)(),
					defaultSubscribe
				)
				local result = (function()
					if toggle then
						return "B: "
					end

					return "A: "
				end)() .. state

				return result
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(App, { toggle = false }))
			end)

			jestExpect(root).toMatchRenderedOutput("A: initial")

			act(function()
				ReactNoop.discreteUpdates(function()
					-- Update both A and B to the same value
					mutateA("Update")
					mutateB("Update") -- Toggle to B in the same batch

					root.render(React.createElement(App, { toggle = true }))
				end)
				-- Mutate A at lower priority. This should never be rendered, because
				-- by the time we get to the lower priority, we've already switched
				-- to B.

				mutateA("OOPS! This mutation should be ignored")
			end)

			jestExpect(root).toMatchRenderedOutput("B: Update")
		end
	)

	-- @gate experimental
	it(
		"should clear the update queue when source changes with pending lower priority updates",
		function()
			local sourceA = createSource("initial")
			local sourceB = createSource("initial")
			local mutableSourceA = createMutableSource(sourceA, function(param)
				return param.versionA
			end)
			local mutableSourceB = createMutableSource(sourceB, function(param)
				return param.versionB
			end)

			local function App(props)
				local toggle = props.toggle
				local state = useMutableSource(
					(function()
						if toggle then
							return mutableSourceB
						end

						return mutableSourceA
					end)(),
					defaultGetSnapshot,
					defaultSubscribe
				)
				local result = (function()
					if toggle then
						return "B: "
					end

					return "A: "
				end)() .. state

				return result
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(App, { toggle = false }))
			end)

			jestExpect(root).toMatchRenderedOutput("A: initial")

			act(function()
				ReactNoop.discreteUpdates(function()
					-- Update both A and B to the same value
					sourceA.value = "Update"
					sourceB.value = "Update"
					-- Toggle to B in the same batch
					root.render(React.createElement(App, { toggle = true }))
				end)
				-- Mutate A at lower priority. This should never be rendered, because
				-- by the time we get to the lower priority, we've already switched
				-- to B.

				sourceA.value = "OOPS! This mutation should be ignored"
			end)

			jestExpect(root).toMatchRenderedOutput("B: Update")
		end
	)

	-- @gate experimental
	it(
		"should always treat reading as potentially unsafe when getSnapshot changes between renders",
		function()
			local source = createSource({
				a = "foo",
				b = "bar",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function mutateA(newA)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'a'
				local tempTable = LuauPolyfill.Object.assign({}, source.value)
				tempTable.a = newA
				source.value = tempTable
			end
			local function App(props)
				local getSnapshotFirst, getSnapshotSecond =
					props.getSnapshotFirst, props.getSnapshotSecond
				local first =
					useMutableSource(mutableSource, getSnapshotFirst, defaultSubscribe)
				local second =
					useMutableSource(mutableSource, getSnapshotSecond, defaultSubscribe)
				local result = string.format("x: %s, y: %s", first, second)

				if getSnapshotFirst == getSnapshotSecond then
					-- When both getSnapshot functions are equal,
					-- the two values must be consistent.
					if first ~= second then
						result = "Oops, tearing!"
					end
				end

				React.useEffect(function()
					Scheduler.unstable_yieldValue(result)
				end, { result })

				return result
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(App, {
					getSnapshotFirst = getSnapshotA,
					getSnapshotSecond = getSnapshotB,
				}))
			end)

			-- x and y start out reading from different parts of the store.
			jestExpect(Scheduler).toHaveYielded({
				"x: foo, y: bar",
			})

			act(function()
				ReactNoop.discreteUpdates(function()
					-- At high priority, toggle y so that it reads from A instead of B.
					-- Simultaneously, mutate A.
					mutateA("baz")
					root.render(React.createElement(App, {
						getSnapshotFirst = getSnapshotA,
						getSnapshotSecond = getSnapshotA,
					}))
					-- If this update were processed before the next mutation,
					-- it would be expected to yield "baz" and "baz".
				end)

				-- At lower priority, mutate A again.
				-- This happens to match the initial value of B.
				mutateA("bar")

				-- When this update is processed,
				-- it is expected to yield "bar" and "bar".
			end)

			-- Check that we didn't commit any inconsistent states.
			-- The actual sequence of work will be:
			-- 1. React renders the high-pri update, sees a new getSnapshot, detects the source has been further mutated, and throws
			-- 2. React re-renders with all pending updates, including the second mutation, and renders "bar" and "bar".
			jestExpect(Scheduler).toHaveYielded({
				"x: bar, y: bar",
			})
		end
	)

	-- ROBLOX TODO: unimplemented toFlushUntilNextPaint
	-- @gate experimental
	xit(
		"getSnapshot changes and then source is mutated in between paint and passive effect phase",
		function()
			local source = createSource({
				a = "foo",
				b = "bar",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			local function mutateB(newB)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'b'
				local tempTable = LuauPolyfill.Object.entries(source.value)
				tempTable.b = newB
				source.value = tempTable
			end

			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function App(props)
				local getSnapshot = props.getSnapshot
				local value =
					useMutableSource(mutableSource, getSnapshot, defaultSubscribe)

				Scheduler.unstable_yieldValue("Render: " .. value)
				React.useEffect(function()
					Scheduler.unstable_yieldValue("Commit: " .. value)
				end, { value })

				return value
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(App, {
					getSnapshot = getSnapshotA,
				}))
			end)

			jestExpect(Scheduler).toHaveYielded({
				"Render: foo",
				"Commit: foo",
			})

			act(function()
				-- Switch getSnapshot to read from B instead
				root.render(React.createElement(App, {
					getSnapshot = getSnapshotB,
				}))
				-- Render and finish the tree, but yield right after paint, before
				-- the passive effects have fired.
				jestExpect(Scheduler).toFlushUntilNextPaint({ "Render: bar" })
				-- Then mutate B.
				mutateB("baz")
			end)

			jestExpect(Scheduler).toHaveYielded({
				"Render: bar",
				-- Fires the effect from the previous render
				"Commit: bar",
				-- During that effect, it should detect that the snapshot has changed
				-- and re-render.
				"Render: baz",
				"Commit: baz",
			})
			jestExpect(root).toMatchRenderedOutput("baz")
		end
	)

	-- ROBLOX TODO: unimplemented toFlushUntilNextPaint() and getChildrenAsJSX()
	-- @gate experimental
	xit(
		"getSnapshot changes and then source is mutated in between paint and passive effect phase, case 2",
		function()
			local source = createSource({
				a = "a0",
				b = "b0",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function mutateA(newA)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'a'
				local tempTable = LuauPolyfill.Object.entries(source.value)
				tempTable.A = newA
				source.value = tempTable
			end
			local function App(props)
				local getSnapshotFirst, getSnapshotSecond =
					props.getSnapshotFirst, props.getSnapshotSecond
				local first =
					useMutableSource(mutableSource, getSnapshotFirst, defaultSubscribe)
				local second =
					useMutableSource(mutableSource, getSnapshotSecond, defaultSubscribe)

				return string.format("first: %s, second: %s", first, second)
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(App, {
					getSnapshotFirst = getSnapshotA,
					getSnapshotSecond = getSnapshotB,
				}))
			end)
			jestExpect(root.getChildrenAsJSX()).toEqual("first: a0, second: b0")

			act(function()
				-- Switch the second getSnapshot to also read from A
				root.render(React.createElement(App, {
					getSnapshotFirst = getSnapshotA,
					getSnapshotSecond = getSnapshotB,
				}))
				-- Render and finish the tree, but yield right after paint, before
				-- the passive effects have fired.
				jestExpect(Scheduler).toFlushUntilNextPaint({})

				-- Now mutate A. Both hooks should update.
				-- This is at high priority so that it doesn't get batched with default
				-- priority updates that might fire during the passive effect
				ReactNoop.discreteUpdates(function()
					mutateA("a1")
				end)
				jestExpect(Scheduler).toFlushUntilNextPaint({})

				jestExpect(root.getChildrenAsJSX()).toEqual("first: a1, second: a1")
			end)
			jestExpect(root.getChildrenAsJSX()).toEqual("first: a1, second: a1")
		end
	)

	-- ROBLOX TODO: unimplemented toFlushUntilNextPaint()
	-- @gate experimental
	xit(
		"if source is mutated after initial read but before subscription is set "
			.. "up, should still entangle all pending mutations even if snapshot of "
			.. "new subscription happens to match",
		function()
			local source = createSource({
				a = "a0",
				b = "b0",
			})
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local getSnapshotA = function()
				return source.value.a
			end
			local getSnapshotB = function()
				return source.value.b
			end

			local function mutateA(newA)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'a'
				local tempTable = LuauPolyfill.Object.assign({}, source.value)
				tempTable.a = newA
				source.value = tempTable
			end
			local function mutateB(newB)
				-- ROBLOX deviation: no table spread available, so we duplicate then add an entry for 'b'
				local tempTable = LuauPolyfill.Object.assign({}, source.value)
				tempTable.b = newB
				source.value = tempTable
			end
			local function Read(props)
				local getSnapshot = props.getSnapshot
				local value =
					useMutableSource(mutableSource, getSnapshot, defaultSubscribe)

				Scheduler.unstable_yieldValue(value)

				return value
			end
			local function Text(props)
				local text = props.text

				Scheduler.unstable_yieldValue(text)

				return text
			end

			local root = ReactNoop.createRoot()
			act(function()
				root.render(React.createElement(Read, {
					getSnapshot = getSnapshotA,
				}))
			end)

			jestExpect(Scheduler).toHaveYielded({
				"a0",
			})
			jestExpect(root).toMatchRenderedOutput("a0")
			act(function()
				root.render(
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(Read, {
							getSnapshotFirst = getSnapshotA,
						}),
						React.createElement(Read, {
							getSnapshotFirst = getSnapshotB,
						}),
						React.createElement(Text, {
							text = "c",
						})
					)
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({ "a0", "b0" })
				-- Mutate in an event. This schedules a subscription update on a, which
				-- already mounted, but not b, which hasn't subscribed yet.
				mutateA("a1")
				mutateB("b1")

				-- Mutate again at lower priority. This will schedule another subscription
				-- update on a, but not b. When b mounts and subscriptions, the value it
				-- read during render will happen to match the latest value. But it should
				-- still entangle the updates to prevent the previous update (a1) from
				-- rendering by itself.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_IdlePriority,
					function()
						mutateA("a0")
						mutateB("b0")
					end
				)
				-- Finish the current render
				jestExpect(Scheduler).toFlushUntilNextPaint({ "c" })
				-- a0 will re-render because of the mutation update. But it should show
				-- the latest value, not the intermediate one, to avoid tearing with b.
				jestExpect(Scheduler).toFlushUntilNextPaint({ "a0" })
				jestExpect(root).toMatchRenderedOutput("a0b0c")
				-- We should be done.
				jestExpect(Scheduler).toFlushAndYield({})
				jestExpect(root).toMatchRenderedOutput("a0b0c")
			end)
		end
	)

	-- @gate experimental
	it("warns about functions being used as snapshot values", function()
		local source = createSource(function()
			return "a"
		end)
		local mutableSource = createMutableSource(source, function(param)
			return param.version
		end)
		local getSnapshot = function()
			return source.value
		end

		local function Read()
			local fn = useMutableSource(mutableSource, getSnapshot, defaultSubscribe)
			local value = fn()
			Scheduler.unstable_yieldValue(value)
			return value
		end

		local root = ReactNoop.createRoot()
		act(function()
			root.render(
				React.createElement(React.Fragment, nil, React.createElement(Read))
			)
			jestExpect(function()
				jestExpect(Scheduler).toFlushAndYield({ "a" })
			end).toErrorDev(
				"Mutable source should not return a function as the snapshot value."
			)
		end)

		jestExpect(root).toMatchRenderedOutput("a")
	end)

	-- @gate experimental
	it(
		"getSnapshot changes and then source is mutated during interleaved event",
		function()
			local useEffect = React.useEffect

			local source = createComplexSource("1", "2")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)

			-- Subscribe to part of the store.
			local getSnapshotA = function(s)
				return s.valueA
			end
			local subscribeA = function(s, callback)
				return s.subscribeA(callback)
			end
			local configA = { getSnapshotA, subscribeA }
			local getSnapshotB = function(s)
				return s.valueB
			end
			local subscribeB = function(s, callback)
				return s.subscribeB(callback)
			end
			local configB = { getSnapshotB, subscribeB }

			local function Child(props)
				local parentConfig, childConfig, parentValue =
					props.parentConfig, props.childConfig, props.parentValue
				local getSnapshot, subscribe = childConfig[1], childConfig[2]
				local childValue = useMutableSource(mutableSource, getSnapshot, subscribe)

				Scheduler.unstable_yieldValue("Child: " .. childValue)

				local result = string.format("%s, %s", parentValue, childValue)

				if parentConfig == childConfig then
					-- When both components read using the same config, the two values
					-- must be consistent.
					if parentValue ~= childValue then
						result = "Oops, tearing!"
					end
				end

				useEffect(function()
					Scheduler.unstable_yieldValue("Commit: " .. result)
				end, { result })

				return result
			end

			local function App(props)
				local parentConfig, childConfig = props.parentConfig, props.childConfig
				local getSnapshot, subscribe = parentConfig[1], parentConfig[2]
				local parentValue =
					useMutableSource(mutableSource, getSnapshot, subscribe)
				Scheduler.unstable_yieldValue("Parent: " .. parentValue)

				return React.createElement(Child, {
					parentConfig = parentConfig,
					childConfig = childConfig,
					parentValue = parentValue,
				})
			end

			local root = ReactNoop.createRoot()
			Promise.try(function()
				act(function()
					root.render(
						React.createElement(
							App,
							{ parentConfig = configA, childConfig = configB }
						)
					)
				end)
			end):await()

			jestExpect(Scheduler).toHaveYielded({
				"Parent: 1",
				"Child: 2",
				"Commit: 1, 2",
			})
			act(function()
				-- Switch the parent and the child to read using the same config
				root.render(
					React.createElement(
						App,
						{ parentConfig = configB, childConfig = configB }
					)
				)
				-- Start rendering the parent, but yield before rendering the child
				jestExpect(Scheduler).toFlushAndYieldThrough({ "Parent: 2" })

				-- Mutate the config. This is at lower priority so that 1) to make sure
				-- it doesn't happen to get batched with the in-progress render, and 2)
				-- so it doesn't interrupt the in-progress render.
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_IdlePriority,
					function()
						source.valueB = "3"
					end
				)

				jestExpect(Scheduler).toFlushAndYieldThrough({
					-- The partial render completes
					"Child: 2",
					"Commit: 2, 2",
				})

				-- Now there are two pending mutations at different priorities. But they
				-- both read the same version of the mutable source, so we must render
				-- them simultaneously.
				--
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"Parent: 3",
					-- Demonstrates that we can yield here
				})
				jestExpect(Scheduler).toFlushAndYield({
					-- Now finish the rest of the update
					"Child: 3",
					"Commit: 3, 3",
				})
			end)
		end
	)

	-- @gate experimental
	it(
		"should not tear with newly mounted component when updates were scheduled at a lower priority",
		function()
			local source = createSource("one")
			local mutableSource = createMutableSource(source, function(param)
				return param.version
			end)
			local committedA = nil
			local committedB = nil
			local onRender = function()
				if committedB ~= nil then
					jestExpect(committedA).toEqual(committedB)
				end
			end

			local function ComponentA()
				local snapshot =
					useMutableSource(mutableSource, defaultGetSnapshot, defaultSubscribe)

				Scheduler.unstable_yieldValue(string.format("a:%s", snapshot))
				React.useEffect(function()
					committedA = snapshot
				end, { snapshot })

				return React.createElement("div", nil, string.format("a:%s", snapshot))
			end
			local function ComponentB()
				local snapshot =
					useMutableSource(mutableSource, defaultGetSnapshot, defaultSubscribe)

				Scheduler.unstable_yieldValue(string.format("b:%s", snapshot))
				React.useEffect(function()
					committedB = snapshot
				end, { snapshot })

				return React.createElement("div", nil, string.format("b:%s", snapshot))
			end

			-- Mount ComponentA with data version 1
			act(function()
				ReactNoop.render(
					React.createElement(React.Profiler, {
						id = "root",
						onRender = onRender,
					}, React.createElement(ComponentA)),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
			end)
			jestExpect(Scheduler).toHaveYielded({
				"a:one",
				"Sync effect",
			})
			jestExpect(source.listenerCount).toEqual(1)

			-- Mount ComponentB with version 1 (but don't commit it)
			act(function()
				ReactNoop.render(
					React.createElement(React.Profiler, {
						id = "root",
						onRender = onRender,
					}, React.createElement(ComponentA), React.createElement(
						ComponentB
					)),
					function()
						return Scheduler.unstable_yieldValue("Sync effect")
					end
				)
				jestExpect(Scheduler).toFlushAndYieldThrough({
					"a:one",
					"b:one",
					"Sync effect",
				})
				jestExpect(source.listenerCount).toEqual(1)

				-- Mutate -> schedule update for ComponentA
				Scheduler.unstable_runWithPriority(
					Scheduler.unstable_IdlePriority,
					function()
						source.value = "two"
					end
				)

				-- Commit ComponentB -> notice the change and schedule an update for ComponentB
				jestExpect(Scheduler).toFlushAndYield({
					"a:two",
					"b:two",
				})
				jestExpect(source.listenerCount).toEqual(2)
			end)
		end
	)

	if _G.__DEV__ then
		describe("dev warnings", function()
			-- @gate experimental
			it(
				"should warn if the subscribe function does not return an unsubscribe function",
				function()
					local source = createSource("one")
					local mutableSource = createMutableSource(source, function(param)
						return param.version
					end)
					local brokenSubscribe = function() end

					jestExpect(function()
						act(function()
							ReactNoop.render(React.createElement(Component, {
								label = "only",
								getSnapshot = defaultGetSnapshot,
								mutableSource = mutableSource,
								subscribe = brokenSubscribe,
							}))
						end)
					end).toErrorDev(
						"Mutable source subscribe function must return an unsubscribe function."
					)
				end
			)

			-- -- ROBLOX TODO: spyOnDev
			-- -- @gate experimental
			-- xit('should error if multiple renderers of the same type use a mutable source at the same time', function()
			--             --     local source = createSource('one')
			--     local mutableSource = createMutableSource(source, function(param)
			--         return param.version
			--     end)

			--     act(function()
			--         -- Start a render that uses the mutable source.
			--         ReactNoop.render(React.createElement(React.Fragment, nil, React.createElement(Component, {
			--             label = 'a',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         }), React.createElement(Component, {
			--             label = 'b',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         })))
			--         jestExpect(Scheduler).toFlushAndYieldThrough({
			--             'a:one',
			--         })

			--         local PrevScheduler = Scheduler
			--         -- Get a new copy of ReactNoop.

			--         loadModules()

			--         spyOnDev(console, 'error')

			--         -- Use the mutablesource again but with a different renderer.
			--         ReactNoop.render(React.createElement(Component, {
			--             label = 'c',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         }))
			--         jestExpect(Scheduler).toFlushAndYieldThrough({
			--             'c:one',
			--         })
			--         jestExpect(console.error.calls.argsFor(0)[0]).toContain('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.')

			--         -- TODO (useMutableSource) Act will automatically flush remaining work from render 1,
			--         -- but at this point something in the hooks dispatcher has been broken by jest.resetModules()
			--         -- Figure out what this is and remove this catch.
			--         jestExpect(function()
			--             return PrevScheduler.unstable_flushAllWithoutAsserting()
			--         end).toThrow('Invalid hook call')
			--     end)
			-- end)

			-- -- ROBLOX TODO: spyOnDev
			-- @gate experimental
			-- xit('should error if multiple renderers of the same type use a mutable source at the same time with mutation between', function(
			-- )
			--         --     local source = createSource('one')
			--     local mutableSource = createMutableSource(source, function(param)
			--         return param.version
			--     end)

			--     act(function()
			--         -- Start a render that uses the mutable source.
			--         ReactNoop.render(React.createElement(React.Fragment, nil, React.createElement(Component, {
			--             label = 'a',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         }), React.createElement(Component, {
			--             label = 'b',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         })))
			--         jestExpect(Scheduler).toFlushAndYieldThrough({
			--             'a:one',
			--         })

			--         local PrevScheduler = Scheduler

			--         -- Get a new copy of ReactNoop.
			--         loadModules()

			--         spyOnDev(console, 'error')

			--         -- Mutate before the new render reads from the source.
			--         source.value ='two')

			--         -- Use the mutablesource again but with a different renderer.
			--         ReactNoop.render(React.createElement(Component, {
			--             label = 'c',
			--             getSnapshot = defaultGetSnapshot,
			--             mutableSource = mutableSource,
			--             subscribe = defaultSubscribe,
			--         }))
			--         jestExpect(Scheduler).toFlushAndYieldThrough({
			--             'c:two',
			--         })
			--         jestExpect(console.error.calls.argsFor(0)[0]).toContain('Detected multiple renderers concurrently rendering the ' .. 'same mutable source. This is currently unsupported.')

			--         -- TODO (useMutableSource) Act will automatically flush remaining work from render 1,
			--         -- but at this point something in the hooks dispatcher has been broken by jest.resetModules()
			--         -- Figure out what this is and remove this catch.
			--         jestExpect(function()
			--             return PrevScheduler.unstable_flushAllWithoutAsserting()
			--         end).toThrow('Invalid hook call')
			--     end)
			-- end)
		end)
	end
end) ]]
eC.Children._ba0500bc9505c67567d1949ff5c65927=fI
local fJ

local fK={ClassName="Folder",Children={},Properties={}}
fK.Name="forks"
cX.Children._0a1fbb01f1f87415d22b1f313fca1a99=fK
local fL
local fM={ClassName="ModuleScript",Children={},Properties={}}
fM.Name="ReactFiberHostConfig.test"
fM.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-reconciler/src/forks/ReactFiberHostConfig.test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent.Parent

return require(Packages.Dev.ReactTestRenderer) ]]
fL.Children._998caa1e2efad607ca61c62362008fc3=fM
local fN

local fO={ClassName="ModuleScript",Children={},Properties={}}
fO.Name="ReactRoblox"
fO.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local HostTypes = require(script.client["ReactRobloxHostTypes.roblox"])
export type RootType = HostTypes.RootType
return require(script.client.ReactRoblox) ]]
c.Children._27edc362b0f37fe1967e342c69b398d9=fO
local fP
local fQ={ClassName="ModuleScript",Children={},Properties={}}
fQ.Name="ReactReconciler.roblox"
fQ.Properties.Source=[[ --!strict
-- ROBLOX deviation: Initializes the reconciler with this package's host
-- config and returns the resulting module

local Packages = script.Parent.Parent
local initializeReconciler = require(Packages.ReactReconciler)

local ReactRobloxHostConfig = require(script.Parent.client.ReactRobloxHostConfig)

return initializeReconciler(ReactRobloxHostConfig) ]]
fP.Children._a6c6f4b7c3fabed66a4be5e1c4ef9672=fQ
local fR

local fS={ClassName="Folder",Children={},Properties={}}
fS.Name="client"
fP.Children._f9ff67a23f97fd97242dbf58db086150=fS
local fT
local fU={ClassName="ModuleScript",Children={},Properties={}}
fU.Name="ReactRoblox"
fU.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOM.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local Packages = script.Parent.Parent.Parent

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type Container = ReactRobloxHostTypes.Container

-- local '../shared/checkReact'
-- local ReactRobloxLegacy = require(script.Parent.ReactRobloxLegacy)
-- local findDOMNode = ReactRobloxLegacy.findDOMNode
-- local render = ReactRobloxLegacy.render
-- local hydrate = ReactRobloxLegacy.hydrate
-- local unstable_renderSubtreeIntoContainer = ReactRobloxLegacy.unstable_renderSubtreeIntoContainer
-- local unmountComponentAtNode = ReactRobloxLegacy.unmountComponentAtNode

local ReactRobloxRoot
ReactRobloxRoot = require(script.Parent.ReactRobloxRoot)
local createRoot = ReactRobloxRoot.createRoot
local createBlockingRoot = ReactRobloxRoot.createBlockingRoot
local createLegacyRoot = ReactRobloxRoot.createLegacyRoot
local isValidContainer = ReactRobloxRoot.isValidContainer
-- local createEventHandle = require(script.Parent.ReactDOMEventHandle).createEventHandle

-- ROBLOX deviation: Use the config-injecting entry point for the reconciler
local ReactReconciler = require(script.Parent.Parent["ReactReconciler.roblox"])
-- local batchedEventUpdates = ReactReconciler.batchedEventUpdates
local batchedUpdates = ReactReconciler.batchedUpdates
-- local discreteUpdates = ReactReconciler.discreteUpdates
-- local flushDiscreteUpdates = ReactReconciler.flushDiscreteUpdates
-- local flushSync = ReactReconciler.flushSync
-- local flushControlled = ReactReconciler.flushControlled
local injectIntoDevTools = ReactReconciler.injectIntoDevTools
local flushPassiveEffects = ReactReconciler.flushPassiveEffects
local IsThisRendererActing = ReactReconciler.IsThisRendererActing
-- local attemptSynchronousHydration = ReactReconciler.attemptSynchronousHydration
-- local attemptUserBlockingHydration = ReactReconciler.attemptUserBlockingHydration
-- local attemptContinuousHydration = ReactReconciler.attemptContinuousHydration
-- local attemptHydrationAtCurrentPriority = ReactReconciler.attemptHydrationAtCurrentPriority
-- local runWithPriority = ReactReconciler.runWithPriority
-- local getCurrentUpdateLanePriority = ReactReconciler.getCurrentUpdateLanePriority

local createPortalImpl = ReactReconciler.createPortal
-- local canUseDOM = require(Packages.Shared).ExecutionEnvironment.canUseDOM
local ReactVersion = require(Packages.Shared).ReactVersion
local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local warnUnstableRenderSubtreeIntoContainer = ReactFeatureFlags.warnUnstableRenderSubtreeIntoContainer
local enableNewReconciler = ReactFeatureFlags.enableNewReconciler

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
local getInstanceFromNode = ReactRobloxComponentTree.getInstanceFromNode
local getNodeFromInstance = ReactRobloxComponentTree.getNodeFromInstance
local getFiberCurrentPropsFromNode = ReactRobloxComponentTree.getFiberCurrentPropsFromNode
local getClosestInstanceFromNode = ReactRobloxComponentTree.getClosestInstanceFromNode
-- local restoreControlledState = require(script.Parent.ReactRobloxComponent).restoreControlledState

-- local ReactDOMEventReplaying = require(Packages.Parent.Parent.events.ReactDOMEventReplaying)
-- local setAttemptSynchronousHydration = ReactDOMEventReplaying.setAttemptSynchronousHydration
-- local setAttemptUserBlockingHydration = ReactDOMEventReplaying.setAttemptUserBlockingHydration
-- local setAttemptContinuousHydration = ReactDOMEventReplaying.setAttemptContinuousHydration
-- local setAttemptHydrationAtCurrentPriority = ReactDOMEventReplaying.setAttemptHydrationAtCurrentPriority
-- local queueExplicitHydrationTarget = ReactDOMEventReplaying.queueExplicitHydrationTarget
-- local setGetCurrentUpdatePriority = ReactDOMEventReplaying.setGetCurrentUpdatePriority
-- local setAttemptHydrationAtPriority = ReactDOMEventReplaying.setAttemptHydrationAtPriority

-- local setBatchingImplementation = require(Packages.Parent.Parent.events.ReactDOMUpdateBatching).setBatchingImplementation
-- local ReactDOMControlledComponent = require(script.Parent.Parent.events.ReactDOMControlledComponent)
-- local setRestoreImplementation = ReactDOMControlledComponent.setRestoreImplementation
-- local enqueueStateRestore = ReactDOMControlledComponent.enqueueStateRestore
-- local restoreStateIfNeeded = ReactDOMControlledComponent.restoreStateIfNeeded

local Event = require(Packages.Shared).Event
local Change = require(Packages.Shared).Change
local Tag = require(Packages.Shared).Tag

-- setAttemptSynchronousHydration(attemptSynchronousHydration)
-- setAttemptUserBlockingHydration(attemptUserBlockingHydration)
-- setAttemptContinuousHydration(attemptContinuousHydration)
-- setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority)
-- setGetCurrentUpdatePriority(getCurrentUpdateLanePriority)
-- setAttemptHydrationAtPriority(runWithPriority)

-- local didWarnAboutUnstableCreatePortal = false
-- local didWarnAboutUnstableRenderSubtreeIntoContainer = false

-- deviation: Built-ins for maps and sets are not required
-- if _G.__DEV__ then
--   if
--     typeof Map ~= 'function' or
--     -- $FlowIssue Flow incorrectly thinks Map has no prototype
--     Map.prototype == nil or
--     typeof Map.prototype.forEach ~= 'function' or
--     typeof Set ~= 'function' or
--     -- $FlowIssue Flow incorrectly thinks Set has no prototype
--     Set.prototype == nil or
--     typeof Set.prototype.clear ~= 'function' or
--     typeof Set.prototype.forEach ~= 'function'
--   )
--     console.error(
--       'React depends on Map and Set built-in types. Make sure that you load a ' +
--         'polyfill in older browsers. https://reactjs.org/link/react-polyfills',
--     )
--   end
-- end

-- setRestoreImplementation(restoreControlledState)
-- setBatchingImplementation(
--   batchedUpdates,
--   discreteUpdates,
--   flushDiscreteUpdates,
--   batchedEventUpdates
-- )

local function createPortal(
	children: ReactNodeList,
	container: Container,
	key: string?
): any
	-- ): React$Portal
	invariant(
		isValidContainer(container),
		-- ROBLOX deviation: Use roblox engine terminology
		"Target container is not a Roblox Instance."
	)
	-- TODO: pass ReactDOM portal implementation as third argument
	-- $FlowFixMe The Flow type is opaque but there's no way to actually create it.
	-- ROBLOX FIXME: luau doesn't realize that this function errors, and it's
	-- expecting us to return something. Can be removed when implementation is
	-- done.
	return createPortalImpl(children, container, nil, key)
end

-- local function scheduleHydration(target: any)
--   if target then
--     queueExplicitHydrationTarget(target)
--   end
-- end

-- local function renderSubtreeIntoContainer(
--   parentComponent: React$Component<any, any>,
--   element: React$Element<any>,
--   containerNode: Container,
--   callback: ?Function,
-- )
-- local function renderSubtreeIntoContainer(
--   parentComponent: any,
--   element: any,
--   containerNode: Container,
--   callback: any
-- )
--   if _G.__DEV__ then
--     if
--       warnUnstableRenderSubtreeIntoContainer and
--       not didWarnAboutUnstableRenderSubtreeIntoContainer
--     then
--       didWarnAboutUnstableRenderSubtreeIntoContainer = true
--       console.warn(
--         "ReactDOM.unstable_renderSubtreeIntoContainer() is deprecated " ..
--           "and will be removed in a future major release. Consider using " ..
--           "React Portals instead."
--       )
--     end
--   end
--   return unstable_renderSubtreeIntoContainer(
--     parentComponent,
--     element,
--     containerNode,
--     callback
--   )
-- end

-- local function unstable_createPortal(
--   children: ReactNodeList,
--   container: Container,
--   key: string?
-- )
--   if _G.__DEV__ then
--     if not didWarnAboutUnstableCreatePortal then
--       didWarnAboutUnstableCreatePortal = true
--       console.warn(
--         "The ReactDOM.unstable_createPortal() alias has been deprecated, " ..
--           "and will be removed in React 18+. Update your code to use " ..
--           "ReactDOM.createPortal() instead. It has the exact same API, " ..
--           "but without the \"unstable_\" prefix."
--       )
--     end
--   end
--   return createPortal(children, container, key)
-- end

local Internals = {
	-- Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
	-- This is an array for better minification.
	Events = {
		getInstanceFromNode = getInstanceFromNode,
		getNodeFromInstance = getNodeFromInstance,
		getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNode,
		-- enqueueStateRestore = enqueueStateRestore,
		-- restoreStateIfNeeded = restoreStateIfNeeded,
		flushPassiveEffects = flushPassiveEffects,
		-- TODO: This is related to `act`, not events. Move to separate key?
		IsThisRendererActing = IsThisRendererActing,
	},
}

local exports = {
	createPortal = createPortal,
	unstable_batchedUpdates = batchedUpdates,
	-- flushSync = flushSync,
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals,
	version = ReactVersion,
	-- Disabled behind disableLegacyReactDOMAPIs
	-- findDOMNode = findDOMNode,
	-- hydrate = hydrate,
	-- render = render,
	-- unmountComponentAtNode = unmountComponentAtNode,
	-- exposeConcurrentModeAPIs
	createRoot = createRoot,
	createBlockingRoot = createBlockingRoot,
	createLegacyRoot = createLegacyRoot,
	-- unstable_flushControlled = flushControlled,
	-- unstable_scheduleHydration = scheduleHydration,
	-- Disabled behind disableUnstableRenderSubtreeIntoContainer
	-- unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer,
	-- Disabled behind disableUnstableCreatePortal
	-- Temporary alias since we already shipped React 16 RC with it.
	-- TODO: remove in React 18.
	-- unstable_createPortal = unstable_createPortal,
	-- enableCreateEventHandleAPI
	-- unstable_createEventHandle = createEventHandle,
	-- TODO: Remove this once callers migrate to alternatives.
	-- This should only be used by React internals.
	-- unstable_runWithPriority = runWithPriority,

	-- ROBLOX deviation: Export logic attached from Roact

	-- ROBLOX FIXME: Is there a better way to provide this? Exposing these here
	-- means that a large number of react components that wouldn't otherwise need
	-- to import `ReactRoblox` will need to do so in order to set events/change
	Event = Event,
	Change = Change,
	Tag = Tag,
	unstable_isNewReconciler = enableNewReconciler,

	-- ROBLOX deviation: Export `act` function for testing purposes; in
	-- production (a.k.a. scheduler isn't mocked), give an instructive error
	act = function(_: () -> ()): ()
		error(
			"ReactRoblox.act is only available in testing environments, not "
				.. "production. Enable the `__ROACT_17_MOCK_SCHEDULER__` global in your "
				.. "test configuration in order to use `act`."
		)
	end,
}

if _G.__ROACT_17_MOCK_SCHEDULER__ then
	-- ROBLOX deviation: When the __ROACT_17_MOCK_SCHEDULER__ is enabled, we
	-- re-export the `act` function from ReactReconciler. The global will
	-- additionally force the scheduler to use the mock interface
	exports.act = ReactReconciler.act
end

-- ROBLOX deviation: we don't currently implement the logic below that uses this
-- value
local _foundDevTools = injectIntoDevTools({
	findFiberByHostInstance = getClosestInstanceFromNode,
	bundleType = if _G.__DEV__ then 1 else 0,
	version = ReactVersion,
	rendererPackageName = "ReactRoblox",
})

if _G.__DEV__ then
	-- if not foundDevTools and canUseDOM and window.top == window.self then
	--   If we're in Chrome or Firefox, provide a download link if not installed.
	--   if
	--     (navigator.userAgent.indexOf('Chrome') > -1 and
	--       navigator.userAgent.indexOf('Edge') == -1) or
	--     navigator.userAgent.indexOf('Firefox') > -1
	--   )
	--     local protocol = window.location.protocol
	--     -- Don't warn in exotic cases like chrome-extension://.
	--     if /^(https?|file):$/.test(protocol))
	--       -- eslint-disable-next-line react-internal/no-production-logging
	--       console.info(
	--         '%cDownload the React DevTools ' +
	--           'for a better development experience: ' +
	--           'https://reactjs.org/link/react-devtools' +
	--           (protocol == 'file:'
	--             ? '\nYou might need to use a local HTTP server (instead of file://): ' +
	--               'https://reactjs.org/link/react-devtools-faq'
	--             : ''),
	--         'font-weight:bold',
	--       )
	--     end
	--   end
	-- end
end

return exports ]]
fT.Children._e1f949aa9a91b7b1449a7b531beae2f6=fU
local fV

local fW={ClassName="ModuleScript",Children={},Properties={}}
fW.Name="ReactRobloxComponent"
fW.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMComponent.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local RobloxComponentProps = require(script.Parent.roblox.RobloxComponentProps)

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance

-- deviation: Essentially a placeholder for dom-specific logic, taking the place
-- of ReactDOMComponent. Most of the logic will differ pretty dramatically

type Array<T> = { [number]: T }
type Object = { [any]: any }

local exports: { [string]: any } = {}

exports.setInitialProperties = RobloxComponentProps.setInitialProperties

-- Calculate the diff between the two objects.
local function diffProperties(
	domElement: HostInstance,
	tag: string,
	lastRawProps: Object,
	nextRawProps: Object,
	rootContainerElement: HostInstance
): (nil | Array<any>)
	-- if _G.__DEV__ then
	--   validatePropertiesInDevelopment(tag, nextRawProps)
	-- end

	-- ROBLOX FIXME: Type refinement
	-- local updatePayload: nil | Array<any> = nil
	local updatePayload = nil

	local lastProps = lastRawProps
	local nextProps = nextRawProps
	-- local lastProps: Object
	-- local nextProps: Object
	-- switch (tag) {
	--   case 'input':
	--     lastProps = ReactDOMInputGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMInputGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'option':
	--     lastProps = ReactDOMOptionGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMOptionGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'select':
	--     lastProps = ReactDOMSelectGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMSelectGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'textarea':
	--     lastProps = ReactDOMTextareaGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMTextareaGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   default:
	--     lastProps = lastRawProps;
	--     nextProps = nextRawProps;
	--     if (
	--       typeof lastProps.onClick !== 'function' &&
	--       typeof nextProps.onClick === 'function'
	--     ) {
	--       // TODO: This cast may not be sound for SVG, MathML or custom elements.
	--       trapClickOnNonInteractiveElement(((domElement: any): HTMLElement));
	--     }
	--     break;
	-- }

	-- assertValidProps(tag, nextProps);

	-- let propKey;
	-- let styleName;
	-- let styleUpdates = null;
	for propKey, _ in lastProps do
		if nextProps[propKey] ~= nil then
			continue
		end
		-- if (propKey === STYLE) {
		--   const lastStyle = lastProps[propKey];
		--   for (styleName in lastStyle) {
		--     if (lastStyle.hasOwnProperty(styleName)) {
		--       if (!styleUpdates) {
		--         styleUpdates = {};
		--       }
		--       styleUpdates[styleName] = '';
		--     }
		--   }
		-- } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
		--   // Noop. This is handled by the clear text mechanism.
		-- } else if (
		--   propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
		--   propKey === SUPPRESS_HYDRATION_WARNING
		-- ) {
		--   // Noop
		-- } else if (propKey === AUTOFOCUS) {
		--   // Noop. It doesn't work on updates anyway.
		-- } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
		--   // This is a special case. If any listener updates we need to ensure
		--   // that the "current" fiber pointer gets updated so we need a commit
		--   // to update this element.
		--   if (!updatePayload) {
		--     updatePayload = [];
		--   }
		-- } else {
		-- For all other deleted properties we add it to the queue. We use
		-- the allowed property list in the commit phase instead.
		-- ROBLOX performance: prealloc table size 2 for these 2 items at least
		updatePayload = updatePayload or table.create(2)
		table.insert(updatePayload, propKey)
		table.insert(updatePayload, Object.None)
		-- }
	end
	for propKey, nextProp in nextProps do
		local lastProp = if lastProps ~= nil then lastProps[propKey] else nil
		if nextProp == lastProp then
			continue
		end
		-- if (propKey === STYLE) {
		--   if (__DEV__) {
		--     if (nextProp) {
		--       // Freeze the next style object so that we can assume it won't be
		--       // mutated. We have already warned for this in the past.
		--       Object.freeze(nextProp);
		--     }
		--   }
		--   if (lastProp) {
		--     // Unset styles on `lastProp` but not on `nextProp`.
		--     for (styleName in lastProp) {
		--       if (
		--         lastProp.hasOwnProperty(styleName) &&
		--         (!nextProp || !nextProp.hasOwnProperty(styleName))
		--       ) {
		--         if (!styleUpdates) {
		--           styleUpdates = {};
		--         }
		--         styleUpdates[styleName] = '';
		--       }
		--     }
		--     // Update styles that changed since `lastProp`.
		--     for (styleName in nextProp) {
		--       if (
		--         nextProp.hasOwnProperty(styleName) &&
		--         lastProp[styleName] !== nextProp[styleName]
		--       ) {
		--         if (!styleUpdates) {
		--           styleUpdates = {};
		--         }
		--         styleUpdates[styleName] = nextProp[styleName];
		--       }
		--     }
		--   } else {
		--     // Relies on `updateStylesByID` not mutating `styleUpdates`.
		--     if (!styleUpdates) {
		--       if (!updatePayload) {
		--         updatePayload = [];
		--       }
		--       updatePayload.push(propKey, styleUpdates);
		--     }
		--     styleUpdates = nextProp;
		--   }
		-- } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
		--   const nextHtml = nextProp ? nextProp[HTML] : undefined;
		--   const lastHtml = lastProp ? lastProp[HTML] : undefined;
		--   if (nextHtml != null) {
		--     if (lastHtml !== nextHtml) {
		--       (updatePayload = updatePayload || []).push(propKey, nextHtml);
		--     }
		--   } else {
		--     // TODO: It might be too late to clear this if we have children
		--     // inserted already.
		--   }
		-- } else if (propKey === CHILDREN) {
		--   if (typeof nextProp === 'string' || typeof nextProp === 'number') {
		--     (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
		--   }
		-- } else if (
		--   propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
		--   propKey === SUPPRESS_HYDRATION_WARNING
		-- ) {
		--   // Noop
		-- } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
		--   if (nextProp != null) {
		--     // We eagerly listen to this even though we haven't committed yet.
		--     if (__DEV__ && typeof nextProp !== 'function') {
		--       warnForInvalidEventListener(propKey, nextProp);
		--     }
		--     if (!enableEagerRootListeners) {
		--       ensureListeningTo(rootContainerElement, propKey, domElement);
		--     } else if (propKey === 'onScroll') {
		--       listenToNonDelegatedEvent('scroll', domElement);
		--     }
		--   }
		--   if (!updatePayload && lastProp !== nextProp) {
		--     // This is a special case. If any listener updates we need to ensure
		--     // that the "current" props pointer gets updated so we need a commit
		--     // to update this element.
		--     updatePayload = [];
		--   }
		-- } else if (
		--   typeof nextProp === 'object' &&
		--   nextProp !== null &&
		--   nextProp.$$typeof === REACT_OPAQUE_ID_TYPE
		-- ) {
		--   // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
		--   // In this case, call the opaque object's toString function which generates a new client
		--   // ID so client and server IDs match and throws to rerender.
		--   nextProp.toString();
		-- } else {
		-- For any other property we always add it to the queue and then we
		-- filter it out using the allowed property list during the commit.
		-- ROBLOX performance: prealloc table size 2 for these 2 items at least
		-- ROBLOX performance TODO: don't create a table here, return multiple values!
		updatePayload = updatePayload or table.create(2)
		table.insert(updatePayload, propKey)
		table.insert(updatePayload, nextProp)
		-- }
	end
	-- if (styleUpdates) {
	--   if (__DEV__) {
	--     validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
	--   }
	--   (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
	-- }
	return updatePayload
end
exports.diffProperties = diffProperties
exports.updateProperties = RobloxComponentProps.updateProperties
exports.cleanupHostComponent = RobloxComponentProps.cleanupHostComponent

return exports ]]
fT.Children._fcc979aca5618d90f742d526a31cd6a4=fW
local fX

local fY={ClassName="ModuleScript",Children={},Properties={}}
fY.Name="ReactRobloxComponentTree"
fY.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMComponentTree.js
-- ROBLOX upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeComponentTree.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent.Parent

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance
type TextInstance = ReactRobloxHostTypes.TextInstance
type SuspenseInstance = ReactRobloxHostTypes.SuspenseInstance
type Container = ReactRobloxHostTypes.Container
type Props = ReactRobloxHostTypes.Props

local ReactInternalTypes = require(Packages.ReactReconciler)
type Fiber = ReactInternalTypes.Fiber
local Shared = require(Packages.Shared)
type ReactScopeInstance = Shared.ReactScopeInstance
-- local type {
--   ReactDOMEventHandle,
--   ReactDOMEventHandleListener,
-- } = require(Packages.../shared/ReactDOMTypes'
-- local type {
--   Container,
--   TextInstance,
--   Instance,
--   SuspenseInstance,
--   Props,
-- } = require(Packages../ReactDOMHostConfig'

local ReactWorkTags
local HostComponent
local HostText
local HostRoot
local SuspenseComponent

local getParentSuspenseInstance
local invariant = Shared.invariant
-- local {enableScopeAPI} = require(Packages.shared/ReactFeatureFlags'

local exports: { [any]: any } = {}

-- ROBLOX deviation: Use internal maps, since we can't set properties on Containers
-- (which are Instances). We might consider using the Attributes feature for
-- this when it releases
local containerToRoot: { [Container]: Fiber } = {}
local instanceToFiber: { [HostInstance | SuspenseInstance | ReactScopeInstance]: Fiber } =
	{}
local instanceToProps: { [HostInstance | SuspenseInstance]: Props } = {}

local randomKey = string.sub(tostring(math.random()), 3)
local internalInstanceKey = "__reactFiber$" .. randomKey
local internalContainerInstanceKey = "__reactContainer$" .. randomKey
-- local internalPropsKey = "__reactProps$" .. randomKey
-- local internalEventHandlersKey = '__reactEvents$' + randomKey
-- local internalEventHandlerListenersKey = '__reactListeners$' + randomKey
-- local internalEventHandlesSetKey = '__reactHandles$' + randomKey

exports.precacheFiberNode =
	function(hostInst: Fiber, node: HostInstance | SuspenseInstance | ReactScopeInstance)
		instanceToFiber[node] = hostInst
	end

exports.uncacheFiberNode =
	function(node: HostInstance | SuspenseInstance | ReactScopeInstance)
		instanceToFiber[node] = nil
		instanceToProps[node] = nil
	end

exports.markContainerAsRoot = function(hostRoot: Fiber, node: Container)
	-- deviation: Use our module-level map
	containerToRoot[node] = hostRoot
	-- node[internalContianerInstanceKey] = hostRoot
end

exports.unmarkContainerAsRoot = function(node: Container)
	-- deviation: Use our module-level map
	containerToRoot[node] = nil
	-- node[internalContainerInstanceKey] = nil
end

exports.isContainerMarkedAsRoot = function(node: Container): boolean
	-- deviation: Use our module-level map
	return not not containerToRoot[node]
	-- return not not node[internalContainerInstanceKey]
end

-- Given a Roblox node, return the closest HostComponent or HostText fiber ancestor.
-- If the target node is part of a hydrated or not yet rendered subtree, then
-- this may also return a SuspenseComponent or HostRoot to indicate that.
-- Conceptually the HostRoot fiber is a child of the Container node. So if you
-- pass the Container node as the targetNode, you will not actually get the
-- HostRoot back. To get to the HostRoot, you need to pass a child of it.
-- The same thing applies to Suspense boundaries.
-- ROBLOX TODO: This function is untested and may not work!
exports.getClosestInstanceFromNode = function(targetNode: Instance): Fiber?
	-- ROBLOX deviation: Use internal maps since we can't set properties on Containers
	local targetInst = instanceToFiber[targetNode]
	if targetInst then
		-- Don't return HostRoot or SuspenseComponent here.
		return targetInst
	end
	-- If the direct event target isn't a React owned DOM node, we need to look
	-- to see if one of its parents is a React owned DOM node.
	local parentNode = targetNode.Parent
	while parentNode do
		-- We'll check if this is a container root that could include
		-- React nodes in the future. We need to check this first because
		-- if we're a child of a dehydrated container, we need to first
		-- find that inner container before moving on to finding the parent
		-- instance. Note that we don't check this field on  the targetNode
		-- itself because the fibers are conceptually between the container
		-- node and the first child. It isn't surrounding the container node.
		-- If it's not a container, we check if it's an instance.
		targetInst = instanceToFiber[parentNode]
		if targetInst then
			-- Since this wasn't the direct target of the event, we might have
			-- stepped past dehydrated DOM nodes to get here. However they could
			-- also have been non-React nodes. We need to answer which one.
			-- If we the instance doesn't have any children, then there can't be
			-- a nested suspense boundary within it. So we can use this as a fast
			-- bailout. Most of the time, when people add non-React children to
			-- the tree, it is using a ref to a child-less DOM node.
			-- Normally we'd only need to check one of the fibers because if it
			-- has ever gone from having children to deleting them or vice versa
			-- it would have deleted the dehydrated boundary nested inside already.
			-- However, since the HostRoot starts out with an alternate it might
			-- have one on the alternate so we need to check in case this was a
			-- root.
			local alternate = targetInst.alternate
			if
				targetInst.child ~= nil
				or (alternate ~= nil and alternate.child ~= nil)
			then
				-- ROBLOX deviation: lazy initialize to work around circular dependency
				if getParentSuspenseInstance == nil then
					getParentSuspenseInstance = (require(
						script.Parent.ReactRobloxHostConfig
					) :: any).getParentSuspenseInstance
				end

				-- Next we need to figure out if the node that skipped past is
				-- nested within a dehydrated boundary and if so, which one.
				local suspenseInstance = getParentSuspenseInstance(targetNode)
				while suspenseInstance ~= nil do
					-- We found a suspense instance. That means that we haven't
					-- hydrated it yet. Even though we leave the comments in the
					-- DOM after hydrating, and there are boundaries in the DOM
					-- that could already be hydrated, we wouldn't have found them
					-- through this pass since if the target is hydrated it would
					-- have had an internalInstanceKey on it.
					-- Let's get the fiber associated with the SuspenseComponent
					-- as the deepest instance.
					local targetSuspenseInst = instanceToFiber[suspenseInstance]
					if targetSuspenseInst then
						return targetSuspenseInst
					end
					-- If we don't find a Fiber on the comment, it might be because
					-- we haven't gotten to hydrate it yet. There might still be a
					-- parent boundary that hasn't above this one so we need to find
					-- the outer most that is known.
					suspenseInstance = getParentSuspenseInstance(suspenseInstance)
					-- If we don't find one, then that should mean that the parent
					-- host component also hasn't hydrated yet. We can return it
					-- below since it will bail out on the isMounted check later.
				end
			end
			return targetInst
		end
		targetNode = parentNode
		parentNode = targetNode.Parent
	end
	return nil
end

--\[\[*
 * Given a Roblox node, return the Roblox Component
 * instance, or nil if the node was not rendered by this React.
 \]\]
exports.getInstanceFromNode = function(node): Fiber?
	-- ROBLOX deviation: lazy initialize to avoid circular dependency
	if ReactWorkTags == nil then
		local ReactReconciler =
			require(script.Parent.Parent["ReactReconciler.roblox"]) :: any
		ReactWorkTags = ReactReconciler.ReactWorkTags

		HostComponent = ReactWorkTags.HostComponent
		HostText = ReactWorkTags.HostComponent
		HostRoot = ReactWorkTags.HostComponent
		SuspenseComponent = ReactWorkTags.HostComponent
	end

	local inst = (node :: any)[internalInstanceKey]
		or (node :: any)[internalContainerInstanceKey]
	if inst then
		if
			inst.tag == HostComponent
			or inst.tag == HostText
			or inst.tag == SuspenseComponent
			or inst.tag == HostRoot
		then
			return inst
		else
			return nil
		end
	end
	return nil
end

--\[\[*
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 \]\]
exports.getNodeFromInstance = function(inst: Fiber): Instance | TextInstance
	if inst.tag == HostComponent or inst.tag == HostText then
		-- In Fiber this, is just the state node right now. We assume it will be
		-- a host component or host text.
		return inst.stateNode
	end

	-- Without this first invariant, passing a non-DOM-component triggers the next
	-- invariant for a missing parent, which is super confusing.
	invariant(false, "getNodeFromInstance: Invalid argument.")
	-- ROBLOX deviation: Luau analysis doesn't understand that invariant(false,...) is always-throw
	error("getNodeFromInstance: Invalid argument.")
end

exports.getFiberCurrentPropsFromNode =
	function(node: Instance | TextInstance | SuspenseInstance): Props
		return instanceToProps[node]
	end

exports.updateFiberProps = function(node: Instance | SuspenseInstance, props: Props)
	instanceToProps[node] = props
end

-- exports.getEventListenerSet(node: EventTarget): Set<string> {
--   local elementListenerSet = (node: any)[internalEventHandlersKey]
--   if elementListenerSet == undefined)
--     elementListenerSet = (node: any)[internalEventHandlersKey] = new Set()
--   end
--   return elementListenerSet
-- end

-- exports.getFiberFromScopeInstance(
--   scope: ReactScopeInstance,
-- ): nil | Fiber {
--   if enableScopeAPI)
--     return (scope: any)[internalInstanceKey] or nil
--   end
--   return nil
-- end

-- exports.setEventHandlerListeners(
--   scope: EventTarget | ReactScopeInstance,
--   listeners: Set<ReactDOMEventHandleListener>,
-- ): void {
--   (scope: any)[internalEventHandlerListenersKey] = listeners
-- end

-- exports.getEventHandlerListeners(
--   scope: EventTarget | ReactScopeInstance,
-- ): nil | Set<ReactDOMEventHandleListener> {
--   return (scope: any)[internalEventHandlerListenersKey] or nil
-- end

-- exports.addEventHandleToTarget(
--   target: EventTarget | ReactScopeInstance,
--   eventHandle: ReactDOMEventHandle,
-- ): void {
--   local eventHandles = (target: any)[internalEventHandlesSetKey]
--   if eventHandles == undefined)
--     eventHandles = (target: any)[internalEventHandlesSetKey] = new Set()
--   end
--   eventHandles.add(eventHandle)
-- end

-- exports.doesTargetHaveEventHandle(
--   target: EventTarget | ReactScopeInstance,
--   eventHandle: ReactDOMEventHandle,
-- ): boolean {
--   local eventHandles = (target: any)[internalEventHandlesSetKey]
--   if eventHandles == undefined)
--     return false
--   end
--   return eventHandles.has(eventHandle)
-- end

return exports ]]
fT.Children._7ea9035315e325708d1b49954d02d5a0=fY
local fZ

local f_={ClassName="ModuleScript",Children={},Properties={}}
f_.Name="ReactRobloxHostConfig"
f_.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMHostConfig.js
-- ROBLOX upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeHostConfig.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local CollectionService = game:GetService("CollectionService")
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
local console = require(Packages.Shared).console
local Object = LuauPolyfill.Object
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout

-- local type {DOMEventName} = require(Packages.../events/DOMEventNames'
-- local type {Fiber, FiberRoot} = require(Packages.react-reconciler/src/ReactInternalTypes'
-- local type {
--   BoundingRect,
--   IntersectionObserverOptions,
--   ObserveVisibleRectsCallback,
-- } = require(Packages.react-reconciler/src/ReactTestSelectors'
local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type RootType = ReactRobloxHostTypes.RootType
type Container = ReactRobloxHostTypes.Container
type HostInstance = ReactRobloxHostTypes.HostInstance
type SuspenseInstance = ReactRobloxHostTypes.SuspenseInstance
type TextInstance = ReactRobloxHostTypes.TextInstance
type Props = ReactRobloxHostTypes.Props
type Type = ReactRobloxHostTypes.Type
type HostContext = ReactRobloxHostTypes.HostContext

-- local type {ReactScopeInstance} = require(Packages.shared/ReactTypes'
-- local type {ReactDOMFundamentalComponentInstance} = require(Packages.../shared/ReactDOMTypes'

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
local precacheFiberNode = ReactRobloxComponentTree.precacheFiberNode
local uncacheFiberNode = ReactRobloxComponentTree.uncacheFiberNode
local updateFiberProps = ReactRobloxComponentTree.updateFiberProps
-- local getClosestInstanceFromNode = ReactRobloxComponentTree.getClosestInstanceFromNode
-- local getFiberFromScopeInstance = ReactRobloxComponentTree.getFiberFromScopeInstance
-- local getInstanceFromNodeDOMTree = ReactRobloxComponentTree.getInstanceFromNode
-- local isContainerMarkedAsRoot = ReactRobloxComponentTree.isContainerMarkedAsRoot

-- local {hasRole} = require(Packages../DOMAccessibilityRoles'
local ReactRobloxComponent = require(script.Parent.ReactRobloxComponent)
-- local createElement = ReactRobloxComponent.createElement
-- local createTextNode = ReactRobloxComponent.createTextNode
local setInitialProperties = ReactRobloxComponent.setInitialProperties
local diffProperties = ReactRobloxComponent.diffProperties
local updateProperties = ReactRobloxComponent.updateProperties
local cleanupHostComponent = ReactRobloxComponent.cleanupHostComponent
-- local diffHydratedProperties = ReactRobloxComponent.diffHydratedProperties
-- local diffHydratedText = ReactRobloxComponent.diffHydratedText
-- local trapClickOnNonInteractiveElement = ReactRobloxComponent.trapClickOnNonInteractiveElement
-- local warnForUnmatchedText = ReactRobloxComponent.warnForUnmatchedText
-- local warnForDeletedHydratableElement = ReactRobloxComponent.warnForDeletedHydratableElement
-- local warnForDeletedHydratableText = ReactRobloxComponent.warnForDeletedHydratableText
-- local warnForInsertedHydratedElement = ReactRobloxComponent.warnForInsertedHydratedElement
-- local warnForInsertedHydratedText = ReactRobloxComponent.warnForInsertedHydratedText
-- local {getSelectionInformation, restoreSelection} = require(Packages../ReactInputSelection'
-- local setTextContent = require(Packages../setTextContent'
-- local {validateDOMNesting, updatedAncestorInfo} = require(Packages../validateDOMNesting'
-- local {
--   isEnabled as ReactBrowserEventEmitterIsEnabled,
--   setEnabled as ReactBrowserEventEmitterSetEnabled,
-- } = require(Packages.../events/ReactDOMEventListener'
-- local {getChildNamespace} = require(Packages.../shared/DOMNamespaces'
-- local {
--   ELEMENT_NODE,
--   TEXT_NODE,
--   COMMENT_NODE,
--   DOCUMENT_NODE,
--   DOCUMENT_FRAGMENT_NODE,
-- } = require(Packages.../shared/HTMLNodeType'
-- local dangerousStyleValue = require(Packages.../shared/dangerousStyleValue'

-- local {REACT_OPAQUE_ID_TYPE} = require(Packages.shared/ReactSymbols'
-- local {retryIfBlockedOn} = require(Packages.../events/ReactDOMEventReplaying'

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local enableCreateEventHandleAPI = ReactFeatureFlags.enableCreateEventHandleAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
-- local enableEagerRootListeners = ReactFeatureFlags.enableEagerRootListeners

-- local {HostComponent, HostText} = require(Packages.react-reconciler/src/ReactWorkTags'
-- local {
--   listenToReactEvent,
--   listenToAllSupportedEvents,
-- } = require(Packages.../events/DOMPluginEventSystem'

type Array<T> = { [number]: T }
type Object = { [any]: any }

-- ROBLOX deviation: Moved to ReactRobloxHostTypes
-- export type Type = string;
-- export type Props = {
--   autoFocus: boolean?,
--   children: any,
--   disabled: boolean?,
--   hidden: boolean?,
--   suppressHydrationWarning: boolean?,
--   dangerouslySetInnerHTML: any,
--   style: { display: string, [any]: any }?,
--   bottom: number?,
--   left: number?,
--   right: number?,
--   top: number?,
--   -- ...
--   [any]: any,
-- };
-- export type EventTargetChildElement = {
--   type: string,
--   props: nil | {
--     style?: {
--       position?: string,
--       zIndex?: number,
--       bottom?: string,
--       left?: string,
--       right?: string,
--       top?: string,
--       ...
--     },
--     ...
--   },
--   ...
-- end

-- ROBLOX deviation: Moved to ReactRobloxHostTypes
-- export type SuspenseInstance = Comment & {_reactRetry?: () => void, ...}
-- export type HydratableInstance = Instance | TextInstance | SuspenseInstance

-- ROBLOX deviation: Moved to ReactRobloxHostTypes
-- export type PublicInstance = Element | Text
-- type HostContextDev = {
--   namespace: string,
--   ancestorInfo: any,
--   -- ...
--   [any]: any,
-- }
-- type HostContextProd = string
-- export type HostContext = HostContextDev | HostContextProd

-- export type UpdatePayload = Array<mixed>
-- ROBLOX FIXME: cannot create type equal to void
-- export type ChildSet = void; -- Unused
-- export type TimeoutHandle = TimeoutID
-- export type NoTimeout = -1
-- export type RendererInspectionConfig = $ReadOnly<{or}>

-- export opaque type OpaqueIDType =
--   | string
--   | {
--       toString: () => string | void,
--       valueOf: () => string | void,
--     end

-- type SelectionInformation = {|
--   focusedElem: nil | HTMLElement,
--   selectionRange: mixed,
-- |}

-- local SUPPRESS_HYDRATION_WARNING
-- if __DEV__)
--   SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning'
-- end

-- local SUSPENSE_START_DATA = '$'
-- local SUSPENSE_END_DATA = '/$'
-- local SUSPENSE_PENDING_START_DATA = '$?'
-- local SUSPENSE_FALLBACK_START_DATA = '$!'

-- local STYLE = 'style'

-- local eventsEnabled: boolean? = nil
-- local selectionInformation: nil | SelectionInformation = nil

-- function shouldAutoFocusHostComponent(type: string, props: Props): boolean {
--   switch (type)
--     case 'button':
--     case 'input':
--     case 'select':
--     case 'textarea':
--       return !!props.autoFocus
--   end
--   return false
-- end

-- ROBLOX deviation: Use GetDescendants rather than recursion
local function recursivelyUncacheFiberNode(node: HostInstance)
	-- ROBLOX https://jira.rbx.com/browse/LUAFDN-713: Tables are somehow ending up
	-- in this function that expects Instances. In that case, we won't be able to
	-- iterate through its descendants.
	if typeof(node :: any) ~= "Instance" then
		return
	end

	uncacheFiberNode(node)

	for _, child in node:GetDescendants() do
		uncacheFiberNode(child)
	end
end

local exports: { [any]: any } = {}
Object.assign(exports, require(Packages.Shared).ReactFiberHostConfig.WithNoPersistence)

exports.getRootHostContext = function(rootContainerInstance: Container): HostContext
	-- ROBLOX deviation: This is a lot of HTML-DOM specific logic; I'm not clear on
	-- whether there'll be an equivalent of `namespaceURI` for our use cases, but
	-- we may want to provide other kinds of context for host objects.

	-- For now, as a guess, we'll return the kind of instance we're attached to
	return rootContainerInstance.ClassName

	-- local type
	-- local namespace
	-- local nodeType = rootContainerInstance.nodeType
	-- switch (nodeType)
	--   case DOCUMENT_NODE:
	--   case DOCUMENT_FRAGMENT_NODE: {
	--     type = nodeType == DOCUMENT_NODE ? '#document' : '#fragment'
	--     local root = (rootContainerInstance: any).documentElement
	--     namespace = root ? root.namespaceURI : getChildNamespace(null, '')
	--     break
	--   end
	--   default: {
	--     local container: any =
	--       nodeType == COMMENT_NODE
	--         ? rootContainerInstance.parentNode
	--         : rootContainerInstance
	--     local ownNamespace = container.namespaceURI or nil
	--     type = container.tagName
	--     namespace = getChildNamespace(ownNamespace, type)
	--     break
	--   end
	-- end
	-- if _G.__DEV__ then
	--   local validatedTag = type.toLowerCase()
	--   local ancestorInfo = updatedAncestorInfo(null, validatedTag)
	--   return {namespace, ancestorInfo}
	-- end
	-- return namespace
end

exports.getChildHostContext = function(
	parentHostContext: HostContext,
	type: string,
	rootContainerInstance: Container
): HostContext
	-- ROBLOX deviation: unclear on the purpose here just yet, might be fine to
	-- just return parent's hostContext for now
	return parentHostContext
	-- if _G.__DEV__ then
	--   local parentHostContextDev = ((parentHostContext: any): HostContextDev)
	--   local namespace = getChildNamespace(parentHostContextDev.namespace, type)
	--   local ancestorInfo = updatedAncestorInfo(
	--     parentHostContextDev.ancestorInfo,
	--     type,
	--   )
	--   return {namespace, ancestorInfo}
	-- end
	-- local parentNamespace = ((parentHostContext: any): HostContextProd)
	-- return getChildNamespace(parentNamespace, type)
end

exports.getPublicInstance = function(instance: Instance): any
	return instance
end

exports.prepareForCommit = function(containerInfo: Container): Object?
	-- eventsEnabled = ReactBrowserEventEmitterIsEnabled()
	-- selectionInformation = getSelectionInformation()
	local activeInstance = nil
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		--   local focusedElem = selectionInformation.focusedElem
		--   if focusedElem ~= nil then
		--     activeInstance = getClosestInstanceFromNode(focusedElem)
		--   end
	end
	-- ReactBrowserEventEmitterSetEnabled(false)
	return activeInstance
end

exports.beforeActiveInstanceBlur = function()
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		-- ReactBrowserEventEmitterSetEnabled(true)
		-- dispatchBeforeDetachedBlur((selectionInformation: any).focusedElem)
		-- ReactBrowserEventEmitterSetEnabled(false)
	end
end

exports.afterActiveInstanceBlur = function()
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		-- ReactBrowserEventEmitterSetEnabled(true)
		-- dispatchAfterDetachedBlur((selectionInformation: any).focusedElem)
		-- ReactBrowserEventEmitterSetEnabled(false)
	end
end

exports.resetAfterCommit = function(containerInfo: Container)
	-- warn("Skip unimplemented: resetAfterCommit")
	-- restoreSelection(selectionInformation)
	-- ReactBrowserEventEmitterSetEnabled(eventsEnabled)
	-- eventsEnabled = nil
	-- selectionInformation = nil
end

exports.createInstance = function(
	type_: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: HostContext,
	internalInstanceHandle: Object
): HostInstance
	-- local hostKey = virtualNode.hostKey

	local domElement = Instance.new(type_)
	-- ROBLOX deviation: compatibility with old Roact where instances have their name
	-- set to the key value
	if internalInstanceHandle.key then
		domElement.Name = internalInstanceHandle.key
	else
		local currentHandle = internalInstanceHandle.return_
		while currentHandle do
			if currentHandle.key then
				domElement.Name = currentHandle.key
				break
			end
			currentHandle = currentHandle.return_
		end
	end

	precacheFiberNode(internalInstanceHandle, domElement)
	updateFiberProps(domElement, props)

	-- TODO: Support refs (does that actually happen here, or later?)
	-- applyRef(element.props[Ref], instance)

	-- Will have to be managed outside of createInstance
	-- if virtualNode.eventManager ~= nil then
	--   virtualNode.eventManager:resume()
	-- end

	return domElement

	-- return Instance.new("Frame")
	-- local parentNamespace: string
	-- if __DEV__)
	--   -- TODO: take namespace into account when validating.
	--   local hostContextDev = ((hostContext: any): HostContextDev)
	--   validateDOMNesting(type, nil, hostContextDev.ancestorInfo)
	--   if
	--     typeof props.children == 'string' or
	--     typeof props.children == 'number'
	--   )
	--     local string = '' + props.children
	--     local ownAncestorInfo = updatedAncestorInfo(
	--       hostContextDev.ancestorInfo,
	--       type,
	--     )
	--     validateDOMNesting(null, string, ownAncestorInfo)
	--   end
	--   parentNamespace = hostContextDev.namespace
	-- } else {
	--   parentNamespace = ((hostContext: any): HostContextProd)
	-- end
	-- local domElement: Instance = createElement(
	--   type,
	--   props,
	--   rootContainerInstance,
	--   parentNamespace,
	-- )
end

exports.appendInitialChild = function(parentInstance: Instance, child: Instance)
	-- ROBLOX deviation: Establish hierarchy with Parent property
	child.Parent = parentInstance
end

exports.finalizeInitialChildren = function(
	domElement: HostInstance,
	type_: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: HostContext
): boolean
	setInitialProperties(domElement, type_, props, rootContainerInstance)
	return false
	-- return shouldAutoFocusHostComponent(type_, props)
end

local function prepareUpdate(
	domElement: Instance,
	type_: string,
	oldProps: Props,
	newProps: Props,
	rootContainerInstance: Container,
	hostContext: HostContext
): nil | Array<any>
	-- if _G.__DEV__ then
	--   local hostContextDev = ((hostContext: any): HostContextDev)
	--   if
	--     typeof newProps.children ~= typeof oldProps.children and
	--     (typeof newProps.children == 'string' or
	--       typeof newProps.children == 'number')
	--   )
	--     local string = '' + newProps.children
	--     local ownAncestorInfo = updatedAncestorInfo(
	--       hostContextDev.ancestorInfo,
	--       type,
	--     )
	--     validateDOMNesting(null, string, ownAncestorInfo)
	--   end
	-- end
	return diffProperties(domElement, type_, oldProps, newProps, rootContainerInstance)
end
exports.prepareUpdate = prepareUpdate

exports.shouldSetTextContent = function(_type: string, _props: Props): boolean
	-- ROBLOX deviation: Ignore TextInstance logic, which isn't applicable to Roblox
	return false
	--   return (
	--     type == 'textarea' or
	--     type == 'option' or
	--     type == 'noscript' or
	--     typeof props.children == 'string' or
	--     typeof props.children == 'number' or
	--     (typeof props.dangerouslySetInnerHTML == 'table’' and
	--       props.dangerouslySetInnerHTML ~= nil and
	--       props.dangerouslySetInnerHTML.__html ~= nil)
	--   )
end

-- ROBLOX deviation: Text nodes aren't supported in Roblox renderer, so error so that tests fail immediately
exports.createTextInstance = function(
	text: string,
	rootContainerInstance: Container,
	hostContext: HostContext,
	internalInstanceHandle: Object
): any
	unimplemented("createTextInstance")
	return nil
end

exports.isPrimaryRenderer = true
exports.warnsIfNotActing = true
-- This initialization code may run even on server environments
-- if a component just imports ReactDOM (e.g. for findDOMNode).
-- Some environments might not have setTimeout or clearTimeout.
-- ROBLOX deviation: We're only dealing with client right now, so these always populate
exports.scheduleTimeout = setTimeout
exports.cancelTimeout = clearTimeout
exports.noTimeout = -1

-- -------------------
--     Mutation
-- -------------------

exports.supportsMutation = true

exports.commitMount = function(
	domElement: Instance,
	type: string,
	newProps: Props,
	internalInstanceHandle: Object
)
	unimplemented("commitMount")
	-- -- Despite the naming that might imply otherwise, this method only
	-- -- fires if there is an `Update` effect scheduled during mounting.
	-- -- This happens if `finalizeInitialChildren` returns `true` (which it
	-- -- does to implement the `autoFocus` attribute on the client). But
	-- -- there are also other cases when this might happen (such as patching
	-- -- up text content during hydration mismatch). So we'll check this again.
	-- if shouldAutoFocusHostComponent(type, newProps))
	--   ((domElement: any):
	--     | HTMLButtonElement
	--     | HTMLInputElement
	--     | HTMLSelectElement
	--     | HTMLTextAreaElement).focus()
	-- end
end

exports.commitUpdate = function(
	domElement: Instance,
	updatePayload: Array<any>,
	type_: string,
	oldProps: Props,
	newProps: Props,
	internalInstanceHandle: Object
)
	-- Update the props handle so that we know which props are the ones with
	-- with current event handlers.
	updateFiberProps(domElement, newProps)
	-- Apply the diff to the DOM node.
	updateProperties(domElement, updatePayload, oldProps)
end

-- ROBLOX deviation: Ignore TextInstance logic, which isn't applicable to Roblox
-- exports.resetTextContent(domElement: Instance): void {
--   setTextContent(domElement, '')
-- end

-- ROBLOX deviation: Ignore TextInstance logic, which isn't applicable to Roblox
-- exports.commitTextUpdate(
--   textInstance: TextInstance,
--   oldText: string,
--   newText: string,
-- ): void {
--   textInstance.nodeValue = newText
-- end

local function checkTags(instance: Instance)
	if typeof(instance :: any) ~= "Instance" then
		console.warn("Could not check tags on non-instance %s.", inspect(instance))
		return
	end
	if not instance:IsDescendantOf(game) then
		if #CollectionService:GetTags(instance) > 0 then
			console.warn(
				'Tags applied to orphaned %s "%s" cannot be accessed via'
					.. " CollectionService:GetTagged. If you're relying on tag"
					.. " behavior in a unit test, consider mounting your test "
					.. "root into the DataModel.",
				instance.ClassName,
				instance.Name
			)
		end
	end
end

exports.appendChild = function(parentInstance: Instance, child: Instance)
	-- ROBLOX deviation: Roblox's DOM is based on child->parent references
	child.Parent = parentInstance
	-- parentInstance.appendChild(child)
	if _G.__DEV__ then
		checkTags(child)
	end
end

exports.appendChildToContainer = function(container: Container, child: Instance)
	-- ROBLOX TODO: Some of this logic may come back; for now, keep it simple
	local parentNode = container
	exports.appendChild(parentNode, child)

	-- if container.nodeType == COMMENT_NODE)
	--   parentNode = (container.parentNode: any)
	--   parentNode.insertBefore(child, container)
	-- } else {
	--   parentNode = container
	--   parentNode.appendChild(child)
	-- end
	-- -- This container might be used for a portal.
	-- -- If something inside a portal is clicked, that click should bubble
	-- -- through the React tree. However, on Mobile Safari the click would
	-- -- never bubble through the *DOM* tree unless an ancestor with onclick
	-- -- event exists. So we wouldn't see it and dispatch it.
	-- -- This is why we ensure that non React root containers have inline onclick
	-- -- defined.
	-- -- https://github.com/facebook/react/issues/11918
	-- local reactRootContainer = container._reactRootContainer
	-- if
	--   reactRootContainer == nil and parentNode.onclick == nil
	-- then
	--   -- TODO: This cast may not be sound for SVG, MathML or custom elements.
	--   trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement))
	-- end
end

exports.insertBefore =
	function(parentInstance: Instance, child: Instance, _beforeChild: Instance)
		-- ROBLOX deviation: Roblox's DOM is based on child->parent references
		child.Parent = parentInstance
		-- parentInstance.insertBefore(child, beforeChild)
		if _G.__DEV__ then
			checkTags(child)
		end
	end

exports.insertInContainerBefore =
	function(container: Container, child: Instance, beforeChild: Instance)
		-- ROBLOX deviation: use our container definition
		local parentNode = container
		exports.insertBefore(parentNode, child, beforeChild)
		-- if container.nodeType == COMMENT_NODE)
		--   (container.parentNode: any).insertBefore(child, beforeChild)
		-- } else {
		--   container.insertBefore(child, beforeChild)
		-- end
	end

-- function createEvent(type: DOMEventName, bubbles: boolean): Event {
--   local event = document.createEvent('Event')
--   event.initEvent(((type: any): string), bubbles, false)
--   return event
-- end

-- function dispatchBeforeDetachedBlur(target: HTMLElement): void {
--   if enableCreateEventHandleAPI)
--     local event = createEvent('beforeblur', true)
--     -- Dispatch "beforeblur" directly on the target,
--     -- so it gets picked up by the event system and
--     -- can propagate through the React internal tree.
--     target.dispatchEvent(event)
--   end
-- end

-- function dispatchAfterDetachedBlur(target: HTMLElement): void {
--   if enableCreateEventHandleAPI)
--     local event = createEvent('afterblur', false)
--     -- So we know what was detached, make the relatedTarget the
--     -- detached target on the "afterblur" event.
--     (event: any).relatedTarget = target
--     -- Dispatch the event on the document.
--     document.dispatchEvent(event)
--   end
-- end

exports.removeChild = function(_parentInstance: Instance, child: Instance)
	recursivelyUncacheFiberNode(child)
	-- ROBLOX deviation: The roblox renderer tracks bindings and event managers
	-- for instances, so make sure we clean those up when we remove the instance
	cleanupHostComponent(child)
	-- ROBLOX deviation: Roblox's DOM is based on child->parent references
	child.Parent = nil
	-- parentInstance.removeChild(child)
	-- ROBLOX deviation: Guard against misuse by locking parent and forcing external cleanup via Destroy
	child:Destroy()
end

exports.removeChildFromContainer = function(_container: Container, child: Instance)
	-- ROBLOX deviation: Containers don't have special behavior and comment nodes
	-- have no datamodel equivalent, so just forward to the removeChild logic
	exports.removeChild(_container, child)
	-- if container.nodeType == COMMENT_NODE)
	--   (container.parentNode: any).removeChild(child)
	-- } else {
	--   container.removeChild(child)
	-- end
end

exports.clearSuspenseBoundary =
	function(parentInstance: Instance, suspenseInstance: SuspenseInstance)
		-- ROBLOX FIXME: this is a major thing we need to fix for Suspense to work as a feature
		unimplemented("clearSuspenseBoundary")
		--   local node = suspenseInstance
		--   -- Delete all nodes within this suspense boundary.
		--   -- There might be nested nodes so we need to keep track of how
		--   -- deep we are and only break out when we're back on top.
		--   local depth = 0
		--   do {
		--     local nextNode = node.nextSibling
		--     parentInstance.removeChild(node)
		--     if nextNode and nextNode.nodeType == COMMENT_NODE)
		--       local data = ((nextNode: any).data: string)
		--       if data == SUSPENSE_END_DATA)
		--         if depth == 0)
		--           parentInstance.removeChild(nextNode)
		--           -- Retry if any event replaying was blocked on this.
		--           retryIfBlockedOn(suspenseInstance)
		--           return
		--         } else {
		--           depth--
		--         end
		--       } else if
		--         data == SUSPENSE_START_DATA or
		--         data == SUSPENSE_PENDING_START_DATA or
		--         data == SUSPENSE_FALLBACK_START_DATA
		--       )
		--         depth++
		--       end
		--     end
		--     node = nextNode
		--   } while (node)
		--   -- TODO: Warn, we didn't find the end comment boundary.
		--   -- Retry if any event replaying was blocked on this.
		--   retryIfBlockedOn(suspenseInstance)
	end

exports.clearSuspenseBoundaryFromContainer =
	function(container: Container, suspenseInstance: SuspenseInstance)
		-- ROBLOX FIXME: this is a major thing we need to fix for Suspense to work as a feature
		unimplemented("clearSuspenseBoundaryFromContainer")
		--   if container.nodeType == COMMENT_NODE)
		--     clearSuspenseBoundary((container.parentNode: any), suspenseInstance)
		--   } else if container.nodeType == ELEMENT_NODE)
		--     clearSuspenseBoundary((container: any), suspenseInstance)
		--   } else {
		--     -- Document nodes should never contain suspense boundaries.
		--   end
		--   -- Retry if any event replaying was blocked on this.
		--   retryIfBlockedOn(container)
	end

exports.hideInstance = function(instance: Instance)
	unimplemented("hideInstance")
	-- -- TODO: Does this work for all element types? What about MathML? Should we
	-- -- pass host context to this method?
	-- instance = ((instance: any): HTMLElement)
	-- local style = instance.style
	-- if typeof style.setProperty == 'function')
	--   style.setProperty('display', 'none', 'important')
	-- } else {
	--   style.display = 'none'
	-- end
end

-- ROBLOX deviation: error on TextInstance logic, which isn't applicable to Roblox
exports.hideTextInstance = function(textInstance: TextInstance): ()
	unimplemented("hideTextInstance")
	--   textInstance.nodeValue = ''
end

exports.unhideInstance = function(instance: Instance, props: Props)
	unimplemented("unhideInstance")
	-- instance = ((instance: any): HTMLElement)
	-- local styleProp = props[STYLE]
	-- local display =
	--   styleProp ~= undefined and
	--   styleProp ~= nil and
	--   styleProp.hasOwnProperty('display')
	--     ? styleProp.display
	--     : nil
	-- instance.style.display = dangerousStyleValue('display', display)
end

-- ROBLOX deviation: error on TextInstance logic, which isn't applicable to Roblox
exports.unhideTextInstance = function(textInstance: TextInstance, text: string): ()
	unimplemented("unhideTextInstance")
	--   textInstance.nodeValue = text
end

exports.clearContainer = function(container: Container)
	-- ROBLOX deviation: with Roblox, we can simply enumerate and remove the children
	local parentInstance = container
	for _, child in parentInstance:GetChildren() do
		exports.removeChild(parentInstance, child)
	end
	-- if container.nodeType == ELEMENT_NODE)
	--   ((container: any): Element).textContent = ''
	-- } else if container.nodeType == DOCUMENT_NODE)
	--   local body = ((container: any): Document).body
	--   if body ~= nil)
	--     body.textContent = ''
	--   end
	-- end
end

-- -- -------------------
-- --     Hydration
-- -- -------------------

-- export local supportsHydration = true

-- exports.canHydrateInstance(
--   instance: HydratableInstance,
--   type: string,
--   props: Props,
-- ): nil | Instance {
--   if
--     instance.nodeType ~= ELEMENT_NODE or
--     type.toLowerCase() ~= instance.nodeName.toLowerCase()
--   )
--     return nil
--   end
--   -- This has now been refined to an element node.
--   return ((instance: any): Instance)
-- end

-- exports.canHydrateTextInstance(
--   instance: HydratableInstance,
--   text: string,
-- ): nil | TextInstance {
--   if text == '' or instance.nodeType ~= TEXT_NODE)
--     -- Empty strings are not parsed by HTML so there won't be a correct match here.
--     return nil
--   end
--   -- This has now been refined to a text node.
--   return ((instance: any): TextInstance)
-- end

-- exports.canHydrateSuspenseInstance(
--   instance: HydratableInstance,
-- ): nil | SuspenseInstance {
--   if instance.nodeType ~= COMMENT_NODE)
--     -- Empty strings are not parsed by HTML so there won't be a correct match here.
--     return nil
--   end
--   -- This has now been refined to a suspense node.
--   return ((instance: any): SuspenseInstance)
-- end

-- exports.isSuspenseInstanceFallback(instance: SuspenseInstance)
--   return instance.data == SUSPENSE_FALLBACK_START_DATA
-- end

-- exports.registerSuspenseInstanceRetry(
--   instance: SuspenseInstance,
--   callback: () => void,
-- )
--   instance._reactRetry = callback
-- end

-- function getNextHydratable(node)
--   -- Skip non-hydratable nodes.
--   for (; node ~= nil; node = node.nextSibling)
--     local nodeType = node.nodeType
--     if nodeType == ELEMENT_NODE or nodeType == TEXT_NODE)
--       break
--     end
--     if enableSuspenseServerRenderer)
--       if nodeType == COMMENT_NODE)
--         local nodeData = (node: any).data
--         if
--           nodeData == SUSPENSE_START_DATA or
--           nodeData == SUSPENSE_FALLBACK_START_DATA or
--           nodeData == SUSPENSE_PENDING_START_DATA
--         )
--           break
--         end
--       end
--     end
--   end
--   return (node: any)
-- end

-- exports.getNextHydratableSibling(
--   instance: HydratableInstance,
-- ): nil | HydratableInstance {
--   return getNextHydratable(instance.nextSibling)
-- end

-- exports.getFirstHydratableChild(
--   parentInstance: Container | Instance,
-- ): nil | HydratableInstance {
--   return getNextHydratable(parentInstance.firstChild)
-- end

-- exports.hydrateInstance(
--   instance: Instance,
--   type: string,
--   props: Props,
--   rootContainerInstance: Container,
--   hostContext: HostContext,
--   internalInstanceHandle: Object,
-- ): nil | Array<mixed> {
--   precacheFiberNode(internalInstanceHandle, instance)
--   -- TODO: Possibly defer this until the commit phase where all the events
--   -- get attached.
--   updateFiberProps(instance, props)
--   local parentNamespace: string
--   if __DEV__)
--     local hostContextDev = ((hostContext: any): HostContextDev)
--     parentNamespace = hostContextDev.namespace
--   } else {
--     parentNamespace = ((hostContext: any): HostContextProd)
--   end
--   return diffHydratedProperties(
--     instance,
--     type,
--     props,
--     parentNamespace,
--     rootContainerInstance,
--   )
-- end

-- exports.hydrateTextInstance(
--   textInstance: TextInstance,
--   text: string,
--   internalInstanceHandle: Object,
-- ): boolean {
--   precacheFiberNode(internalInstanceHandle, textInstance)
--   return diffHydratedText(textInstance, text)
-- end

-- exports.hydrateSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
--   internalInstanceHandle: Object,
-- )
--   precacheFiberNode(internalInstanceHandle, suspenseInstance)
-- end

-- exports.getNextHydratableInstanceAfterSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
-- ): nil | HydratableInstance {
--   local node = suspenseInstance.nextSibling
--   -- Skip past all nodes within this suspense boundary.
--   -- There might be nested nodes so we need to keep track of how
--   -- deep we are and only break out when we're back on top.
--   local depth = 0
--   while (node)
--     if node.nodeType == COMMENT_NODE)
--       local data = ((node: any).data: string)
--       if data == SUSPENSE_END_DATA)
--         if depth == 0)
--           return getNextHydratableSibling((node: any))
--         } else {
--           depth--
--         end
--       } else if
--         data == SUSPENSE_START_DATA or
--         data == SUSPENSE_FALLBACK_START_DATA or
--         data == SUSPENSE_PENDING_START_DATA
--       )
--         depth++
--       end
--     end
--     node = node.nextSibling
--   end
--   -- TODO: Warn, we didn't find the end comment boundary.
--   return nil
-- end

-- -- Returns the SuspenseInstance if this node is a direct child of a
-- -- SuspenseInstance. I.e. if its previous sibling is a Comment with
-- -- SUSPENSE_x_START_DATA. Otherwise, nil.
-- exports.getParentSuspenseInstance(
--   targetInstance: Node,
-- ): nil | SuspenseInstance {
--   local node = targetInstance.previousSibling
--   -- Skip past all nodes within this suspense boundary.
--   -- There might be nested nodes so we need to keep track of how
--   -- deep we are and only break out when we're back on top.
--   local depth = 0
--   while (node)
--     if node.nodeType == COMMENT_NODE)
--       local data = ((node: any).data: string)
--       if
--         data == SUSPENSE_START_DATA or
--         data == SUSPENSE_FALLBACK_START_DATA or
--         data == SUSPENSE_PENDING_START_DATA
--       )
--         if depth == 0)
--           return ((node: any): SuspenseInstance)
--         } else {
--           depth--
--         end
--       } else if data == SUSPENSE_END_DATA)
--         depth++
--       end
--     end
--     node = node.previousSibling
--   end
--   return nil
-- end

-- exports.commitHydratedContainer(container: Container): void {
--   -- Retry if any event replaying was blocked on this.
--   retryIfBlockedOn(container)
-- end

-- exports.commitHydratedSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
-- ): void {
--   -- Retry if any event replaying was blocked on this.
--   retryIfBlockedOn(suspenseInstance)
-- end

-- exports.didNotMatchHydratedContainerTextInstance(
--   parentContainer: Container,
--   textInstance: TextInstance,
--   text: string,
-- )
--   if __DEV__)
--     warnForUnmatchedText(textInstance, text)
--   end
-- end

-- exports.didNotMatchHydratedTextInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   textInstance: TextInstance,
--   text: string,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForUnmatchedText(textInstance, text)
--   end
-- end

-- exports.didNotHydrateContainerInstance(
--   parentContainer: Container,
--   instance: HydratableInstance,
-- )
--   if __DEV__)
--     if instance.nodeType == ELEMENT_NODE)
--       warnForDeletedHydratableElement(parentContainer, (instance: any))
--     } else if instance.nodeType == COMMENT_NODE)
--       -- TODO: warnForDeletedHydratableSuspenseBoundary
--     } else {
--       warnForDeletedHydratableText(parentContainer, (instance: any))
--     end
--   end
-- end

-- exports.didNotHydrateInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   instance: HydratableInstance,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     if instance.nodeType == ELEMENT_NODE)
--       warnForDeletedHydratableElement(parentInstance, (instance: any))
--     } else if instance.nodeType == COMMENT_NODE)
--       -- TODO: warnForDeletedHydratableSuspenseBoundary
--     } else {
--       warnForDeletedHydratableText(parentInstance, (instance: any))
--     end
--   end
-- end

-- exports.didNotFindHydratableContainerInstance(
--   parentContainer: Container,
--   type: string,
--   props: Props,
-- )
--   if __DEV__)
--     warnForInsertedHydratedElement(parentContainer, type, props)
--   end
-- end

-- exports.didNotFindHydratableContainerTextInstance(
--   parentContainer: Container,
--   text: string,
-- )
--   if __DEV__)
--     warnForInsertedHydratedText(parentContainer, text)
--   end
-- end

-- exports.didNotFindHydratableContainerSuspenseInstance(
--   parentContainer: Container,
-- )
--   if __DEV__)
--     -- TODO: warnForInsertedHydratedSuspense(parentContainer)
--   end
-- end

-- exports.didNotFindHydratableInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   type: string,
--   props: Props,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForInsertedHydratedElement(parentInstance, type, props)
--   end
-- end

-- exports.didNotFindHydratableTextInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   text: string,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForInsertedHydratedText(parentInstance, text)
--   end
-- end

-- exports.didNotFindHydratableSuspenseInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     -- TODO: warnForInsertedHydratedSuspense(parentInstance)
--   end
-- end

-- exports.getFundamentalComponentInstance(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): Instance {
--   if enableFundamentalAPI)
--     local {currentFiber, impl, props, state} = fundamentalInstance
--     local instance = impl.getInstance(null, props, state)
--     precacheFiberNode(currentFiber, instance)
--     return instance
--   end
--   -- Because of the flag above, this gets around the Flow error
--   return (null: any)
-- end

-- exports.mountFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, props, state} = fundamentalInstance
--     local onMount = impl.onMount
--     if onMount ~= undefined)
--       onMount(null, instance, props, state)
--     end
--   end
-- end

-- exports.shouldUpdateFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): boolean {
--   if enableFundamentalAPI)
--     local {impl, prevProps, props, state} = fundamentalInstance
--     local shouldUpdate = impl.shouldUpdate
--     if shouldUpdate ~= undefined)
--       return shouldUpdate(null, prevProps, props, state)
--     end
--   end
--   return true
-- end

-- exports.updateFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, prevProps, props, state} = fundamentalInstance
--     local onUpdate = impl.onUpdate
--     if onUpdate ~= undefined)
--       onUpdate(null, instance, prevProps, props, state)
--     end
--   end
-- end

-- exports.unmountFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, props, state} = fundamentalInstance
--     local onUnmount = impl.onUnmount
--     if onUnmount ~= undefined)
--       onUnmount(null, instance, props, state)
--     end
--   end
-- end

-- exports.getInstanceFromNode(node: HTMLElement): nil | Object {
--   return getClosestInstanceFromNode(node) or nil
-- end

-- local clientId: number = 0
-- exports.makeClientId(): OpaqueIDType {
--   return 'r:' + (clientId++).toString(36)
-- end

-- exports.makeClientIdInDEV(warnOnAccessInDEV: () => void): OpaqueIDType {
--   local id = 'r:' + (clientId++).toString(36)
--   return {
--     toString()
--       warnOnAccessInDEV()
--       return id
--     },
--     valueOf()
--       warnOnAccessInDEV()
--       return id
--     },
--   end
-- end

-- exports.isOpaqueHydratingObject(value: mixed): boolean {
--   return (
--     value ~= nil and
--     typeof value == 'table’' and
--     value.$$typeof == REACT_OPAQUE_ID_TYPE
--   )
-- end

-- exports.makeOpaqueHydratingObject(
--   attemptToReadValue: () => void,
-- ): OpaqueIDType {
--   return {
--     $$typeof: REACT_OPAQUE_ID_TYPE,
--     toString: attemptToReadValue,
--     valueOf: attemptToReadValue,
--   end
-- end

exports.preparePortalMount = function(portalInstance: Instance): ()
	-- ROBLOX TODO: Revisit this logic and see if any of it applies
	-- if enableEagerRootListeners then
	--   listenToAllSupportedEvents(portalInstance)
	-- else
	--   listenToReactEvent('onMouseEnter', portalInstance)
	-- end
end

-- exports.prepareScopeUpdate(
--   scopeInstance: ReactScopeInstance,
--   internalInstanceHandle: Object,
-- ): void {
--   if enableScopeAPI)
--     precacheFiberNode(internalInstanceHandle, scopeInstance)
--   end
-- end

-- exports.getInstanceFromScope(
--   scopeInstance: ReactScopeInstance,
-- ): nil | Object {
--   if enableScopeAPI)
--     return getFiberFromScopeInstance(scopeInstance)
--   end
--   return nil
-- end

-- export local supportsTestSelectors = true

-- exports.findFiberRoot(node: Instance): nil | FiberRoot {
--   local stack = [node]
--   local index = 0
--   while (index < stack.length)
--     local current = stack[index++]
--     if isContainerMarkedAsRoot(current))
--       return ((getInstanceFromNodeDOMTree(current): any): FiberRoot)
--     end
--     stack.push(...current.children)
--   end
--   return nil
-- end

-- exports.getBoundingRect(node: Instance): BoundingRect {
--   local rect = node.getBoundingClientRect()
--   return {
--     x: rect.left,
--     y: rect.top,
--     width: rect.width,
--     height: rect.height,
--   end
-- end

-- exports.matchAccessibilityRole(node: Instance, role: string): boolean {
--   if hasRole(node, role))
--     return true
--   end

--   return false
-- end

-- exports.getTextContent(fiber: Fiber): string | nil {
--   switch (fiber.tag)
--     case HostComponent:
--       local textContent = ''
--       local childNodes = fiber.stateNode.childNodes
--       for (local i = 0; i < childNodes.length; i++)
--         local childNode = childNodes[i]
--         if childNode.nodeType == Node.TEXT_NODE)
--           textContent += childNode.textContent
--         end
--       end
--       return textContent
--     case HostText:
--       return fiber.stateNode.textContent
--   end

--   return nil
-- end

-- exports.isHiddenSubtree(fiber: Fiber): boolean {
--   return fiber.tag == HostComponent and fiber.memoizedProps.hidden == true
-- end

-- exports.setFocusIfFocusable(node: Instance): boolean {
--   -- The logic for determining if an element is focusable is kind of complex,
--   -- and since we want to actually change focus anyway- we can just skip it.
--   -- Instead we'll just listen for a "focus" event to verify that focus was set.
--   --
--   -- We could compare the node to document.activeElement after focus,
--   -- but this would not handle the case where application code managed focus to automatically blur.
--   local didFocus = false
--   local handleFocus = () => {
--     didFocus = true
--   end

--   local element = ((node: any): HTMLElement)
--   try {
--     element.addEventListener('focus', handleFocus)
--     (element.focus or HTMLElement.prototype.focus).call(element)
--   } finally {
--     element.removeEventListener('focus', handleFocus)
--   end

--   return didFocus
-- end

-- type RectRatio = {
--   ratio: number,
--   rect: BoundingRect,
-- end

-- exports.setupIntersectionObserver(
--   targets: Array<Instance>,
--   callback: ObserveVisibleRectsCallback,
--   options?: IntersectionObserverOptions,
-- ): {|
--   disconnect: () => void,
--   observe: (instance: Instance) => void,
--   unobserve: (instance: Instance) => void,
-- |} {
--   local rectRatioCache: Map<Instance, RectRatio> = new Map()
--   targets.forEach(target => {
--     rectRatioCache.set(target, {
--       rect: getBoundingRect(target),
--       ratio: 0,
--     })
--   })

--   local handleIntersection = (entries: Array<IntersectionObserverEntry>) => {
--     entries.forEach(entry => {
--       local {boundingClientRect, intersectionRatio, target} = entry
--       rectRatioCache.set(target, {
--         rect: {
--           x: boundingClientRect.left,
--           y: boundingClientRect.top,
--           width: boundingClientRect.width,
--           height: boundingClientRect.height,
--         },
--         ratio: intersectionRatio,
--       })
--     })

--     callback(Array.from(rectRatioCache.values()))
--   end

--   local observer = new IntersectionObserver(handleIntersection, options)
--   targets.forEach(target => {
--     observer.observe((target: any))
--   })

--   return {
--     disconnect: () => observer.disconnect(),
--     observe: target => {
--       rectRatioCache.set(target, {
--         rect: getBoundingRect(target),
--         ratio: 0,
--       })
--       observer.observe((target: any))
--     },
--     unobserve: target => {
--       rectRatioCache.delete(target)
--       observer.unobserve((target: any))
--     },
--   end
-- end

return exports ]]
fT.Children._0dea315b987f2e9187ebe2de7835ef7c=f_
local f0

local f1={ClassName="ModuleScript",Children={},Properties={}}
f1.Name="ReactRobloxHostTypes.roblox"
f1.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMHostConfig.js
-- ROBLOX upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeHostConfig.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local Packages = script.Parent.Parent.Parent

local ReactReconciler = require(Packages.ReactReconciler)
type FiberRoot = ReactReconciler.FiberRoot

local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type ReactNodeList = ReactTypes.ReactNodeList

type Array<T> = { [number]: T }

-- deviation: Containers should also be instances; at some point, we may
-- restrict which _kinds_ of instances, but that's not necessary right now
export type Container = Instance
-- export type Container =
--   | (Element & {_reactRootContainer?: RootType, ...})
--   | (Document & {_reactRootContainer?: RootType, ...})

-- deviation: We can't export this as `Instance`; luau gets upset!
export type HostInstance = Instance

export type TextInstance = Instance

-- ROBLOX TODO: Revisit this type for suspense
-- export type SuspenseInstance = Comment & {_reactRetry?: () => void, ...}
export type SuspenseInstance = any

export type Type = string
export type Props = {
	autoFocus: boolean?,
	children: any,
	disabled: boolean?,
	hidden: boolean?,
	suppressHydrationWarning: boolean?,
	dangerouslySetInnerHTML: any,
	style: { display: string, [any]: any }?,
	bottom: number?,
	left: number?,
	right: number?,
	top: number?,
	-- ...
	[any]: any,
}

-- ROBLOX TODO: Revisit this type for hydration
-- export type HydratableInstance = Instance | TextInstance | SuspenseInstance
export type HydratableInstance = Instance | SuspenseInstance

-- ROBLOX TODO: Revisit this to make sure it makes sense
-- export type PublicInstance = Element | Text
export type PublicInstance = HostInstance

-- ROBLOX TODO: See if these actually make sense
type HostContextDev = {
	namespace: string,
	ancestorInfo: any,
	-- ...
	[any]: any,
}
type HostContextProd = string
export type HostContext = HostContextDev | HostContextProd

export type RootType = {
	render: (self: RootType, children: ReactNodeList) -> (),
	unmount: (self: RootType) -> (),
	_internalRoot: any,
	-- _internalRoot: FiberRoot,
	-- ...
	[any]: any,
}

export type RootOptions = {
	hydrate: boolean?,
	hydrationOptions: {
		onHydrated: (suspenseNode: any) -> ()?,
		onDeleted: (suspenseNode: any) -> ()?,
		mutableSources: Array<MutableSource<any>>?,
		-- ...
		[any]: any,
	}?,
	-- ...
	[any]: any,
}

return {} ]]
fT.Children._695e07b66ae759f1049b44da7016fddc=f1
local f2

local f3={ClassName="ModuleScript",Children={},Properties={}}
f3.Name="ReactRobloxRoot"
f3.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMRoot.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent.Parent

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type Container = ReactRobloxHostTypes.Container
type RootType = ReactRobloxHostTypes.RootType
type RootOptions = ReactRobloxHostTypes.RootOptions

local ReconcilerTypes = require(Packages.ReactReconciler)
type RootTag = ReconcilerTypes.RootTag
local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type ReactNodeList = ReactTypes.ReactNodeList
local ReactInternalTypes = require(Packages.ReactReconciler)
type FiberRoot = ReactInternalTypes.FiberRoot

type Array<T> = { [number]: T }

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
-- local isContainerMarkedAsRoot = ReactRobloxComponentTree.isContainerMarkedAsRoot
local markContainerAsRoot = ReactRobloxComponentTree.markContainerAsRoot
local unmarkContainerAsRoot = ReactRobloxComponentTree.unmarkContainerAsRoot
-- local listenToAllSupportedEvents = require(script.Parent.Parent.events.DOMPluginEventSystem).listenToAllSupportedEvents
-- local eagerlyTrapReplayableEvents = require(script.Parent.Parent.events.ReactDOMEventReplaying).eagerlyTrapReplayableEvents
-- local HTMLNodeType = require(script.Parent.Parent.shared.HTMLNodeType)
-- local ELEMENT_NODE = HTMLNodeType.ELEMENT_NODE
-- local COMMENT_NODE = HTMLNodeType.COMMENT_NODE
-- local DOCUMENT_NODE = HTMLNodeType.DOCUMENT_NODE
-- local DOCUMENT_FRAGMENT_NODE = HTMLNodeType.DOCUMENT_FRAGMENT_NODE
-- local ensureListeningTo = require(Packages.ReactDOMComponent).ensureListeningTo

-- ROBLOX deviation: Use the config-injecting entry point for the reconciler
local ReactFiberReconciler = require(script.Parent.Parent["ReactReconciler.roblox"])
local createContainer = ReactFiberReconciler.createContainer
local updateContainer = ReactFiberReconciler.updateContainer
-- local findHostInstanceWithNoPortals = ReactFiberReconciler.findHostInstanceWithNoPortals
-- local registerMutableSourceForHydration = ReactFiberReconciler.registerMutableSourceForHydration
local invariant = require(Packages.Shared).invariant
local enableEagerRootListeners =
	require(Packages.Shared).ReactFeatureFlags.enableEagerRootListeners

local BlockingRoot = ReactFiberReconciler.ReactRootTags.BlockingRoot
local ConcurrentRoot = ReactFiberReconciler.ReactRootTags.ConcurrentRoot
local LegacyRoot = ReactFiberReconciler.ReactRootTags.LegacyRoot

local createRootImpl

local ReactRobloxRoot = {}
ReactRobloxRoot.__index = ReactRobloxRoot

function ReactRobloxRoot.new(container: Container, options: RootOptions?): RootType
	local root: RootType = (setmetatable({}, ReactRobloxRoot) :: any) :: RootType
	root._internalRoot = createRootImpl(container, ConcurrentRoot, options)

	return root
end

local function createBlockingRoot(
	container: Container,
	tag: RootTag,
	options: RootOptions?
): RootType
	-- deviation: We can just share the logic here via metatables
	local root: RootType = (setmetatable({}, ReactRobloxRoot) :: any) :: RootType
	root._internalRoot = createRootImpl(container, tag, options)

	return root
end

function ReactRobloxRoot:render(children: ReactNodeList)
	local root = self._internalRoot
	-- if _G.__DEV__ then
	--   if typeof (arguments[1] == 'function')
	--     console.error(
	--       'render(...): does not support the second callback argument. ' +
	--         'To execute a side effect after rendering, declare it in a component body with useEffect().',
	--     )
	--   end
	--   local container = root.containerInfo

	--   if container.nodeType ~= COMMENT_NODE)
	--     local hostInstance = findHostInstanceWithNoPortals(root.current)
	--     if hostInstance)
	--       if hostInstance.parentNode ~= container)
	--         console.error(
	--           'render(...): It looks like the React-rendered content of the ' +
	--             'root container was removed without using React. This is not ' +
	--             'supported and will cause errors. Instead, call ' +
	--             "root.unmount() to empty a root's container.",
	--         )
	--       end
	--     end
	--   end
	-- end
	updateContainer(children, root, nil)
end

function ReactRobloxRoot:unmount()
	-- if _G.__DEV__ then
	--   if typeof arguments[0] == 'function')
	--     console.error(
	--       'unmount(...): does not support a callback argument. ' +
	--         'To execute a side effect after rendering, declare it in a component body with useEffect().',
	--     )
	--   end
	-- end
	local root = self._internalRoot
	local container = root.containerInfo
	updateContainer(nil, root, nil, function()
		unmarkContainerAsRoot(container)
	end)
end

-- ROBLOX TODO: add Options type
-- createRootImpl = function(
--   container: Container,
--   tag: RootTag,
--   options: RootOptions
-- )
createRootImpl = function(container: Container, tag: RootTag, options: any)
	-- Tag is either LegacyRoot or Concurrent Root
	local hydrate = options ~= nil and options.hydrate == true
	local hydrationCallbacks = if options ~= nil then options.hydrationOptions else nil
	local mutableSources = (
		options ~= nil
		and options.hydrationOptions ~= nil
		and options.hydrationOptions.mutableSources
	) or nil
	local root = createContainer(container, tag, hydrate, hydrationCallbacks)
	markContainerAsRoot(root.current, container)
	-- local containerNodeType = container.nodeType

	if enableEagerRootListeners then
		--   local rootContainerElement =
		--     container.nodeType == COMMENT_NODE and container.parentNode or container
		--   listenToAllSupportedEvents(rootContainerElement)
		-- } else {
		--   if hydrate and tag ~= LegacyRoot)
		--     local doc =
		--       containerNodeType == DOCUMENT_NODE
		--         ? container
		--         : container.ownerDocument
		--     -- We need to cast this because Flow doesn't work
		--     -- with the hoisted containerNodeType. If we inline
		--     -- it, then Flow doesn't complain. We intentionally
		--     -- hoist it to reduce code-size.
		--     eagerlyTrapReplayableEvents(container, ((doc: any): Document))
		--   } else if
		--     containerNodeType ~= DOCUMENT_FRAGMENT_NODE and
		--     containerNodeType ~= DOCUMENT_NODE
		--   )
		--     ensureListeningTo(container, 'onMouseEnter')
		--   end
	end

	if mutableSources then
		-- for (local i = 0; i < mutableSources.length; i++)
		--   local mutableSource = mutableSources[i]
		--   registerMutableSourceForHydration(root, mutableSource)
		-- end
	end

	return root
end

local exports = {}

local function isValidContainer(node: any): boolean
	-- ROBLOX TODO: This behavior will deviate, for now just check that it's an
	-- instance, which should be good enough
	return typeof(node) == "Instance"
	-- return not not (
	--   node and
	--   (node.nodeType == ELEMENT_NODE or
	--     node.nodeType == DOCUMENT_NODE or
	--     node.nodeType == DOCUMENT_FRAGMENT_NODE or
	--     (node.nodeType == COMMENT_NODE and
	--       node.nodeValue == ' react-mount-point-unstable '))
	-- )
end

exports.isValidContainer = isValidContainer

-- deviation: Create `Container` from instance
exports.createRoot = function(container: Container, options: RootOptions?): RootType
	invariant(
		isValidContainer(container),
		-- ROBLOX deviation: Use roblox engine terminology
		"createRoot(...): Target container is not a Roblox Instance."
	)
	warnIfReactDOMContainerInDEV(container)
	return ReactRobloxRoot.new(container, options)
end

exports.createBlockingRoot =
	function(container: Container, options: RootOptions?): RootType
		invariant(
			isValidContainer(container),
			-- ROBLOX deviation: Use roblox engine terminology
			"createRoot(...): Target container is not a Roblox Instance."
		)
		warnIfReactDOMContainerInDEV(container)
		return createBlockingRoot(container, BlockingRoot, options)
	end

exports.createLegacyRoot = function(container: Container, options: RootOptions?): RootType
	return createBlockingRoot(container, LegacyRoot, options)
end

function warnIfReactDOMContainerInDEV(container)
	if _G.__DEV__ then
		-- ROBLOX TODO: This behavior will deviate; should we validate that the
		-- container is not a PlayerGui of any sort?

		-- if
		--   container.nodeType == ELEMENT_NODE and
		--   container.tagName and
		--   container.tagName.toUpperCase() == 'BODY'
		-- then
		--   console.error(
		--     'createRoot(): Creating roots directly with document.body is ' ..
		--       'discouraged, since its children are often manipulated by third-party ' ..
		--       'scripts and browser extensions. This may lead to subtle ' ..
		--       'reconciliation issues. Try using a container element created ' ..
		--       'for your app.'
		--   )
		-- end
		-- if isContainerMarkedAsRoot(container) then
		--   if container._reactRootContainer then
		--     console.error(
		--       'You are calling ReactDOM.createRoot() on a container that was previously ' ..
		--         'passed to ReactDOM.render(). This is not supported.'
		--     )
		--   else
		--     console.error(
		--       'You are calling ReactDOM.createRoot() on a container that ' ..
		--         'has already been passed to createRoot() before. Instead, call ' ..
		--         'root.render() on the existing root instead if you want to update it.'
		--     )
		--   end
		-- end
	end
end

return exports ]]
fT.Children._aadc8457246217633cbda15f2d823111=f3
local f4

local f5={ClassName="Folder",Children={},Properties={}}
f5.Name="__tests__"
fT.Children._c6e19edaa184f95f04a8663de3d8b89f=f5
local f6
local f7={ClassName="ModuleScript",Children={},Properties={}}
f7.Name="PropAssignmentErrors.roblox.spec"
f7.Properties.Source=[[ local Packages = script.Parent.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local jest = JestGlobals.jest

local React
local ReactRoblox
local reactRobloxRoot
local Scheduler
local parent

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false

	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
	Scheduler = require(Packages.Scheduler)
end)

it("should provide a useful error when initial prop assignment fails", function()
	reactRobloxRoot:render(
		React.createElement(
			"Frame",
			{},
			{ Root = React.createElement("TextLabel", { AbsentProp = 1 }) }
		)
	)

	jestExpect(function()
		jestExpect(Scheduler.unstable_flushAllWithoutAsserting).toErrorDev(
			"Error applying initial props to Roblox Instance 'Root' (TextLabel)"
		)
	end).toThrow()
end)

it("should provide a useful error when a props update fails", function()
	reactRobloxRoot:render(
		React.createElement(
			"Frame",
			{},
			{ Root = React.createElement("TextLabel", { Text = "Okay!" }) }
		)
	)

	Scheduler.unstable_flushAllWithoutAsserting()

	reactRobloxRoot:render(React.createElement("Frame", {}, {
		Root = React.createElement("TextLabel", { Text = "Not good", AbsentProp = 1 }),
	}))

	jestExpect(function()
		jestExpect(Scheduler.unstable_flushAllWithoutAsserting).toErrorDev(
			"Error updating props on Roblox Instance 'Root' (TextLabel):"
		)
	end).toThrow()
end)

it("should provide a useful error when a binding update fails", function()
	local neighbor, setNeighbor = React.createBinding(nil)
	reactRobloxRoot:render(React.createElement("Frame", {}, {
		Root = React.createElement("TextLabel", { NextSelectionLeft = neighbor }),
	}))

	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(function()
		jestExpect(function()
			setNeighbor("not an Instance")
		end).toErrorDev(
			"Error updating binding or ref assigned to key NextSelectionLeft of 'Root' (TextLabel).",
			{ withoutStack = true }
		)
	end).toThrow()
end) ]]
f6.Children._54e34900fe999b8116d9b2ac1dd83751=f7
local f8

local f9={ClassName="ModuleScript",Children={},Properties={}}
f9.Name="ReactRobloxBindings.roblox.spec"
f9.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local describe = JestGlobals.describe

local React
local ReactRoblox
local reactRobloxRoot
local parent

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false

	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
end)

it("should update a value without re-rendering", function()
	local value, setValue = React.createBinding("hello")
	local renderCount = 0
	local function Component(props)
		renderCount += 1
		return React.createElement("TextLabel", {
			Name = "Label",
			Text = value,
		})
	end

	ReactRoblox.act(function()
		reactRobloxRoot:render(React.createElement(Component))
	end)

	jestExpect(renderCount).toBe(1)
	jestExpect(parent.Label.Text).toBe("hello")

	setValue("world")

	jestExpect(renderCount).toBe(1)
	jestExpect(parent.Label.Text).toBe("world")
end)

it("subscribe to updates when used as a ref", function()
	local leftButtonRef = React.createRef()
	local rightButtonRef = React.createRef()

	local function Component(props)
		return React.createElement(React.Fragment, nil, {
			Left = React.createElement("TextButton", {
				ref = leftButtonRef,
				NextSelectionRight = rightButtonRef,
			}),
			Right = React.createElement("TextButton", {
				ref = rightButtonRef,
				NextSelectionRight = leftButtonRef,
			}),
		})
	end

	ReactRoblox.act(function()
		reactRobloxRoot:render(React.createElement(Component))
	end)

	jestExpect(leftButtonRef.current).never.toBeNil()
	jestExpect(rightButtonRef.current).never.toBeNil()

	jestExpect(leftButtonRef.current.NextSelectionRight).toBe(rightButtonRef.current)
	jestExpect(rightButtonRef.current.NextSelectionRight).toBe(leftButtonRef.current)
end)

it("should not return the same root twice", function()
	local parent2 = Instance.new("Folder")
	local reactRobloxRoot2 = ReactRoblox.createRoot(parent2)

	jestExpect(reactRobloxRoot).never.toBe(reactRobloxRoot2)
end)

describe("useBinding hook", function()
	it("returns the same binding object each time", function()
		local captureBinding = jest.fn()
		local updateComponent
		local function Component(props)
			local binding, updater = React.useBinding("hello")
			local stateValue, updateStateValue = React.useState(1)
			captureBinding(binding, updater)
			updateComponent = function()
				updateStateValue(function(prev)
					return prev + 1
				end)
			end

			return React.createElement("TextLabel", {
				Name = "Label",
				LayoutOrder = stateValue,
				Text = binding,
			})
		end

		ReactRoblox.act(function()
			reactRobloxRoot:render(React.createElement(Component))
		end)

		jestExpect(captureBinding).toHaveBeenCalledTimes(1)
		jestExpect(parent.Label.Text).toBe("hello")
		jestExpect(parent.Label.LayoutOrder).toBe(1)

		ReactRoblox.act(function()
			updateComponent()
		end)

		jestExpect(captureBinding).toHaveBeenCalledTimes(2)
		local capturedBindings = captureBinding.mock.calls
		jestExpect(capturedBindings[1]).toEqual(capturedBindings[2])
		jestExpect(parent.Label.Text).toBe("hello")
		jestExpect(parent.Label.LayoutOrder).toBe(2)
	end)

	it("updates the relevant property without re-rendering", function()
		local updateBinding
		local renderCount = 0
		local function Component(props)
			local value, setValue = React.useBinding("hello")
			updateBinding = setValue
			renderCount += 1
			return React.createElement("TextLabel", {
				Name = "Label",
				Text = value,
			})
		end

		ReactRoblox.act(function()
			reactRobloxRoot:render(React.createElement(Component))
		end)

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("hello")

		updateBinding("world")

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("world")
	end)

	it("can be used with mapped bindings", function()
		local updateBinding
		local renderCount = 0
		local function Component(props)
			local text, setText = React.useBinding("hello")
			updateBinding = setText
			renderCount += 1
			return React.createElement("TextLabel", {
				Name = "Label",
				Text = text:map(function(value)
					return string.reverse(value)
				end),
			})
		end

		ReactRoblox.act(function()
			reactRobloxRoot:render(React.createElement(Component))
		end)

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("olleh")

		updateBinding("world")

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("dlrow")
	end)

	it("mapped bindings can be re-mapped", function()
		-- Accepts a binding and remaps it
		local function Remap(props)
			return React.createElement("TextLabel", {
				Name = "LabelLength",
				Text = props.length:map(function(value)
					return "Length: " .. tostring(value)
				end),
			})
		end

		local updateBinding
		local renderCount = 0
		local function Component(props)
			local text, setText = React.useBinding("hello")
			updateBinding = setText
			renderCount += 1
			return React.createElement(
				React.Fragment,
				nil,
				React.createElement("TextLabel", {
					Name = "Label",
					Text = text:map(string.reverse),
				}),
				React.createElement(Remap, {
					length = text:map(string.len),
				})
			)
		end

		ReactRoblox.act(function()
			reactRobloxRoot:render(React.createElement(Component))
		end)

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("olleh")
		jestExpect(parent.LabelLength.Text).toBe("Length: 5")

		updateBinding("friends")

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("sdneirf")
		jestExpect(parent.LabelLength.Text).toBe("Length: 7")
	end)

	it("can be used with joined bindings", function()
		local updatePrefix, updateText
		local renderCount = 0
		local function Component(props)
			local prefix, setPrefix = React.useBinding("Greeting:")
			local text, setText = React.useBinding("hello")
			updatePrefix, updateText = setPrefix, setText
			renderCount += 1

			local fullText = React.joinBindings({ prefix, text })

			return React.createElement("TextLabel", {
				Name = "Label",
				Text = fullText:map(function(values)
					return table.concat(values, " ")
				end),
			})
		end

		ReactRoblox.act(function()
			reactRobloxRoot:render(React.createElement(Component))
		end)

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("Greeting: hello")

		updatePrefix("Salutation:")

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("Salutation: hello")

		updateText("sup")

		jestExpect(renderCount).toBe(1)
		jestExpect(parent.Label.Text).toBe("Salutation: sup")
	end)
end) ]]
f6.Children._a5a0346c11d2fabe10b1afe15e6a9aee=f9
local ga

local gb={ClassName="ModuleScript",Children={},Properties={}}
gb.Name="ReactRobloxComponentTree.roblox.spec"
gb.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-dom/src/__tests__/ReactDOMComponentTree-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

local React
local ReactRoblox
local reactRobloxRoot
local ReactRobloxComponentTree
local Scheduler
local parent

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
	ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode = false

	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	Scheduler = require(Packages.Scheduler)
	ReactRobloxComponentTree = require(script.Parent.Parent.ReactRobloxComponentTree)
	parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
end)

it("getClosestInstanceFromNode should return a cached instance", function()
	reactRobloxRoot:render(
		React.createElement(
			"Frame",
			{},
			{ Label = React.createElement("TextLabel", { Text = "Hello" }) }
		)
	)

	Scheduler.unstable_flushAllWithoutAsserting()

	local labelNode =
		ReactRobloxComponentTree.getClosestInstanceFromNode(parent.Frame.Label)
	jestExpect(labelNode.memoizedProps.Text).toEqual("Hello")
end)

it("getClosestInstanceFromNode should return portaled instances", function()
	local portalContainer1 = Instance.new("Frame")
	local portalContainer2 = Instance.new("Frame")
	local portalContainer3 = Instance.new("Frame")

	reactRobloxRoot:render({
		React.createElement("TextLabel", { key = "a", Text = "normal[0]" }),
		ReactRoblox.createPortal({
			React.createElement("TextLabel", { key = "b", Text = "portal1[0]" }),
			ReactRoblox.createPortal(
				React.createElement("TextLabel", { key = "c", Text = "portal2[0]" }),
				portalContainer2
			),
			ReactRoblox.createPortal(
				React.createElement("TextLabel", { key = "d", Text = "portal3[0]" }),
				portalContainer3
			),
			React.createElement("TextLabel", { key = "e", Text = "portal1[1]" }),
		}, portalContainer1),
		React.createElement("TextLabel", { key = "f", Text = "normal[1]" }),
	})

	Scheduler.unstable_flushAllWithoutAsserting()

	local portal3Label = ReactRobloxComponentTree.getClosestInstanceFromNode(
		portalContainer3:GetChildren()[1]
	)
	jestExpect(portal3Label.memoizedProps.Text).toEqual("portal3[0]")
end) ]]
f6.Children._6e26bfb07ed9a955ba229041700422c8=gb
local gc

local gd={ClassName="ModuleScript",Children={},Properties={}}
gd.Name="ReactRobloxFiber.spec"
gd.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-dom/src/__tests__/ReactDOMFiber-test.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]

-- 'use strict'
local Packages = script.Parent.Parent.Parent.Parent

local React
local ReactRoblox
local reactRobloxRoot
local Scheduler
local parent
-- local PropTypes = require('prop-types')

-- local container
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local xit = JestGlobals.xit

beforeEach(function()
	-- ROBLOX DEVIATION: Document logic does not apply to Roblox
	-- container = document.createElement('div')
	-- document.body.appendChild(container)
	jest.resetModules()
	jest.useFakeTimers()
	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
	Scheduler = require(Packages.Scheduler)
end)

-- ROBLOX DEVIATION: Document logic does not apply to Roblox
-- afterEach(function()
--   document.body.removeChild(container)
--   container = nil
-- end)

-- it('should render strings as children', () => {
--   local Box = ({value}) => <div>{value}</div>

--   ReactDOM.render(<Box value="foo" />, container)
--   expect(container.textContent).toEqual('foo')
-- })

-- it('should render numbers as children', () => {
--   local Box = ({value}) => <div>{value}</div>

--   ReactDOM.render(<Box value={10} />, container)

--   expect(container.textContent).toEqual('10')
-- })

-- it('should be called a callback argument', () => {
--   -- mounting phase
--   local called = false
--   ReactDOM.render(<div>Foo</div>, container, () => (called = true))
--   expect(called).toEqual(true)

--   -- updating phase
--   called = false
--   ReactDOM.render(<div>Foo</div>, container, () => (called = true))
--   expect(called).toEqual(true)
-- })

-- it('should call a callback argument when the same element is re-rendered', () => {
--   class Foo extends React.Component {
--     render()
--       return <div>Foo</div>
--     }
--   }
--   local element = <Foo />

--   -- mounting phase
--   local called = false
--   ReactDOM.render(element, container, () => (called = true))
--   expect(called).toEqual(true)

--   -- updating phase
--   called = false
--   ReactDOM.unstable_batchedUpdates(() => {
--     ReactDOM.render(element, container, () => (called = true))
--   })
--   expect(called).toEqual(true)
-- })

-- it('should render a component returning strings directly from render', () => {
--   local Text = ({value}) => value

--   ReactDOM.render(<Text value="foo" />, container)
--   expect(container.textContent).toEqual('foo')
-- })

-- it('should render a component returning numbers directly from render', () => {
--   local Text = ({value}) => value

--   ReactDOM.render(<Text value={10} />, container)

--   expect(container.textContent).toEqual('10')
-- })

-- it('finds the DOM Text node of a string child', () => {
--   class Text extends React.Component {
--     render()
--       return this.props.value
--     }
--   }

--   local instance = nil
--   ReactDOM.render(
--     <Text value="foo" ref={ref => (instance = ref)} />,
--     container,
--   )

--   local textNode = ReactDOM.findDOMNode(instance)
--   expect(textNode).toBe(container.firstChild)
--   expect(textNode.nodeType).toBe(3)
--   expect(textNode.nodeValue).toBe('foo')
-- })

-- it('finds the first child when a component returns a fragment', () => {
--   class Fragment extends React.Component {
--     render()
--       return [<div key="a" />, <span key="b" />]
--     }
--   }

--   local instance = nil
--   ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container)

--   expect(container.childNodes.length).toBe(2)

--   local firstNode = ReactDOM.findDOMNode(instance)
--   expect(firstNode).toBe(container.firstChild)
--   expect(firstNode.tagName).toBe('DIV')
-- })

-- it('finds the first child even when fragment is nested', () => {
--   class Wrapper extends React.Component {
--     render()
--       return this.props.children
--     }
--   }

--   class Fragment extends React.Component {
--     render()
--       return [
--         <Wrapper key="a">
--           <div />
--         </Wrapper>,
--         <span key="b" />,
--       ]
--     }
--   }

--   local instance = nil
--   ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container)

--   expect(container.childNodes.length).toBe(2)

--   local firstNode = ReactDOM.findDOMNode(instance)
--   expect(firstNode).toBe(container.firstChild)
--   expect(firstNode.tagName).toBe('DIV')
-- })

-- it('finds the first child even when first child renders nil', () => {
--   class NullComponent extends React.Component {
--     render()
--       return nil
--     }
--   }

--   class Fragment extends React.Component {
--     render()
--       return [<NullComponent key="a" />, <div key="b" />, <span key="c" />]
--     }
--   }

--   local instance = nil
--   ReactDOM.render(<Fragment ref={ref => (instance = ref)} />, container)

--   expect(container.childNodes.length).toBe(2)

--   local firstNode = ReactDOM.findDOMNode(instance)
--   expect(firstNode).toBe(container.firstChild)
--   expect(firstNode.tagName).toBe('DIV')
-- })

-- it('renders an empty fragment', () => {
--   local Div = () => <div />
--   local EmptyFragment = () => <></>
--   local NonEmptyFragment = () => (
--     <>
--       <Div />
--     </>
--   )

--   ReactDOM.render(<EmptyFragment />, container)
--   expect(container.firstChild).toBe(null)

--   ReactDOM.render(<NonEmptyFragment />, container)
--   expect(container.firstChild.tagName).toBe('DIV')

--   ReactDOM.render(<EmptyFragment />, container)
--   expect(container.firstChild).toBe(null)

--   ReactDOM.render(<Div />, container)
--   expect(container.firstChild.tagName).toBe('DIV')

--   ReactDOM.render(<EmptyFragment />, container)
--   expect(container.firstChild).toBe(null)
-- })

-- local svgEls, htmlEls, mathEls
-- local expectSVG = {ref: el => svgEls.push(el)}
-- local expectHTML = {ref: el => htmlEls.push(el)}
-- local expectMath = {ref: el => mathEls.push(el)}

-- local usePortal = function(tree)
--   return ReactDOM.createPortal(tree, document.createElement('div'))
-- }

-- local assertNamespacesMatch = function(tree)
--   local testContainer = document.createElement('div')
--   svgEls = []
--   htmlEls = []
--   mathEls = []

--   ReactDOM.render(tree, testContainer)
--   svgEls.forEach(el => {
--     expect(el.namespaceURI).toBe('http://www.w3.org/2000/svg')
--   })
--   htmlEls.forEach(el => {
--     expect(el.namespaceURI).toBe('http://www.w3.org/1999/xhtml')
--   })
--   mathEls.forEach(el => {
--     expect(el.namespaceURI).toBe('http://www.w3.org/1998/Math/MathML')
--   })

--   ReactDOM.unmountComponentAtNode(testContainer)
--   expect(testContainer.innerHTML).toBe('')
-- }

it("should render one portal", function()
	local portalContainer = Instance.new("Frame")

	reactRobloxRoot:render(
		React.createElement(
			"Frame",
			{},
			ReactRoblox.createPortal(
				React.createElement("TextLabel", { Text = "portal" }),
				portalContainer
			)
		)
	)
	Scheduler.unstable_flushAllWithoutAsserting()

	local children = portalContainer:GetChildren()

	jestExpect(#children).toBe(1)
	jestExpect(children[1].ClassName).toBe("TextLabel")
	jestExpect(children[1].Text).toBe("portal")

	reactRobloxRoot:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	children = portalContainer:GetChildren()

	jestExpect(#children).toBe(0)
end)

-- ROBLOX DEVIATION: unstable_createPortal is not implemented in Roblox
-- -- TODO: remove in React 18
-- if !__EXPERIMENTAL__)
--   it('should support unstable_createPortal alias', () => {
--     local portalContainer = document.createElement('div')

--     expect(() =>
--       ReactDOM.render(
--         <div>
--           {ReactDOM.unstable_createPortal(<div>portal</div>, portalContainer)}
--         </div>,
--         container,
--       ),
--     ).toWarnDev(
--       'The ReactDOM.unstable_createPortal() alias has been deprecated, ' +
--         'and will be removed in React 18+. Update your code to use ' +
--         'ReactDOM.createPortal() instead. It has the exact same API, ' +
--         'but without the "unstable_" prefix.',
--       {withoutStack: true},
--     )
--     expect(portalContainer.innerHTML).toBe('<div>portal</div>')
--     expect(container.innerHTML).toBe('<div></div>')

--     ReactDOM.unmountComponentAtNode(container)
--     expect(portalContainer.innerHTML).toBe('')
--     expect(container.innerHTML).toBe('')
--   })
-- }

it("should render many portals", function()
	local portalContainer1 = Instance.new("Frame")
	local portalContainer2 = Instance.new("Frame")

	local ops = {}

	local Child = React.Component:extend("Child")

	function Child:componentDidMount()
		ops[#ops + 1] = self.props.name .. " componentDidMount"
	end

	function Child:componentDidUpdate()
		ops[#ops + 1] = self.props.name .. " componentDidUpdate"
	end

	function Child:componentWillUnmount()
		ops[#ops + 1] = self.props.name .. " componentWillUnmount"
	end

	function Child:render()
		return React.createElement("TextLabel", { Text = self.props.name })
	end

	local Parent = React.Component:extend("Parent")

	function Parent:componentDidMount()
		ops[#ops + 1] = "Parent:" .. self.props.step .. " componentDidMount"
	end

	function Parent:componentDidUpdate()
		ops[#ops + 1] = "Parent:" .. self.props.step .. " componentDidUpdate"
	end

	function Parent:componentWillUnmount()
		ops[#ops + 1] = "Parent:" .. self.props.step .. " componentWillUnmount"
	end

	function Parent:render()
		local step = self.props.step
		return {
			React.createElement(Child, {
				key = "a",
				name = "normal[0]:" .. step,
			}),
			ReactRoblox.createPortal(
				React.createElement(Child, {
					key = "b",
					name = "portal1[0]:" .. step,
				}),
				portalContainer1
			),
			React.createElement(Child, {
				key = "c",
				name = "normal[1]:" .. step,
			}),
			ReactRoblox.createPortal({
				React.createElement(Child, {
					key = "d",
					name = "portal2[0]:" .. step,
				}),
				React.createElement(Child, {
					key = "e",
					name = "portal2[1]:" .. step,
				}),
			}, portalContainer2),
		}
	end

	reactRobloxRoot:render(React.createElement(Parent, { step = "a" }))

	Scheduler.unstable_flushAllWithoutAsserting()

	local children1 = portalContainer1:GetChildren()
	jestExpect(#children1).toBe(1)
	jestExpect(children1[1].ClassName).toBe("TextLabel")
	jestExpect(children1[1].Text).toBe("portal1[0]:a")

	local children2 = portalContainer2:GetChildren()
	jestExpect(#children2).toBe(2)
	jestExpect(children2[1].ClassName).toBe("TextLabel")
	jestExpect(children2[1].Text).toBe("portal2[0]:a")
	jestExpect(children2[2].ClassName).toBe("TextLabel")
	jestExpect(children2[2].Text).toBe("portal2[1]:a")

	local childrenParent = parent:GetChildren()
	jestExpect(#childrenParent).toBe(2)
	jestExpect(childrenParent[1].ClassName).toBe("TextLabel")
	jestExpect(childrenParent[1].Text).toBe("normal[0]:a")
	jestExpect(childrenParent[2].ClassName).toBe("TextLabel")
	jestExpect(childrenParent[2].Text).toBe("normal[1]:a")

	jestExpect(ops).toEqual({
		"normal[0]:a componentDidMount",
		"portal1[0]:a componentDidMount",
		"normal[1]:a componentDidMount",
		"portal2[0]:a componentDidMount",
		"portal2[1]:a componentDidMount",
		"Parent:a componentDidMount",
	})

	ops = {}

	reactRobloxRoot:render(React.createElement(Parent, { step = "b" }))

	Scheduler.unstable_flushAllWithoutAsserting()

	children1 = portalContainer1:GetChildren()
	jestExpect(#children1).toBe(1)
	jestExpect(children1[1].ClassName).toBe("TextLabel")
	jestExpect(children1[1].Text).toBe("portal1[0]:b")

	children2 = portalContainer2:GetChildren()
	jestExpect(#children2).toBe(2)
	jestExpect(children2[1].ClassName).toBe("TextLabel")
	jestExpect(children2[1].Text).toBe("portal2[0]:b")
	jestExpect(children2[2].ClassName).toBe("TextLabel")
	jestExpect(children2[2].Text).toBe("portal2[1]:b")

	childrenParent = parent:GetChildren()
	jestExpect(#childrenParent).toBe(2)
	jestExpect(childrenParent[1].ClassName).toBe("TextLabel")
	jestExpect(childrenParent[1].Text).toBe("normal[0]:b")
	jestExpect(childrenParent[2].ClassName).toBe("TextLabel")
	jestExpect(childrenParent[2].Text).toBe("normal[1]:b")

	jestExpect(ops).toEqual({
		"normal[0]:b componentDidUpdate",
		"portal1[0]:b componentDidUpdate",
		"normal[1]:b componentDidUpdate",
		"portal2[0]:b componentDidUpdate",
		"portal2[1]:b componentDidUpdate",
		"Parent:b componentDidUpdate",
	})

	ops = {}

	reactRobloxRoot:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	children1 = portalContainer1:GetChildren()
	jestExpect(#children1).toBe(0)

	children2 = portalContainer2:GetChildren()
	jestExpect(#children2).toBe(0)

	childrenParent = parent:GetChildren()
	jestExpect(#childrenParent).toBe(0)

	jestExpect(ops).toEqual({
		"Parent:b componentWillUnmount",
		"normal[0]:b componentWillUnmount",
		"portal1[0]:b componentWillUnmount",
		"normal[1]:b componentWillUnmount",
		"portal2[0]:b componentWillUnmount",
		"portal2[1]:b componentWillUnmount",
	})
end)

it("should render nested portals", function()
	local portalContainer1 = Instance.new("Frame")
	local portalContainer2 = Instance.new("Frame")
	local portalContainer3 = Instance.new("Frame")

	reactRobloxRoot:render({
		React.createElement("TextLabel", { key = "a", Text = "normal[0]" }),
		ReactRoblox.createPortal({
			React.createElement("TextLabel", { key = "b", Text = "portal1[0]" }),
			ReactRoblox.createPortal(
				React.createElement("TextLabel", { key = "c", Text = "portal2[0]" }),
				portalContainer2
			),
			ReactRoblox.createPortal(
				React.createElement("TextLabel", { key = "d", Text = "portal3[0]" }),
				portalContainer3
			),
			React.createElement("TextLabel", { key = "e", Text = "portal1[1]" }),
		}, portalContainer1),
		React.createElement("TextLabel", { key = "f", Text = "normal[1]" }),
	})

	Scheduler.unstable_flushAllWithoutAsserting()

	local children1 = portalContainer1:GetChildren()
	jestExpect(#children1).toBe(2)
	jestExpect(children1[1].Text).toBe("portal1[0]")
	jestExpect(children1[2].Text).toBe("portal1[1]")

	local children2 = portalContainer2:GetChildren()
	jestExpect(#children2).toBe(1)
	jestExpect(children2[1].Text).toBe("portal2[0]")

	local children3 = portalContainer3:GetChildren()
	jestExpect(#children3).toBe(1)
	jestExpect(children3[1].Text).toBe("portal3[0]")

	local childrenParent = parent:GetChildren()
	jestExpect(#childrenParent).toBe(2)
	jestExpect(childrenParent[1].Text).toBe("normal[0]")
	jestExpect(childrenParent[2].Text).toBe("normal[1]")

	reactRobloxRoot:unmount()

	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(#portalContainer1:GetChildren()).toBe(0)
	jestExpect(#portalContainer2:GetChildren()).toBe(0)
	jestExpect(#portalContainer3:GetChildren()).toBe(0)
	jestExpect(#parent:GetChildren()).toBe(0)
end)

it("should reconcile portal children", function()
	local portalContainer = Instance.new("Frame")

	reactRobloxRoot:render(React.createElement("Frame", {}, {
		ReactRoblox.createPortal(
			React.createElement("TextLabel", { Text = "portal:1" }),
			portalContainer
		),
	}))

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("portal:1")
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)

	reactRobloxRoot:render(React.createElement("Frame", {}, {
		ReactRoblox.createPortal(
			React.createElement("TextLabel", { Text = "portal:2" }),
			portalContainer
		),
	}))

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("portal:2")
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)

	reactRobloxRoot:render(React.createElement("Frame", {}, {
		ReactRoblox.createPortal(
			React.createElement("TextLabel", { Text = "portal:3" }),
			portalContainer
		),
	}))

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("portal:3")
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)

	reactRobloxRoot:render(React.createElement(
		"Frame",
		{},
		ReactRoblox.createPortal({
			-- ROBLOX deviation START: upstream uses text children, which are
			-- exempt from key warnings, but we get them if we don't provide keys
			React.createElement("TextLabel", { key = "1", Text = "Hi" }),
			React.createElement("TextLabel", { key = "2", Text = "Bye" }),
			-- ROBLOX deviation END
		}, portalContainer)
	))

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(2)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("Hi")
	jestExpect(portalContainer:GetChildren()[2].Text).toBe("Bye")
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)

	reactRobloxRoot:render(React.createElement(
		"Frame",
		{},
		ReactRoblox.createPortal({
			-- ROBLOX deviation START: upstream uses text children, which are
			-- exempt from key warnings, but we get them if we don't provide keys
			React.createElement("TextLabel", { key = "1", Text = "Bye" }),
			React.createElement("TextLabel", { key = "2", Text = "Hi" }),
			-- ROBLOX deviation END
		}, portalContainer)
	))

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(2)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("Bye")
	jestExpect(portalContainer:GetChildren()[2].Text).toBe("Hi")
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)

	reactRobloxRoot:render(
		React.createElement("Frame", {}, ReactRoblox.createPortal(nil, portalContainer))
	)

	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#portalContainer:GetChildren()).toBe(0)
	jestExpect(#parent:GetChildren()).toBe(1)
	jestExpect(#parent:GetChildren()[1]:GetChildren()).toBe(0)
end)

it("should unmount empty portal component wherever it appears", function()
	local portalContainer = Instance.new("Frame")

	local capturedState
	local capturedSetState

	local Wrapper = React.Component:extend("Wrapper")
	function Wrapper:init()
		self:setState({
			show = true,
		})
	end

	function Wrapper:render()
		capturedState = self.state
		capturedSetState = function(...)
			self:setState(...)
		end

		return React.createElement(
			"Frame",
			{},
			self.state.show
				and React.createElement(
					React.Fragment,
					nil,
					ReactRoblox.createPortal(nil, portalContainer),
					React.createElement("TextLabel", { Text = "child" })
				),
			React.createElement("TextLabel", { Text = "parent" })
		)
	end

	reactRobloxRoot:render(React.createElement(Wrapper))
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(#parent:GetChildren()).toBe(1)

	local children = parent:GetChildren()[1]:GetChildren()
	jestExpect(#children).toBe(2)
	jestExpect(children[1].Text).toBe("child")
	jestExpect(children[2].Text).toBe("parent")

	capturedSetState({ show = false })
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(capturedState.show).toBe(false)
	jestExpect(#parent:GetChildren()).toBe(1)

	children = parent:GetChildren()[1]:GetChildren()
	jestExpect(#children).toBe(1)
	jestExpect(children[1].Text).toBe("parent")
end)

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should keep track of namespace across portals (simple)', () => {
--   assertNamespacesMatch(
--     <svg {...expectSVG}>
--       <image {...expectSVG} />
--       {usePortal(<div {...expectHTML} />)}
--       <image {...expectSVG} />
--     </svg>,
--   )
--   assertNamespacesMatch(
--     <math {...expectMath}>
--       <mi {...expectMath} />
--       {usePortal(<div {...expectHTML} />)}
--       <mi {...expectMath} />
--     </math>,
--   )
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       <p {...expectHTML} />
--       {usePortal(
--         <svg {...expectSVG}>
--           <image {...expectSVG} />
--         </svg>,
--       )}
--       <p {...expectHTML} />
--     </div>,
--   )
-- })

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should keep track of namespace across portals (medium)', () => {
--   assertNamespacesMatch(
--     <svg {...expectSVG}>
--       <image {...expectSVG} />
--       {usePortal(<div {...expectHTML} />)}
--       <image {...expectSVG} />
--       {usePortal(<div {...expectHTML} />)}
--       <image {...expectSVG} />
--     </svg>,
--   )
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       <math {...expectMath}>
--         <mi {...expectMath} />
--         {usePortal(
--           <svg {...expectSVG}>
--             <image {...expectSVG} />
--           </svg>,
--         )}
--       </math>
--       <p {...expectHTML} />
--     </div>,
--   )
--   assertNamespacesMatch(
--     <math {...expectMath}>
--       <mi {...expectMath} />
--       {usePortal(
--         <svg {...expectSVG}>
--           <image {...expectSVG} />
--           <foreignObject {...expectSVG}>
--             <p {...expectHTML} />
--             <math {...expectMath}>
--               <mi {...expectMath} />
--             </math>
--             <p {...expectHTML} />
--           </foreignObject>
--           <image {...expectSVG} />
--         </svg>,
--       )}
--       <mi {...expectMath} />
--     </math>,
--   )
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       {usePortal(
--         <svg {...expectSVG}>
--           {usePortal(<div {...expectHTML} />)}
--           <image {...expectSVG} />
--         </svg>,
--       )}
--       <p {...expectHTML} />
--     </div>,
--   )
--   assertNamespacesMatch(
--     <svg {...expectSVG}>
--       <svg {...expectSVG}>
--         {usePortal(<div {...expectHTML} />)}
--         <image {...expectSVG} />
--       </svg>
--       <image {...expectSVG} />
--     </svg>,
--   )
-- })

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should keep track of namespace across portals (complex)', () => {
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       {usePortal(
--         <svg {...expectSVG}>
--           <image {...expectSVG} />
--         </svg>,
--       )}
--       <p {...expectHTML} />
--       <svg {...expectSVG}>
--         <image {...expectSVG} />
--       </svg>
--       <svg {...expectSVG}>
--         <svg {...expectSVG}>
--           <image {...expectSVG} />
--         </svg>
--         <image {...expectSVG} />
--       </svg>
--       <p {...expectHTML} />
--     </div>,
--   )
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       <svg {...expectSVG}>
--         <svg {...expectSVG}>
--           <image {...expectSVG} />
--           {usePortal(
--             <svg {...expectSVG}>
--               <image {...expectSVG} />
--               <svg {...expectSVG}>
--                 <image {...expectSVG} />
--               </svg>
--               <image {...expectSVG} />
--             </svg>,
--           )}
--           <image {...expectSVG} />
--           <foreignObject {...expectSVG}>
--             <p {...expectHTML} />
--             {usePortal(<p {...expectHTML} />)}
--             <p {...expectHTML} />
--           </foreignObject>
--         </svg>
--         <image {...expectSVG} />
--       </svg>
--       <p {...expectHTML} />
--     </div>,
--   )
--   assertNamespacesMatch(
--     <div {...expectHTML}>
--       <svg {...expectSVG}>
--         <foreignObject {...expectSVG}>
--           <p {...expectHTML} />
--           {usePortal(
--             <svg {...expectSVG}>
--               <image {...expectSVG} />
--               <svg {...expectSVG}>
--                 <image {...expectSVG} />
--                 <foreignObject {...expectSVG}>
--                   <p {...expectHTML} />
--                 </foreignObject>
--                 {usePortal(<p {...expectHTML} />)}
--               </svg>
--               <image {...expectSVG} />
--             </svg>,
--           )}
--           <p {...expectHTML} />
--         </foreignObject>
--         <image {...expectSVG} />
--       </svg>
--       <p {...expectHTML} />
--     </div>,
--   )
-- })

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should unwind namespaces on uncaught errors', () => {
--   function BrokenRender()
--     throw new Error('Hello')
--   }

--   expect(() => {
--     assertNamespacesMatch(
--       <svg {...expectSVG}>
--         <BrokenRender />
--       </svg>,
--     )
--   }).toThrow('Hello')
--   assertNamespacesMatch(<div {...expectHTML} />)
-- })

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should unwind namespaces on caught errors', () => {
--   function BrokenRender()
--     throw new Error('Hello')
--   }

--   class ErrorBoundary extends React.Component {
--     state = {error: nil}
--     componentDidCatch(error)
--       this.setState({error})
--     }
--     render()
--       if this.state.error)
--         return <p {...expectHTML} />
--       }
--       return this.props.children
--     }
--   }

--   assertNamespacesMatch(
--     <svg {...expectSVG}>
--       <foreignObject {...expectSVG}>
--         <ErrorBoundary>
--           <math {...expectMath}>
--             <BrokenRender />
--           </math>
--         </ErrorBoundary>
--       </foreignObject>
--       <image {...expectSVG} />
--     </svg>,
--   )
--   assertNamespacesMatch(<div {...expectHTML} />)
-- })

-- ROBLOX DEVIATION: Roblox does not have the same concept of namespaces as upstream React
-- it('should unwind namespaces on caught errors in a portal', () => {
--   function BrokenRender()
--     throw new Error('Hello')
--   }

--   class ErrorBoundary extends React.Component {
--     state = {error: nil}
--     componentDidCatch(error)
--       this.setState({error})
--     }
--     render()
--       if this.state.error)
--         return <image {...expectSVG} />
--       }
--       return this.props.children
--     }
--   }

--   assertNamespacesMatch(
--     <svg {...expectSVG}>
--       <ErrorBoundary>
--         {usePortal(
--           <div {...expectHTML}>
--             <math {...expectMath}>
--               <BrokenRender />)
--             </math>
--           </div>,
--         )}
--       </ErrorBoundary>
--       {usePortal(<div {...expectHTML} />)}
--     </svg>,
--   )
-- })

it("should pass portal context when rendering subtree elsewhere", function()
	local portalContainer = Instance.new("Folder")

	local Context = React.createContext(1)

	local function Consumer()
		return React.createElement(Context.Consumer, nil, function(value)
			return React.createElement("TextLabel", { Text = tostring(value) })
		end)
	end

	local function Parent(props)
		return React.createElement(Context.Provider, {
			value = props.value,
		}, {
			Portal = ReactRoblox.createPortal({
				Consumer = React.createElement(Consumer),
			}, portalContainer),
		})
	end

	reactRobloxRoot:render(React.createElement(Parent, { value = "bar" }))
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#parent:GetChildren()).toBe(0)
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("bar")
end)

it("should update portal context if it changes due to setState", function()
	local portalContainer = Instance.new("Folder")

	local Context = React.createContext(1)

	local function Consumer()
		return React.createElement(Context.Consumer, nil, function(value)
			return React.createElement("TextLabel", { Text = tostring(value) })
		end)
	end

	local capturedSetState

	local Parent = React.Component:extend("Parent")

	function Parent:init()
		self:setState({
			value = "initial",
		})
	end

	function Parent:render()
		capturedSetState = function(...)
			self:setState(...)
		end

		return React.createElement(Context.Provider, {
			value = self.state.value,
		}, {
			Portal = ReactRoblox.createPortal({
				Consumer = React.createElement(Consumer),
			}, portalContainer),
		})
	end

	reactRobloxRoot:render(React.createElement(Parent))
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#parent:GetChildren()).toBe(0)
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("initial")

	capturedSetState({ value = "changed" })
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#parent:GetChildren()).toBe(0)
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("changed")
end)

it("should update portal context if it changes due to re-render", function()
	-- ROBLOX TODO: This test is essentially duplicated in RobloxRenderer.roblox.spec.lua. Where do we want it?
	local portalContainer = Instance.new("Folder")

	local Context = React.createContext(1)

	local function Consumer()
		return React.createElement(Context.Consumer, nil, function(value)
			return React.createElement("TextLabel", { Text = tostring(value) })
		end)
	end

	local function Parent(props)
		return React.createElement(Context.Provider, {
			value = props.value,
		}, {
			Portal = ReactRoblox.createPortal({
				Consumer = React.createElement(Consumer),
			}, portalContainer),
		})
	end

	reactRobloxRoot:render(React.createElement(Parent, { value = "initial" }))
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#parent:GetChildren()).toBe(0)
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("initial")

	reactRobloxRoot:render(React.createElement(Parent, { value = "changed" }))
	Scheduler.unstable_flushAllWithoutAsserting()
	jestExpect(#parent:GetChildren()).toBe(0)
	jestExpect(#portalContainer:GetChildren()).toBe(1)
	jestExpect(portalContainer:GetChildren()[1].Text).toBe("changed")
end)

-- it('findDOMNode should find dom element after expanding a fragment', () => {
--   class MyNode extends React.Component {
--     render()
--       return !this.props.flag
--         ? [<div key="a" />]
--         : [<span key="b" />, <div key="a" />]
--     }
--   }

--   local myNodeA = ReactDOM.render(<MyNode />, container)
--   local a = ReactDOM.findDOMNode(myNodeA)
--   expect(a.tagName).toBe('DIV')

--   local myNodeB = ReactDOM.render(<MyNode flag={true} />, container)
--   expect(myNodeA == myNodeB).toBe(true)

--   local b = ReactDOM.findDOMNode(myNodeB)
--   expect(b.tagName).toBe('SPAN')
-- })

-- ROBLOX DEVIATION: We do not have event bubbling like this in Roact
xit("should bubble events from the portal to the parent", function()
	--   local portalContainer = document.createElement('div')
	--   document.body.appendChild(portalContainer)
	--   try {
	--     local ops = []
	--     local portal = nil

	--     ReactDOM.render(
	--       <div onClick={() => ops.push('parent clicked')}>
	--         {ReactDOM.createPortal(
	--           <div
	--             onClick={() => ops.push('portal clicked')}
	--             ref={n => (portal = n)}>
	--             portal
	--           </div>,
	--           portalContainer,
	--         )}
	--       </div>,
	--       container,
	--     )

	--     expect(portal.tagName).toBe('DIV')

	--     portal.click()

	--     expect(ops).toEqual(['portal clicked', 'parent clicked'])
	--   } finally {
	--     document.body.removeChild(portalContainer)
	--   }
end)

-- ROBLOX DEVIATION: We do not have event bubbling in Roblox like this
xit("should not onMouseLeave when staying in the portal", function()
	--   local portalContainer = document.createElement('div')
	--   document.body.appendChild(portalContainer)

	--   local ops = []
	--   local firstTarget = nil
	--   local secondTarget = nil
	--   local thirdTarget = nil

	--   function simulateMouseMove(from, to)
	--     if from)
	--       from.dispatchEvent(
	--         new MouseEvent('mouseout', {
	--           bubbles: true,
	--           cancelable: true,
	--           relatedTarget: to,
	--         }),
	--       )
	--     }
	--     if to)
	--       to.dispatchEvent(
	--         new MouseEvent('mouseover', {
	--           bubbles: true,
	--           cancelable: true,
	--           relatedTarget: from,
	--         }),
	--       )
	--     }
	--   }

	--   try {
	--     ReactDOM.render(
	--       <div>
	--         <div
	--           onMouseEnter={() => ops.push('enter parent')}
	--           onMouseLeave={() => ops.push('leave parent')}>
	--           <div ref={n => (firstTarget = n)} />
	--           {ReactDOM.createPortal(
	--             <div
	--               onMouseEnter={() => ops.push('enter portal')}
	--               onMouseLeave={() => ops.push('leave portal')}
	--               ref={n => (secondTarget = n)}>
	--               portal
	--             </div>,
	--             portalContainer,
	--           )}
	--         </div>
	--         <div ref={n => (thirdTarget = n)} />
	--       </div>,
	--       container,
	--     )

	--     simulateMouseMove(null, firstTarget)
	--     expect(ops).toEqual(['enter parent'])

	--     ops = []

	--     simulateMouseMove(firstTarget, secondTarget)
	--     expect(ops).toEqual([
	--       -- Parent did not invoke leave because we're still inside the portal.
	--       'enter portal',
	--     ])

	--     ops = []

	--     simulateMouseMove(secondTarget, thirdTarget)
	--     expect(ops).toEqual([
	--       'leave portal',
	--       'leave parent', -- Only when we leave the portal does onMouseLeave fire.
	--     ])
	--   } finally {
	--     document.body.removeChild(portalContainer)
	--   }
end)

-- -- Regression test for https://github.com/facebook/react/issues/19562
-- it('does not fire mouseEnter twice when relatedTarget is the root node', () => {
--   local ops = []
--   local target = nil

--   function simulateMouseMove(from, to)
--     if from)
--       from.dispatchEvent(
--         new MouseEvent('mouseout', {
--           bubbles: true,
--           cancelable: true,
--           relatedTarget: to,
--         }),
--       )
--     }
--     if to)
--       to.dispatchEvent(
--         new MouseEvent('mouseover', {
--           bubbles: true,
--           cancelable: true,
--           relatedTarget: from,
--         }),
--       )
--     }
--   }

--   ReactDOM.render(
--     <div
--       ref={n => (target = n)}
--       onMouseEnter={() => ops.push('enter')}
--       onMouseLeave={() => ops.push('leave')}
--     />,
--     container,
--   )

--   simulateMouseMove(null, container)
--   expect(ops).toEqual([])

--   ops = []
--   simulateMouseMove(container, target)
--   expect(ops).toEqual(['enter'])

--   ops = []
--   simulateMouseMove(target, container)
--   expect(ops).toEqual(['leave'])

--   ops = []
--   simulateMouseMove(container)
--   expect(ops).toEqual([])
-- })

-- -- @gate enableEagerRootListeners
-- it('listens to events that do not exist in the Portal subtree', () => {
--   local onClick = jest.fn()

--   local ref = React.createRef()
--   ReactDOM.render(
--     <div onClick={onClick}>
--       {ReactDOM.createPortal(<button ref={ref}>click</button>, document.body)}
--     </div>,
--     container,
--   )
--   local event = new MouseEvent('click', {
--     bubbles: true,
--   })
--   ref.current.dispatchEvent(event)

--   expect(onClick).toHaveBeenCalledTimes(1)
-- })

it("should throw on bad createPortal argument", function()
	jestExpect(function()
		ReactRoblox.createPortal(React.createElement("Frame"))
	end).toThrow("Target container is not a Roblox Instance.")
	jestExpect(function()
		ReactRoblox.createPortal(React.createElement("Frame"), "hi")
	end).toThrow("Target container is not a Roblox Instance.")
end)

-- it('should warn for non-functional event listeners', () => {
--   class Example extends React.Component {
--     render()
--       return <div onClick="woops" />
--     }
--   }
--   expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
--     'Expected `onClick` listener to be a function, instead got a value of `string` type.\n' +
--       '    in div (at **)\n' +
--       '    in Example (at **)',
--   )
-- })

-- it('should warn with a special message for `false` event listeners', () => {
--   class Example extends React.Component {
--     render()
--       return <div onClick={false} />
--     }
--   }
--   expect(() => ReactDOM.render(<Example />, container)).toErrorDev(
--     'Expected `onClick` listener to be a function, instead got `false`.\n\n' +
--       'If you used to conditionally omit it with onClick={condition and value}, ' +
--       'pass onClick={condition ? value : undefined} instead.\n' +
--       '    in div (at **)\n' +
--       '    in Example (at **)',
--   )
-- })

-- it('should not update event handlers until commit', () => {
--   spyOnDev(console, 'error')

--   local ops = []
--   local handlerA = () => ops.push('A')
--   local handlerB = () => ops.push('B')

--   function click()
--     local event = new MouseEvent('click', {
--       bubbles: true,
--       cancelable: true,
--     })
--     Object.defineProperty(event, 'timeStamp', {
--       value: 0,
--     })
--     node.dispatchEvent(event)
--   }

--   class Example extends React.Component {
--     state = {flip: false, count: 0}
--     flip()
--       this.setState({flip: true, count: this.state.count + 1})
--     }
--     tick()
--       this.setState({count: this.state.count + 1})
--     }
--     render()
--       local useB = !this.props.forceA and this.state.flip
--       return <div onClick={useB ? handlerB : handlerA} />
--     }
--   }

--   class Click extends React.Component {
--     constructor()
--       super()
--       node.click()
--     }
--     render()
--       return nil
--     }
--   }

--   local inst
--   ReactDOM.render([<Example key="a" ref={n => (inst = n)} />], container)
--   local node = container.firstChild
--   expect(node.tagName).toEqual('DIV')

--   click()

--   expect(ops).toEqual(['A'])
--   ops = []

--   -- Render with the other event handler.
--   inst.flip()

--   click()

--   expect(ops).toEqual(['B'])
--   ops = []

--   -- Rerender without changing any props.
--   inst.tick()

--   click()

--   expect(ops).toEqual(['B'])
--   ops = []

--   -- Render a flip back to the A handler. The second component invokes the
--   -- click handler during render to simulate a click during an aborted
--   -- render. I use this hack because at current time we don't have a way to
--   -- test aborted ReactDOM renders.
--   ReactDOM.render(
--     [<Example key="a" forceA={true} />, <Click key="b" />],
--     container,
--   )

--   -- Because the new click handler has not yet committed, we should still
--   -- invoke B.
--   expect(ops).toEqual(['B'])
--   ops = []

--   -- Any click that happens after commit, should invoke A.
--   click()
--   expect(ops).toEqual(['A'])

--   if __DEV__)
--     -- TODO: this warning shouldn't be firing in the first place if user didn't call it.
--     local errorCalls = console.error.calls.count()
--     for (local i = 0; i < errorCalls; i++)
--       expect(console.error.calls.argsFor(i)[0]).toMatch(
--         'unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.',
--       )
--     }
--   }
-- })

-- it('should not crash encountering low-priority tree', () => {
--   ReactDOM.render(
--     <div hidden={true}>
--       <div />
--     </div>,
--     container,
--   )
-- })

-- it('should not warn when rendering into an empty container', () => {
--   ReactDOM.render(<div>foo</div>, container)
--   expect(container.innerHTML).toBe('<div>foo</div>')
--   ReactDOM.render(null, container)
--   expect(container.innerHTML).toBe('')
--   ReactDOM.render(<div>bar</div>, container)
--   expect(container.innerHTML).toBe('<div>bar</div>')
-- })

-- it('should warn when replacing a container which was manually updated outside of React', () => {
--   -- when not messing with the DOM outside of React
--   ReactDOM.render(<div key="1">foo</div>, container)
--   ReactDOM.render(<div key="1">bar</div>, container)
--   expect(container.innerHTML).toBe('<div>bar</div>')
--   -- then we mess with the DOM before an update
--   -- we know this will error - that is expected right now
--   -- It's an error of type 'NotFoundError' with no message
--   container.innerHTML = '<div>MEOW.</div>'

--   expect(() => {
--     expect(() =>
--       ReactDOM.render(<div key="2">baz</div>, container),
--     ).toErrorDev(
--       'render(...): ' +
--         'It looks like the React-rendered content of this container was ' +
--         'removed without using React. This is not supported and will ' +
--         'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
--         'to empty a container.',
--       {withoutStack: true},
--     )
--   }).toThrowError()
-- })

-- it('should warn when doing an update to a container manually updated outside of React', () => {
--   -- when not messing with the DOM outside of React
--   ReactDOM.render(<div>foo</div>, container)
--   ReactDOM.render(<div>bar</div>, container)
--   expect(container.innerHTML).toBe('<div>bar</div>')
--   -- then we mess with the DOM before an update
--   container.innerHTML = '<div>MEOW.</div>'
--   expect(() =>
--     ReactDOM.render(<div>baz</div>, container),
--   ).toErrorDev(
--     'render(...): ' +
--       'It looks like the React-rendered content of this container was ' +
--       'removed without using React. This is not supported and will ' +
--       'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
--       'to empty a container.',
--     {withoutStack: true},
--   )
-- })

-- it('should warn when doing an update to a container manually cleared outside of React', () => {
--   -- when not messing with the DOM outside of React
--   ReactDOM.render(<div>foo</div>, container)
--   ReactDOM.render(<div>bar</div>, container)
--   expect(container.innerHTML).toBe('<div>bar</div>')
--   -- then we mess with the DOM before an update
--   container.innerHTML = ''
--   expect(() =>
--     ReactDOM.render(<div>baz</div>, container),
--   ).toErrorDev(
--     'render(...): ' +
--       'It looks like the React-rendered content of this container was ' +
--       'removed without using React. This is not supported and will ' +
--       'cause errors. Instead, call ReactDOM.unmountComponentAtNode ' +
--       'to empty a container.',
--     {withoutStack: true},
--   )
-- })

-- it('should render a text component with a text DOM node on the same document as the container', () => {
--   -- 1. Create a new document through the use of iframe
--   -- 2. Set up the spy to make asserts when a text component
--   --    is rendered inside the iframe container
--   local textContent = 'Hello world'
--   local iframe = document.createElement('iframe')
--   document.body.appendChild(iframe)
--   local iframeDocument = iframe.contentDocument
--   iframeDocument.write(
--     '<!DOCTYPE html><html><head></head><body><div></div></body></html>',
--   )
--   iframeDocument.close()
--   local iframeContainer = iframeDocument.body.firstChild

--   local actualDocument
--   local textNode

--   spyOnDevAndProd(iframeContainer, 'appendChild').and.callFake(node => {
--     actualDocument = node.ownerDocument
--     textNode = node
--   })

--   ReactDOM.render(textContent, iframeContainer)

--   expect(textNode.textContent).toBe(textContent)
--   expect(actualDocument).not.toBe(document)
--   expect(actualDocument).toBe(iframeDocument)
--   expect(iframeContainer.appendChild).toHaveBeenCalledTimes(1)
-- })

-- it('should mount into a document fragment', () => {
--   local fragment = document.createDocumentFragment()
--   ReactDOM.render(<div>foo</div>, fragment)
--   expect(container.innerHTML).toBe('')
--   container.appendChild(fragment)
--   expect(container.innerHTML).toBe('<div>foo</div>')
-- })

-- -- Regression test for https://github.com/facebook/react/issues/12643#issuecomment-413727104
-- it('should not diff memoized host components', () => {
--   local inputRef = React.createRef()
--   local didCallOnChange = false

--   class Child extends React.Component {
--     state = {}
--     componentDidMount()
--       document.addEventListener('click', this.update, true)
--     }
--     componentWillUnmount()
--       document.removeEventListener('click', this.update, true)
--     }
--     update = () => {
--       -- We're testing that this setState()
--       -- doesn't cause React to commit updates
--       -- to the input outside (which would itself
--       -- prevent the parent's onChange parent handler
--       -- from firing).
--       this.setState({})
--       -- Note that onChange was always broken when there was an
--       -- earlier setState() in a manual document capture phase
--       -- listener *in the same component*. But that's very rare.
--       -- Here we're testing that a *child* component doesn't break
--       -- the parent if this happens.
--     }
--     render()
--       return <div />
--     }
--   }

--   class Parent extends React.Component {
--     handleChange = val => {
--       didCallOnChange = true
--     }
--     render()
--       return (
--         <div>
--           <Child />
--           <input
--             ref={inputRef}
--             type="checkbox"
--             checked={true}
--             onChange={this.handleChange}
--           />
--         </div>
--       )
--     }
--   }

--   ReactDOM.render(<Parent />, container)
--   inputRef.current.dispatchEvent(
--     new MouseEvent('click', {
--       bubbles: true,
--     }),
--   )
--   expect(didCallOnChange).toBe(true)
-- })

-- it('unmounted legacy roots should never clear newer root content from a container', () => {
--   local ref = React.createRef()

--   function OldApp()
--     local hideOnFocus = () => {
--       -- This app unmounts itself inside of a focus event.
--       ReactDOM.unmountComponentAtNode(container)
--     }

--     return (
--       <button onFocus={hideOnFocus} ref={ref}>
--         old
--       </button>
--     )
--   }

--   function NewApp()
--     return <button ref={ref}>new</button>
--   }

--   ReactDOM.render(<OldApp />, container)
--   ref.current.focus()

--   ReactDOM.render(<NewApp />, container)

--   -- Calling focus again will flush previously scheduled discrete work for the old root-
--   -- but this should not clear out the newly mounted app.
--   ref.current.focus()

--   expect(container.textContent).toBe('new')
-- }) ]]
f6.Children._3e6c84affde831b74ed2aeeb1112b665=gd
local ge

local gf={ClassName="ModuleScript",Children={},Properties={}}
gf.Name="RobloxRenderer.roblox.spec"
gf.Properties.Source=[[ local Packages = script.Parent.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local expect = jestExpect
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it
local describe = JestGlobals.describe

local React
local ReactRoblox
local reactRobloxRoot
local Scheduler
local parent

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()

	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	parent = Instance.new("Folder")
	reactRobloxRoot = ReactRoblox.createRoot(parent)
	Scheduler = require(Packages.Scheduler)
end)

describe("mounting instances", function()
	it("should create instances with correct props", function()
		local value = "Hello!"
		local key = "Some Key"

		local element = React.createElement("StringValue", {
			Name = key,
			Value = value,
		})

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#parent:GetChildren()).toBe(1)

		local rootInstance = parent:GetChildren()[1]

		jestExpect(rootInstance.ClassName).toBe("StringValue")
		jestExpect(rootInstance.Value).toBe(value)
		jestExpect(rootInstance.Name).toBe(key)
	end)

	it("names instances with their key value using legacy key syntax", function()
		local key = "Some Key"

		local element = React.createElement("Folder", {}, {
			[key] = React.createElement("BoolValue"),
		})

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#parent:GetChildren()).toBe(1)

		local rootInstance = parent:GetChildren()[1]
		jestExpect(rootInstance.ClassName).toBe("Folder")

		local boolValueInstance = rootInstance:FindFirstChildOfClass("BoolValue")
		jestExpect(boolValueInstance).toBeDefined()
		jestExpect(boolValueInstance.Name).toEqual(key)
	end)

	it("names instances with their key value (using props)", function()
		local key = "Some Key"

		local element = React.createElement(
			"Folder",
			{},
			React.createElement("BoolValue", {
				key = key,
			})
		)

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#parent:GetChildren()).toBe(1)

		local rootInstance = parent:GetChildren()[1]
		jestExpect(rootInstance.ClassName).toBe("Folder")

		local boolValueInstance = rootInstance:FindFirstChildOfClass("BoolValue")
		jestExpect(boolValueInstance).toBeDefined()
		jestExpect(boolValueInstance.Name).toEqual(key)
	end)

	it(
		"names instances with their key value using legacy key syntax and updates them",
		function()
			local key = "Some Key"
			local fnMock = jest.fn()
			local ref = function(...)
				return fnMock(...)
			end

			local element = React.createElement("Folder", {}, {
				[key] = React.createElement("BoolValue", {
					ref = ref,
				}),
			})

			reactRobloxRoot:render(element)
			Scheduler.unstable_flushAllWithoutAsserting()

			jestExpect(fnMock).toHaveBeenCalledTimes(1)
			local refValue = fnMock.mock.calls[1][1]
			jestExpect(refValue.Name).toEqual(key)

			local updatedKey = "Some other key"
			local updatedElement = React.createElement("Folder", {}, {
				[updatedKey] = React.createElement("BoolValue", {
					ref = ref,
				}),
			})
			reactRobloxRoot:render(updatedElement)
			Scheduler.unstable_flushAllWithoutAsserting()

			jestExpect(fnMock).toHaveBeenCalledTimes(3)
			-- ROBLOX FIXME: jest mocks should be able to handle explicit
			-- trailing nils, but do not appear to do so
			jestExpect(fnMock).toHaveBeenNthCalledWith(2 --\[\[, nil \]\])

			local lastRefValue = fnMock.mock.calls[3][1]
			jestExpect(lastRefValue.Name).toEqual(updatedKey)
		end
	)

	it("should create children with correct names and props", function()
		local rootValue = "Hey there!"
		local childValue = 173
		local key = "Some Key"

		local element = React.createElement("StringValue", {
			key = key,
			Value = rootValue,
		}, {
			ChildA = React.createElement("IntValue", {
				Value = childValue,
			}),

			ChildB = React.createElement("Folder"),
		})

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		expect(#parent:GetChildren()).toEqual(1)

		local rootInstance = parent:GetChildren()[1]

		expect(rootInstance.ClassName).toEqual("StringValue")
		expect(rootInstance.Value).toEqual(rootValue)
		expect(rootInstance.Name).toEqual(key)

		expect(#rootInstance:GetChildren()).toEqual(2)

		local childA = rootInstance.ChildA
		local childB = rootInstance.ChildB

		expect(childA).toBeTruthy()
		expect(childB).toBeTruthy()

		expect(childA.ClassName).toEqual("IntValue")
		expect(childA.Value).toEqual(childValue)

		expect(childB.ClassName).toEqual("Folder")
	end)

	it(
		"names instances with their key value using legacy key syntax through function component",
		function()
			local key = "Some Key"

			local function Foo()
				return React.createElement("BoolValue")
			end

			local element = React.createElement("Folder", {}, {
				[key] = React.createElement(Foo),
			})

			reactRobloxRoot:render(element)
			Scheduler.unstable_flushAllWithoutAsserting()

			jestExpect(#parent:GetChildren()).toBe(1)

			local rootInstance = parent:GetChildren()[1]
			jestExpect(rootInstance.ClassName).toBe("Folder")

			local boolValueInstance = rootInstance:FindFirstChildOfClass("BoolValue")
			jestExpect(boolValueInstance).toBeDefined()
			jestExpect(boolValueInstance.Name).toEqual(key)
		end
	)

	-- it("should attach Bindings to Roblox properties", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local binding, update = Binding.create(10)
	-- 	local element = createElement("IntValue", {
	-- 		Value = binding,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(instance.ClassName).toEqual("IntValue")
	-- 	expect(instance.Value).toEqual(10)

	-- 	update(20)

	-- 	expect(instance.Value).toEqual(20)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should connect Binding refs", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local ref = createRef()
	-- 	local element = createElement("Frame", {
	-- 		[Ref] = ref,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(ref.current).toBeTruthy()
	-- 	expect(ref.current).toEqual(instance)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should call function refs", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local spyRef = createSpy()
	-- 	local element = createElement("Frame", {
	-- 		[Ref] = spyRef.value,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(spyRef.callCount).toEqual(1)
	-- 	spyRef:assertCalledWith(instance)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should throw if setting invalid instance properties", function()
	-- 	local configValues = {
	-- 		elementTracing = true,
	-- 	}

	-- 	GlobalConfig.scoped(configValues, function()
	-- 		local parent = Instance.new("Folder")
	-- 		local key = "Some Key"

	-- 		local element = createElement("Frame", {
	-- 			Frob = 6,
	-- 		})

	-- 		local node = reconciler.createVirtualNode(element, parent, key)

	-- 		local success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)
	-- 		assert(not success, "Expected call to fail")

	-- 		expect(string.find(message, "Frob")).toBeTruthy()
	-- 		expect(string.find(message, "Frame")).toBeTruthy()
	-- 		expect(string.find(message, "RobloxRenderer%.spec")).toBeTruthy()
	-- 	end)
	-- end)
end)

describe("updating instances", function()
	it("should update node props and children", function()
		local key = "updateHostNodeTest"
		local firstValue = "foo"
		local newValue = "bar"

		local defaultStringValue = Instance.new("StringValue").Value

		local element = React.createElement("StringValue", {
			Name = key,
			Value = firstValue,
		}, {
			ChildA = React.createElement("IntValue", {
				Name = "ChildA",
				Value = 1,
			}),
			ChildB = React.createElement("BoolValue", {
				Name = "ChildB",
				Value = true,
			}),
			ChildC = React.createElement("StringValue", {
				Name = "ChildC",
				Value = "test",
			}),
			ChildD = React.createElement("StringValue", {
				Name = "ChildD",
				Value = "test",
			}),
		})

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		-- Not testing mountHostNode's work here, only testing that the
		-- node is properly updated.

		local newElement = React.createElement("StringValue", {
			Name = key,
			Value = newValue,
		}, {
			-- ChildA changes element type.
			ChildA = React.createElement("StringValue", {
				Name = "ChildA",
				Value = "test",
			}),
			-- ChildB changes child properties.
			ChildB = React.createElement("BoolValue", {
				Name = "ChildB",
				Value = false,
			}),
			-- ChildC should reset its Value property back to the default.
			ChildC = React.createElement("StringValue", {
				Name = "ChildC",
			}),
			-- ChildD is deleted.
			-- ChildE is added.
			ChildE = React.createElement("Folder", {
				Name = "ChildE",
			}),
		})

		reactRobloxRoot:render(newElement)
		Scheduler.unstable_flushAllWithoutAsserting()

		local rootInstance = parent[key]
		jestExpect(rootInstance.ClassName).toBe("StringValue")
		jestExpect(rootInstance.Value).toBe(newValue)
		jestExpect(#rootInstance:GetChildren()).toBe(4)

		local childA = rootInstance.ChildA
		jestExpect(childA.ClassName).toBe("StringValue")
		jestExpect(childA.Value).toBe("test")

		local childB = rootInstance.ChildB
		jestExpect(childB.ClassName).toBe("BoolValue")
		jestExpect(childB.Value).toBe(false)

		local childC = rootInstance.ChildC
		jestExpect(childC.ClassName).toBe("StringValue")
		jestExpect(childC.Value).toBe(defaultStringValue)

		local childE = rootInstance.ChildE
		jestExpect(childE.ClassName).toBe("Folder")
	end)

	-- it("should update Bindings", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local bindingA, updateA = Binding.create(10)
	-- 	local element = createElement("IntValue", {
	-- 		Value = bindingA,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(instance.Value).toEqual(10)

	-- 	local bindingB, updateB = Binding.create(99)
	-- 	local newElement = createElement("IntValue", {
	-- 		Value = bindingB,
	-- 	})

	-- 	RobloxRenderer.updateHostNode(reconciler, node, newElement)

	-- 	expect(instance.Value).toEqual(99)

	-- 	updateA(123)

	-- 	expect(instance.Value).toEqual(99)

	-- 	updateB(123)

	-- 	expect(instance.Value).toEqual(123)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should update Binding refs", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local refA = createRef()
	-- 	local refB = createRef()

	-- 	local element = createElement("Frame", {
	-- 		[Ref] = refA,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(refA.current).toEqual(instance)
	-- 	expect(refB.current).never.toBeTruthy()

	-- 	local newElement = createElement("Frame", {
	-- 		[Ref] = refB,
	-- 	})

	-- 	RobloxRenderer.updateHostNode(reconciler, node, newElement)

	-- 	expect(refA.current).never.toBeTruthy()
	-- 	expect(refB.current).toEqual(instance)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should call old function refs with nil and new function refs with a valid rbx", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local spyRefA = createSpy()
	-- 	local spyRefB = createSpy()

	-- 	local element = createElement("Frame", {
	-- 		[Ref] = spyRefA.value,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(spyRefA.callCount).toEqual(1)
	-- 	spyRefA:assertCalledWith(instance)
	-- 	expect(spyRefB.callCount).toEqual(0)

	-- 	local newElement = createElement("Frame", {
	-- 		[Ref] = spyRefB.value,
	-- 	})

	-- 	RobloxRenderer.updateHostNode(reconciler, node, newElement)

	-- 	expect(spyRefA.callCount).toEqual(2)
	-- 	spyRefA:assertCalledWith(nil)
	-- 	expect(spyRefB.callCount).toEqual(1)
	-- 	spyRefB:assertCalledWith(instance)

	-- 	RobloxRenderer.unmountHostNode(reconciler, node)
	-- end)

	-- it("should not call function refs again if they didn't change", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local spyRef = createSpy()

	-- 	local element = createElement("Frame", {
	-- 		Size = UDim2.new(1, 0, 1, 0),
	-- 		[Ref] = spyRef.value,
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]

	-- 	expect(spyRef.callCount).toEqual(1)
	-- 	spyRef:assertCalledWith(instance)

	-- 	local newElement = createElement("Frame", {
	-- 		Size = UDim2.new(0.5, 0, 0.5, 0),
	-- 		[Ref] = spyRef.value,
	-- 	})

	-- 	RobloxRenderer.updateHostNode(reconciler, node, newElement)

	-- 	-- Not called again
	-- 	expect(spyRef.callCount).toEqual(1)
	-- end)

	-- it("should throw if setting invalid instance properties", function()
	-- 	local configValues = {
	-- 		elementTracing = true,
	-- 	}

	-- 	GlobalConfig.scoped(configValues, function()
	-- 		local parent = Instance.new("Folder")
	-- 		local key = "Some Key"

	-- 		local firstElement = createElement("Frame")
	-- 		local secondElement = createElement("Frame", {
	-- 			Frob = 6,
	-- 		})

	-- 		local node = reconciler.createVirtualNode(firstElement, parent, key)
	-- 		RobloxRenderer.mountHostNode(reconciler, node)

	-- 		local success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)
	-- 		assert(not success, "Expected call to fail")

	-- 		expect(string.find(message, "Frob")).toBeTruthy()
	-- 		expect(string.find(message, "Frame")).toBeTruthy()
	-- 		expect(string.find(message, "RobloxRenderer%.spec")).toBeTruthy()
	-- 	end)
	-- end)

	-- it("should delete instances when reconciling to nil children", function()
	-- 	local parent = Instance.new("Folder")
	-- 	local key = "Some Key"

	-- 	local element = createElement("Frame", {
	-- 		Size = UDim2.new(1, 0, 1, 0),
	-- 	}, {
	-- 		child = createElement("Frame"),
	-- 	})

	-- 	local node = reconciler.createVirtualNode(element, parent, key)

	-- 	RobloxRenderer.mountHostNode(reconciler, node)

	-- 	expect(#parent:GetChildren()).toEqual(1)

	-- 	local instance = parent:GetChildren()[1]
	-- 	expect(#instance:GetChildren()).toEqual(1)

	-- 	local newElement = createElement("Frame", {
	-- 		Size = UDim2.new(0.5, 0, 0.5, 0),
	-- 	})

	-- 	RobloxRenderer.updateHostNode(reconciler, node, newElement)
	-- 	expect(#instance:GetChildren()).toEqual(0)
	-- end)
end)

-- describe("removing instances", function()
-- 	it("should delete instances from the inside-out", function()
-- 		local parent = Instance.new("Folder")
-- 		local key = "Root"
-- 		local element = createElement("Folder", nil, {
-- 			Child = createElement("Folder", nil, {
-- 				Grandchild = createElement("Folder"),
-- 			}),
-- 		})

-- 		local node = reconciler.mountVirtualNode(element, parent, key)

-- 		expect(#parent:GetChildren()).toEqual(1)

-- 		local root = parent:GetChildren()[1]
-- 		expect(#root:GetChildren()).toEqual(1)

-- 		local child = root:GetChildren()[1]
-- 		expect(#child:GetChildren()).toEqual(1)

-- 		local grandchild = child:GetChildren()[1]

-- 		RobloxRenderer.unmountHostNode(reconciler, node)

-- 		expect(grandchild.Parent).toEqual(nil)
-- 		expect(child.Parent).toEqual(nil)
-- 		expect(root.Parent).toEqual(nil)
-- 	end)

-- 	it("should unsubscribe from any Bindings", function()
-- 		local parent = Instance.new("Folder")
-- 		local key = "Some Key"

-- 		local binding, update = Binding.create(10)
-- 		local element = createElement("IntValue", {
-- 			Value = binding,
-- 		})

-- 		local node = reconciler.createVirtualNode(element, parent, key)

-- 		RobloxRenderer.mountHostNode(reconciler, node)

-- 		local instance = parent:GetChildren()[1]

-- 		expect(instance.Value).toEqual(10)

-- 		RobloxRenderer.unmountHostNode(reconciler, node)
-- 		update(56)

-- 		expect(instance.Value).toEqual(10)
-- 	end)

-- 	it("should clear Binding refs", function()
-- 		local parent = Instance.new("Folder")
-- 		local key = "Some Key"

-- 		local ref = createRef()
-- 		local element = createElement("Frame", {
-- 			[Ref] = ref,
-- 		})

-- 		local node = reconciler.createVirtualNode(element, parent, key)

-- 		RobloxRenderer.mountHostNode(reconciler, node)

-- 		expect(ref.current).toBeTruthy()

-- 		RobloxRenderer.unmountHostNode(reconciler, node)

-- 		expect(ref.current).never.toBeTruthy()
-- 	end)

-- 	it("should call function refs with nil", function()
-- 		local parent = Instance.new("Folder")
-- 		local key = "Some Key"

-- 		local spyRef = createSpy()
-- 		local element = createElement("Frame", {
-- 			[Ref] = spyRef.value,
-- 		})

-- 		local node = reconciler.createVirtualNode(element, parent, key)

-- 		RobloxRenderer.mountHostNode(reconciler, node)

-- 		expect(spyRef.callCount).toEqual(1)

-- 		RobloxRenderer.unmountHostNode(reconciler, node)

-- 		expect(spyRef.callCount).toEqual(2)
-- 		spyRef:assertCalledWith(nil)
-- 	end)
-- end)

describe("Portals", function()
	it("should create and destroy instances as children of `target`", function()
		local target = Instance.new("Folder")

		local function FunctionComponent(props)
			return React.createElement("IntValue", {
				Name = "intValueOne",
				Value = props.value,
			})
		end

		local element = ReactRoblox.createPortal({
			React.createElement("Folder", { key = "1", Name = "folderOne" }),
			React.createElement("Folder", { key = "2", Name = "folderTwo" }),
			React.createElement(FunctionComponent, {
				key = "3",
				value = 42,
			}),
		}, target)

		reactRobloxRoot:render(element)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#target:GetChildren()).toBe(3)
		jestExpect(target:FindFirstChild("folderOne")).toBeDefined()
		jestExpect(target:FindFirstChild("folderTwo")).toBeDefined()
		jestExpect(target:FindFirstChild("intValueOne")).toBeDefined()
		jestExpect(target:FindFirstChild("intValueOne").Value).toBe(42)

		reactRobloxRoot:unmount()
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#target:GetChildren()).toBe(0)
	end)

	it("should pass prop updates through to children", function()
		local target = Instance.new("Folder")

		local firstElement = ReactRoblox.createPortal({
			ChildValue = React.createElement("IntValue", { Value = 1 }),
		}, target)

		local secondElement = ReactRoblox.createPortal({
			ChildValue = React.createElement("IntValue", { Value = 2 }),
		}, target)

		reactRobloxRoot:render(firstElement)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#target:GetChildren()).toBe(1)
		jestExpect(target:GetChildren()[1].Value).toBe(1)

		reactRobloxRoot:render(secondElement)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#target:GetChildren()).toBe(1)
		jestExpect(target:GetChildren()[1].Value).toBe(2)

		reactRobloxRoot:unmount()
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#target:GetChildren()).toBe(0)
	end)

	-- ROBLOX TODO: Duplicated in ReactRobloxFiber. Should we delete here?
	it("should throw if `target` is nil", function()
		-- TODO: Relax this restriction?
		jestExpect(function()
			ReactRoblox.createPortal(React.createElement("IntValue", { Value = 1 }))
		end).toThrow()
	end)

	-- ROBLOX TODO: Duplicated in ReactRobloxFiber. Should we delete here?
	-- it("should throw if `target` is not a Roblox instance", function()
	-- 	local element = createElement(Portal, {
	-- 		target = {},
	-- 	})
	-- 	local hostParent = nil
	-- 	local hostKey = "Unleash the keys!"

	-- 	expect(function()
	-- 		reconciler.mountVirtualNode(element, hostParent, hostKey)
	-- 	end).to.throw()
	-- end)

	it("should recreate instances if `target` changes in an update", function()
		local firstTarget = Instance.new("Folder")
		local secondTarget = Instance.new("Folder")

		local firstElement = ReactRoblox.createPortal(
			React.createElement("IntValue", { Value = 1 }),
			firstTarget
		)

		local secondElement = ReactRoblox.createPortal(
			React.createElement("IntValue", { Value = 2 }),
			secondTarget
		)

		reactRobloxRoot:render(firstElement)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#firstTarget:GetChildren()).toBe(1)
		jestExpect(#secondTarget:GetChildren()).toBe(0)
		jestExpect(firstTarget:GetChildren()[1].Value).toBe(1)

		reactRobloxRoot:render(secondElement)
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#firstTarget:GetChildren()).toBe(0)
		jestExpect(#secondTarget:GetChildren()).toBe(1)
		jestExpect(secondTarget:GetChildren()[1].Value).toBe(2)

		reactRobloxRoot:unmount()
		Scheduler.unstable_flushAllWithoutAsserting()

		jestExpect(#firstTarget:GetChildren()).toBe(0)
		jestExpect(#secondTarget:GetChildren()).toBe(0)
	end)
end)

-- describe("Fragments", function()
-- 	it("should parent the fragment's elements into the fragment's parent", function()
-- 		local hostParent = Instance.new("Folder")

-- 		local fragment = createFragment({
-- 			key = createElement("IntValue", {
-- 				Value = 1,
-- 			}),
-- 			key2 = createElement("IntValue", {
-- 				Value = 2,
-- 			}),
-- 		})

-- 		local node = reconciler.mountVirtualNode(fragment, hostParent, "test")

-- 		expect(hostParent:FindFirstChild("key")).toBeTruthy()
-- 		expect(hostParent.key.ClassName).toEqual("IntValue")
-- 		expect(hostParent.key.Value).toEqual(1)

-- 		expect(hostParent:FindFirstChild("key2")).toBeTruthy()
-- 		expect(hostParent.key2.ClassName).toEqual("IntValue")
-- 		expect(hostParent.key2.Value).toEqual(2)

-- 		reconciler.unmountVirtualNode(node)

-- 		expect(#hostParent:GetChildren()).toEqual(0)
-- 	end)

-- 	it("should allow sibling fragment to have common keys", function()
-- 		local hostParent = Instance.new("Folder")
-- 		local hostKey = "Test"

-- 		local function parent(props)
-- 			return createElement("IntValue", {}, {
-- 				fragmentA = createFragment({
-- 					key = createElement("StringValue", {
-- 						Value = "A",
-- 					}),
-- 					key2 = createElement("StringValue", {
-- 						Value = "B",
-- 					}),
-- 				}),
-- 				fragmentB = createFragment({
-- 					key = createElement("StringValue", {
-- 						Value = "C",
-- 					}),
-- 					key2 = createElement("StringValue", {
-- 						Value = "D",
-- 					}),
-- 				}),
-- 			})
-- 		end

-- 		local node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)
-- 		local parentChildren = hostParent[hostKey]:GetChildren()

-- 		expect(#parentChildren).toEqual(4)

-- 		local childValues = {}

-- 		for _, child in parentChildren do
-- 			expect(child.ClassName).toEqual("StringValue")
-- 			childValues[child.Value] = 1 + (childValues[child.Value] or 0)
-- 		end

-- 		-- check if the StringValues have not collided
-- 		expect(childValues.A).toEqual(1)
-- 		expect(childValues.B).toEqual(1)
-- 		expect(childValues.C).toEqual(1)
-- 		expect(childValues.D).toEqual(1)

-- 		reconciler.unmountVirtualNode(node)

-- 		expect(#hostParent:GetChildren()).toEqual(0)
-- 	end)

-- 	it("should render nested fragments", function()
-- 		local hostParent = Instance.new("Folder")

-- 		local fragment = createFragment({
-- 			key = createFragment({
-- 				TheValue = createElement("IntValue", {
-- 					Value = 1,
-- 				}),
-- 				TheOtherValue = createElement("IntValue", {
-- 					Value = 2,
-- 				})
-- 			})
-- 		})

-- 		local node = reconciler.mountVirtualNode(fragment, hostParent, "Test")

-- 		expect(hostParent:FindFirstChild("TheValue")).toBeTruthy()
-- 		expect(hostParent.TheValue.ClassName).toEqual("IntValue")
-- 		expect(hostParent.TheValue.Value).toEqual(1)

-- 		expect(hostParent:FindFirstChild("TheOtherValue")).toBeTruthy()
-- 		expect(hostParent.TheOtherValue.ClassName).toEqual("IntValue")
-- 		expect(hostParent.TheOtherValue.Value).toEqual(2)

-- 		reconciler.unmountVirtualNode(node)

-- 		expect(#hostParent:GetChildren()).toEqual(0)
-- 	end)

-- 	it("should not add any instances if the fragment is empty", function()
-- 		local hostParent = Instance.new("Folder")

-- 		local node = reconciler.mountVirtualNode(createFragment({}), hostParent, "test")

-- 		expect(#hostParent:GetChildren()).toEqual(0)

-- 		reconciler.unmountVirtualNode(node)

-- 		expect(#hostParent:GetChildren()).toEqual(0)
-- 	end)
-- end)

describe("Context", function()
	-- it("should pass context values through Roblox host nodes", function()
	-- 	local Consumer = Component:extend("Consumer")

	-- 	local capturedContext
	-- 	function Consumer:init()
	-- 		capturedContext = {
	-- 			hello = self:__getContext("hello")
	-- 		}
	-- 	end

	-- 	function Consumer:render()
	-- 	end

	-- 	local element = createElement("Folder", nil, {
	-- 		Consumer = createElement(Consumer)
	-- 	})
	-- 	local hostParent = nil
	-- 	local hostKey = "Context Test"
	-- 	local context = {
	-- 		hello = "world",
	-- 	}
	-- 	local node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)

	-- 	expect(capturedContext).never.toEqual(context)
	-- 	assertDeepEqual(capturedContext, context)

	-- 	reconciler.unmountVirtualNode(node)
	-- end)

	it("should pass context values through portal nodes", function()
		local target = Instance.new("Folder")
		local Context = React.createContext(1)

		local function App(props)
			return React.createElement(Context.Provider, {
				value = props.value,
			}, {
				Portal = ReactRoblox.createPortal({
					Consumer = React.createElement(Context.Consumer, nil, function(value)
						return React.createElement(
							"TextLabel",
							{ Text = "Result: " .. tostring(value) }
						)
					end),
				}, target),
			})
		end

		reactRobloxRoot:render(React.createElement(App, { value = 2 }))
		Scheduler.unstable_flushAllWithoutAsserting()
		jestExpect(#target:GetChildren()).toBe(1)
		jestExpect(target:GetChildren()[1].Text).toBe("Result: 2")

		reactRobloxRoot:render(React.createElement(App, { value = 3 }))
		Scheduler.unstable_flushAllWithoutAsserting()
		jestExpect(#target:GetChildren()).toBe(1)
		jestExpect(target:GetChildren()[1].Text).toBe("Result: 3")
	end)
end)

-- describe("Legacy context", function()
-- 	it("should pass context values through Roblox host nodes", function()
-- 		local Consumer = Component:extend("Consumer")

-- 		local capturedContext
-- 		function Consumer:init()
-- 			capturedContext = self._context
-- 		end

-- 		function Consumer:render()
-- 		end

-- 		local element = createElement("Folder", nil, {
-- 			Consumer = createElement(Consumer)
-- 		})
-- 		local hostParent = nil
-- 		local hostKey = "Context Test"
-- 		local context = {
-- 			hello = "world",
-- 		}
-- 		local node = reconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)

-- 		expect(capturedContext).never.toEqual(context)
-- 		assertDeepEqual(capturedContext, context)

-- 		reconciler.unmountVirtualNode(node)
-- 	end)

-- 	it("should pass context values through portal nodes", function()
-- 		local target = Instance.new("Folder")

-- 		local Provider = Component:extend("Provider")

-- 		function Provider:init()
-- 			self._context.foo = "bar"
-- 		end

-- 		function Provider:render()
-- 			return createElement("Folder", nil, self.props[Children])
-- 		end

-- 		local Consumer = Component:extend("Consumer")

-- 		local capturedContext
-- 		function Consumer:init()
-- 			capturedContext = self._context
-- 		end

-- 		function Consumer:render()
-- 			return nil
-- 		end

-- 		local element = createElement(Provider, nil, {
-- 			Portal = createElement(Portal, {
-- 				target = target,
-- 			}, {
-- 				Consumer = createElement(Consumer),
-- 			})
-- 		})
-- 		local hostParent = nil
-- 		local hostKey = "Some Key"
-- 		reconciler.mountVirtualNode(element, hostParent, hostKey)

-- 		assertDeepEqual(capturedContext, {
-- 			foo = "bar"
-- 		})
-- 	end)
-- end) ]]
f6.Children._61dc8b7a925bf1bba19020fd1394d86f=gf
local gg

local gh={ClassName="Folder",Children={},Properties={}}
gh.Name="roblox"
fT.Children._dc3cb628e151e3c47ea9c06f36854f75=gh
local gi
local gj={ClassName="ModuleScript",Children={},Properties={}}
gj.Name="RobloxComponentProps"
gj.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
local __DEV__ = _G.__DEV__ :: boolean
local CollectionService = game:GetService("CollectionService")
local Packages = script.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local String = LuauPolyfill.String
local inspect = LuauPolyfill.util.inspect

local console = require(Packages.Shared).console

local React = require(Packages.React)
local ReactSymbols = require(Packages.Shared).ReactSymbols
local SingleEventManager = require(script.Parent.SingleEventManager)
type EventManager = SingleEventManager.EventManager
local Type = require(Packages.Shared).Type
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local ReactRobloxHostTypes = require(script.Parent.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance
local Tag = require(Packages.React).Tag

-- ROBLOX deviation: Essentially a placeholder for dom-specific logic, taking the place
-- of ReactDOMComponent. Most of the logic will differ pretty dramatically

type Array<T> = { [number]: T }
type Object = { [any]: any }

-- deviation: Can't assign attributes to Roblox instances, so we use maps to
-- store associated data for host instance features like binding and event
-- management
-- ROBLOX FIXME: Stronger typing for EventManager

local instanceToEventManager: { [HostInstance]: EventManager } = {}
local instanceToBindings: { [HostInstance]: { [string]: any } } = {}

local applyPropsError = \[\[
Error applying initial props to Roblox Instance '%s' (%s):
  %s
\]\]

local updatePropsError = \[\[
Error updating props on Roblox Instance '%s' (%s):
  %s
\]\]

local updateBindingError = \[\[
Error updating binding or ref assigned to key %s of '%s' (%s).

Updated value:
  %s

Error:
  %s

%s
\]\]

local function identity(...)
	return ...
end

local function setRobloxInstanceProperty(hostInstance, key, newValue): ()
	if newValue == nil then
		local hostClass = hostInstance.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostInstance[key] = newValue
end

local function removeBinding(hostInstance, key)
	local bindings = instanceToBindings[hostInstance]
	if bindings ~= nil then
		local disconnect = bindings[key]
		disconnect()
		bindings[key] = nil
	end
end

local function attachBinding(hostInstance, key, newBinding): ()
	local function updateBoundProperty(newValue)
		local success, errorMessage =
			xpcall(setRobloxInstanceProperty, identity, hostInstance, key, newValue)

		if not success then
			local source = newBinding._source or "<enable DEV mode for stack>"
			local fullMessage = string.format(
				updateBindingError,
				key,
				hostInstance.Name,
				hostInstance.ClassName,
				tostring(newValue),
				errorMessage,
				source
			)
			console.error(fullMessage)
			-- FIXME: Until console.error can be instrumented to send telemetry, we
			-- need to keep the hard error here
			error(fullMessage, 0)
		end
	end

	if instanceToBindings[hostInstance] == nil then
		instanceToBindings[hostInstance] = {}
	end

	instanceToBindings[hostInstance][key] =
		React.__subscribeToBinding(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function applyTags(hostInstance: Instance, oldTags: string?, newTags: string?)
	if __DEV__ then
		if newTags ~= nil and typeof(newTags) ~= "string" then
			console.error(
				"Type provided for ReactRoblox.Tag is invalid - tags should be "
					.. "specified as a single string, with individual tags delimited "
					.. "by spaces. Instead received:\n%s",
				inspect(newTags)
			)
			return
		end
	end

	local oldTagSet = Set.new(String.split(oldTags or "", " "))
	local newTagSet = Set.new(String.split(newTags or "", " "))

	for _, tag in oldTagSet do
		if not newTagSet:has(tag) then
			CollectionService:RemoveTag(hostInstance, tag)
		end
	end
	for _, tag in newTagSet do
		if not oldTagSet:has(tag) then
			CollectionService:AddTag(hostInstance, tag)
		end
	end
end

local function removeAllTags(hostInstance: Instance)
	for _, tag in CollectionService:GetTags(hostInstance) do
		CollectionService:RemoveTag(hostInstance, tag)
	end
end

local function applyProp(hostInstance: Instance, key, newValue, oldValue): ()
	-- ROBLOX performance: gets checked in applyProps so we can assume the key is valid
	-- if key == "ref" or key == "children" then
	--   return
	-- end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		local eventManager = instanceToEventManager[hostInstance]
		if eventManager == nil then
			eventManager = (SingleEventManager.new(hostInstance) :: any) :: EventManager
			instanceToEventManager[hostInstance] = eventManager
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			eventManager:connectPropertyChange(eventName, newValue)
		else
			eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	-- Handle bindings
	local newIsBinding = typeof(newValue) == "table"
		and newValue["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE
	local oldIsBinding = oldValue ~= nil
		and typeof(oldValue) == "table"
		and oldValue["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE
	if oldIsBinding then
		removeBinding(hostInstance, key)
	end

	if newIsBinding then
		attachBinding(hostInstance, key, newValue)
	elseif key == Tag then
		applyTags(hostInstance, oldValue, newValue)
	else
		setRobloxInstanceProperty(hostInstance, key, newValue)
	end
end

local function applyProps(hostInstance: Instance, props: Object): ()
	for propKey, value in props do
		-- ROBLOX performance: avoid the function call by inlining check here
		if propKey == "ref" or propKey == "children" then
			continue
		end

		applyProp(hostInstance, propKey, value)
	end
end

local function setInitialProperties(
	domElement: HostInstance,
	_tag: string,
	rawProps: Object,
	_rootContainerElement: HostInstance
): ()
	-- deviation: Use Roact's prop application logic
	local success, errorMessage = xpcall(applyProps, identity, domElement, rawProps)
	-- ROBLOX deviation: Roblox renderer doesn't currently track where instances
	-- were created the way that legacy Roact did, but DEV mode should include
	-- component stack traces as a separate warning
	if not success then
		local fullMessage = string.format(
			applyPropsError,
			domElement.Name,
			domElement.ClassName,
			errorMessage
		)
		console.error(fullMessage)
		-- FIXME: Until console.error can be instrumented to send telemetry, we need
		-- to keep the hard error here
		error(fullMessage, 0)
	end

	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:resume()
	end
end

local function safelyApplyProperties(
	domElement: HostInstance,
	updatePayload: Array<any>,
	lastProps: Object
): ()
	local updatePayloadCount = #updatePayload
	for i = 1, updatePayloadCount, 2 do
		local propKey = updatePayload[i]
		local value = updatePayload[i + 1]
		if value == Object.None then
			value = nil
		end
		-- ROBLOX performance: avoid the function call by inlining check here
		if propKey ~= "ref" and propKey ~= "children" then
			applyProp(domElement, propKey, value, lastProps[propKey])
		end
	end
end

local function updateProperties(
	domElement: HostInstance,
	updatePayload: Array<any>,
	lastProps: Object
): ()
	-- deviation: Use Roact's prop application logic
	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:suspend()
	end

	local success, errorMessage =
		xpcall(safelyApplyProperties, identity, domElement, updatePayload, lastProps)

	if not success then
		-- ROBLOX deviation: Roblox renderer doesn't currently track where instances
		-- were created the way that legacy Roact did, but DEV mode should include
		-- component stack traces as a separate warning
		local fullMessage = string.format(
			updatePropsError,
			domElement.Name,
			domElement.ClassName,
			errorMessage
		)
		console.error(fullMessage)
		-- FIXME: Until console.error can be instrumented to send telemetry, we need
		-- to keep the hard error here
		error(fullMessage, 0)
	end

	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:resume()
	end
end

-- ROBLOX deviation: Clear out references to components when they unmount so we
-- avoid leaking memory when they're removed
local function cleanupHostComponent(domElement: HostInstance)
	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement] = nil
	end
	if instanceToBindings[domElement] ~= nil then
		instanceToBindings[domElement] = nil
	end

	-- ROBLOX https://jira.rbx.com/browse/LUAFDN-718: Tables are somehow ending up
	-- in this function that expects Instances. In that case, we won't be able to
	-- iterate through its descendants.
	if typeof(domElement :: any) ~= "Instance" then
		return
	end

	removeAllTags(domElement)
	for _, descElement in domElement:GetDescendants() do
		if instanceToEventManager[descElement] ~= nil then
			instanceToEventManager[descElement] = nil
		end
		if instanceToBindings[descElement] ~= nil then
			instanceToBindings[descElement] = nil
		end
		removeAllTags(domElement)
	end
end

return {
	setInitialProperties = setInitialProperties,
	updateProperties = updateProperties,
	cleanupHostComponent = cleanupHostComponent,

	-- ROBLOX deviation: expose maps to test for Instance cleanups
	_instanceToEventManager = instanceToEventManager,
	_instanceToBindings = instanceToBindings,
} ]]
gi.Children._54989d642f15de732463a6b4a83e9f3b=gj
local gk

local gl={ClassName="ModuleScript",Children={},Properties={}}
gl.Name="SingleEventManager"
gl.Properties.Source=[[ -- ROBLOX upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/SingleEventManager.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

--\[\[
	A manager for a single host virtual node's connected events.
\]\]

local Packages = script.Parent.Parent.Parent.Parent

local console = require(Packages.Shared).console
type Function = (...any) -> ...any

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

export type EventManager = {
	connectPropertyChange: (self: any, eventName: string, newValue: any) -> (),
	connectEvent: (self: any, eventName: string, newValue: any) -> (),
	resume: (self: any) -> (),
	suspend: (self: any) -> (),
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance: Instance): EventManager
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return (self :: any) :: EventManager
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event =
		pcall(self._instance.GetPropertyChangedSignal, self._instance, key)

	if not success then
		error(
			string.format(
				"Cannot get changed signal on property %q: %s",
				tostring(key),
				event
			),
			0
		)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(
						self._suspendedEventQueue,
						{ eventKey, argumentCount, ... }
					)
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	for _, eventInvocation in self._suspendedEventQueue do
		local listener = self._listeners[eventInvocation[1\]\]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount)
			)

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				console.warn("%s", result)
			end
		end
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	table.clear(self._suspendedEventQueue)
end

return SingleEventManager ]]
gi.Children._9e57556a108233e4178cbf1205f30fce=gl
local gm

local gn={ClassName="Folder",Children={},Properties={}}
gn.Name="__tests__"
gi.Children._2fb26c1c1fc1e664b92e40714864881e=gn
local go
local gp={ClassName="ModuleScript",Children={},Properties={}}
gp.Name="RobloxComponentProps.roblox.spec"
gp.Properties.Source=[[ local React
local ReactRoblox
local Scheduler
local RobloxComponentProps

local Packages = script.Parent.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local beforeEach = JestGlobals.beforeEach
local it = JestGlobals.it

beforeEach(function()
	jest.resetModules()
	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	Scheduler = require(Packages.Scheduler)
	RobloxComponentProps = require(script.Parent.Parent.RobloxComponentProps)
end)

local function getSizeOfMap(map)
	local count = 0
	for _ in map do
		count += 1
	end
	return count
end

it("should clear instanceToBindings map of unmounted instances", function()
	local value = React.createBinding("Hello world!")
	local function Component()
		return React.createElement("TextLabel", {
			key = "label",
			Text = value,
		})
	end

	local target = Instance.new("Folder")

	local root = ReactRoblox.createRoot(target)
	root:render(React.createElement(Component))
	Scheduler.unstable_flushAllWithoutAsserting()

	-- There should be one instance in the map
	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToBindings)).toBe(1)

	-- Validate that anything in the map is a mounted instance
	for hostInstance in RobloxComponentProps._instanceToBindings do
		jestExpect(hostInstance:IsDescendantOf(target)).toBe(true)
	end

	root:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToBindings)).toBe(0)
end)

it("should clear instanceToEventManager map of unmounted instances", function()
	local function Component()
		return React.createElement("TextButton", {
			key = "button",
			[ReactRoblox.Event.Activated] = function()
				-- do something
			end,
			[ReactRoblox.Change.Text] = function()
				-- do something
			end,
		})
	end

	local target = Instance.new("Folder")

	local root = ReactRoblox.createRoot(target)
	root:render(React.createElement(Component))
	Scheduler.unstable_flushAllWithoutAsserting()

	-- There should be one instance in the map
	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToEventManager)).toBe(1)

	-- Validate that anything in the map is a mounted instance
	for hostInstance in RobloxComponentProps._instanceToEventManager do
		jestExpect(hostInstance:IsDescendantOf(target)).toBe(true)
	end

	root:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToEventManager)).toBe(0)
end)

it("should clear instanceToBindings map of unmounted descendents", function()
	local value = React.createBinding("Hello world!")
	local function Component()
		-- Outer component has no bindings or events, but will get cleaned
		-- up directly by `unmount`
		-- Outer component has no bindings or events, but will get cleaned
		-- up directly by `unmount`
		return React.createElement("Frame", {}, {
			Label = React.createElement("TextLabel", {
				Text = value,
			}),
			Button = React.createElement("TextButton", {
				Text = value:map(function(text)
					return text .. " (Button)"
				end),
			}),
		})
	end

	local target = Instance.new("Folder")

	local root = ReactRoblox.createRoot(target)
	root:render(React.createElement("ScreenGui", nil, React.createElement(Component)))
	Scheduler.unstable_flushAllWithoutAsserting()

	-- There should be one instance in the map
	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToBindings)).toBe(2)

	-- Validate that anything in the map is a mounted instance
	for hostInstance in RobloxComponentProps._instanceToBindings do
		jestExpect(hostInstance:IsDescendantOf(target)).toBe(true)
	end

	root:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToBindings)).toBe(0)
end)

it("should clear instanceToEventManager map of unmounted descendents", function()
	local function Component()
		-- Outer component has no bindings or events, but will get cleaned
		-- up directly by `unmount`
		return React.createElement("Frame", {}, {
			Button = React.createElement("TextButton", {
				[ReactRoblox.Event.Activated] = function()
					-- do something
				end,
			}),
			Label = React.createElement("TextLabel", {
				[ReactRoblox.Change.Text] = function()
					-- do something
				end,
			}),
		})
	end

	local target = Instance.new("Folder")

	local root = ReactRoblox.createRoot(target)
	root:render(React.createElement("ScreenGui", nil, React.createElement(Component)))
	Scheduler.unstable_flushAllWithoutAsserting()

	-- There should be one instance in the map
	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToEventManager)).toBe(2)

	-- Validate that anything in the map is a mounted instance
	for hostInstance in RobloxComponentProps._instanceToEventManager do
		jestExpect(hostInstance:IsDescendantOf(target)).toBe(true)
	end

	root:unmount()
	Scheduler.unstable_flushAllWithoutAsserting()

	jestExpect(getSizeOfMap(RobloxComponentProps._instanceToEventManager)).toBe(0)
end) ]]
go.Children._06e8402f87e6466aa5970d222b412ed8=gp
local gq

local gr={ClassName="ModuleScript",Children={},Properties={}}
gr.Name="SingleEventManager.spec"
gr.Properties.Source=[[ -- ROBLOX upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/SingleEventManager.spec.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local it = JestGlobals.it
local describe = JestGlobals.describe
-- ROBLOX FIXME
-- local Logging = require(script.Parent.Parent.Logging)

local SingleEventManager = require(script.Parent.Parent.SingleEventManager)
local waitForEvents = require(script.Parent.waitForEvents)

describe("new", function()
	it("should create a SingleEventManager", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)

		jestExpect(manager).never.toBeNil()
	end)
end)

describe("connectEvent", function()
	it("should connect to events", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)
		local eventSpy = jest.fn()

		manager:connectEvent("Event", function(...)
			eventSpy(...)
		end)
		manager:resume()

		instance:Fire("foo")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(1)
		jestExpect(eventSpy).toBeCalledWith(instance, "foo")

		instance:Fire("bar")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(2)
		jestExpect(eventSpy).toBeCalledWith(instance, "bar")

		manager:connectEvent("Event")

		instance:Fire("baz")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(2)
	end)

	it("should drop events until resumed initially", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)
		local eventSpy = jest.fn()

		manager:connectEvent("Event", function(...)
			eventSpy(...)
		end)

		instance:Fire("foo")
		waitForEvents()

		jestExpect(eventSpy).never.toBeCalled()

		manager:resume()

		instance:Fire("bar")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(1)
		jestExpect(eventSpy).toBeCalledWith(instance, "bar")
	end)

	it("should invoke suspended events when resumed", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)
		local eventSpy = jest.fn()

		manager:connectEvent("Event", function(...)
			eventSpy(...)
		end)
		manager:resume()

		instance:Fire("foo")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(1)
		jestExpect(eventSpy).toBeCalledWith(instance, "foo")

		manager:suspend()

		instance:Fire("bar")
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(1)

		manager:resume()
		jestExpect(eventSpy).toBeCalledTimes(2)
		jestExpect(eventSpy).toBeCalledWith(instance, "bar")
	end)

	it("should invoke events triggered during resumption in the correct order", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)

		local recordedValues = {}
		local eventSpy = jest.fn(function(_, value)
			table.insert(recordedValues, value)

			if value == 2 then
				instance:Fire(3)
			elseif value == 3 then
				instance:Fire(4)
			end
		end)

		manager:connectEvent("Event", function(...)
			eventSpy(...)
		end)
		manager:suspend()

		instance:Fire(1)
		instance:Fire(2)
		waitForEvents()

		manager:resume()
		waitForEvents()
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(4)
		jestExpect(recordedValues).toEqual({ 1, 2, 3, 4 })
	end)

	it(
		"should not invoke events fired during suspension but disconnected before resumption",
		function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)
			local eventSpy = jest.fn()

			manager:connectEvent("Event", function(...)
				eventSpy(...)
			end)
			manager:suspend()

			instance:Fire(1)
			waitForEvents()

			manager:connectEvent("Event")

			manager:resume()
			jestExpect(eventSpy).never.toBeCalled()
		end
	)

	it("should not yield events through the SingleEventManager when resuming", function()
		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)

		manager:connectEvent("Event", function()
			coroutine.yield()
		end)

		manager:resume()

		local co = coroutine.create(function()
			instance:Fire(5)
			waitForEvents()
		end)

		assert(coroutine.resume(co))
		waitForEvents()

		jestExpect(coroutine.status(co)).toBe("dead")

		manager:suspend()
		instance:Fire(5)
		waitForEvents()

		co = coroutine.create(function()
			manager:resume()
		end)

		assert(coroutine.resume(co))
		jestExpect(coroutine.status(co)).toBe("dead")
	end)

	it("should not throw errors through SingleEventManager when resuming", function()
		local errorText = "Error from SingleEventManager test"

		local instance = Instance.new("BindableEvent")
		local manager = SingleEventManager.new(instance)

		manager:connectEvent("Event", function()
			error(errorText)
		end)

		manager:resume()

		-- If we call instance:Fire() here, the error message will leak to
		-- the console since the thread's resumption will be handled by
		-- Roblox's scheduler.

		manager:suspend()
		instance:Fire(5)

		-- local logInfo = Logging.capture(function()
		-- 	manager:resume()
		-- end)

		-- jestExpect(#logInfo.errors).to.equal(0)
		-- jestExpect(#logInfo.warnings).to.equal(1)
		-- jestExpect(#logInfo.infos).to.equal(0)

		-- jestExpect(logInfo.warnings[1]:find(errorText)).to.be.ok()
	end)

	it(
		"should not overflow with events if manager:resume() is invoked when resuming a suspended event",
		function()
			local instance = Instance.new("BindableEvent")
			local manager = SingleEventManager.new(instance)

			-- This connection emulates what happens if reconciliation is
			-- triggered again in response to reconciliation. Without
			-- appropriate guards, the inner resume() call will process the
			-- Fire(1) event again, causing a nasty stack overflow.
			local eventSpy = jest.fn(function(_, value)
				if value == 1 then
					manager:suspend()
					instance:Fire(2)
					manager:resume()
				end
			end)

			manager:connectEvent("Event", function(...)
				eventSpy(...)
			end)

			manager:suspend()
			instance:Fire(1)
			manager:resume()
			waitForEvents()
			waitForEvents()

			jestExpect(eventSpy).toBeCalledTimes(2)
		end
	)
end)

describe("connectPropertyChange", function()
	-- Since property changes utilize the same mechanisms as other events,
	-- the tests here are slimmed down to reduce redundancy.

	it("should connect to property changes", function()
		local instance = Instance.new("Folder")
		local manager = SingleEventManager.new(instance)
		local eventSpy = jest.fn()

		manager:connectPropertyChange("Name", function(...)
			eventSpy(...)
		end)
		manager:resume()

		instance.Name = "foo"
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(1)
		jestExpect(eventSpy).toBeCalledWith(instance)

		instance.Name = "bar"
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(2)
		jestExpect(eventSpy).toBeCalledWith(instance)

		manager:connectPropertyChange("Name")

		instance.Name = "baz"
		waitForEvents()

		jestExpect(eventSpy).toBeCalledTimes(2)
	end)

	it("should throw an error if the property is invalid", function()
		local instance = Instance.new("Folder")
		local manager = SingleEventManager.new(instance)

		jestExpect(function()
			manager:connectPropertyChange("foo", function() end)
		end).toThrow()
	end)
end) ]]
go.Children._b0a3943cd069148c62d4ae215535045d=gr
local gs

local gt={ClassName="ModuleScript",Children={},Properties={}}
gt.Name="Tagging.spec"
gt.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local React
local ReactRoblox
local Scheduler
local Tag

local CollectionService = game:GetService("CollectionService")
local Packages = script.Parent.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local jest = JestGlobals.jest
local waitForEvents = require(script.Parent.waitForEvents)
local beforeEach = JestGlobals.beforeEach
local afterEach = JestGlobals.afterEach
local it = JestGlobals.it
local describe = JestGlobals.describe

beforeEach(function()
	jest.resetModules()
	React = require(Packages.React)
	ReactRoblox = require(Packages.ReactRoblox)
	Scheduler = require(Packages.Scheduler)
	Tag = require(Packages.React).Tag
end)

describe("adding tags", function()
	local root, parent
	local tag1AddedMock, tag2AddedMock
	local tag1AddedConnection, tag2AddedConnection
	beforeEach(function()
		local tag1Mock, tag1Fn = jest.fn()
		local tag2Mock, tag2Fn = jest.fn()
		tag1AddedConnection = CollectionService:GetInstanceAddedSignal("tag1")
			:Connect(tag1Fn)
		tag2AddedConnection = CollectionService:GetInstanceAddedSignal("tag2")
			:Connect(tag2Fn)

		tag1AddedMock = tag1Mock
		tag2AddedMock = tag2Mock

		parent = Instance.new("Folder")
		parent.Parent = game:GetService("Workspace")
		root = ReactRoblox.createRoot(parent)
	end)

	afterEach(function()
		tag1AddedConnection:Disconnect()
		tag2AddedConnection:Disconnect()

		root:unmount()
		parent:Destroy()
	end)

	it("should add a single tag", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1AddedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
	end)

	it("should add several tags", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1AddedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(tag2AddedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })
	end)

	it("should add tags to several children", function()
		local textLabelRef, textBoxRef = React.createRef(), React.createRef()
		root:render(React.createElement(
			"Frame",
			nil,
			React.createElement("TextLabel", {
				ref = textLabelRef,
				[Tag] = "tag1",
			}),
			React.createElement("TextBox", {
				ref = textBoxRef,
				[Tag] = "tag1",
			})
		))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1AddedMock).toHaveBeenCalledWith(textLabelRef.current)
		jestExpect(tag1AddedMock).toHaveBeenCalledWith(textBoxRef.current)

		-- We don't have any guarantees about order from the engine, so we
		-- just check that both instances are present
		local tags = CollectionService:GetTagged("tag1")
		jestExpect(tags).toHaveLength(2)
		jestExpect(tags).toContain(textLabelRef.current)
		jestExpect(tags).toContain(textBoxRef.current)
	end)

	it("should add no tags when given an empty string", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTags(ref.current)).toEqual({})
	end)

	it("should not change tags that are re-ordered", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1AddedMock).toHaveBeenCalledTimes(1)
		jestExpect(tag2AddedMock).toHaveBeenCalledTimes(1)

		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag2 tag1",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1AddedMock).toHaveBeenCalledTimes(1)
		jestExpect(tag2AddedMock).toHaveBeenCalledTimes(1)
	end)
end)

describe("removing tags", function()
	local root, parent
	local tag1RemovedMock, tag2RemovedMock
	local tag1RemovedConnection, tag2RemovedConnection

	beforeEach(function()
		local tag1Mock, tag1Fn = jest.fn()
		local tag2Mock, tag2Fn = jest.fn()
		tag1RemovedConnection = CollectionService:GetInstanceRemovedSignal("tag1")
			:Connect(tag1Fn)
		tag2RemovedConnection = CollectionService:GetInstanceRemovedSignal("tag2")
			:Connect(tag2Fn)

		tag1RemovedMock = tag1Mock
		tag2RemovedMock = tag2Mock

		parent = Instance.new("Folder")
		parent.Parent = game:GetService("Workspace")
		root = ReactRoblox.createRoot(parent)
	end)

	afterEach(function()
		tag1RemovedConnection:Disconnect()
		tag2RemovedConnection:Disconnect()

		root:unmount()
		parent:Destroy()
	end)

	it("should remove a tag when updated", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		root:render(React.createElement("TextLabel", {
			ref = ref,
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1RemovedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
	end)

	it("should remove one tag in a list when updated", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })

		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1RemovedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(tag2RemovedMock).never.toHaveBeenCalled()
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })
	end)

	it("should remove several tags when updated", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })

		root:render(React.createElement("TextLabel", {
			ref = ref,
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1RemovedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(tag2RemovedMock).toHaveBeenCalledWith(ref.current)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({})
	end)

	it("should remove tags on unmount", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })

		root:render(nil)
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1RemovedMock).toHaveBeenCalledTimes(1)
		jestExpect(tag2RemovedMock).toHaveBeenCalledTimes(1)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({})
	end)

	it("should remove tags when provided an empty tag string", function()
		local ref = React.createRef()
		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "tag1 tag2",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(CollectionService:GetTagged("tag1")).toEqual({ ref.current })
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({ ref.current })

		root:render(React.createElement("TextLabel", {
			ref = ref,
			[Tag] = "",
		}))
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()

		jestExpect(tag1RemovedMock).toHaveBeenCalledTimes(1)
		jestExpect(tag2RemovedMock).toHaveBeenCalledTimes(1)
		jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
		jestExpect(CollectionService:GetTagged("tag2")).toEqual({})
	end)
end)

it("should warn when assigning tags with an incorrect type", function()
	local parent = Instance.new("Folder")
	parent.Parent = game:GetService("Workspace")
	local root = ReactRoblox.createRoot(parent)
	local ref = React.createRef()
	root:render(React.createElement("TextLabel", {
		key = "My Label",
		ref = ref,
		[Tag] = 42,
	}))
	jestExpect(function()
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()
	end).toErrorDev(
		"Warning: Type provided for ReactRoblox.Tag is invalid - tags "
			.. "should be specified as a single string, with "
			.. "individual tags delimited by spaces. Instead received:"
			.. "\n42"
	)
end)

it("should warn when assigning tags to unrooted instances", function()
	local parent = Instance.new("Folder")
	local orphanedRoot = ReactRoblox.createRoot(parent)
	local ref = React.createRef()
	orphanedRoot:render(React.createElement("TextLabel", {
		key = "My Label",
		ref = ref,
		[Tag] = "tag1",
	}))
	jestExpect(function()
		Scheduler.unstable_flushAllWithoutAsserting()
		waitForEvents()
	end).toWarnDev(
		'Warning: Tags applied to orphaned TextLabel "My Label" cannot'
			.. " be accessed via CollectionService:GetTagged. If you're relying"
			.. " on tag behavior in a unit test, consider mounting your test"
			.. " root into the DataModel."
	)

	-- Despite the warning, the tag should belong to the instance's set of
	-- tags retrieved via `GetTags`
	jestExpect(CollectionService:GetTags(ref.current)).toEqual({ "tag1" })
	-- However, we expect `GetTagged` for the tag itself to be empty; it
	-- only gets populated when the orphaned root is added to the DataModel
	jestExpect(CollectionService:GetTagged("tag1")).toEqual({})
end) ]]
go.Children._af0923efb11edcf37012193cf529f918=gt
local gu

local gv={ClassName="ModuleScript",Children={},Properties={}}
gv.Name="getDefaultInstanceProperty.spec"
gv.Properties.Source=[[ -- ROBLOX upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/getDefaultInstanceProperty.spec.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local getDefaultInstanceProperty =
	require(script.Parent.Parent.getDefaultInstanceProperty)

it("should get default name string values", function()
	local _, defaultName = getDefaultInstanceProperty("StringValue", "Name")

	jestExpect(defaultName).toBe("Value")
end)

it("should get default empty string values", function()
	local _, defaultValue = getDefaultInstanceProperty("StringValue", "Value")

	jestExpect(defaultValue).toBe("")
end)

it("should get default number values", function()
	local _, defaultValue = getDefaultInstanceProperty("IntValue", "Value")

	jestExpect(defaultValue).toBe(0)
end)

it("should get nil default values", function()
	local _, defaultValue = getDefaultInstanceProperty("ObjectValue", "Value")

	jestExpect(defaultValue).toBe(nil)
end)

it("should get bool default values", function()
	local _, defaultValue = getDefaultInstanceProperty("BoolValue", "Value")

	jestExpect(defaultValue).toBe(false)
end) ]]
go.Children._19ca56da70522b974dbc9b9fbfad9c33=gv
local gw

local gx={ClassName="ModuleScript",Children={},Properties={}}
gx.Name="waitForEvents"
gx.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

-- Defers remaining execution until after deferred lua events have run
return function()
	task.defer(coroutine.running())
	coroutine.yield()
end ]]
go.Children._dadba852cf69da220dc55c66d83f1f52=gx
local gy

local gz={ClassName="ModuleScript",Children={},Properties={}}
gz.Name="getDefaultInstanceProperty"
gz.Properties.Source=[[ -- ROBLOX upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/getDefaultInstanceProperty.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

--\[\[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
\]\]

local Packages = script.Parent.Parent.Parent.Parent
local Symbol = require(Packages.Shared).Symbol

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function tryPropertyName(instance, propertyName)
	return instance[propertyName]
end

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(tryPropertyName, created, propertyName)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty ]]
gi.Children._000b3181ef446f3c15275b6d755590e5=gz
local gA

local gB={ClassName="ModuleScript",Children={},Properties={}}
gB.Name="ReactShallowRenderer"
gB.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of self source tree.
 *
 *
 \]\]

local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Error = LuauPolyfill.Error
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>

local React = require(Packages.React)

local ReactIs = require(Packages.ReactIs)
local isForwardRef = ReactIs.isForwardRef
local isMemo = ReactIs.isMemo
local ForwardRef = ReactIs.ForwardRef

local ReactComponentStackFrame = require(Packages.Shared).ReactComponentStackFrame
local describeComponentFrame = ReactComponentStackFrame.describeComponentFrame
local getComponentName = require(Packages.Shared).getComponentName
local shallowEqual = require(Packages.Shared).shallowEqual
local checkPropTypes = require(Packages.Shared).checkPropTypes
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local consoleWithStackDev = require(Packages.Shared).consoleWithStackDev
local is = require(Packages.Shared).objectIs

local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

local RE_RENDER_LIMIT: number = 25

local emptyObject = {}
if _G.__DEV__ then
	Object.freeze(emptyObject)
end

-- In DEV, self is the name of the currently executing primitive hook
-- ROBLOX deviation: this is a weird unassigned variable bug present in upstream
local currentHookNameInDev = "currentHookNameInDev"

local function areHookInputsEqual(nextDeps, prevDeps)
	if prevDeps == nil then
		if _G.__DEV__ then
			consoleWithStackDev.error(
				"%s received a final argument during self render, but not during "
					.. "the previous render. Even though the final argument is optional, "
					.. "its type cannot change between renders.",
				currentHookNameInDev
			)
		end
		return false
	end

	if _G.__DEV__ then
		-- Don't bother comparing lengths in prod because these arrays should be
		-- passed inline.
		if #nextDeps ~= #prevDeps then
			consoleWithStackDev.error(
				"The final argument passed to %s changed size between renders. The "
					.. "order and size of self array must remain constant.\n\n"
					.. "Previous: %s\n"
					.. "Incoming: %s",
				currentHookNameInDev,
				table.concat(nextDeps, ", "),
				table.concat(prevDeps, ", ")
			)
		end
	end
	local maxValue = math.min(#prevDeps, #nextDeps)
	for i = 1, maxValue do
		if is(nextDeps[i], prevDeps[i]) then
			continue
		end
		return false
	end
	return true
end

-- ROBLOX deviation: bind functions to upvalue
function createUpdater(renderer)
	local updater = {
		_renderer = renderer,
		_callbacks = {},
	}

	function updater._enqueueCallback(callback, publicInstance)
		if typeof(callback) == "function" and publicInstance then
			table.insert(updater._callbacks, {
				callback = callback,
				publicInstance = publicInstance,
			})
		end
	end

	function updater._invokeCallbacks()
		local callbacks = updater._callbacks
		updater._callbacks = {}

		for _, value in callbacks do
			local callback = value.callback
			local publicInstance = value.publicInstance

			callback(publicInstance)
		end
	end

	function updater.isMounted(publicInstance)
		return not not updater._renderer._element
	end

	function updater.enqueueForceUpdate(publicInstance, callback, _callerName)
		updater._enqueueCallback(callback, publicInstance)
		updater._renderer._forcedUpdate = true
		updater._renderer:render(updater._renderer._element, updater._renderer._context)
	end

	function updater.enqueueReplaceState(
		publicInstance,
		completeState,
		callback,
		_callerName
	)
		updater._enqueueCallback(callback, publicInstance)
		updater._renderer._newState = completeState
		updater._renderer:render(updater._renderer._element, updater._renderer._context)
	end

	function updater.enqueueSetState(publicInstance, partialState, callback, _callerName)
		updater._enqueueCallback(callback, publicInstance)
		local currentState = updater._renderer._newState or publicInstance.state

		if typeof(partialState) == "function" then
			-- ROBLOX deviation: in React, the partial state function is called on the
			-- publicInstance, meaning that `this` is accessible, and scoped correctly,
			-- inside of the state updater; with Lua, you would need to define your
			-- functions differently, by explicitly adding the first argument for 'self'
			-- for this to work the same way
			partialState = partialState(currentState, publicInstance.props)
		end

		-- Null and undefined are treated as no-ops.
		if partialState == nil then
			return
		end

		updater._renderer._newState = Object.assign({}, currentState, partialState)

		updater._renderer:render(updater._renderer._element, updater._renderer._context)
	end

	return updater
end

function createHook()
	return {
		memoizedState = nil,
		queue = nil,
		next = nil,
	}
end

function basicStateReducer(state, action)
	if typeof(action) == "function" then
		return action(state)
	else
		return action
	end
end

-- ROBLOX deviation: hoist declaration
local currentlyValidatingElement = nil

local ReactShallowRenderer = {}
ReactShallowRenderer.__index = ReactShallowRenderer

-- ROBLOX deviation: Collapse static create function and constructor together; since
-- Lua only has the former anyway
function ReactShallowRenderer.createRenderer()
	local self = setmetatable({}, ReactShallowRenderer)
	self:_reset()

	return self
end

function ReactShallowRenderer:_reset()
	self._context = nil
	self._element = nil
	self._instance = nil
	self._newState = nil
	self._rendered = nil
	self._rendering = false
	self._forcedUpdate = false
	self._updater = createUpdater(self)
	self._dispatcher = self:_createDispatcher()
	self._workInProgressHook = nil
	self._firstWorkInProgressHook = nil
	self._isReRender = false
	self._didScheduleRenderPhaseUpdate = false
	self._renderPhaseUpdates = nil
	self._numberOfReRenders = 0
end

function ReactShallowRenderer:_validateCurrentlyRenderingComponent()
	if not (self._rendering and not self._instance) then
		error(
			Error(
				\[\[Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://fb.me/react-invalid-hook-call for tips about how to debug and fix self problem.\]\]
			)
		)
	end
end

function ReactShallowRenderer:_createDispatcher()
	-- ROBLOX deviation: This function returns two values instead of an array. Lua does
	-- not support destructuring, but _does_ support multiple return values
	local function useReducer(reducer, initialArg, init)
		self:_validateCurrentlyRenderingComponent()
		self:_createWorkInProgressHook()
		local workInProgressHook = self._workInProgressHook

		if self._isReRender then
			-- This is a re-render.
			local queue = workInProgressHook.queue
			local dispatch = queue.dispatch
			if self._numberOfReRenders > 0 then
				-- Apply the new render phase updates to the previous current hook.
				if self._renderPhaseUpdates ~= nil then
					-- Render phase updates are stored in a map of queue -> linked list
					local firstRenderPhaseUpdate = self._renderPhaseUpdates[queue]
					if firstRenderPhaseUpdate ~= nil then
						self._renderPhaseUpdates[queue] = nil
						local newState = workInProgressHook.memoizedState
						local update = firstRenderPhaseUpdate
						repeat
							local action = update.action
							newState = reducer(newState, action)
							update = update.next
						until update == nil
						workInProgressHook.memoizedState = newState
						return newState, dispatch
					end
				end
				return workInProgressHook.memoizedState, dispatch
			end
			-- Process updates outside of render
			local newState = workInProgressHook.memoizedState
			local update = queue.first
			if update ~= nil then
				repeat
					local action = update.action
					newState = reducer(newState, action)
					update = update.next
				until update == nil
				queue.first = nil
				workInProgressHook.memoizedState = newState
			end
			return newState, dispatch
		else
			local initialState
			if reducer == basicStateReducer then
				-- Special case for `useState`.
				if typeof(initialArg) == "function" then
					initialState = initialArg()
				else
					initialState = initialArg
				end
			else
				if init ~= nil then
					initialState = init(initialArg)
				else
					initialState = initialArg
				end
			end
			workInProgressHook.memoizedState = initialState
			workInProgressHook.queue = {
				first = nil,
				dispatch = nil,
			}
			local queue = workInProgressHook.queue
			queue.dispatch = function(...)
				self:_dispatchAction(queue, ...)
			end
			local dispatch = queue.dispatch
			return workInProgressHook.memoizedState, dispatch
		end
	end

	local function useState(initialState)
		return useReducer(
			basicStateReducer,
			-- useReducer has a special case to support lazy useState initializers
			initialState
		)
	end

	-- ROBLOX FIXME Luau: work around 'Failed to unify type packs' error: : CLI-51338
	local function useMemo<T...>(nextCreate: () -> T..., deps: Array<any> | nil): ...any
		self:_validateCurrentlyRenderingComponent()
		self:_createWorkInProgressHook()

		local nextDeps = deps

		if
			self._workInProgressHook ~= nil
			and self._workInProgressHook.memoizedState ~= nil
		then
			local prevState = self._workInProgressHook.memoizedState
			local prevDeps = prevState[2]
			if nextDeps ~= nil then
				if areHookInputsEqual(nextDeps, prevDeps) then
					return unpack(prevState[1])
				end
			end
		end

		-- ROBLOX DEVIATION: Wrap memoized values in a table and unpack to allow for multiple return values
		local nextValue = { nextCreate() }
		self._workInProgressHook.memoizedState = { nextValue, nextDeps }
		return unpack(nextValue)
	end

	local function useRef(initialValue)
		self:_validateCurrentlyRenderingComponent()
		self:_createWorkInProgressHook()
		local previousRef = self._workInProgressHook.memoizedState
		if previousRef == nil then
			local ref = { current = initialValue }
			if _G.__DEV__ then
				Object.seal(ref)
			end
			self._workInProgressHook.memoizedState = ref
			return ref
		else
			return previousRef
		end
	end

	local function readContext(context, _observedBits)
		return context._currentValue
	end

	local function noOp()
		self:_validateCurrentlyRenderingComponent()
	end

	local function identity(fn)
		return fn
	end

	local function useResponder(responder, props)
		return {
			props = props,
			responder = responder,
		}
	end

	-- TODO: implement if we decide to keep the shallow renderer
	local function useTransition(_config)
		self:_validateCurrentlyRenderingComponent()
		local startTransition = function(callback)
			callback()
		end
		return { startTransition, false }
	end

	-- TODO: implement if we decide to keep the shallow renderer
	local function useDeferredValue(value, _config)
		self:_validateCurrentlyRenderingComponent()
		return value
	end

	return {
		readContext = readContext,
		useCallback = identity,
		useContext = function(context)
			self:_validateCurrentlyRenderingComponent()
			return readContext(context)
		end,
		useDebugValue = noOp,
		useEffect = noOp,
		useImperativeHandle = noOp,
		useLayoutEffect = noOp,
		-- ROBLOX FIXME Luau: needs : CLI-51338
		useMemo = useMemo :: any,
		useReducer = useReducer,
		useRef = useRef,
		useState = useState,
		useResponder = useResponder,
		useTransition = useTransition,
		useDeferredValue = useDeferredValue,
	}
end

function ReactShallowRenderer:_dispatchAction(queue, action)
	local numberOfRenders: number = self._numberOfReRenders
	if numberOfRenders > RE_RENDER_LIMIT then
		error(
			Error(
				"Too many re-renders. React limits the number of renders to prevent an infinite loop."
			)
		)
	end

	if self._rendering then
		-- This is a render phase update. Stash it in a lazily-created map of
		-- queue -> linked list of updates. After self render pass, we'll restart
		-- and apply the stashed updates on top of the work-in-progress hook.
		self._didScheduleRenderPhaseUpdate = true
		local update = {
			action = action,
			next = nil,
		}
		local renderPhaseUpdates = self._renderPhaseUpdates
		if renderPhaseUpdates == nil then
			renderPhaseUpdates = {}
			self._renderPhaseUpdates = renderPhaseUpdates
		end
		local firstRenderPhaseUpdate = renderPhaseUpdates[queue]
		if firstRenderPhaseUpdate == nil then
			renderPhaseUpdates[queue] = update
		else
			-- Append the update to the end of the list.
			local lastRenderPhaseUpdate = firstRenderPhaseUpdate
			while lastRenderPhaseUpdate.next ~= nil do
				lastRenderPhaseUpdate = lastRenderPhaseUpdate.next
			end
			lastRenderPhaseUpdate.next = update
		end
	else
		local update = {
			action = action,
			next = nil,
		}

		-- Append the update to the end of the list.
		local last = queue.first
		if last == nil then
			queue.first = update
		else
			while last.next ~= nil do
				last = last.next
			end
			last.next = update
		end

		-- Re-render now.
		self:render(self._element, self._context)
	end
end

function ReactShallowRenderer:_createWorkInProgressHook()
	if self._workInProgressHook == nil then
		-- This is the first hook in the list
		if self._firstWorkInProgressHook == nil then
			self._isReRender = false
			self._workInProgressHook = createHook()
			self._firstWorkInProgressHook = self._workInProgressHook
		else
			-- There's already a work-in-progress. Reuse it.
			self._isReRender = true
			self._workInProgressHook = self._firstWorkInProgressHook
		end
	else
		if self._workInProgressHook.next == nil then
			self._isReRender = false
			-- Append to the end of the list
			self._workInProgressHook.next = createHook()
			self._workInProgressHook = self._workInProgressHook.next
		else
			-- There's already a work-in-progress. Reuse it.
			self._isReRender = true
			self._workInProgressHook = self._workInProgressHook.next
		end
	end
	return self._workInProgressHook
end

function ReactShallowRenderer:_finishHooks(element, context)
	if self._didScheduleRenderPhaseUpdate then
		-- Updates were scheduled during the render phase. They are stored in
		-- the `renderPhaseUpdates` map. Call the component again, reusing the
		-- work-in-progress hooks and applying the additional updates on top. Keep
		-- restarting until no more updates are scheduled.
		self._didScheduleRenderPhaseUpdate = false
		self._numberOfReRenders += 1

		-- Start over from the beginning of the list
		self._workInProgressHook = nil
		self._rendering = false
		self:render(element, context)
	else
		self._workInProgressHook = nil
		self._renderPhaseUpdates = nil
		self._numberOfReRenders = 0
	end
end

function ReactShallowRenderer:getMountedInstance()
	return self._instance
end

function ReactShallowRenderer:getRenderOutput()
	return self._rendered
end

function ReactShallowRenderer:render(element, maybeContext)
	local context = maybeContext or emptyObject
	if not React.isValidElement(element) then
		local message = ""
		if
			typeof(element) == "function"
			or (typeof(element) == "table" and element.__componentName ~= nil)
		then
			message = " Instead of passing a component class, make sure to instantiate "
				.. "it by passing it to React.createElement."
		end
		error(
			Error(
				string.format(
					"ReactShallowRenderer render(): Invalid component element.%s",
					message
				)
			)
		)
	end
	-- Show a special message for host elements since it's a common case.
	if not (typeof(element.type) ~= "string") then
		local elementType = element.type
		error(
			Error(
				string.format(
					"ReactShallowRenderer render(): Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting the rendered output, look at `el.props` directly instead.",
					tostring(elementType)
				)
			)
		)
	end
	-- ROBLOX deviation: include check for isReactComponent since our "class" components
	-- aren't functions like React's are
	if
		not (
			isForwardRef(element)
			or typeof(element.type) == "function"
			or (typeof(element.type) == "table" and element.type.isReactComponent == true)
			or isMemo(element)
		)
	then
		local elementType = typeof(element.type)
		if Array.isArray(element.type) then
			elementType = "array"
		end
		error(
			Error(
				string.format(
					"ReactShallowRenderer render(): Shallow rendering works only with custom components, but the provided element type was `%s`.",
					elementType
				)
			)
		)
	end

	if self._rendering then
		return
	end
	if self._element ~= nil and self._element.type ~= element.type then
		self:_reset()
	end

	local elementType
	if isMemo(element) then
		elementType = element.type.type
	else
		elementType = element.type
	end

	local previousElement = self._element
	self._rendering = true
	self._element = element
	-- ROBLOX deviation: functions can't have properties in Lua, so we can't access
	-- `contextTypes` if `elementType` is a function; as far as I can tell, React
	-- doesn't support `contextTypes` on function components anyways, so the
	-- behavior should be compatible
	local contextTypes
	if typeof(elementType) == "table" then
		contextTypes = elementType.contextTypes
	end
	self._context = getMaskedContext(contextTypes, context)

	-- Inner memo component props aren't currently validated in createElement.
	local prevGetStack
	if _G.__DEV__ then
		prevGetStack = ReactDebugCurrentFrame.getCurrentStack
		ReactDebugCurrentFrame.getCurrentStack = getStackAddendum
	end
	local ok, result = pcall(function()
		if
			isMemo(element)
			and typeof(elementType) == "table"
			and (elementType.propTypes or elementType.validateProps)
		then
			currentlyValidatingElement = element
			-- ROBLOX deviation: adds support for legacy Roact's validateProps()
			checkPropTypes(
				elementType.propTypes,
				elementType.validateProps,
				element.props,
				"prop",
				getComponentName(elementType)
			)
		end

		if self._instance then
			self:_updateClassComponent(elementType, element, self._context)
		else
			if shouldConstruct(elementType) then
				-- ROBLOX deviation: we don't have 'new', so we need to enumerate the element
				-- types we can support
				if typeof(elementType) == "function" then
					self._instance =
						elementType(element.props, self._context, self._updater)
				else
					if elementType.isReactComponent then
						self._instance = elementType.__ctor(
							element.props,
							self._context,
							self._updater
						)
					end
				end
				if
					typeof(elementType) == "table"
					and typeof(elementType.getDerivedStateFromProps) == "function"
				then
					local partialState = elementType.getDerivedStateFromProps(
						element.props,
						self._instance.state
					)
					if partialState ~= nil then
						self._instance.state =
							Object.assign({}, self._instance.state, partialState)
					end
				end

				if
					typeof(elementType) == "table"
					and (elementType.contextTypes or elementType.validateProps)
				then
					currentlyValidatingElement = element
					-- ROBLOX deviation: adds support for legacy Roact's validateProps()
					checkPropTypes(
						elementType.contextTypes,
						elementType.validateProps,
						self._context,
						"context",
						getName(elementType, self._instance)
					)

					currentlyValidatingElement = nil
				end

				self:_mountClassComponent(elementType, element, self._context)
			else
				local shouldRender = true
				if isMemo(element) and previousElement ~= nil then
					-- This is a Memo component that is being re-rendered.
					local compare = element.type.compare or shallowEqual
					if compare(previousElement.props, element.props) then
						shouldRender = false
					end
				end
				if shouldRender then
					local prevDispatcher = ReactCurrentDispatcher.current
					ReactCurrentDispatcher.current = self._dispatcher
					local ok, result = pcall(function()
						-- elementType could still be a ForwardRef if it was
						-- nested inside Memo.
						if
							typeof(elementType) == "table"
							and elementType["$$typeof"] == ForwardRef
						then
							if typeof(elementType.render) ~= "function" then
								error(
									Error(
										string.format(
											"forwardRef requires a render function but was given %s.",
											typeof(elementType.render)
										)
									)
								)
							end
							self._rendered =
								elementType.render(element.props, element.ref)
						else
							self._rendered = elementType(element.props, self._context)
						end
					end)

					-- finally
					ReactCurrentDispatcher.current = prevDispatcher

					-- no catch, so we throw again
					if not ok then
						error(result)
					end

					self:_finishHooks(element, context)
				end
			end
		end
	end)

	-- finally
	if _G.__DEV__ then
		ReactDebugCurrentFrame.getCurrentStack = prevGetStack
	end

	-- no catch, so we throw after resolving the 'finally'
	if not ok then
		error(result)
	end

	self._rendering = false
	self._updater._invokeCallbacks()

	return self:getRenderOutput()
end

function ReactShallowRenderer:unmount()
	if self._instance then
		if typeof(self._instance.componentWillUnmount) == "function" then
			self._instance:componentWillUnmount()
		end
	end
	self:_reset()
end

function ReactShallowRenderer:_mountClassComponent(elementType, element, context)
	self._instance.context = context
	self._instance.props = element.props
	self._instance.state = self._instance.state or nil
	self._instance.__updater = self._updater

	if
		typeof(self._instance.UNSAFE_componentWillMount) == "function"
		or typeof(self._instance.componentWillMount) == "function"
	then
		local beforeState = self._newState

		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			typeof(elementType.getDerivedStateFromProps) ~= "function"
			and typeof(self._instance.getSnapshotBeforeUpdate) ~= "function"
		then
			if typeof(self._instance.componentWillMount) == "function" then
				self._instance:componentWillMount()
			end
			if typeof(self._instance.UNSAFE_componentWillMount) == "function" then
				self._instance:UNSAFE_componentWillMount()
			end
		end

		-- setState may have been called during cWM
		if beforeState ~= self._newState then
			self._instance.state = self._newState or emptyObject
		end
	end

	self._rendered = self._instance:render()
	-- Intentionally do not call componentDidMount()
	-- because DOM refs are not available.
end

function ReactShallowRenderer:_updateClassComponent(elementType, element, context)
	local props = element.props

	local oldState = self._instance.state or emptyObject
	local oldProps = self._instance.props

	if oldProps ~= props then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			typeof(elementType.getDerivedStateFromProps) ~= "function"
			and typeof(self._instance.getSnapshotBeforeUpdate) ~= "function"
		then
			if typeof(self._instance.componentWillReceiveProps) == "function" then
				self._instance:componentWillReceiveProps(props, context)
			end
			if typeof(self._instance.UNSAFE_componentWillReceiveProps) == "function" then
				self._instance:UNSAFE_componentWillReceiveProps(props, context)
			end
		end
	end

	-- Read state after cWRP in case it calls setState
	local state = self._newState or oldState
	if typeof(elementType.getDerivedStateFromProps) == "function" then
		local partialState = elementType.getDerivedStateFromProps(props, state)
		if partialState ~= nil then
			state = Object.assign({}, state, partialState)
		end
	end

	local shouldUpdate = true
	if self._forcedUpdate then
		shouldUpdate = true
		self._forcedUpdate = false
	elseif typeof(self._instance.shouldComponentUpdate) == "function" then
		shouldUpdate = not not self._instance:shouldComponentUpdate(props, state, context)
	elseif typeof(elementType) == "table" and elementType.isPureReactComponent then
		shouldUpdate = not shallowEqual(oldProps, props)
			or not shallowEqual(oldState, state)
	end

	if shouldUpdate then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			typeof(elementType.getDerivedStateFromProps) ~= "function"
			and typeof(self._instance.getSnapshotBeforeUpdate) ~= "function"
		then
			if typeof(self._instance.componentWillUpdate) == "function" then
				self._instance:componentWillUpdate(props, state, context)
			end
			if typeof(self._instance.UNSAFE_componentWillUpdate) == "function" then
				self._instance:UNSAFE_componentWillUpdate(props, state, context)
			end
		end
	end

	self._instance.context = context
	self._instance.props = props
	self._instance.state = state
	self._newState = nil

	if shouldUpdate then
		self._rendered = self._instance:render()
	end
	-- Intentionally do not call componentDidUpdate()
	-- because DOM refs are not available.
end

function getDisplayName(element)
	if element == nil then
		return "#empty"
	elseif typeof(element) == "string" or typeof(element) == "number" then
		return "#text"
	elseif typeof(element.type) == "string" then
		return element.type
	else
		local elementType
		if isMemo(element) then
			elementType = element.type.type
		else
			elementType = element.type
		end
		return elementType.displayName or elementType.name or "Unknown"
	end
end

function getStackAddendum()
	local stack = ""
	if currentlyValidatingElement then
		local name = getDisplayName(currentlyValidatingElement)
		local owner = currentlyValidatingElement._owner
		stack ..= describeComponentFrame(
			name,
			currentlyValidatingElement._source,
			owner and getComponentName(owner.type)
		)
	end
	return stack
end

function getName(type, instance)
	local constructor = instance and instance.constructor
	return type.displayName
		or (constructor and constructor.displayName)
		or type.name
		or (constructor and constructor.name)
		or nil
end

function shouldConstruct(Component)
	return not not (typeof(Component) == "table" and Component.isReactComponent)
end

function getMaskedContext(contextTypes, unmaskedContext)
	if not contextTypes and not unmaskedContext then
		return emptyObject
	end
	if contextTypes and not unmaskedContext then
		return emptyObject
	end
	-- ROBLOX deviation: we can't mask context types for function components, so be 'unsafe' to make tests pass
	if not contextTypes and unmaskedContext then
		contextTypes = unmaskedContext
	end

	local context = {}
	for key, _ in contextTypes do
		context[key] = unmaskedContext[key]
	end
	return context
end

return ReactShallowRenderer ]]
c.Children._091bb85f1926347272befeb3bd96644b=gB
local gC
local gD={ClassName="Folder",Children={},Properties={}}
gD.Name="__tests__"
gC.Children._1b7fb6d2fa3a59b89792e2b8e08e988b=gD
local gE
local gF={ClassName="ModuleScript",Children={},Properties={}}
gF.Name="ReactShallowRenderer.spec"
gF.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

-- local Dependencies = script.Parent.Parent.Parent.Parent.Packages
local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local UninitializedState
-- local PropTypes = require(Dependencies.PropTypes)
local React
local ReactShallowRenderer
local createRenderer

beforeEach(function()
	UninitializedState = require(Packages.Shared).UninitializedState
	React = require(Packages.React)
	ReactShallowRenderer = require(script.Parent.Parent)
	createRenderer = ReactShallowRenderer.createRenderer
end)

local function validateElement(element)
	if _G.__DEV__ then
		element._store.validated = true
	end
	return element
end

local function validate(list)
	if _G.__DEV__ then
		for _, element in list do
			validateElement(element)
		end
	end
	return list
end

-- ROBLOX deviation START: inline simplified PropTypes logic
local function propTypes(value, expectedType, isRequired)
	if not isRequired and value == nil then
		return nil
	end
	if type(value) ~= expectedType then
		return Error("expected " .. expectedType)
	end
	return nil
end
local PropTypes = {
	string = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "string")
	end,
	string_isRequired = function(props, typeSpecName)
		return propTypes(props[typeSpecName], "string", true)
	end,
}
-- ROBLOX deviation END

it("should call all of the legacy lifecycle hooks", function()
	local logs = {}
	local logger = function(message)
		return function()
			table.insert(logs, message)
			return true
		end
	end

	local SomeComponent = React.Component:extend("SomeComponent")
	SomeComponent.UNSAFE_componentWillMount = logger("componentWillMount")
	SomeComponent.componentDidMount = logger("componentDidMount")
	SomeComponent.UNSAFE_componentWillReceiveProps = logger("componentWillReceiveProps")
	SomeComponent.shouldComponentUpdate = logger("shouldComponentUpdate")
	SomeComponent.UNSAFE_componentWillUpdate = logger("componentWillUpdate")
	SomeComponent.componentDidUpdate = logger("componentDidUpdate")
	SomeComponent.componentWillUnmount = logger("componentWillUnmount")
	function SomeComponent:render()
		return React.createElement("Frame")
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SomeComponent, {
		foo = 1,
	}))

	-- Calling cDU might lead to problems with host component references.
	-- Since our components aren't really mounted, refs won't be available.
	jestExpect(logs).toEqual({ "componentWillMount" })

	Array.splice(logs, 1)

	local instance = shallowRenderer:getMountedInstance()
	instance:setState({})

	jestExpect(logs).toEqual({ "shouldComponentUpdate", "componentWillUpdate" })

	Array.splice(logs, 1)

	shallowRenderer:render(React.createElement(SomeComponent, {
		foo = 2,
	}))

	-- The previous shallow renderer did not trigger cDU for props changes.
	jestExpect(logs).toEqual({
		"componentWillReceiveProps",
		"shouldComponentUpdate",
		"componentWillUpdate",
	})
end)

it("should call all of the new lifecycle hooks", function()
	local logs = {}
	local logger = function(message)
		return function()
			table.insert(logs, message)
			return true
		end
	end

	local SomeComponent = React.Component:extend("SomeComponent")
	SomeComponent.getDerivedStateFromProps = logger("getDerivedStateFromProps")
	SomeComponent.componentDidMount = logger("componentDidMount")
	SomeComponent.shouldComponentUpdate = logger("shouldComponentUpdate")
	SomeComponent.componentDidUpdate = logger("componentDidUpdate")
	SomeComponent.componentWillUnmount = logger("componentWillUnmount")
	function SomeComponent:init()
		self.state = {}
	end
	function SomeComponent:render()
		return React.createElement("Frame")
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SomeComponent, {
		foo = 1,
	}))

	-- Calling cDU might lead to problems with host component references.
	-- Since our components aren't really mounted, refs won't be available.
	jestExpect(logs).toEqual({ "getDerivedStateFromProps" })

	Array.splice(logs, 1)

	local instance = shallowRenderer:getMountedInstance()
	instance:setState({})

	jestExpect(logs).toEqual({ "getDerivedStateFromProps", "shouldComponentUpdate" })

	Array.splice(logs, 1)

	shallowRenderer:render(React.createElement(SomeComponent, {
		foo = 2,
	}))

	-- The previous shallow renderer did not trigger cDU for props changes.
	jestExpect(logs).toEqual({ "getDerivedStateFromProps", "shouldComponentUpdate" })
end)

it(
	"should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present",
	function()
		local Component = React.Component:extend("Component")
		function Component:init()
			self.state = {}
		end
		function Component.getDerivedStateFromProps()
			return nil
		end
		function Component:componentWillMount()
			error(Error("unexpected"))
		end
		function Component:componentWillReceiveProps()
			error(Error("unexpected"))
		end
		function Component:componentWillUpdate()
			error(Error("unexpected"))
		end
		function Component:render()
			return nil
		end

		local shallowRenderer = createRenderer()
		jestExpect(function()
			shallowRenderer:render(React.createElement(Component))
		end).never.toThrow()
	end
)

it(
	"should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present",
	function()
		local Component = React.Component:extend("Component")
		function Component:getSnapshotBeforeUpdate()
			return nil
		end
		function Component:componentWillMount()
			error(Error("unexpected"))
		end
		function Component:componentWillReceiveProps()
			error(Error("unexpected"))
		end
		function Component:componentWillUpdate()
			error(Error("unexpected"))
		end
		function Component:render()
			return nil
		end

		local shallowRenderer = createRenderer()
		jestExpect(function()
			shallowRenderer:render(React.createElement(Component, { value = 1 }))
		end).never.toThrow()
		jestExpect(function()
			shallowRenderer:render(React.createElement(Component, { value = 2 }))
		end).never.toThrow()
	end
)

it(
	"should not call getSnapshotBeforeUpdate or componentDidUpdate when updating since refs wont exist",
	function()
		local Component = React.Component:extend("Component")
		function Component:getSnapshotBeforeUpdate()
			error(Error("unexpected"))
		end
		function Component:componentDidUpdate()
			error(Error("unexpected"))
		end
		function Component:render()
			return nil
		end

		local shallowRenderer = createRenderer()
		jestExpect(function()
			shallowRenderer:render(React.createElement(Component, { value = 1 }))
		end).never.toThrow()
		jestExpect(function()
			shallowRenderer:render(React.createElement(Component, { value = 2 }))
		end).never.toThrow()
	end
)

it("should only render 1 level deep", function()
	local function Child()
		error(Error("This component should not render"))
	end

	local function Parent()
		return React.createElement("Frame", nil, {
			Child = React.createElement(Child),
		})
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Parent))
end)

it("should have shallow rendering", function()
	local SomeComponent = React.Component:extend("Component")
	function SomeComponent:render()
		return React.createElement(
			"Frame",
			nil,
			React.createElement("TextLabel", { Text = "child1" }),
			React.createElement("TextLabel", { Text = "child2" })
		)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SomeComponent))

	jestExpect(result.type).toEqual("Frame")
	jestExpect(result.props.children).toEqual(validate({
		React.createElement("TextLabel", { Text = "child1" }),
		React.createElement("TextLabel", { Text = "child2" }),
	}))
end)

it("should handle ForwardRef", function()
	local testRef = React.createRef()
	local SomeComponent = React.forwardRef(function(props, ref)
		jestExpect(ref).toEqual(testRef)
		return React.createElement(
			"Frame",
			nil,
			React.createElement("TextLabel", { Text = "child1" }),
			React.createElement("TextLabel", { Text = "child2" })
		)
	end)

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SomeComponent, {
		ref = testRef,
	}))

	jestExpect(result.type).toEqual("Frame")
	jestExpect(result.props.children).toEqual(validate({
		React.createElement("TextLabel", { Text = "child1" }),
		React.createElement("TextLabel", { Text = "child2" }),
	}))
end)

it("should handle Profiler", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:render()
		return React.createElement(
			React.Profiler,
			{ id = "test", onRender = function() end },
			React.createElement(
				"Text",
				nil,
				React.createElement("Frame", { className = "child1" }),
				React.createElement("Frame", { className = "child2" })
			)
		)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SomeComponent))

	jestExpect(result.type).toEqual(React.Profiler)
	jestExpect(result.props.children).toEqual(
		validateElement(
			React.createElement(
				"Text",
				nil,
				React.createElement("Frame", { className = "child1" }),
				React.createElement("Frame", { className = "child2" })
			)
		)
	)
end)

it("should enable shouldComponentUpdate to prevent a re-render", function()
	local renderCounter = 0
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { update = false }
	end
	function SimpleComponent:shouldComponentUpdate(nextProps, nextState)
		return self.state.update ~= nextState.update
	end
	function SimpleComponent:render()
		renderCounter += 1
		return React.createElement("TextLabel", { Text = renderCounter })
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	local instance = shallowRenderer:getMountedInstance()
	instance:setState({ update = false })
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	instance:setState({ update = true })
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 2 })
	)
end)

it("should enable PureComponent to prevent a re-render", function()
	local renderCounter = 0
	local SimpleComponent = React.PureComponent:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { update = false }
	end
	function SimpleComponent:render()
		renderCounter += 1
		return React.createElement("TextLabel", { Text = renderCounter })
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	local instance = shallowRenderer:getMountedInstance()
	instance:setState({ update = false })
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	instance:setState({ update = true })
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 2 })
	)
end)

it("should not run shouldComponentUpdate during forced update", function()
	local scuCounter = 0
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { count = 1 }
	end
	function SimpleComponent:shouldComponentUpdate()
		scuCounter += 1
		return false
	end
	function SimpleComponent:render()
		return React.createElement("TextLabel", { Text = self.state.count })
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(scuCounter).toEqual(0)
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	-- Force update the initial state. sCU should not fire.
	local instance = shallowRenderer:getMountedInstance()
	instance:forceUpdate()
	jestExpect(scuCounter).toEqual(0)
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	-- Setting state updates the instance, but doesn't re-render
	-- because sCU returned false.
	instance:setState(function(state)
		return { count = state.count + 1 }
	end)
	jestExpect(scuCounter).toEqual(1)
	jestExpect(instance.state.count).toEqual(2)
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 1 })
	)

	-- A force update updates the render output, but doesn't call sCU.
	instance:forceUpdate()
	jestExpect(scuCounter).toEqual(1)
	jestExpect(instance.state.count).toEqual(2)
	jestExpect(shallowRenderer:getRenderOutput()).toEqual(
		React.createElement("TextLabel", { Text = 2 })
	)
end)

it("should rerender when calling forceUpdate", function()
	local renderCounter = 0
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:render()
		renderCounter += 1
		return React.createElement("TextLabel")
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(renderCounter).toEqual(1)

	local instance = shallowRenderer:getMountedInstance()
	instance:forceUpdate()
	jestExpect(renderCounter).toEqual(2)
end)

it("should shallow render a function component", function()
	local SomeComponent = function(props, context)
		return (
			React.createElement("Frame", nil, {
				ChildFoo = React.createElement("TextLabel", { Text = props.foo }),
				ChildBar = React.createElement("TextLabel", { Text = context.bar }),
				Child1 = React.createElement("Frame", { Value = "child1" }),
				Child2 = React.createElement("Frame", { Value = "child2" }),
			})
		)
	end
	-- ROBLOX deviation: we don't support contextTypes on function components
	--     SomeComponent.contextTypes = {
	--       bar = PropTypes.string
	--     }

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(
		React.createElement(SomeComponent, { foo = "FOO" }),
		{ bar = "BAR" }
	)

	jestExpect(result.type).toEqual("Frame")
	jestExpect(result.props.children).toEqual(validate({
		ChildFoo = React.createElement("TextLabel", { Text = "FOO" }),
		ChildBar = React.createElement("TextLabel", { Text = "BAR" }),
		Child1 = React.createElement("Frame", { Value = "child1" }),
		Child2 = React.createElement("Frame", { Value = "child2" }),
	}))
end)

it("should shallow render a component returning strings directly from render", function()
	local Text = function(props)
		return props.value
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(Text, { value = "foo" }))
	jestExpect(result).toEqual("foo")
end)

it("should shallow render a component returning numbers directly from render", function()
	local Text = function(props)
		return props.value
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(Text, { value = 10 }))
	jestExpect(result).toEqual(10)
end)

it("should shallow render a fragment", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:render()
		return React.createElement("TextLabel")
	end

	local Fragment = React.Component:extend("Fragment")
	function Fragment:render()
		return {
			ChildA = React.createElement("TextLabel", { Text = "a" }),
			ChildB = React.createElement("Frame", { Value = "b" }),
			ChildC = React.createElement(SomeComponent),
		}
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(Fragment))
	jestExpect(result.ChildA).toEqual(React.createElement("TextLabel", { Text = "a" }))
	jestExpect(result.ChildB).toEqual(React.createElement("Frame", { Value = "b" }))
	jestExpect(result.ChildC).toEqual(React.createElement(SomeComponent))
	jestExpect(result).toEqual({
		ChildC = React.createElement(SomeComponent),
		ChildA = React.createElement("TextLabel", { Text = "a" }),
		ChildB = React.createElement("Frame", { Value = "b" }),
	})
end)

it("should shallow render a React.Fragment", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:render()
		return React.createElement("TextLabel")
	end

	local Fragment = React.Component:extend("Fragment")
	function Fragment:render()
		return React.createElement(
			React.Fragment,
			nil,
			React.createElement("Text"),
			React.createElement("Frame"),
			React.createElement(SomeComponent)
		)
	end
	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(Fragment))
	jestExpect(result.type).toEqual(React.Fragment)

	jestExpect(#result.props.children).toEqual(3)
	jestExpect(result.props.children[1]).toEqual(
		validateElement(React.createElement("Text"))
	)
	jestExpect(result.props.children[2]).toEqual(
		validateElement(React.createElement("Frame"))
	)
	React.createElement(
		React.Fragment,
		nil,
		React.createElement("Text"),
		React.createElement("Frame"),
		React.createElement(SomeComponent)
	)
end)

it("should throw for invalid elements", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:render()
		return React.createElement("TextLabel")
	end

	local shallowRenderer = createRenderer()
	jestExpect(function()
		shallowRenderer:render(SomeComponent)
	end).toThrow(
		"ReactShallowRenderer render(): Invalid component element. Instead of "
			.. "passing a component class, make sure to instantiate it by passing it "
			.. "to React.createElement."
	)
	jestExpect(function()
		shallowRenderer:render(React.createElement("div"))
	end).toThrow(
		"ReactShallowRenderer render(): Shallow rendering works only with "
			.. "custom components, not primitives (div). Instead of calling "
			.. "`.render(el)` and inspecting the rendered output, look at `el.props` "
			.. "directly instead."
	)
end)

it("should have shallow unmounting", function()
	local willUnmountWasCalled = false
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:componentWillUnmount()
		willUnmountWasCalled = true
	end

	function SomeComponent:render()
		return React.createElement("TextLabel")
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SomeComponent))
	shallowRenderer:unmount()

	jestExpect(willUnmountWasCalled).toEqual(true)
end)

it("can shallow render to nil", function()
	local SomeComponent = React.Component:extend("Component")
	function SomeComponent:render()
		return nil
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SomeComponent))

	jestExpect(result).toEqual(nil)
end)

it("can shallow render with a ref", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:render()
		return React.createElement("TestLabel", { ref = "hello" })
	end

	local shallowRenderer = createRenderer()
	-- Shouldn't crash.
	jestExpect(function()
		shallowRenderer:render(React.createElement(SomeComponent))
	end).never.toThrow()
end)

it("lets you update shallowly rendered components", function()
	local SomeComponent = React.Component:extend("SomeComponent")
	function SomeComponent:init()
		self.state = { clicked = false }
	end

	function SomeComponent:onClick()
		self:setState({ clicked = true })
	end

	function SomeComponent:render()
		local className
		if self.state.clicked then
			className = "was-clicked"
		else
			className = ""
		end

		if self.props.aNew == "prop" then
			return React.createElement("Button", {
				onClick = function()
					self:onClick()
				end,
				className = className,
			})
		else
			return React.createElement(
				"TextLabel",
				nil,
				React.createElement("Frame", { className = "child1" }),
				React.createElement("Frame", { className = "child2" })
			)
		end
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SomeComponent))
	jestExpect(result.type).toEqual("TextLabel")
	jestExpect(result.props.children).toEqual(validate({
		React.createElement("Frame", { className = "child1" }),
		React.createElement("Frame", { className = "child2" }),
	}))

	local updatedResult =
		shallowRenderer:render(React.createElement(SomeComponent, { aNew = "prop" }))
	jestExpect(updatedResult.type).toEqual("Button")

	updatedResult.props:onClick()

	local updatedResultCausedByClick = shallowRenderer:getRenderOutput()
	jestExpect(updatedResultCausedByClick.type).toEqual("Button")
	jestExpect(updatedResultCausedByClick.props.className).toEqual("was-clicked")
end)

it("can access the mounted component instance", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:someMethod()
		return self.props.n
	end

	function SimpleComponent:render()
		return React.createElement("TextLabel", { Text = self.props.n })
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent, { n = 5 }))
	jestExpect(shallowRenderer:getMountedInstance():someMethod()).toEqual(5)
end)

it("can shallowly render components with contextTypes", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	SimpleComponent.contextTypes = {
		name = PropTypes.string,
	}

	function SimpleComponent:render()
		return React.createElement("TextLabel")
	end

	local shallowRenderer = createRenderer()
	-- ROBLOX Test Noise: jest setup config makes this hide error
	-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result).toEqual(React.createElement("TextLabel"))
end)

it("passes expected params to legacy component lifecycle methods", function()
	local componentDidUpdateParams = {}
	local componentWillReceivePropsParams = {}
	local componentWillUpdateParams = {}
	local setStateParams = {}
	local shouldComponentUpdateParams = {}

	local initialProp = { prop = "init prop" }
	local initialState = { state = "init state" }
	local initialContext = { context = "init context" }
	local updatedState = { state = "updated state" }
	local updatedProp = { prop = "updated prop" }
	local updatedContext = { context = "updated context" }

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init(props, context)
		self.state = initialState
	end

	SimpleComponent.contextTypes = {
		context = PropTypes.string,
	}

	function SimpleComponent:componentDidUpdate(...)
		table.insert(componentDidUpdateParams, { ... })
	end
	function SimpleComponent:UNSAFE_componentWillReceiveProps(...)
		table.insert(componentWillReceivePropsParams, { ... })
		self:setState(function(...)
			table.insert(setStateParams, { ... })
			return updatedState
		end)
	end
	function SimpleComponent:UNSAFE_componentWillUpdate(...)
		table.insert(componentWillUpdateParams, { ... })
	end
	function SimpleComponent:shouldComponentUpdate(...)
		table.insert(shouldComponentUpdateParams, { ... })
		return true
	end
	function SimpleComponent:render()
		return nil
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(
		React.createElement(SimpleComponent, initialProp),
		initialContext
	)
	jestExpect(componentDidUpdateParams).toEqual({})
	jestExpect(componentWillReceivePropsParams).toEqual({})
	jestExpect(componentWillUpdateParams).toEqual({})
	jestExpect(setStateParams).toEqual({})
	jestExpect(shouldComponentUpdateParams).toEqual({})

	-- Lifecycle hooks should be invoked with the correct prev/next params on update.
	-- ROBLOX Test Noise: jest setup config makes this hide error
	-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
	shallowRenderer:render(
		React.createElement(SimpleComponent, updatedProp),
		updatedContext
	)

	jestExpect(componentWillReceivePropsParams).toEqual({
		{ updatedProp, updatedContext },
	})
	jestExpect(setStateParams).toEqual({
		{ initialState, initialProp },
	})
	jestExpect(shouldComponentUpdateParams).toEqual({
		{ updatedProp, updatedState, updatedContext },
	})
	jestExpect(componentWillUpdateParams).toEqual({
		{ updatedProp, updatedState, updatedContext },
	})
	jestExpect(componentDidUpdateParams).toEqual({})
end)

it("passes expected params to new component lifecycle methods", function()
	local componentDidUpdateParams = {}
	local getDerivedStateFromPropsParams = {}
	local shouldComponentUpdateParams = {}

	local initialProp = { prop = "init prop" }
	local initialState = { state = "init state" }
	local initialContext = { context = "init context" }
	local updatedProp = { prop = "updated prop" }
	local updatedContext = { context = "updated context" }

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init(props, context)
		self.state = initialState
	end

	SimpleComponent.contextTypes = {
		context = PropTypes.string,
	}

	function SimpleComponent:componentDidUpdate(...)
		table.insert(componentDidUpdateParams, { ... })
	end

	function SimpleComponent.getDerivedStateFromProps(...)
		table.insert(getDerivedStateFromPropsParams, { ... })
		return nil
	end

	function SimpleComponent:shouldComponentUpdate(...)
		table.insert(shouldComponentUpdateParams, { ... })
		return true
	end

	function SimpleComponent:render()
		return nil
	end

	local shallowRenderer = createRenderer()

	-- The only lifecycle hook that should be invoked on initial render
	-- Is the static getDerivedStateFromProps() methods
	shallowRenderer:render(
		React.createElement(SimpleComponent, initialProp),
		initialContext
	)
	jestExpect(getDerivedStateFromPropsParams).toEqual({
		{
			initialProp,
			initialState,
		},
	})
	jestExpect(componentDidUpdateParams).toEqual({})
	jestExpect(shouldComponentUpdateParams).toEqual({})

	-- Lifecycle hooks should be invoked with the correct prev/next params on update.
	shallowRenderer:render(
		React.createElement(SimpleComponent, updatedProp),
		updatedContext
	)

	jestExpect(getDerivedStateFromPropsParams).toEqual({
		{ initialProp, initialState },
		{ updatedProp, initialState },
	})
	jestExpect(shouldComponentUpdateParams).toEqual({
		{
			updatedProp,
			initialState,
			updatedContext,
		},
	})
	jestExpect(componentDidUpdateParams).toEqual({})
end)

it("can shallowly render components with ref as function", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { clicked = false }
	end

	function SimpleComponent:handleUserClick()
		self:setState({ clicked = true })
	end

	function SimpleComponent:render()
		local wasClicked
		if self.state.clicked then
			wasClicked = "clicked"
		else
			wasClicked = ""
		end

		return React.createElement(SimpleComponent, {
			ref = function() end,
			onClick = function()
				self:handleUserClick()
			end,
			className = wasClicked,
		})
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent))
	local result = shallowRenderer:getRenderOutput()
	-- jestExpect(result.type).toEqual('div')
	jestExpect(result.props.className).toEqual("")
	result.props.onClick()

	result = shallowRenderer:getRenderOutput()
	-- jestExpect(result.type).toEqual('div')
	jestExpect(result.props.className).toEqual("clicked")
end)

it("can initialize state via static getDerivedStateFromProps", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = {
			count = 1,
		}
	end

	function SimpleComponent.getDerivedStateFromProps(props, prevState)
		return {
			count = prevState.count + props.incrementBy,
			other = "foobar",
		}
	end

	function SimpleComponent:render()
		return React.createElement(
			"TextLabel",
			nil,
			"count:" .. self.state.count .. ", other:" .. self.state.other
		)
	end

	local shallowRenderer = createRenderer()
	local result =
		shallowRenderer:render(React.createElement(SimpleComponent, { incrementBy = 2 }))
	jestExpect(result).toEqual(
		React.createElement("TextLabel", nil, "count:3, other:foobar")
	)
end)

it("can setState in componentWillMount when shallow rendering", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:UNSAFE_componentWillMount()
		self:setState({ groovy = "doovy" })
	end

	function SimpleComponent:render()
		return React.createElement("TextLabel", { Text = self.state.groovy })
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result).toEqual(React.createElement("TextLabel", { Text = "doovy" }))
end)

it("can setState in componentWillMount repeatedly when shallow rendering", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { separator = "-" }
	end

	function SimpleComponent:UNSAFE_componentWillMount()
		self:setState({ groovy = "doovy" })
		self:setState({ doovy = "groovy" })
	end

	function SimpleComponent:render()
		local groovy = self.state.groovy
		local doovy = self.state.doovy
		local separator = self.state.separator

		return React.createElement("TextLabel", { Text = groovy .. separator .. doovy })
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result).toEqual(
		React.createElement("TextLabel", { Text = "doovy-groovy" })
	)
end)

it(
	"can setState in componentWillMount with an updater function repeatedly when shallow rendering",
	function()
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init()
			self.state = { separator = "-" }
		end

		function SimpleComponent:UNSAFE_componentWillMount()
			self:setState(function(state)
				return { groovy = "doovy" }
			end)
			self:setState(function(state)
				return { doovy = state.groovy }
			end)
		end

		function SimpleComponent:render()
			local groovy = self.state.groovy
			local doovy = self.state.doovy
			local separator = self.state.separator

			return React.createElement("TextLabel", nil, { groovy .. separator .. doovy })
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(React.createElement(SimpleComponent))
		jestExpect(result.props.children[1]).toEqual("doovy-doovy")
	end
)

it("can setState in componentWillReceiveProps when shallow rendering", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { count = 0 }
	end

	function SimpleComponent:UNSAFE_componentWillReceiveProps(nextProps)
		if nextProps.updateState then
			self:setState({ count = 1 })
		end
	end

	function SimpleComponent:render()
		return React.createElement("TextLabel", nil, self.state.count)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(
		React.createElement(SimpleComponent, { updateState = false })
	)

	jestExpect(result.props.children).toEqual(0)

	result = shallowRenderer:render(
		React.createElement(SimpleComponent, { updateState = true })
	)

	jestExpect(result.props.children).toEqual(1)
end)

it(
	"can update state with static getDerivedStateFromProps when shallow rendering",
	function()
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init()
			self.state = { count = 1 }
		end

		function SimpleComponent.getDerivedStateFromProps(nextProps, prevState)
			if nextProps.updateState then
				return { count = nextProps.incrementBy + prevState.count }
			end

			return nil
		end

		function SimpleComponent:render()
			return React.createElement("TextLabel", nil, self.state.count)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SimpleComponent, { updateState = false, incrementBy = 0 })
		)

		jestExpect(result.props.children).toEqual(1)

		result = shallowRenderer:render(
			React.createElement(SimpleComponent, { updateState = true, incrementBy = 2 })
		)
		jestExpect(result.props.children).toEqual(3)

		result = shallowRenderer:render(
			React.createElement(SimpleComponent, { updateState = false, incrementBy = 2 })
		)

		jestExpect(result.props.children).toEqual(3)
	end
)

it(
	"should not override state with stale values if prevState is spread within getDerivedStateFromProps",
	function()
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init()
			self.state = { value = 0 }
		end

		function SimpleComponent.getDerivedStateFromProps(nextProps, prevState)
			return { table.unpack(prevState) }
		end

		function SimpleComponent:updateState()
			self:setState(function(state)
				return { value = state.value + 1 }
			end)
		end

		function SimpleComponent:render()
			return React.createElement("TextLabel", nil, "value:" .. self.state.value)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(React.createElement(SimpleComponent))
		jestExpect(result).toEqual(React.createElement("TextLabel", nil, "value:0"))

		local instance = shallowRenderer:getMountedInstance()
		instance:updateState()
		result = shallowRenderer:getRenderOutput()
		jestExpect(result).toEqual(React.createElement("TextLabel", nil, "value:1"))
	end
)

it(
	"should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps",
	function()
		local SimpleComponent = React.Component:extend("SimpleComponent")
		function SimpleComponent:init()
			self.state = {
				value = self.props.value,
			}
		end

		function SimpleComponent.getDerivedStateFromProps(nextProps, prevState)
			if nextProps.value == prevState.value then
				return nil
			end

			return { value = nextProps.value }
		end

		function SimpleComponent:shouldComponentUpdate(nextProps, nextState)
			return nextState.value ~= self.state.value
		end

		function SimpleComponent:render()
			return React.createElement(
				"TextLabel",
				{ Text = "value:" .. self.state.value }
			)
		end

		local shallowRenderer = createRenderer()
		local initialResult = shallowRenderer:render(
			React.createElement(SimpleComponent, { value = "initial" })
		)
		jestExpect(initialResult).toEqual(
			React.createElement("TextLabel", { Text = "value:initial" })
		)
		local updatedResult = shallowRenderer:render(
			React.createElement(SimpleComponent, { value = "updated" })
		)
		jestExpect(updatedResult).toEqual(
			React.createElement("TextLabel", { Text = "value:updated" })
		)
	end
)

it("can setState with an updater function", function()
	local instance

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = {
			counter = 0,
		}
	end

	function SimpleComponent:render()
		instance = self
		return (React.createElement("Button", nil, self.state.counter))
	end

	local shallowRenderer = createRenderer()
	local result =
		shallowRenderer:render(React.createElement(SimpleComponent, { defaultCount = 1 }))
	jestExpect(result.props.children).toEqual(0)

	instance:setState(function(state, props)
		return { counter = instance.props.defaultCount + 1 }
	end)

	result = shallowRenderer:getRenderOutput()
	jestExpect(result.props.children).toEqual(2)
end)

-- ROBLOX deviation: Lua doesn't have a good way to bind to the correct closure for this pattern
-- it's okay, since it doesn't work in leacy Roact and should be okay with the useState() hook
it.skip("can access component instance from setState updater function", function()
	local instance

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = { something = "here" }
	end
	function SimpleComponent:render()
		instance = self
		return nil
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SimpleComponent, { myProp = 31337 }))

	local updaterWasCalled = false
	instance:setState(function(state, props)
		-- ROBLOX deviation: we deviate here. legacy Roact doesn't support this, and is moot with useState() hook
		-- jestExpect(self).toEqual(instance)
		jestExpect(state).toEqual({ something = "here" })
		jestExpect(props).toEqual({ myProp = 31337 })
		updaterWasCalled = true
	end)
	jestExpect(updaterWasCalled).toEqual(true)
end)

it("can setState with a callback", function()
	local instance

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = {
			counter = 0,
		}
	end
	function SimpleComponent:render()
		instance = self
		return React.createElement("Text", nil, self.state.counter)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result.props.children).toEqual(0)

	local callbackHasBeenCalled = false
	local callback = function(self)
		callbackHasBeenCalled = true
		jestExpect(self).toEqual(instance)
	end

	instance:setState({ counter = 1 }, callback)

	local updated = shallowRenderer:getRenderOutput()
	jestExpect(updated.props.children).toEqual(1)
	jestExpect(callbackHasBeenCalled).toEqual(true)
end)

it("can replaceState with a callback", function()
	local instance

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = {
			counter = 0,
		}
	end
	function SimpleComponent:render()
		instance = self
		return React.createElement("Text", nil, self.state.counter)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result.props.children).toEqual(0)

	local callbackHasBeenCalled = false
	local callback = function(self)
		callbackHasBeenCalled = true
		jestExpect(self).toEqual(instance)
	end

	-- No longer a public API, but we can test that it works internally by
	-- reaching into the updater.
	shallowRenderer._updater.enqueueReplaceState(instance, { counter = 1 }, callback)

	local updated = shallowRenderer:getRenderOutput()
	jestExpect(updated.props.children).toEqual(1)
	jestExpect(callbackHasBeenCalled).toEqual(true)
end)

it("can forceUpdate with a callback", function()
	local instance

	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init()
		self.state = {
			counter = 0,
		}
	end
	function SimpleComponent:render()
		instance = self
		return React.createElement("Text", nil, self.state.counter)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent))
	jestExpect(result.props.children).toEqual(0)

	local callbackHasBeenCalled = false
	local callback = function(self)
		callbackHasBeenCalled = true
		jestExpect(self).toEqual(instance)
	end

	instance:forceUpdate(callback)

	local updated = shallowRenderer:getRenderOutput()
	jestExpect(updated.props.children).toEqual(0)
	jestExpect(callbackHasBeenCalled).toEqual(true)
end)

it("can pass context when shallowly rendering", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	SimpleComponent.contextTypes = {
		name = PropTypes.string,
	}

	function SimpleComponent:render()
		return React.createElement("Text", nil, self.context.name)
	end

	local shallowRenderer = createRenderer()
	-- ROBLOX Test Noise: jest setup config makes this hide error
	-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
	local result = shallowRenderer:render(React.createElement(SimpleComponent), {
		name = "foo",
	})
	jestExpect(result).toEqual(React.createElement("Text", nil, "foo"))
end)

it("should track context across updates", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	SimpleComponent.contextTypes = {
		foo = PropTypes.string,
	}

	function SimpleComponent:init()
		self.state = {
			bar = "bar",
		}
	end

	function SimpleComponent:render()
		return React.createElement("Text", nil, self.context.foo .. ":" .. self.state.bar)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent), {
		foo = "foo",
	})
	jestExpect(result.props.children).toEqual("foo:bar")

	local instance = shallowRenderer:getMountedInstance()
	instance:setState({ bar = "baz" })

	result = shallowRenderer:getRenderOutput()
	jestExpect(result.props.children).toEqual("foo:baz")
end)

it("should filter context by contextTypes", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	SimpleComponent.contextTypes = {
		foo = PropTypes.string,
	}
	function SimpleComponent:render()
		return React.createElement(
			"Text",
			nil,
			self.context.foo .. ":" .. tostring(self.context.bar)
		)
	end

	local shallowRenderer = createRenderer()
	local result = shallowRenderer:render(React.createElement(SimpleComponent), {
		foo = "foo",
		bar = "bar",
	})
	jestExpect(result.props.children).toEqual("foo:nil")
end)

-- ROBLOX TODO: we'll need prop-types ported for this to pass
it.skip("can fail context when shallowly rendering", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	SimpleComponent.contextTypes = {
		-- ROBLOX deviation: using simplified inline PropTypes
		name = PropTypes.string_isRequired,
	}

	function SimpleComponent:render()
		return React.createElement("Text", nil, self.context.name)
	end

	local shallowRenderer = createRenderer()
	jestExpect(function()
		shallowRenderer:render(React.createElement(SimpleComponent))
	end).toThrow(
		"Warning: Failed context type: The context `name` is marked as "
			.. "required in `SimpleComponent`, but its value is `undefined`.\n"
			.. "    in SimpleComponent (at **)"
	)
end)

-- ROBLOX TODO: we'll need prop-types ported for this to pass
it.skip("should warn about propTypes (but only once)", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:render()
		return React.createElement("Text", nil, self.props.name)
	end

	SimpleComponent.propTypes = {
		-- ROBLOX deviation: using simplified inline PropTypes
		name = PropTypes.string_isRequired,
	}

	local shallowRenderer = createRenderer()
	jestExpect(function()
		shallowRenderer:render(React.createElement(SimpleComponent, { name = 123 }))
	end).toThrow()
	-- ROBLOX TODO: port toErrorDev to jest-roblox matchers
	-- ).toErrorDev(
	--   'Warning: Failed prop type: Invalid prop `name` of type `number` ' +
	--     'supplied to `SimpleComponent`, expected `string`.\n' +
	--     '    in SimpleComponent',
	-- )
end)

it("should enable rendering of cloned element", function()
	local SimpleComponent = React.Component:extend("SimpleComponent")
	function SimpleComponent:init(props)
		self.state = {
			bar = "bar",
		}
	end

	function SimpleComponent:render()
		return React.createElement("Text", nil, self.props.foo .. ":" .. self.state.bar)
	end

	local shallowRenderer = createRenderer()
	local el = React.createElement(SimpleComponent, { foo = "foo" })
	local result = shallowRenderer:render(el)
	jestExpect(result.props.children).toEqual("foo:bar")

	local cloned = React.cloneElement(el, { foo = "baz" })
	result = shallowRenderer:render(cloned)
	jestExpect(result.props.children).toEqual("baz:bar")
end)

it(
	"self.state should be updated on setState callback inside componentWillMount",
	function()
		local stateSuccessfullyUpdated = false

		local MyComponent = React.Component:extend("Component")
		function MyComponent:init(props, context)
			self.state = {
				hasUpdatedState = false,
			}
		end

		function MyComponent:UNSAFE_componentWillMount()
			self:setState({ hasUpdatedState = true }, function()
				stateSuccessfullyUpdated = self.state.hasUpdatedState
			end)
		end

		function MyComponent:render()
			return React.createElement("Text", nil, self.props.children)
		end

		local shallowRenderer = createRenderer()
		shallowRenderer:render(React.createElement(MyComponent))
		jestExpect(stateSuccessfullyUpdated).toEqual(true)
	end
)

it("should handle multiple callbacks", function()
	local mockCalledTimes = 0
	local mockFn = function()
		mockCalledTimes += 1
	end
	local shallowRenderer = createRenderer()

	local Component = React.Component:extend("Component")
	function Component:init(props, context)
		self.state = {
			foo = "foo",
		}
	end

	function Component:UNSAFE_componentWillMount()
		self:setState({ foo = "bar" }, mockFn)
		self:setState({ foo = "foobar" }, mockFn)
	end

	function Component:render()
		return React.createElement("Text", nil, self.state.foo)
	end

	shallowRenderer:render(React.createElement(Component))

	jestExpect(mockCalledTimes).toEqual(2)

	-- Ensure the callback queue is cleared after the callbacks are invoked
	local mountedInstance = shallowRenderer:getMountedInstance()
	mountedInstance:setState({ foo = "bar" }, function()
		mockFn()
	end)
	jestExpect(mockCalledTimes).toEqual(3)
end)

it("should call the setState callback even if shouldComponentUpdate = false", function()
	local mockCalledTimes = 0
	local mockFn = function()
		mockCalledTimes += 1
		return false
	end

	local Component = React.Component:extend("Component")
	function Component:init(props, context)
		self.state = {
			hasUpdatedState = false,
		}
	end

	function Component:shouldComponentUpdate()
		return mockFn()
	end

	function Component:render()
		return React.createElement("Text", nil, self.state.hasUpdatedState)
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Component))

	local callbackWasCalled = false
	local mountedInstance = shallowRenderer:getMountedInstance()
	mountedInstance:setState({ hasUpdatedState = true }, function()
		jestExpect(mockCalledTimes).toEqual(1)
		jestExpect(mountedInstance.state.hasUpdatedState).toEqual(true)
		callbackWasCalled = true
	end)
	jestExpect(callbackWasCalled).toEqual(true)
end)

it("throws usefully when rendering badly-typed elements", function()
	local shallowRenderer = createRenderer()

	local renderAndVerifyWarningAndError = function(Component, typeString)
		jestExpect(function()
			jestExpect(function()
				shallowRenderer:render(React.createElement(Component))
			end).toErrorDev(
				"React.createElement: type is invalid -- expected a string "
					.. "(for built-in components) or a class/function (for composite components) "
					.. "but got: "
					.. typeString
					.. "."
			)
		end).toThrow(
			"ReactShallowRenderer render(): Shallow rendering works only with custom "
				.. "components, but the provided element type was `"
				.. typeString
				.. "`."
		)
	end

	-- ROBLOX deviation: no undefined in Lua, only nil
	-- renderAndVerifyWarningAndError(undefined, 'undefined')
	renderAndVerifyWarningAndError(nil, "nil")
	renderAndVerifyWarningAndError({}, "array")
end)

-- ROBLOX DEVIATION: We initialize state to a singleton for compatibility
it("should have initial state of UninitializedState if not defined", function()
	local SomeComponent = React.Component:extend("Component")
	function SomeComponent:render()
		return React.createElement("Text")
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(SomeComponent))

	jestExpect(shallowRenderer:getMountedInstance().state).toBe(UninitializedState)
end)

it("should invoke both deprecated and new lifecycles if both are present", function()
	local logs = {}
	local logger = function(message)
		return function()
			table.insert(logs, message)
			return true
		end
	end

	local Component = React.Component:extend("Component")
	Component.componentWillMount = logger("componentWillMount")

	Component.componentWillReceiveProps = logger("componentWillReceiveProps")
	Component.componentWillUpdate = logger("componentWillUpdate")
	Component.UNSAFE_componentWillMount = logger("UNSAFE_componentWillMount")
	Component.UNSAFE_componentWillReceiveProps =
		logger("UNSAFE_componentWillReceiveProps")
	Component.UNSAFE_componentWillUpdate = logger("UNSAFE_componentWillUpdate")

	function Component:render()
		return React.createElement("Text")
	end

	local shallowRenderer = createRenderer()
	jestExpect(logs).toEqual({})
	shallowRenderer:render(React.createElement(Component, { foo = "bar" }))
	jestExpect(logs).toEqual({ "componentWillMount", "UNSAFE_componentWillMount" })

	Array.splice(logs, 1)

	shallowRenderer:render(React.createElement(Component, { foo = "baz" }))
	jestExpect(logs).toEqual({
		"componentWillReceiveProps",
		"UNSAFE_componentWillReceiveProps",
		"componentWillUpdate",
		"UNSAFE_componentWillUpdate",
	})
end)

it("should stop the update when setState returns nil or undefined", function()
	local logs = {}
	local instance
	local Component = React.Component:extend("Component")
	function Component:init(props)
		self.state = {
			count = 0,
		}
	end
	function Component:render()
		table.insert(logs, "render")
		instance = self
		return nil
	end
	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Component))
	Array.splice(logs, 1)
	instance:setState(function()
		return nil
	end)
	-- ROBLOX deviation: no undefined in Lua, no different than nil
	-- instance:setState(() => undefined)
	instance:setState(nil)
	-- ROBLOX deviation: no undefined in Lua, no different than nil
	-- instance:setState(undefined)
	jestExpect(logs).toEqual({})
	instance:setState(function(state)
		return { count = state.count + 1 }
	end)
	jestExpect(logs).toEqual({ "render" })
end)

it("should not get this in a function component", function()
	local logs = {}
	local self = nil
	local Foo = function()
		table.insert(logs, self)
		return React.createElement("Text", nil, "foo")
	end
	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Foo, { foo = "bar" }))
	jestExpect(logs).toEqual({ nil })
end)

it("should handle memo", function()
	local Foo = function()
		return React.createElement("Text")
	end
	local MemoFoo = React.memo(Foo)
	local shallowRenderer = createRenderer()
	local renderOutput = shallowRenderer:render(React.createElement(MemoFoo))
	jestExpect(renderOutput).toEqual(React.createElement("Text"))
end)

it("should enable React.memo to prevent a re-render", function()
	local logs = {}
	local Foo = React.memo(function(props)
		table.insert(logs, "Foo: " .. props.count)
		return React.createElement("Text", nil, props.count)
	end)
	local Bar = React.memo(function(props)
		table.insert(logs, "Bar: " .. props.count)
		return React.createElement("Text", nil, props.count)
	end)
	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Foo, { count = 1 }))
	jestExpect(logs).toEqual({ "Foo: 1" })
	Array.splice(logs, 1)
	-- Rendering the same element with the same props should be prevented
	shallowRenderer:render(React.createElement(Foo, { count = 1 }))
	jestExpect(logs).toEqual({})
	-- A different element with the same props should cause a re-render
	shallowRenderer:render(React.createElement(Bar, { count = 1 }))
	jestExpect(logs).toEqual({ "Bar: 1" })
end)

it("should respect a custom comparison function with React.memo", function()
	local renderCount = 0
	local areEqual = function(props, nextProps)
		return props.foo == nextProps.foo
	end
	local Foo = React.memo(function(props)
		renderCount += 1
		return React.createElement(
			"Text",
			nil,
			tostring(props.foo) .. tostring(props.bar)
		)
	end, areEqual)

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Foo, { foo = 1, bar = 1 }))
	jestExpect(renderCount).toEqual(1)
	-- Change a prop that the comparison funciton ignores
	shallowRenderer:render(React.createElement(Foo, { foo = 1, bar = 2 }))
	jestExpect(renderCount).toEqual(1)
	shallowRenderer:render(React.createElement(Foo, { foo = 2, bar = 2 }))
	jestExpect(renderCount).toEqual(2)
end)

it(
	"should not call the comparison function with React.memo on the initial render",
	function()
		local comparisonWasCalled = false
		local areEqual = function()
			comparisonWasCalled = true
			return false
		end
		local SomeComponent = React.memo(function(props)
			return React.createElement("Text", nil, props.foo)
		end, areEqual)
		local shallowRenderer = createRenderer()
		shallowRenderer:render(React.createElement(SomeComponent, { foo = 1 }))
		jestExpect(comparisonWasCalled).toEqual(false)
		jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual(1)
	end
)

it("should handle memo(forwardRef())", function()
	local testRef = React.createRef()
	local SomeComponent = React.forwardRef(function(props, ref)
		jestExpect(ref).toEqual(testRef)
		return React.createElement(
			"Frame",
			nil,
			React.createElement("Text", { className = "child1" }),
			React.createElement("Text", { className = "child2" })
		)
	end)

	local SomeMemoComponent = React.memo(SomeComponent)

	local shallowRenderer = createRenderer()
	local result =
		shallowRenderer:render(React.createElement(SomeMemoComponent, { ref = testRef }))

	jestExpect(result.type).toEqual("Frame")
	jestExpect(result.props.children).toEqual(validate({
		React.createElement("Text", { className = "child1" }),
		React.createElement("Text", { className = "child2" }),
	}))
end)

it("should warn for forwardRef(memo())", function()
	local testRef = React.createRef()
	local SomeMemoComponent = React.memo(function(props)
		return React.createElement("Text", nil, props.foo)
	end)
	local shallowRenderer = createRenderer()
	jestExpect(function()
		jestExpect(function()
			local SomeComponent = React.forwardRef(SomeMemoComponent)
			shallowRenderer:render(React.createElement(SomeComponent, { ref = testRef }))
		end).toErrorDev(
			"Warning: forwardRef requires a render function but received "
				.. "a `memo` component. Instead of forwardRef(memo(...)), use "
				.. "memo(forwardRef(...))",
			{ withoutStack = true }
		)
	end).toThrow(
		-- ROBLOX deviaton: we say table instead of object due to typeof
		"forwardRef requires a render function but was given table."
	)
end)

it("should let you change type", function()
	local Foo = function(props)
		return React.createElement("Text", nil, "Foo " .. props.prop)
	end
	local Bar = function(props)
		return React.createElement("Text", nil, "Bar " .. props.prop)
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Foo, { prop = "foo1" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Foo foo1")
	shallowRenderer:render(React.createElement(Foo, { prop = "foo2" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Foo foo2")
	shallowRenderer:render(React.createElement(Bar, { prop = "bar1" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Bar bar1")
	shallowRenderer:render(React.createElement(Bar, { prop = "bar2" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Bar bar2")
end)

it("should local you change class type", function()
	local Foo = React.Component:extend("Component")
	function Foo:render()
		return React.createElement("Text", nil, "Foo " .. self.props.prop)
	end

	local Bar = React.Component:extend("Component")
	function Bar:render()
		return React.createElement("Text", nil, "Bar " .. self.props.prop)
	end

	local shallowRenderer = createRenderer()
	shallowRenderer:render(React.createElement(Foo, { prop = "foo1" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Foo foo1")
	shallowRenderer:render(React.createElement(Foo, { prop = "foo2" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Foo foo2")
	shallowRenderer:render(React.createElement(Bar, { prop = "bar1" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Bar bar1")
	shallowRenderer:render(React.createElement(Bar, { prop = "bar2" }))
	jestExpect(shallowRenderer:getRenderOutput().props.children).toEqual("Bar bar2")
end) ]]
gE.Children._029dc78901903ffd2bde4ac7f8e1bacf=gF
local gG

local gH={ClassName="ModuleScript",Children={},Properties={}}
gH.Name="ReactShallowRendererHooks.spec"
gH.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local React
local ReactShallowRenderer

local createRenderer

beforeEach(function()
	React = require(Packages.React)
	ReactShallowRenderer = require(script.Parent.Parent)
	createRenderer = ReactShallowRenderer.createRenderer
end)

local function validateElement(element)
	if _G.__DEV__ then
		element._store.validated = true
	end
	return element
end

describe("ReactShallowRenderer with hooks", function()
	it("should work with useState", function()
		local function SomeComponent(props)
			local name = React.useState(props.defaultName)

			return React.createElement("TextLabel", {
				Text = "Your name is: " .. name,
			})
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(React.createElement(SomeComponent, {
			defaultName = "Dominic",
		}))

		jestExpect(result).toEqual(React.createElement("TextLabel", {
			Text = "Your name is: Dominic",
		}))

		result = shallowRenderer:render(React.createElement(SomeComponent, {
			defaultName = "Should not use this name",
		}))

		jestExpect(result).toEqual(React.createElement("TextLabel", {
			Text = "Your name is: Dominic",
		}))
	end)

	it("should work with updating a value from useState", function()
		local function SomeComponent(props)
			local name, updateName = React.useState(props.defaultName)

			if name ~= "Dan" then
				updateName("Dan")
			end

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. name,
				})
			)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SomeComponent, { defaultName = "Dominic" })
		)

		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. "Dan",
				})
			)
		)
	end)

	it("should work with updating a derived value from useState", function()
		local _updateName

		local function SomeComponent(props)
			local name, updateName = React.useState(props.defaultName)
			local prevName, updatePrevName = React.useState(props.defaultName)
			local letter, updateLetter = React.useState(string.sub(name, 1, 1))

			_updateName = updateName

			if name ~= prevName then
				updatePrevName(name)
				updateLetter(string.sub(name, 1, 1))
			end

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. name .. " (" .. tostring(letter) .. ")",
				})
			)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SomeComponent, { defaultName = "Sophie" })
		)

		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. "Sophie (S)",
				})
			)
		)

		result = shallowRenderer:render(
			React.createElement(SomeComponent, { defaultName = "Dan" })
		)
		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. "Sophie (S)",
				})
			)
		)

		_updateName("Dan")
		jestExpect(shallowRenderer:getRenderOutput()).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "Your name is: " .. "Dan (D)",
				})
			)
		)
	end)

	it("should work with useReducer", function()
		local function reducer(state, action)
			if action.type == "increment" then
				return { count = state.count + 1 }
			elseif action.type == "decrement" then
				return { count = state.count - 1 }
			else
				error("impossible")
			end
		end

		local function SomeComponent(props)
			local state = React.useReducer(reducer, props, function(p)
				return {
					count = p.initialCount,
				}
			end)

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					"The counter is at: " .. tostring(state.count),
				})
			)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SomeComponent, { initialCount = 0 })
		)
		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					"The counter is at: 0",
				})
			)
		)

		result = shallowRenderer:render(
			React.createElement(SomeComponent, { initialCount = 10 })
		)

		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					"The counter is at: 0",
				})
			)
		)
	end)

	it("should work with a dispatched state change for a useReducer", function()
		local function reducer(state, action)
			if action.type == "increment" then
				return { count = state.count + 1 }
			elseif action.type == "decrement" then
				return { count = state.count - 1 }
			else
				error("impossible")
			end
		end

		local function SomeComponent(props)
			local state, dispatch = React.useReducer(reducer, props, function(p)
				return {
					count = p.initialCount,
				}
			end)

			if state.count == 0 then
				dispatch({ type = "increment" })
			end
			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					"The counter is at: " .. tostring(state.count),
				})
			)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SomeComponent, { initialCount = 0 })
		)

		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					"The counter is at: 1",
				})
			)
		)
	end)

	it("should not trigger effects", function()
		local effectsCalled = {}

		local function SomeComponent(props)
			React.useEffect(function()
				table.insert(effectsCalled, "useEffect")
			end)

			React.useLayoutEffect(function()
				table.insert(effectsCalled, "useEffect")
			end)

			return React.createElement("Text", nil, "Hello world")
		end

		local shallowRenderer = createRenderer()
		shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(effectsCalled).toEqual({})
	end)

	it("should work with useRef", function()
		local function SomeComponent()
			local randomNumberRef = React.useRef({ number = math.random() })

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "The random number is: "
						.. tostring(randomNumberRef.current.number),
				})
			)
		end

		local shallowRenderer = createRenderer()
		local firstResult = shallowRenderer:render(React.createElement(SomeComponent))
		local secondResult = shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(firstResult).toEqual(secondResult)
	end)

	it("should work with useMemo", function()
		local function SomeComponent()
			local randomNumber = React.useMemo(function()
				return { number = math.random() }
			end, {})

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", {
					Text = "The random number is: " .. tostring(randomNumber.number),
				})
			)
		end

		local shallowRenderer = createRenderer()
		local firstResult = shallowRenderer:render(React.createElement(SomeComponent))
		local secondResult = shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(firstResult).toEqual(secondResult)
	end)

	it("should work with useMemo with multiple return values", function()
		local capturedNumber1, capturedNumber2
		local function SomeComponent()
			local number1, number2 = React.useMemo(function()
				return math.random(), math.random()
			end, {})

			capturedNumber1, capturedNumber2 = number1, number2

			return React.createElement(
				"Frame",
				nil,
				React.createElement(
					"TextLabel",
					{ Text = tostring(number1) .. " " .. tostring(number2) }
				)
			)
		end

		local shallowRenderer = createRenderer()
		local firstResult = shallowRenderer:render(React.createElement(SomeComponent))
		local secondResult = shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(firstResult).toEqual(secondResult)
		jestExpect(capturedNumber1).toBeDefined()
		jestExpect(capturedNumber2).toBeDefined()
	end)

	it("should work with useContext", function()
		local SomeContext = React.createContext("default")

		local function SomeComponent()
			local value = React.useContext(SomeContext)

			return React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Text = tostring(value) })
			)
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(result).toEqual(
			React.createElement(
				"Frame",
				nil,
				React.createElement("TextLabel", { Text = "default" })
			)
		)
	end)

	it("should not leak state when component type changes", function()
		local function SomeComponent(props)
			local name = React.useState(props.defaultName)

			return React.createElement("TextLabel", {
				Text = "Your name is: " .. name,
			})
		end

		local function SomeOtherComponent(props)
			local name = React.useState(props.defaultName)

			return React.createElement("TextLabel", {
				Text = "Your name is: " .. name,
			})
		end

		local shallowRenderer = createRenderer()
		local result = shallowRenderer:render(
			React.createElement(SomeComponent, { defaultName = "Dominic" })
		)
		jestExpect(result).toEqual(React.createElement("TextLabel", {
			Text = "Your name is: " .. "Dominic",
		}))

		result = shallowRenderer:render(
			React.createElement(SomeOtherComponent, { defaultName = "Dan" })
		)

		jestExpect(result).toEqual(React.createElement("TextLabel", {
			Text = "Your name is: " .. "Dan",
		}))
	end)

	it("should work with with forwardRef + any hook", function()
		local SomeComponent = React.forwardRef(function(props, ref)
			local randomNumberRef = React.useRef({ number = math.random() })

			return React.createElement(
				"Frame",
				{ ref = ref },
				React.createElement("TextLabel", {
					Text = "The random number is: "
						.. tostring(randomNumberRef.current.number),
				})
			)
		end)

		local shallowRenderer = createRenderer()
		local firstResult = shallowRenderer:render(React.createElement(SomeComponent))
		local secondResult = shallowRenderer:render(React.createElement(SomeComponent))

		jestExpect(firstResult).toEqual(secondResult)
	end)

	it("should update a value from useState outside the render", function()
		local _dispatch

		local function SomeComponent(props)
			local count, dispatch = React.useReducer(function(s, a)
				if a == "inc" then
					return s + 1
				end
				return s
			end, 0)
			local name, updateName = React.useState(props.defaultName)
			_dispatch = function(...)
				return dispatch("inc")
			end

			return React.createElement(
				"Frame",
				{
					onClick = function()
						updateName("Dan")
					end,
				},
				React.createElement("TextLabel", {
					Text = "Your name is: " .. name .. " (" .. count .. ")",
				})
			)
		end

		local shallowRenderer = createRenderer()
		local element = React.createElement(SomeComponent, { defaultName = "Dominic" })
		local result = shallowRenderer:render(element)
		jestExpect(result.props.children).toEqual(
			validateElement(React.createElement("TextLabel", {
				Text = "Your name is: Dominic (0)",
			}))
		)

		result.props.onClick()
		local updated = shallowRenderer:render(element)
		jestExpect(updated.props.children).toEqual(
			validateElement(React.createElement("TextLabel", {
				Text = "Your name is: Dan (0)",
			}))
		)

		_dispatch("foo")
		updated = shallowRenderer:render(element)
		jestExpect(updated.props.children).toEqual(
			validateElement(React.createElement("TextLabel", {
				Text = "Your name is: Dan (1)",
			}))
		)

		_dispatch("inc")
		updated = shallowRenderer:render(element)
		jestExpect(updated.props.children).toEqual(
			validateElement(React.createElement("TextLabel", {
				Text = "Your name is: Dan (2)",
			}))
		)
	end)

	it("should ignore a foreign update outside the render", function()
		local _updateCountForFirstRender

		local function SomeComponent()
			local count, updateCount = React.useState(0)
			if not _updateCountForFirstRender then
				_updateCountForFirstRender = updateCount
			end
			return count
		end

		local shallowRenderer = createRenderer()
		local element = React.createElement(SomeComponent)
		local result = shallowRenderer:render(element)
		jestExpect(result).toEqual(0)
		_updateCountForFirstRender(1)
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(1)

		shallowRenderer:unmount()
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(0)
		_updateCountForFirstRender(1) -- Should be ignored.
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(0)
	end)

	it("should not forget render phase updates", function()
		local _updateCount

		local function SomeComponent()
			local count, updateCount = React.useState(0)
			_updateCount = updateCount
			if count < 5 then
				updateCount(function(x)
					return x + 1
				end)
			end
			return count
		end

		local shallowRenderer = createRenderer()
		local element = React.createElement(SomeComponent)
		local result = shallowRenderer:render(element)
		jestExpect(result).toEqual(5)

		_updateCount(10)
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(10)

		_updateCount(function(x)
			return x + 1
		end)
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(11)

		_updateCount(function(x)
			return x - 10
		end)
		result = shallowRenderer:render(element)
		jestExpect(result).toEqual(5)
	end)
end) ]]
gE.Children._329e4f33815957518ce1b18da21d411e=gH
local gI

local gJ={ClassName="ModuleScript",Children={},Properties={}}
gJ.Name="ReactTestRenderer"
gJ.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-test-renderer/src/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]
return require(script.ReactTestRenderer) ]]
c.Children._9cee958ac4b864b5ca08df4a58ea4acf=gJ
local gK
local gL={ClassName="ModuleScript",Children={},Properties={}}
gL.Name="ReactTestHostConfig"
gL.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-test-renderer/src/ReactTestHostConfig.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)

local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout

-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
type ReactFundamentalComponentInstance<T, U> = ReactTypes.ReactFundamentalComponentInstance<
	T,
	U
>

local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_OPAQUE_ID_TYPE = ReactSymbols.REACT_OPAQUE_ID_TYPE

local RobloxComponentProps = require(script.Parent.roblox.RobloxComponentProps)

type Array<T> = { [number]: T }
type Function = (any) -> any

export type Type = string
export type Props = Object
export type Container = {
	children: Array<Instance | TextInstance>,
	createNodeMock: Function,
	tag: string, -- ROBLOX deviation: Luau can't specify literals
}
export type Instance = {
	type: string,
	props: Object,
	isHidden: boolean,
	children: Array<Instance | TextInstance>,
	internalInstanceHandle: Object,
	rootContainerInstance: Container,
	tag: "INSTANCE",
}
export type TextInstance = {
	text: string,
	isHidden: boolean,
	tag: string,
}
export type HydratableInstance = Instance | TextInstance
export type PublicInstance = Instance | TextInstance
export type HostContext = Object
export type UpdatePayload = Object
-- Unused
-- export type ChildSet = void;

-- FIXME (roblox): This typically uses a builtin flowtype called 'TimeoutID', we
-- should find a common solution for polyfill types with Luau
export type TimeoutHandle = any
export type NoTimeout = number
export type EventResponder = any
-- deviation: explicitly include `$$typeof` in type def
export type OpaqueIDType = string | Object
-- export type OpaqueIDType = string | {
-- 	toString: () -> string?,
-- 	valueOf: () -> string?,
-- };

export type RendererInspectionConfig = {}

local ReactFiberHostConfig = require(Packages.Shared).ReactFiberHostConfig
local exports = Object.assign(
	{},
	ReactFiberHostConfig.WithNoPersistence,
	ReactFiberHostConfig.WithNoHydration,
	ReactFiberHostConfig.WithNoTestSelectors
) :: { [string]: any }

local NO_CONTEXT = {}
local UPDATE_SIGNAL = {}
local nodeToInstanceMap: { [Object]: Instance? } = {}

if _G.__DEV__ then
	Object.freeze(NO_CONTEXT)
	Object.freeze(UPDATE_SIGNAL)
end

exports.getPublicInstance = function(inst: Instance | TextInstance)
	-- ROBLOX FIXME Luau: Luau should narrow to Instance based on singleton type comparison
	if inst.tag == "INSTANCE" then
		local createNodeMock = (inst :: Instance).rootContainerInstance.createNodeMock
		local mockNode = createNodeMock({
			type = (inst :: Instance).type,
			props = (inst :: Instance).props,
		})
		if typeof(mockNode) == "table" then
			nodeToInstanceMap[mockNode] = inst :: Instance
		end
		return mockNode
	else
		return inst
	end
end

exports.appendChild =
	function(parentInstance: Instance | Container, child: Instance | TextInstance)
		if _G.__DEV__ then
			if not Array.isArray(parentInstance.children) then
				console.error(
					"An invalid container has been provided. "
						.. "This may indicate that another renderer is being used in addition to the test renderer. "
						.. "(For example, ReactNoop.createPortal inside of a ReactTestRenderer tree.) "
						.. "This is not supported."
				)
			end
		end
		local index = Array.indexOf(parentInstance.children, child)
		if index ~= -1 then
			Array.splice(parentInstance.children, index, 1)
		end
		table.insert(parentInstance.children, child)
	end

exports.insertBefore = function(
	parentInstance: Instance | Container,
	child: Instance | TextInstance,
	beforeChild: Instance | TextInstance
)
	local index = Array.indexOf(parentInstance.children, child)
	if index ~= -1 then
		Array.splice(parentInstance.children, index, 1)
	end
	local beforeIndex = Array.indexOf(parentInstance.children, beforeChild)
	Array.splice(parentInstance.children, beforeIndex, 0, child)
end

exports.removeChild =
	function(parentInstance: Instance | Container, child: Instance | TextInstance)
		RobloxComponentProps.removeTags(child)
		local index = Array.indexOf(parentInstance.children, child)
		Array.splice(parentInstance.children, index, 1)
	end

exports.clearContainer = function(container: Container)
	Array.splice(container.children, 0)
end

exports.getRootHostContext = function(rootContainerInstance: Container): HostContext
	return NO_CONTEXT
end

exports.getChildHostContext = function(
	parentHostContext: HostContext,
	type: string,
	rootContainerInstance: Container
): HostContext
	return NO_CONTEXT
end

exports.prepareForCommit = function(containerInfo: Container): Object?
	-- noop
	return nil
end

exports.resetAfterCommit = function(containerInfo: Container)
	-- noop
end

exports.createInstance = function(
	type: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: Object,
	internalInstanceHandle: Object
): Instance
	return {
		type = type,
		props = props,
		isHidden = false,
		children = {},
		internalInstanceHandle = internalInstanceHandle,
		rootContainerInstance = rootContainerInstance,
		tag = "INSTANCE",
	}
end

exports.appendInitialChild =
	function(parentInstance: Instance, child: Instance | TextInstance)
		local index = Array.indexOf(parentInstance.children, child)
		if index ~= -1 then
			Array.splice(parentInstance.children, index, 1)
		end
		table.insert(parentInstance.children, child)
	end

exports.finalizeInitialChildren = function(
	testElement: Instance,
	type_: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: Object
): boolean
	RobloxComponentProps.setInitialTags(testElement, type_, props, rootContainerInstance)
	return false
end

exports.prepareUpdate = function(
	testElement: Instance,
	type: string,
	oldProps: Props,
	newProps: Props,
	rootContainerInstance: Container,
	hostContext: Object
): Object?
	return UPDATE_SIGNAL
end

exports.shouldSetTextContent = function(type: string, props: Props): boolean
	return false
end

exports.createTextInstance = function(
	text: string,
	rootContainerInstance: Container,
	hostContext: Object,
	internalInstanceHandle: Object
): TextInstance
	return {
		text = text,
		isHidden = false,
		tag = "TEXT",
	}
end

exports.isPrimaryRenderer = false
exports.warnsIfNotActing = true

exports.scheduleTimeout = setTimeout
exports.cancelTimeout = clearTimeout
exports.noTimeout = -1

-- -------------------
--     Mutation
-- -------------------

exports.supportsMutation = true

exports.commitUpdate = function(
	instance: Instance,
	updatePayload: { [any]: any },
	type: string,
	oldProps: Props,
	newProps: Props,
	internalInstanceHandle: Object
)
	instance.type = type
	instance.props = newProps
	RobloxComponentProps.updateTags(instance, newProps, oldProps)
end

exports.commitMount = function(
	instance: Instance,
	type: string,
	newProps: Props,
	internalInstanceHandle: Object
)
	-- noop
end

exports.commitTextUpdate =
	function(textInstance: TextInstance, oldText: string, newText: string)
		textInstance.text = newText
	end

exports.resetTextContent = function(testElement: Instance)
	-- noop
end

exports.appendChildToContainer = exports.appendChild
exports.insertInContainerBefore = exports.insertBefore
exports.removeChildFromContainer = exports.removeChild

exports.hideInstance = function(instance: Instance)
	instance.isHidden = true
end

exports.hideTextInstance = function(textInstance: TextInstance)
	textInstance.isHidden = true
end

exports.unhideInstance = function(instance: Instance, props: Props)
	instance.isHidden = false
end

exports.unhideTextInstance = function(textInstance: TextInstance, text: string)
	textInstance.isHidden = false
end

exports.getFundamentalComponentInstance =
	function(fundamentalInstance: ReactFundamentalComponentInstance<any, any>): Instance
		local impl = fundamentalInstance.impl
		local props = fundamentalInstance.props
		local state = fundamentalInstance.state
		return impl.getInstance(nil, props, state)
	end

exports.mountFundamentalComponent =
	function(fundamentalInstance: ReactFundamentalComponentInstance<any, any>)
		local impl = fundamentalInstance.impl
		local instance = fundamentalInstance.instance
		local props = fundamentalInstance.props
		local state = fundamentalInstance.state
		local onMount = impl.onMount
		if onMount ~= nil then
			onMount(nil, instance, props, state)
		end
	end

exports.shouldUpdateFundamentalComponent =
	function(fundamentalInstance: ReactFundamentalComponentInstance<any, any>): boolean
		local impl = fundamentalInstance.impl
		local prevProps = fundamentalInstance.prevProps
		local props = fundamentalInstance.props
		local state = fundamentalInstance.state
		local shouldUpdate = impl.shouldUpdate
		if shouldUpdate ~= nil then
			return shouldUpdate(nil, prevProps, props, state)
		end
		return true
	end

exports.updateFundamentalComponent =
	function(fundamentalInstance: ReactFundamentalComponentInstance<any, any>)
		local impl = fundamentalInstance.impl
		local instance = fundamentalInstance.instance
		local prevProps = fundamentalInstance.prevProps
		local props = fundamentalInstance.props
		local state = fundamentalInstance.state
		local onUpdate = impl.onUpdate
		if onUpdate ~= nil then
			onUpdate(nil, instance, prevProps, props, state)
		end
	end

exports.unmountFundamentalComponent =
	function(fundamentalInstance: ReactFundamentalComponentInstance<any, any>)
		local impl = fundamentalInstance.impl
		local instance = fundamentalInstance.instance
		local props = fundamentalInstance.props
		local state = fundamentalInstance.state
		local onUnmount = impl.onUnmount
		if onUnmount ~= nil then
			onUnmount(nil, instance, props, state)
		end
	end

exports.getInstanceFromNode = function(mockNode: Object): Object?
	local instance = nodeToInstanceMap[mockNode]
	if instance ~= nil then
		return (instance :: Instance).internalInstanceHandle
	end
	return nil
end

local clientId: number = 0
exports.makeClientId = function(): OpaqueIDType
	-- FIXME (roblox): convert to base 36 representation
	-- return result = 'c_' + (clientId++).toString(36)
	local result = "c_" .. clientId
	clientId += 1
	return result
end

exports.makeClientIdInDEV = function(warnOnAccessInDEV: () -> ()): OpaqueIDType
	-- FIXME (roblox): convert to base 36 representation
	-- local id = 'c_' + (clientId++).toString(36)
	local id = "c_" .. clientId
	clientId += 1
	return {
		toString = function()
			warnOnAccessInDEV()
			return id
		end,
		valueOf = function()
			warnOnAccessInDEV()
			return id
		end,
	}
end

exports.isOpaqueHydratingObject = function(value: any): boolean
	return typeof(value) == "table" and value["$$typeof"] == REACT_OPAQUE_ID_TYPE
end

exports.makeOpaqueHydratingObject = function(attemptToReadValue: () -> ()): OpaqueIDType
	return {
		["$$typeof"] = REACT_OPAQUE_ID_TYPE,
		toString = attemptToReadValue,
		valueOf = attemptToReadValue,
	}
end

exports.beforeActiveInstanceBlur = function(internalInstanceHandle: Object)
	-- noop
end

exports.afterActiveInstanceBlur = function()
	-- noop
end

exports.preparePortalMount = function(portalInstance: Instance)
	-- noop
end

exports.prepareScopeUpdate = function(scopeInstance: Object, inst: Object)
	nodeToInstanceMap[scopeInstance] = inst
end

exports.getInstanceFromScope = function(scopeInstance: Object): Object?
	return nodeToInstanceMap[scopeInstance] or nil
end

return exports ]]
gK.Children._c1f4630fbc7103efe2d58241b2cea7e0=gL
local gM

local gN={ClassName="ModuleScript",Children={},Properties={}}
gN.Name="ReactTestRenderer"
gN.Properties.Source=[[ --!nonstrict
-- ROBLOX upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-test-renderer/src/ReactTestRenderer.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent
local Scheduler = require(Packages.Scheduler)
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Symbol = LuauPolyfill.Symbol
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local setTimeout = LuauPolyfill.setTimeout
local ReactTypes = require(Packages.Shared)
local getInstancesForTag =
	require(script.Parent.roblox.RobloxComponentProps).getInstancesForTag
type ReactElement<P, T> = ReactTypes.ReactElement<P, T>

local ReactInternalTypes = require(Packages.ReactReconciler)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot

type Thenable<R> = ReactTypes.Thenable<R>

-- ROBLOX TODO: split below to silence analyze, but why is analyze throwing in first place?
local ReactTestHostConfig = require(script.Parent.ReactTestHostConfig)
-- ROBLOX deviation: For all tests, we mock the reconciler into a configurable
-- function interface that allows injection of HostConfig
local ReactReconciler = require(Packages.ReactReconciler)
local ReactFiberReconciler = ReactReconciler(ReactTestHostConfig)

local getPublicRootInstance = ReactFiberReconciler.getPublicRootInstance
local createContainer = ReactFiberReconciler.createContainer
local updateContainer = ReactFiberReconciler.updateContainer
local flushSync = ReactFiberReconciler.flushSync
local injectIntoDevTools = ReactFiberReconciler.injectIntoDevTools
local batchedUpdates = ReactFiberReconciler.batchedUpdates
local act = ReactFiberReconciler.act
local IsThisRendererActing = ReactFiberReconciler.IsThisRendererActing
local findCurrentFiberUsingSlowPath = ReactFiberReconciler.findCurrentFiberUsingSlowPath
local ReactWorkTags = ReactFiberReconciler.ReactWorkTags
local Fragment = ReactWorkTags.Fragment
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostComponent = ReactWorkTags.HostComponent
local HostPortal = ReactWorkTags.HostPortal
local HostText = ReactWorkTags.HostText
local HostRoot = ReactWorkTags.HostRoot
local ContextConsumer = ReactWorkTags.ContextConsumer
local ContextProvider = ReactWorkTags.ContextProvider
local Mode = ReactWorkTags.Mode
local ForwardRef = ReactWorkTags.ForwardRef
local Profiler = ReactWorkTags.Profiler
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local Block = ReactWorkTags.Block
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local Shared = require(Packages.Shared)
local invariant = Shared.invariant

local getComponentName = Shared.getComponentName
local ReactVersion = Shared.ReactVersion
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local enqueueTask = Shared.enqueueTask
local getPublicInstance = ReactTestHostConfig.getPublicInstance
local ReactRootTags = ReactFiberReconciler.ReactRootTags
local ConcurrentRoot = ReactRootTags.ConcurrentRoot
local LegacyRoot = ReactRootTags.LegacyRoot
local IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing
local JSON = game:GetService("HttpService")

-- ROBLOX deviation: add type for Array and Object
type Array<T> = { [number]: T }
type Object = { [string]: any }

type TestRendererOptions = {
	-- ROBLOX TODO: upstream treats this as optional, somehow flowtype doesn't complain
	createNodeMock: ((element: ReactElement<any, any>) -> any)?,
	unstable_isConcurrent: boolean,
}

type ReactTestRendererJSON = {
	type: string,
	-- props: {[propName: string]: any, ...},
	props: { [string]: any },
	children: nil | Array<ReactTestRendererNode>,
	-- $$typeof?: Symbol, -- Optional because we add it with defineProperty().
}
type ReactTestRendererNode = ReactTestRendererJSON | string

-- type FindOptions = $Shape<{
--     -- performs a "greedy" search: if a matching node is found, will continue
--     -- to search within the matching node's children. (default: true)
--     deep: boolean,
--     ...
-- }>
type FindOptions = any

type Instance = ReactTestHostConfig.Instance

export type Predicate = (Object) -> boolean?

local defaultTestOptions = {
	createNodeMock = function()
		return nil
	end,
}

local function toJSON(inst)
	if inst.isHidden then
		-- Omit timed out children from output entirely. This seems like the least
		-- surprising behavior. We could perhaps add a separate API that includes
		-- them, if it turns out people need it.
		return nil
	end

	-- ROBLOX deviation: if/else instead of switch
	if inst.tag == "TEXT" then
		return inst.text
	elseif inst.tag == "INSTANCE" then
		-- /* eslint-disable no-unused-vars */
		-- We don't include the `children` prop in JSON.
		-- Instead, we will include the actual rendered children.
		local props = Object.assign({}, inst.props)
		props.children = nil

		-- /* eslint-enable */
		local renderedChildren = nil
		if inst.children and #inst.children ~= 0 then
			for i = 1, #inst.children do
				local renderedChild = toJSON(inst.children[i])
				if renderedChild ~= nil then
					if renderedChildren == nil then
						renderedChildren = { renderedChild }
					else
						table.insert(renderedChildren, renderedChild)
					end
				end
			end
		end
		local json: ReactTestRendererJSON = {
			type = inst.type,
			props = props,
			children = renderedChildren,
		}
		-- ROBLOX TODO: Symbol.for
		setmetatable(json, {
			__index = function(t, k)
				if k == "$$typeof" then
					return Symbol.for_("react.test.json")
				end
				return
			end,
		})

		return json
	else
		error("Unexpected node type in toJSON: " .. tostring(inst.tag))
	end
end

local function flatten(arr)
	local result = {}
	local stack = {
		{
			i = 1,
			array = arr,
		},
	}

	while #stack ~= 0 do
		local n = table.remove(stack, #stack)

		while n.i <= #n.array do
			local el = n.array[n.i]

			n.i = n.i + 1

			if Array.isArray(el) then
				table.insert(stack, n)
				table.insert(stack, {
					i = 1,
					array = el,
				})
				break
			end

			table.insert(result, el)
		end
	end

	return result
end

local function nodeAndSiblingsArray(nodeWithSibling)
	local array = {}
	local node = nodeWithSibling

	while node ~= nil do
		table.insert(array, node)
		node = node.sibling
	end

	return array
end

-- ROBLOX deviation: toTree needs to be pre-declared to avoid function call cycle
local toTree

local function childrenToTree(node)
	if not node then
		return nil
	end

	local children = nodeAndSiblingsArray(node)

	if #children == 0 then
		return nil
	elseif #children == 1 then
		return toTree(children[1])
	end

	return flatten(Array.map(children, toTree))
end

-- ROBLOX deviation: change node variable name to nodeInput so we can keep the node name
-- for the majority of the function body after the initial nil check and recast
toTree = function(nodeInput: Fiber | nil)
	if nodeInput == nil then
		return nil
	end

	-- ROBLOX deviation: silence analyze by recasting
	local node: any = nodeInput

	-- ROBLOX deviation: swtich converted to if/else
	if node.tag == HostRoot then
		return childrenToTree(node.child)
	elseif node.tag == HostPortal then
		return childrenToTree(node.child)
	elseif node.tag == ClassComponent then
		return {
			nodeType = "component",
			type = node.type,
			-- ROBLOX deviation: Uses Object.assign for shallow copy
			props = Object.assign({}, node.memoizedProps),
			instance = node.stateNode,
			rendered = childrenToTree(node.child),
		}
	elseif node.tag == SimpleMemoComponent or node.tag == FunctionComponent then
		return {
			nodeType = "component",
			type = node.type,
			-- ROBLOX deviation: Uses Object.assign for shallow copy
			props = Object.assign({}, node.memoizedProps),
			instance = nil,
			rendered = childrenToTree(node.child),
		}
	elseif node.tag == Block then
		return {
			nodeType = "block",
			type = node.type,
			-- ROBLOX deviation: Uses Object.assign for shallow copy
			props = Object.assign({}, node.memoizedProps),
			instance = nil,
			rendered = childrenToTree(node.child),
		}
	elseif node.tag == HostComponent then
		return {
			nodeType = "host",
			type = node.type,
			-- ROBLOX deviation: Uses Object.assign for shallow copy
			props = Object.assign({}, node.memoizedProps),
			instance = nil, -- TODO: use createNodeMock here somehow?
			rendered = flatten(Array.map(nodeAndSiblingsArray(node.child), toTree)),
		}
	elseif node.tag == HostText then
		return node.stateNode.text
	elseif
		node.tag == Fragment
		or node.tag == ContextProvider
		or node.tag == ContextConsumer
		or node.tag == Mode
		or node.tag == Profiler
		or node.tag == ForwardRef
		or node.tag == MemoComponent
		or node.tag == IncompleteClassComponent
		or node.tag == ScopeComponent
	then
		return childrenToTree(node.child)
	else
		invariant(
			false,
			"toTree() does not yet know how to handle nodes with tag="
				.. tostring(node.tag)
		)
	end
	return
end

-- ROBLOX TODO: port ReactTestInstance type infered from the upstream class declaration
local ReactTestInstance = {}

-- ROBLOX deviation: not using Set()
local validWrapperTypes = {
	[FunctionComponent] = true,
	[ClassComponent] = true,
	[HostComponent] = true,
	[ForwardRef] = true,
	[MemoComponent] = true,
	[SimpleMemoComponent] = true,
	[Block] = true,
	-- Normally skipped, but used when there's more than one root child.
	[HostRoot] = true,
}

-- ROBLOX deviation: use table in place of WeakMap
local fiberToWrapper = {}
local function wrapFiber(fiber: Fiber): Object
	local wrapper = fiberToWrapper[fiber]

	if wrapper == nil and fiber.alternate ~= nil then
		wrapper = fiberToWrapper[fiber.alternate]
	end
	if wrapper == nil then
		wrapper = ReactTestInstance.new(fiber)
		fiberToWrapper["fiber"] = wrapper
	end

	return wrapper
end

local function getChildren(parent)
	local children = {}
	local startingNode = parent
	local node = startingNode

	if node.child == nil then
		return children
	end

	node.child.return_ = node
	node = node.child

	-- ROBLOX deviation: use break flag instead of labeled loops
	local breakOuter = false

	while true do
		local descend = false
		if validWrapperTypes[node.tag] ~= nil then
			table.insert(children, wrapFiber(node))
		elseif node.tag == HostText then
			table.insert(children, "" .. node.memoizedProps)
		else
			descend = true
		end
		if descend and node.child ~= nil then
			node.child.return_ = node
			node = node.child
			continue
		end
		while node.sibling == nil do
			if node.return_ == startingNode then
				breakOuter = true
				break
			end
			node = node.return_
		end
		-- ROBLOX deviation: use break flag instead of labeled loops
		if breakOuter then
			break
		end
		node.sibling.return_ = node.return_
		node = node.sibling
	end
	return children
end

local function findAll(
	root: Object,
	predicate: Predicate,
	options: FindOptions?
): Array<Object>
	-- ROBLOX deviation: ternary split to conditional statement
	local deep = true
	if options then
		deep = options.deep
	end
	local results = {}

	if predicate(root) then
		table.insert(results, root)
		if not deep then
			return results
		end
	end

	-- ROBLOX deviation: use for loop instead of forEach
	for _, child in root.children do
		if typeof(child) == "string" then
			continue
		end
		-- ROBLOX deviation: use for loop to insert mulltiple elements
		local findAllResult = findAll(child, predicate, options)
		for i = 1, #findAllResult do
			table.insert(results, findAllResult[i])
		end
	end
	return results
end

local function expectOne(all: Array<Object>, message: string): Object
	if #all == 1 then
		return all[1]
	end

	local prefix
	if #all == 0 then
		prefix = "No instances found "
	else
		prefix = string.format("Expected 1 but found %s instances ", tostring(#all))
	end

	error(prefix .. message)
end

local function propsMatch(props: Object, filter: Object): boolean
	for key, _ in filter do
		if props[key] ~= filter[key] then
			return false
		end
	end
	return true
end

function ReactTestInstance:_currentFiber(): Fiber
	-- Throws if this component has been unmounted.
	local fiber = findCurrentFiberUsingSlowPath(self._fiber)
	invariant(
		fiber ~= nil,
		"Can't read from currently-mounting component. This error is likely "
			.. "caused by a bug in React. Please file an issue."
	)
	return fiber
end

-- ROBLOX deviation:  metatable includes upstream
-- getter methods and Class methods
local function ReactTestInstanceGetters(self, key)
	if key == "instance" then
		if self._fiber.tag == HostComponent then
			return getPublicInstance(self._fiber.stateNode)
		else
			return self._fiber.stateNode
		end
	elseif key == "type" then
		return self._fiber.type
	elseif key == "props" then
		return self:_currentFiber().memoizedProps
	elseif key == "parent" then
		local parent = self._fiber.return_
		while parent ~= nil do
			if validWrapperTypes[parent.tag] ~= nil then
				if parent.tag == HostRoot then
					-- Special case: we only "materialize" instances for roots
					-- if they have more than a single child. So we'll check that now.
					if #getChildren(parent) < 2 then
						return nil
					end
				end
				return wrapFiber(parent)
			end
			parent = parent.return_
		end
		return nil
	elseif key == "children" then
		return getChildren(self:_currentFiber())
	else
		return ReactTestInstance[key]
	end
end

function ReactTestInstance.new(fiber: Fiber)
	invariant(
		validWrapperTypes[fiber.tag] ~= nil,
		"Unexpected object passed to ReactTestInstance constructor (tag: %s). "
			.. "This is probably a bug in React.",
		fiber.tag
	)
	local testInstance = {}

	-- ROBLOX deviation: set metatable to ReactTestInstanceGetters which includes upstream
	-- getter methods and Class methods
	setmetatable(testInstance, {
		__index = ReactTestInstanceGetters,
	})
	testInstance._fiber = fiber
	return testInstance
end

-- Custom search functions
function ReactTestInstance:find(predicate: Predicate): Object
	return expectOne(
		self:findAll(predicate, { deep = false }),
		string.format("matching custom predicate: %s", tostring(predicate))
	)
end
function ReactTestInstance:findByType(type_: any): Object
	return expectOne(
		self:findAllByType(type_, { deep = false }),
		string.format('with node type: "%s"', getComponentName(type_) or "Unknown")
	)
end
function ReactTestInstance:findByProps(props: Object): Object
	return expectOne(
		self:findAllByProps(props, { deep = false }),
		string.format("with props: %s", JSON:JSONEncode(props))
	)
end
function ReactTestInstance:findAll(
	predicate: Predicate,
	options: FindOptions?
): Array<Object>
	return findAll(self, predicate, options)
end
function ReactTestInstance:findAllByType(type_: any, options: FindOptions?): Array<Object>
	return findAll(self, function(node)
		return node.type == type_
	end, options)
end
function ReactTestInstance:findAllByProps(
	props: Object,
	options: FindOptions?
): Array<Object>
	return findAll(self, function(node)
		return node.props and propsMatch(node.props, props)
	end, options)
end

-- ROBLOX deviation START: the first argument gets an explicit nil in many tests
local function create(
	element: ReactElement<any, any> | nil,
	options: TestRendererOptions?
)
	-- ROBLOX deviation END
	local createNodeMock = defaultTestOptions.createNodeMock
	local isConcurrent = false

	if typeof(options) == "table" and options ~= nil then
		if typeof(options.createNodeMock) == "function" then
			createNodeMock = options.createNodeMock
		end
		if options.unstable_isConcurrent == true then
			isConcurrent = true
		end
	end

	local container = {
		children = {},
		createNodeMock = createNodeMock,
		tag = "CONTAINER",
	}

	local rootArg = LegacyRoot
	if isConcurrent then
		rootArg = ConcurrentRoot
	end

	-- ROBLOX deviation: remove Fiber? type to silence analyze
	local root = createContainer(container, rootArg, false, nil)

	invariant(root ~= nil, "something went wrong")
	updateContainer(element, root, nil, nil)

	local entry = {
		_Scheduler = Scheduler,
		root = nil, -- makes flow happy
		-- we define a 'getter' for 'root' below using 'Object.defineProperty'
		toJSON = function()
			if root == nil or root.current == nil or container == nil then
				return nil
			end
			if #container.children == 0 then
				return nil
			end
			if #container.children == 1 then
				return toJSON(container.children[1])
			end
			if
				#container.children == 2
				and container.children[1].isHidden == true
				and container.children[2].isHidden == false
			then
				-- Omit timed out children from output entirely, including the fact that we
				-- temporarily wrap fallback and timed out children in an array.
				return toJSON(container.children[2])
			end

			local renderedChildren = nil

			if container.children and #container.children ~= 0 then
				for i = 1, #container.children do
					local renderedChild = toJSON(container.children[i])

					if renderedChild ~= nil then
						if renderedChildren == nil then
							renderedChildren = { renderedChild }
						else
							table.insert(renderedChildren, renderedChild)
						end
					end
				end
			end

			return renderedChildren
		end,
		toTree = function()
			if root == nil or root.current == nil then
				return nil
			end

			return toTree(root.current)
		end,
		update = function(newElement: ReactElement<any, any>)
			if root == nil or root.current == nil then
				return
			end

			updateContainer(newElement, root, nil, nil)
		end,
		unmount = function()
			if root == nil or root.current == nil then
				return
			end

			updateContainer(nil, root, nil, nil)

			root = nil
		end,
		getInstance = function()
			if root == nil or root.current == nil then
				return nil
			end

			return getPublicRootInstance(root)
		end,
		unstable_flushSync = function(fn)
			return flushSync(fn)
		end,
		getInstancesForTag = function(tag: string): Array<Instance>
			if root == nil or root.containerInfo == nil then
				return {}
			end

			return getInstancesForTag(root.containerInfo, tag)
		end,
	}

	setmetatable(entry, {
		__index = function(t, k)
			if k == "root" then
				if root == nil then
					error("Can't access .root on unmounted test renderer")
				end

				local children = getChildren(root.current)

				if #children == 0 then
					error("Can't access .root on unmounted test renderer")
				elseif #children == 1 then
					return children[1]
				else
					return wrapFiber(root.current)
				end
			end
			return
		end,
	})

	return entry
end

-- Enable ReactTestRenderer to be used to test DevTools integration.
local bundleType = 0
if _G.__DEV__ then
	bundleType = 1
end

injectIntoDevTools({
	findFiberByHostInstance = function()
		error("TestRenderer does not support findFiberByHostInstance()")
	end,
	bundleType = bundleType,
	version = ReactVersion,
	rendererPackageName = "react-test-renderer",
})

local actingUpdatesScopeDepth = 0

-- This version of `act` is only used by our tests. Unlike the public version
-- of `act`, it's designed to work identically in both production and
-- development. It may have slightly different behavior from the public
-- version, too, since our constraints in our test suite are not the same as
-- those of developers using React — we're testing React itself, as opposed to
-- building an app with React.
-- TODO: Migrate our tests to use ReactNoop. Although we would need to figure
-- out a solution for Relay, which has some Concurrent Mode tests.
local function unstable_concurrentAct(scope: () -> () | Thenable<any>)
	if Scheduler.unstable_flushAllWithoutAsserting == nil then
		error("This version of `act` requires a special mock build of Scheduler.")
	end
	if typeof(setTimeout) == "table" and setTimeout._isMockFunction ~= true then
		error(
			"This version of `act` requires Jest's timer mocks "
				.. "(i.e. jest.useFakeTimers)."
		)
	end

	local previousActingUpdatesScopeDepth = actingUpdatesScopeDepth
	local previousIsSomeRendererActing = IsSomeRendererActing.current
	local previousIsThisRendererActing = IsThisRendererActing.current

	IsSomeRendererActing.current = true
	IsThisRendererActing.current = true
	actingUpdatesScopeDepth = actingUpdatesScopeDepth + 1

	local unwind = function()
		actingUpdatesScopeDepth = actingUpdatesScopeDepth - 1
		IsSomeRendererActing.current = previousIsSomeRendererActing
		IsThisRendererActing.current = previousIsThisRendererActing

		if _G.__DEV__ then
			if actingUpdatesScopeDepth > previousActingUpdatesScopeDepth then
				console.error(
					"You seem to have overlapping act() calls, this is not supported. "
						.. "Be sure to await previous act() calls before making a new one. "
				)
			end
		end
	end

	-- TODO: This would be way simpler if 1) we required a promise to be
	-- returned and 2) we could use async/await. Since it's only our used in
	-- our test suite, we should be able to.
	local ok, error_ = pcall(function()
		local thenable = batchedUpdates(scope)
		if
			typeof(thenable) == "table"
			and thenable ~= nil
			and typeof(thenable.andThen) == "function"
		then
			return function(resolve, reject)
				thenable:andThen(function()
					flushActWork(function()
						unwind()
						resolve()
					end, function(error_)
						unwind()
						reject(error_)
					end)
				end, function(error_)
					unwind()
					reject(error_)
				end)
			end
		else
			local _, _ = pcall(function()
				-- TODO: Let's not support non-async scopes at all in our tests. Need to
				-- migrate existing tests.
				local didFlushWork
				repeat
					didFlushWork = Scheduler.unstable_flushAllWithoutAsserting()
				until not didFlushWork
			end)
			-- ROBLOX finally
			unwind()
		end
		return
	end)
	if not ok then
		unwind()
		error(error_)
	end
end

function flushActWork(resolve, reject)
	-- Flush suspended fallbacks
	-- $FlowFixMe: Flow doesn't know about global Jest object

	-- ROBLOX TODO: Jest runONlyPendingTimers() not implemented (uncomment line below)
	-- jest.runOnlyPendingTimers()

	enqueueTask(function()
		local ok, _ = pcall(function()
			local didFlushWork = Scheduler.unstable_flushAllWithoutAsserting()
			if didFlushWork then
				flushActWork(resolve, reject)
			else
				resolve()
			end
		end)
		if not ok then
			reject(error)
		end
	end)
end

return {
	Scheduler = Scheduler,
	create = create,
	unstable_batchedUpdates = batchedUpdates,
	act = act,
	unstable_concurrentAct = unstable_concurrentAct,
} ]]
gK.Children._9b3909d0432570b9d24fcaa0abf4e0b1=gN
local gO

local gP={ClassName="Folder",Children={},Properties={}}
gP.Name="__tests__"
gK.Children._5fee5ffb94272285636ae67543044488=gP
local gQ
local gR={ClassName="ModuleScript",Children={},Properties={}}
gR.Name="ReactTestRenderer-internal.spec"
gR.Properties.Source=[[ -- Upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-test-renderer/src/__tests__/ReactTestRenderer-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

-- !strict
local Packages = script.Parent.Parent.Parent
local ReactFeatureFlags

local React
local ReactTestRenderer
-- local prettyFormat = require('pretty-format')

-- Isolate noop renderer
-- local ReactNoop = require(Packages.ReactNoopRenderer)
-- local Scheduler = require(Packages.Scheduler)

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Symbol = LuauPolyfill.Symbol

-- Kind of hacky, but we nullify all the instances to test the tree structure
-- with jasmine's deep equality function, and test the instances separate. We
-- also delete children props because testing them is more annoying and not
-- really important to verify.
local function cleanNodeOrArray(node)
	if not node then
		return
	end
	if Array.isArray(node) then
		-- ROBLOX deviation: for loop in place of forEach()
		for _, v in node do
			cleanNodeOrArray(v)
		end
		return
	end
	if node and node.instance then
		node.instance = nil
	end
	if node and node.props and node.props.children then
		-- eslint-disable-next-line no-unused-vars
		node.props["children"] = nil
	end
	if Array.isArray(node.rendered) then
		-- ROBLOX deviation: for loop in place of forEach()
		for _, v in node.rendered do
			cleanNodeOrArray(v)
		end
	elseif typeof(node.rendered) == "table" then
		cleanNodeOrArray(node.rendered)
	end
end

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("ReactTestRenderer", function()
	beforeEach(function()
		jest.resetModules()

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback = false

		React = require(Packages.React)
		ReactTestRenderer = require(Packages.ReactTestRenderer)
		-- local prettyFormat = require('pretty-format')
	end)
	it("renders a simple component", function()
		local function Link()
			return React.createElement("a", {
				role = "link",
			})
		end

		local renderer = ReactTestRenderer.create(React.createElement(Link))

		jestExpect(renderer.toJSON()).toEqual({
			type = "a",
			props = {
				role = "link",
			},
			children = nil,
		})
	end)
	it("renders a top-level empty component", function()
		local function Empty()
			return nil
		end

		local renderer = ReactTestRenderer.create(React.createElement(Empty))

		jestExpect(renderer.toJSON()).toEqual(nil)
	end)
	it("exposes a type flag", function()
		local function Link()
			return React.createElement("a", {
				role = "link",
			})
		end

		local renderer = ReactTestRenderer.create(React.createElement(Link))
		local object = renderer.toJSON()
		-- ROBLOX FIXME: needs to stringify $$typeof because Symbol module is reset. Un-stringify once we've found a solution.
		jestExpect(tostring(object["$$typeof"])).toEqual(
			tostring(Symbol.for_("react.test.json"))
		)

		-- $$typeof should not be enumerable.
		for key, _ in object do
			jestExpect(key).never.toEqual("$$typeof")
		end
	end)
	it("can render a composite component", function()
		local Component = React.Component:extend("Component")

		local Child = function()
			return React.createElement("moo")
		end

		function Component:render()
			return React.createElement("div", {
				className = "purple",
			}, React.createElement(Child, nil))
		end

		local renderer = ReactTestRenderer.create(React.createElement(Component))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {
				className = "purple",
			},
			children = {
				{
					type = "moo",
					props = {},
					children = nil,
				},
			},
		})
	end)
	it("renders some basics with an update", function()
		local renders = 0
		local Component = React.Component:extend("Component")

		local Child = function()
			renders = renders + 1

			return React.createElement("moo")
		end
		local Null = function()
			renders = renders + 1
			return nil
		end

		function Component:init()
			self.state = { x = 3 }
			return
		end
		function Component:render()
			renders = renders + 1

			return React.createElement("div", {
				className = "purple",
			}, self.state.x, React.createElement(Child), React.createElement(Null))
		end
		function Component:componentDidMount()
			self:setState({ x = 7 })
		end

		local renderer = ReactTestRenderer.create(React.createElement(Component))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {
				className = "purple",
			},
			children = {
				"7",
				{
					type = "moo",
					props = {},
					children = nil,
				},
			},
		})
		jestExpect(renders).toEqual(6)
	end)
	it("exposes the instance", function()
		local Mouse = React.Component:extend("Mouse")

		function Mouse:init()
			self.state = {
				mouse = "mouse",
			}
		end
		function Mouse:handleMoose()
			self:setState({
				mouse = "moose",
			})
		end
		function Mouse:render()
			return React.createElement("div", nil, self.state.mouse)
		end

		local renderer = ReactTestRenderer.create(React.createElement(Mouse))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {},
			children = {
				"mouse",
			},
		})

		local mouse = renderer.getInstance()

		mouse:handleMoose()
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				"moose",
			},
			props = {},
		})
	end)
	it("updates types", function()
		local renderer =
			ReactTestRenderer.create(React.createElement("div", nil, "mouse"))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {},
			children = {
				"mouse",
			},
		})
		renderer.update(React.createElement("span", nil, "mice"))
		jestExpect(renderer.toJSON()).toEqual({
			type = "span",
			props = {},
			children = {
				"mice",
			},
		})
	end)
	it("updates children", function()
		local renderer = ReactTestRenderer.create(
			React.createElement(
				"div",
				nil,
				React.createElement("span", {
					key = "a",
				}, "A"),
				React.createElement("span", {
					key = "b",
				}, "B"),
				React.createElement("span", {
					key = "c",
				}, "C")
			)
		)

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {},
			children = {
				{
					type = "span",
					props = {},
					children = {
						"A",
					},
				},
				{
					type = "span",
					props = {},
					children = {
						"B",
					},
				},
				{
					type = "span",
					props = {},
					children = {
						"C",
					},
				},
			},
		})
		renderer.update(React.createElement(
			"div",
			nil,
			React.createElement("span", {
				key = "d",
			}, "D"),
			React.createElement("span", {
				key = "c",
			}, "C"),
			React.createElement("span", {
				key = "b",
			}, "B")
		))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {},
			children = {
				{
					type = "span",
					props = {},
					children = {
						"D",
					},
				},
				{
					type = "span",
					props = {},
					children = {
						"C",
					},
				},
				{
					type = "span",
					props = {},
					children = {
						"B",
					},
				},
			},
		})
	end)
	it("does the full lifecycle", function()
		local log = {}
		local Log = React.Component:extend("Log")

		function Log:render()
			table.insert(log, "render " .. self.props.name)
			return React.createElement("div")
		end
		function Log:componentDidMount()
			table.insert(log, "mount " .. self.props.name)
		end
		function Log:componentWillUnmount()
			table.insert(log, "unmount " .. self.props.name)
		end

		local renderer = ReactTestRenderer.create(React.createElement(Log, {
			key = "foo",
			name = "Foo",
		}))

		renderer.update(React.createElement(Log, {
			key = "bar",
			name = "Bar",
		}))
		renderer.unmount()
		jestExpect(log).toEqual({
			"render Foo",
			"mount Foo",
			"render Bar",
			"unmount Foo",
			"mount Bar",
			"unmount Bar",
		})
	end)
	it("gives a ref to native components", function()
		local log = {}

		ReactTestRenderer.create(React.createElement("div", {
			ref = function(r)
				return table.insert(log, r)
			end,
		}))
		jestExpect(log).toEqual({ nil })
	end)
	it("warns correctly for refs on SFCs", function()
		local function Bar()
			return React.createElement("div", nil, "Hello, world")
		end

		local Foo = React.Component:extend("Foo")

		function Foo:render()
			return React.createElement(Bar, {
				ref = React.createRef(),
			})
		end

		local Baz = React.Component:extend("Baz")

		function Baz:render()
			return React.createElement("div", {
				ref = React.createRef(),
			})
		end

		ReactTestRenderer.create(React.createElement(Baz))
		jestExpect(function()
			return ReactTestRenderer.create(React.createElement(Foo))
		end).toErrorDev(
			"Warning: Function components cannot be given refs. Attempts "
				.. "to access this ref will fail. "
				.. "Did you mean to use React.forwardRef()?\n\n"
				.. "Check the render method of `Foo`.\n"
				.. "    in Bar (at **)\n"
				.. "    in Foo (at **)"
		)
	end)
	it("allows an optional createNodeMock function", function()
		local mockDivInstance = {
			appendChild = function() end,
		}
		local mockInputInstance = {
			focus = function() end,
		}
		local mockListItemInstance = {
			click = function() end,
		}
		local mockAnchorInstance = {
			hover = function() end,
		}
		local log = {}

		-- ROBLOX deviation: using createRef in place of string refs
		local bar = React.createRef()
		local Foo = React.Component:extend("Foo")

		function Foo:componentDidMount()
			table.insert(log, bar.current)
		end
		function Foo:render()
			return React.createElement("a", {
				ref = bar,
			}, "Hello, world")
		end

		local function createNodeMock(element)
			if element.type == "div" then
				return mockDivInstance
			elseif element.type == "input" then
				return mockInputInstance
			elseif element.type == "li" then
				return mockListItemInstance
			elseif element.type == "a" then
				return mockAnchorInstance
			else
				return {}
			end
		end

		ReactTestRenderer.create(
			React.createElement("div", {
				ref = function(r)
					return table.insert(log, r)
				end,
			}),
			{ createNodeMock = createNodeMock }
		)
		ReactTestRenderer.create(
			React.createElement("input", {
				ref = function(r)
					return table.insert(log, r)
				end,
			}),
			{ createNodeMock = createNodeMock }
		)
		ReactTestRenderer.create(
			React.createElement(
				"div",
				nil,
				React.createElement(
					"span",
					nil,
					React.createElement(
						"ul",
						nil,
						React.createElement("li", {
							ref = function(r)
								return table.insert(log, r)
							end,
						})
					),
					React.createElement(
						"ul",
						nil,
						React.createElement("li", {
							ref = function(r)
								return table.insert(log, r)
							end,
						}),
						React.createElement("li", {
							ref = function(r)
								return table.insert(log, r)
							end,
						})
					)
				)
			),
			{
				createNodeMock = createNodeMock,
				foobar = true,
			}
		)
		ReactTestRenderer.create(
			React.createElement(Foo),
			{ createNodeMock = createNodeMock }
		)
		ReactTestRenderer.create(React.createElement("div", {
			ref = function(r)
				return table.insert(log, r)
			end,
		}))
		ReactTestRenderer.create(
			React.createElement("div", {
				ref = function(r)
					return table.insert(log, r)
				end,
			}),
			{}
		)
		jestExpect(log).toEqual({
			mockDivInstance,
			mockInputInstance,
			mockListItemInstance,
			mockListItemInstance,
			mockListItemInstance,
			mockAnchorInstance,
		})
	end)
	it("supports unmounting when using refs", function()
		local Foo = React.Component:extend("Foo")

		-- ROBLOX deviation: using createRef in place of string refs
		local foo = React.createRef()

		function Foo:render()
			return React.createElement("div", {
				ref = foo,
			})
		end

		local inst = ReactTestRenderer.create(React.createElement(Foo), {
			createNodeMock = function()
				return foo.current
			end,
		})

		jestExpect(function()
			return inst.unmount()
		end).never.toThrow()
	end)
	it("supports unmounting inner instances", function()
		local count = 0
		local Foo = React.Component:extend("Foo")

		function Foo:componentWillUnmount()
			count = count + 1
		end
		function Foo:render()
			return React.createElement("div")
		end

		local inst = ReactTestRenderer.create(
			React.createElement("div", nil, React.createElement(Foo)),
			{
				createNodeMock = function()
					return "foo"
				end,
			}
		)

		jestExpect(function()
			return inst.unmount()
		end).never.toThrow()
		jestExpect(count).toEqual(1)
	end)
	it("supports updates when using refs", function()
		local log = {}
		local createNodeMock = function(element)
			table.insert(log, element.type)
			return element.type
		end
		local Foo = React.Component:extend("Foo")

		function Foo:render()
			return (function()
				if self.props.useDiv then
					return React.createElement("div", {
						ref = React.createRef(),
					})
				end

				return React.createElement("span", {
					ref = React.createRef(),
				})
			end)()
		end

		local inst = ReactTestRenderer.create(
			React.createElement(Foo, { useDiv = true }),
			{ createNodeMock = createNodeMock }
		)

		inst.update(React.createElement(Foo, { useDiv = false }))
		jestExpect(log).toEqual({
			"div",
			"span",
		})
	end)
	it("supports error boundaries", function()
		local log = {}
		local Angry = React.Component:extend("Angry")

		function Angry:render()
			table.insert(log, "Angry render")
			error("Please, do not render me.")
		end
		function Angry:componentDidMount()
			table.insert(log, "Angry componentDidMount")
		end
		function Angry:componentWillUnmount()
			table.insert(log, "Angry componentWillUnmount")
		end

		local Boundary = React.Component:extend("Boundary")

		function Boundary:init(props)
			self.state = { error = false }
		end
		function Boundary:render()
			table.insert(log, "Boundary render")

			if not self.state.error then
				return React.createElement(
					"div",
					nil,
					React.createElement("button", {
						onClick = self.onClick,
					}, "ClickMe"),
					React.createElement(Angry)
				)
			else
				return React.createElement("div", nil, "Happy Birthday!")
			end
		end
		function Boundary:componentDidMount()
			table.insert(log, "Boundary componentDidMount")
		end
		function Boundary:componentWillUnmount()
			table.insert(log, "Boundary componentWillUnmount")
		end
		function Boundary:onClick()
			-- do nothing
			return
		end
		function Boundary:componentDidCatch()
			table.insert(log, "Boundary componentDidCatch")
			self:setState({ error = true })
		end

		-- ROBLOX Test Noise: jest setup config makes this hide error
		-- boundary warnings in upstream (scripts/jest/setupTests.js:72)
		local renderer = ReactTestRenderer.create(React.createElement(Boundary))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			props = {},
			children = {
				"Happy Birthday!",
			},
		})
		jestExpect(log).toEqual({
			"Boundary render",
			"Angry render",
			"Boundary componentDidMount",
			"Boundary componentDidCatch",
			"Boundary render",
		})
	end)
	it("can update text nodes", function()
		local Component = React.Component:extend("Component")

		function Component:render()
			return React.createElement("div", nil, self.props.children)
		end

		local renderer =
			ReactTestRenderer.create(React.createElement(Component, nil, "Hi"))

		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				"Hi",
			},
			props = {},
		})
		renderer.update(React.createElement(Component, nil, {
			"Hi",
			"Bye",
		}))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				"Hi",
				"Bye",
			},
			props = {},
		})
		renderer.update(React.createElement(Component, nil, "Bye"))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				"Bye",
			},
			props = {},
		})
		renderer.update(React.createElement(Component, nil, 42))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				"42",
			},
			props = {},
		})
		renderer.update(React.createElement(Component, nil, React.createElement("div")))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = {
				{
					type = "div",
					children = nil,
					props = {},
				},
			},
			props = {},
		})
	end)
	it("toTree() renders simple components returning host components", function()
		local Qoo = function()
			return React.createElement("span", {
				className = "Qoo",
			}, "Hello World!")
		end
		local renderer = ReactTestRenderer.create(React.createElement(Qoo))
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)

		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			nodeType = "component",
			type = Qoo,
			props = {},
			instance = nil,
			rendered = {
				nodeType = "host",
				type = "span",
				props = {
					className = "Qoo",
				},
				instance = nil,
				rendered = {
					"Hello World!",
				},
			},
		})
	end)
	it("toTree() handles nested Fragments", function()
		local Foo = function()
			return React.createElement(
				React.Fragment,
				nil,
				React.createElement(React.Fragment, nil, "foo")
			)
		end
		local renderer = ReactTestRenderer.create(React.createElement(Foo))
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)

		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			nodeType = "component",
			type = Foo,
			instance = nil,
			props = {},
			rendered = "foo",
		})
	end)
	it("toTree() handles null rendering components", function()
		local Foo = React.Component:extend("Foo")

		function Foo:render()
			return nil
		end

		local renderer = ReactTestRenderer.create(React.createElement(Foo))
		local tree = renderer.toTree()

		-- ROBLOX deviation: toBeInstanceOf not yet implemented, workaround by checking elementType
		jestExpect(tree.instance._reactInternals.elementType.__componentName).toEqual(
			"Foo"
		)
		cleanNodeOrArray(tree)

		jestExpect(tree).toEqual({
			type = Foo,
			nodeType = "component",
			props = {},
			instance = nil,
			rendered = nil,
		})
	end)
	it("toTree() handles simple components that return arrays", function()
		local Foo = function(_ref)
			local children = _ref.children

			return children
		end
		local renderer = ReactTestRenderer.create(
			React.createElement(
				Foo,
				nil,
				React.createElement("div", nil, "One"),
				React.createElement("div", nil, "Two")
			)
		)
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)

		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			type = Foo,
			nodeType = "component",
			props = {},
			instance = nil,
			rendered = {
				{
					instance = nil,
					nodeType = "host",
					props = {},
					rendered = {
						"One",
					},
					type = "div",
				},
				{
					instance = nil,
					nodeType = "host",
					props = {},
					rendered = {
						"Two",
					},
					type = "div",
				},
			},
		})
	end)
	it("toTree() handles complicated tree of arrays", function()
		local Foo = React.Component:extend("Foo")

		function Foo:render()
			return self.props.children
		end

		local renderer = ReactTestRenderer.create(
			React.createElement(
				"div",
				nil,
				React.createElement(
					Foo,
					nil,
					React.createElement("div", nil, "One"),
					React.createElement("div", nil, "Two"),
					React.createElement(
						Foo,
						nil,
						React.createElement("div", nil, "Three")
					)
				),
				React.createElement("div", nil, "Four")
			)
		)
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)

		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			type = "div",
			instance = nil,
			nodeType = "host",
			props = {},
			rendered = {
				{
					type = Foo,
					nodeType = "component",
					props = {},
					instance = nil,
					rendered = {
						{
							type = "div",
							nodeType = "host",
							props = {},
							instance = nil,
							rendered = {
								"One",
							},
						},
						{
							type = "div",
							nodeType = "host",
							props = {},
							instance = nil,
							rendered = {
								"Two",
							},
						},
						{
							type = Foo,
							nodeType = "component",
							props = {},
							instance = nil,
							rendered = {
								type = "div",
								nodeType = "host",
								props = {},
								instance = nil,
								rendered = {
									"Three",
								},
							},
						},
					},
				},
				{
					type = "div",
					nodeType = "host",
					props = {},
					instance = nil,
					rendered = {
						"Four",
					},
				},
			},
		})
	end)
	it("toTree() handles complicated tree of fragments", function()
		local renderer = ReactTestRenderer.create(
			React.createElement(
				React.Fragment,
				nil,
				React.createElement(
					React.Fragment,
					nil,
					React.createElement("div", nil, "One"),
					React.createElement("div", nil, "Two"),
					React.createElement(
						React.Fragment,
						nil,
						React.createElement("div", nil, "Three")
					)
				),
				React.createElement("div", nil, "Four")
			)
		)
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)
		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			{
				type = "div",
				nodeType = "host",
				props = {},
				instance = nil,
				rendered = {
					"One",
				},
			},
			{
				type = "div",
				nodeType = "host",
				props = {},
				instance = nil,
				rendered = {
					"Two",
				},
			},
			{
				type = "div",
				nodeType = "host",
				props = {},
				instance = nil,
				rendered = {
					"Three",
				},
			},
			{
				type = "div",
				nodeType = "host",
				props = {},
				instance = nil,
				rendered = {
					"Four",
				},
			},
		})
	end)
	it("root instance and createNodeMock ref return the same value", function()
		local createNodeMock = function(ref)
			return { node = ref }
		end
		local refInst = nil
		local renderer = ReactTestRenderer.create(
			React.createElement("div", {
				ref = function(ref)
					refInst = ref
					return
				end,
			}),
			{ createNodeMock = createNodeMock }
		)
		local root = renderer.getInstance()

		jestExpect(root).toEqual(refInst)
	end)
	it("toTree() renders complicated trees of composites and hosts", function()
		-- SFC returning host. no children props.
		local Qoo = function()
			return React.createElement("span", {
				className = "Qoo",
			}, "Hello World!")
		end

		-- SFC returning host. passes through children.
		local Foo = function(props)
			local className, children = props.className, props.children

			return React.createElement(
				"div",
				{
					className = "Foo " .. className,
				},
				React.createElement("span", {
					className = "Foo2",
				}, "Literal"),
				children
			)
		end

		-- class composite returning composite. passes through children.
		local Bar = React.Component:extend("Bar")
		function Bar:render()
			local children = self.props.children
			local special = self.props.special

			return React.createElement(Foo, {
				className = (function()
					if special then
						return "special"
					end

					return "normal"
				end)(),
			}, children)
		end

		-- class composite return composite. no children props.
		local Bam = React.Component:extend("Bam")

		function Bam:render()
			return React.createElement(Bar, { special = true }, React.createElement(Qoo))
		end

		local renderer = ReactTestRenderer.create(React.createElement(Bam))
		local tree = renderer.toTree()

		-- we test for the presence of instances before nulling them out
		-- ROBLOX deviation: toBeInstanceOf not yet implemented, workaround by checking elementType
		jestExpect(tree.instance._reactInternals.elementType.__componentName).toEqual(
			"Bam"
		)
		jestExpect(tree.rendered.instance._reactInternals.elementType.__componentName).toEqual(
			"Bar"
		)

		cleanNodeOrArray(tree)

		jestExpect(tree).toEqual({
			type = Bam,
			nodeType = "component",
			props = {},
			instance = nil,
			rendered = {
				type = Bar,
				nodeType = "component",
				props = { special = true },
				instance = nil,
				rendered = {
					type = Foo,
					nodeType = "component",
					props = {
						className = "special",
					},
					instance = nil,
					rendered = {
						type = "div",
						nodeType = "host",
						props = {
							className = "Foo special",
						},
						instance = nil,
						rendered = {
							{
								type = "span",
								nodeType = "host",
								props = {
									className = "Foo2",
								},
								instance = nil,
								rendered = {
									"Literal",
								},
							},
							{
								type = Qoo,
								nodeType = "component",
								props = {},
								instance = nil,
								rendered = {
									type = "span",
									nodeType = "host",
									props = {
										className = "Qoo",
									},
									instance = nil,
									rendered = {
										"Hello World!",
									},
								},
							},
						},
					},
				},
			},
		})
	end)
	it("can update text nodes when rendered as root", function()
		local renderer = ReactTestRenderer.create({
			"Hello",
			"world",
		})

		jestExpect(renderer.toJSON()).toEqual({
			"Hello",
			"world",
		})
		renderer.update(42)
		jestExpect(renderer.toJSON()).toEqual("42")
		renderer.update({
			42,
			"world",
		})
		jestExpect(renderer.toJSON()).toEqual({
			"42",
			"world",
		})
	end)
	it("can render and update root fragments", function()
		local Component = function(props)
			return props.children
		end
		local renderer = ReactTestRenderer.create({
			React.createElement(Component, {
				key = "a",
			}, "Hi"),
			React.createElement(Component, {
				key = "b",
			}, "Bye"),
		})

		jestExpect(renderer.toJSON()).toEqual({
			"Hi",
			"Bye",
		})
		renderer.update(React.createElement("div"))
		jestExpect(renderer.toJSON()).toEqual({
			type = "div",
			children = nil,
			props = {},
		})
		renderer.update({
			React.createElement("div", {
				key = "a",
			}, "goodbye"),
			"world",
		})
		jestExpect(renderer.toJSON()).toEqual({
			{
				type = "div",
				children = {
					"goodbye",
				},
				props = {},
			},
			"world",
		})
	end)
	it("supports context providers and consumers", function()
		local context = React.createContext("a")
		local Consumer = context.Consumer
		local Provider = context.Provider

		local function Child(props)
			return props.value
		end
		local function App()
			return React.createElement(
				Provider,
				{
					value = "b",
				},
				React.createElement(Consumer, nil, function(value)
					return React.createElement(Child, { value = value })
				end)
			)
		end

		local renderer = ReactTestRenderer.create(React.createElement(App))
		local child = renderer.root:findByType(Child)

		jestExpect(child.children).toEqual({
			"b",
		})
		-- ROBLOX deviation: no need to pretty format
		jestExpect(renderer.toTree()).toEqual({
			instance = nil,
			nodeType = "component",
			props = {},
			rendered = {
				instance = nil,
				nodeType = "component",
				props = {
					value = "b",
				},
				rendered = "b",
				type = Child,
			},
			type = App,
		})
	end)
	it("supports modes", function()
		local function Child(props)
			return props.value
		end
		local function App(props)
			return React.createElement(
				React.StrictMode,
				nil,
				React.createElement(Child, {
					value = props.value,
				})
			)
		end

		local renderer = ReactTestRenderer.create(React.createElement(App, {
			value = "a",
		}))
		local child = renderer.root:findByType(Child)

		jestExpect(child.children).toEqual({
			"a",
		})
		-- ROBLOX deviation: no need to pretty format
		jestExpect(renderer.toTree()).toEqual({
			instance = nil,
			nodeType = "component",
			props = {
				value = "a",
			},
			rendered = {
				instance = nil,
				nodeType = "component",
				props = {
					value = "a",
				},
				rendered = "a",
				type = Child,
			},
			type = App,
		})
	end)
	it("supports forwardRef", function()
		local InnerRefed = React.forwardRef(function(props, ref)
			return React.createElement(
				"div",
				nil,
				React.createElement("span", { ref = ref })
			)
		end)
		local App = React.Component:extend("App")

		function App:render()
			return React.createElement(InnerRefed, {
				ref = function(r)
					self.ref = r
					return
				end,
			})
		end

		local renderer = ReactTestRenderer.create(React.createElement(App))
		local tree = renderer.toTree()

		cleanNodeOrArray(tree)

		-- ROBLOX deviation: no need to pretty format
		jestExpect(tree).toEqual({
			instance = nil,
			nodeType = "component",
			props = {},
			rendered = {
				instance = nil,
				nodeType = "host",
				props = {},
				rendered = {
					{
						instance = nil,
						nodeType = "host",
						props = {},
						rendered = {},
						type = "span",
					},
				},
				type = "div",
			},
			type = App,
		})
	end)
	-- ROBLOX TODO: set up React Noop in this file
	-- xit('can concurrently render context with a "primary" renderer', function()
	--     local Context = React.createContext(nil)
	--     local Indirection = React.Fragment
	--     local App = function()
	--         return React.createElement(Context.Provider, {value = nil}, React.createElement(Indirection, nil, React.createElement(Context.Consumer, nil, function(
	--         )
	--             return nil
	--         end)))
	--     end

	--     ReactNoop.render(React.createElement(App))
	--     jestExpect(Scheduler).toFlushWithoutYielding()
	--     ReactTestRenderer.create(React.createElement(App))
	-- end)
	it(
		'calling findByType() with an invalid component will fall back to "Unknown" for component name',
		function()
			local App = function()
				return nil
			end
			local renderer = ReactTestRenderer.create(React.createElement(App))
			local NonComponent = {}
			jestExpect(function()
				renderer.root:findByType(NonComponent)
			end).toThrow('No instances found with node type: "Unknown"')
		end
	)
end) ]]
gQ.Children._04238b784ed8e138043a4627719b71e1=gR
local gS

local gT={ClassName="ModuleScript",Children={},Properties={}}
gT.Name="ReactTestRenderer.spec"
gT.Properties.Source=[[ --\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 \]\]

-- 'use strict'

local Packages = script.Parent.Parent.Parent
local ReactRoblox
local ReactTestRenderer
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("ReactTestRenderer", function()
	beforeEach(function()
		jest.resetModules()
		jest.useRealTimers()
		ReactRoblox = require(Packages.Dev.ReactRoblox)

		-- Isolate test renderer.
		jest.resetModules()
		ReactTestRenderer = require(Packages.ReactTestRenderer)
	end)

	it("should warn if used to render a ReactRoblox portal", function()
		local container = Instance.new("Folder")

		jestExpect(function()
			jestExpect(function()
				ReactTestRenderer.create(ReactRoblox.createPortal("foo", container))
			end).toThrow()
			-- ROBLOX deviation START: This has `Warning: ` appended to it versus upstream, wording adjusted to not mention ReactDOM
		end).toErrorDev("Warning: An invalid container has been provided.", {
			-- ROBLOX deviation END
			withoutStack = true,
		})
	end)

	-- describe('timed out Suspense hidden subtrees should not be observable via toJSON', () => {
	--   local AsyncText
	--   local PendingResources
	--   local TextResource

	--   beforeEach(() => {
	--     PendingResources = {}
	--     TextResource = ReactCache.unstable_createResource(
	--       text =>
	--         new Promise(resolve => {
	--           PendingResources[text] = resolve
	--         }),
	--       text => text,
	--     )

	--     AsyncText = ({text}) => {
	--       local value = TextResource.read(text)
	--       return value
	--     }
	--   })

	--   it('for root Suspense components', async done => {
	--     local App = ({text}) => {
	--       return (
	--         <React.Suspense fallback="fallback">
	--           <AsyncText text={text} />
	--         </React.Suspense>
	--       )
	--     }

	--     local root = ReactTestRenderer.create(<App text="initial" />)
	--     PendingResources.initial('initial')
	--     await Promise.resolve()
	--     Scheduler.unstable_flushAll()
	--     expect(root.toJSON()).toEqual('initial')

	--     root.update(<App text="dynamic" />)
	--     expect(root.toJSON()).toEqual('fallback')

	--     PendingResources.dynamic('dynamic')
	--     await Promise.resolve()
	--     Scheduler.unstable_flushAll()
	--     expect(root.toJSON()).toEqual('dynamic')

	--     done()
	--   })

	--   it('for nested Suspense components', async done => {
	--     local App = ({text}) => {
	--       return (
	--         <div>
	--           <React.Suspense fallback="fallback">
	--             <AsyncText text={text} />
	--           </React.Suspense>
	--         </div>
	--       )
	--     }

	--     local root = ReactTestRenderer.create(<App text="initial" />)
	--     PendingResources.initial('initial')
	--     await Promise.resolve()
	--     Scheduler.unstable_flushAll()
	--     expect(root.toJSON().children).toEqual(['initial'])

	--     root.update(<App text="dynamic" />)
	--     expect(root.toJSON().children).toEqual(['fallback'])

	--     PendingResources.dynamic('dynamic')
	--     await Promise.resolve()
	--     Scheduler.unstable_flushAll()
	--     expect(root.toJSON().children).toEqual(['dynamic'])

	--     done()
	--   })
	-- })
end) ]]
gQ.Children._317b52c98ec9e486841b9fa9fd45e633=gT
local gU

local gV={ClassName="ModuleScript",Children={},Properties={}}
gV.Name="ReactTestRendererAct.spec"
gV.Properties.Source=[[ local React
local ReactTestRenderer
local Scheduler
local act
local useState, useEffect, useReducer

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

local Promise = require(Packages.Dev.Promise)

describe("ReactTestRenderer.act()", function()
	beforeEach(function()
		jest.resetModules()
		jest.useRealTimers()

		React = require(Packages.React)
		useState, useEffect, useReducer =
			React.useState, React.useEffect, React.useReducer
		ReactTestRenderer = require(Packages.ReactTestRenderer)
		Scheduler = require(Packages.Scheduler)
		act = ReactTestRenderer.act
	end)
	it("can use .act() to flush effects", function()
		local function App(props)
			local ctr, setCtr = useState(0)

			React.useEffect(function()
				props.callback()
				setCtr(1)
			end, {})

			return ctr
		end

		local calledLog = {}
		local root

		act(function()
			root = ReactTestRenderer.create(React.createElement(App, {
				callback = function()
					table.insert(calledLog, #calledLog)
				end,
			}))
		end)
		jestExpect(calledLog).toEqual({ 0 })
		jestExpect(root.toJSON()).toEqual("1")
	end)
	it("warns if you don't use .act", function()
		local ctr, setCtr

		local function App(props)
			ctr, setCtr = useState(0)

			return ctr
		end

		ReactTestRenderer.create(React.createElement(App))

		jestExpect(function()
			setCtr(1)
		end).toErrorDev({
			"An update to App inside a test was not wrapped in act(...).",
		})
	end)
	describe("async", function()
		it("should work with async/await", function()
			local fetch = Promise.promisify(function(url)
				return Promise.resolve({
					details = { 1, 2, 3 },
				})
			end)
			local function App()
				local details, setDetails = React.useState(0)

				React.useEffect(function()
					local fetchDetails = function()
						return fetch():andThen(function(response)
							setDetails(response.details)
						end)
					end

					fetchDetails()
				end, {})

				return details
			end

			local root

			Promise.try(function()
				act(function()
					root = ReactTestRenderer.create(React.createElement(App))
				end)
			end):await()

			jestExpect(root.toJSON()).toEqual({ "1", "2", "3" })
		end)
		it("should not flush effects without also flushing microtasks", function()
			local alreadyResolvedPromise = Promise.resolve()

			local function App()
				-- This component will keep updating itself until step === 3
				local step, proceed = useReducer(function(s)
					if s == 3 then
						return 3
					end

					return s + 1
				end, 1)

				useEffect(function()
					Scheduler.unstable_yieldValue("Effect")
					alreadyResolvedPromise:andThen(function()
						Scheduler.unstable_yieldValue("Microtask")
						proceed()
					end)
				end)

				return step
			end

			local root = ReactTestRenderer.create(nil)

			Promise.try(function()
				act(function()
					root.update(React.createElement(App))
				end)
			end):await()

			jestExpect(Scheduler).toHaveYielded({
				-- Should not flush effects without also flushing microtasks
				-- First render:
				"Effect",
				"Microtask",
				-- Second render:
				"Effect",
				"Microtask",
				-- Final render:
				"Effect",
				"Microtask",
			})

			jestExpect(root).toMatchRenderedOutput("3")
		end)
	end)
end) ]]
gQ.Children._f5911530c95b354b9b1b06a4f34a9b32=gV
local gW

local gX={ClassName="ModuleScript",Children={},Properties={}}
gX.Name="ReactTestRendererMockPropMarkers.roblox.spec"
gX.Properties.Source=[[ -- Upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-test-renderer/src/__tests__/ReactTestRenderer-test.internal.js
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

-- !strict
local Packages = script.Parent.Parent.Parent

local React
local ReactTestRenderer

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("ReactTestRenderer", function()
	beforeEach(function()
		jest.resetModules()

		React = require(Packages.React)
		ReactTestRenderer = require(Packages.ReactTestRenderer)
	end)
	it("renders a component with React.Change, React.Event, React.Tag props", function()
		local onTextChangedCallback = function() end

		local onActivated = function() end

		local function Link()
			return React.createElement("a", {
				role = "link",
				[React.Change.Text] = onTextChangedCallback,
				[React.Event.Activated] = onActivated,
				[React.Tag] = "componentA",
			})
		end

		local renderer = ReactTestRenderer.create(React.createElement(Link))

		jestExpect(renderer.toJSON()).toEqual({
			type = "a",
			props = {
				role = "link",
				[React.Change.Text] = onTextChangedCallback,
				[React.Event.Activated] = onActivated,
				[React.Tag] = "componentA",
			},
			children = nil,
		})
	end)

	it("Can drive change and event signals from a ref", function()
		local ref = React.createRef()
		local textCallback = jest.fn()
		local clickCallback = jest.fn()

		local RootComponent = React.Component:extend("RootComponent")

		function RootComponent:render()
			return React.createElement("Frame", {}, {
				B = React.createElement("Frame", {
					ref = self.props.childRef,
					[React.Change.Text] = self.props.textCallback,
					[React.Event.Activated] = self.props.clickCallback,
				}),
			})
		end

		local renderer = ReactTestRenderer.create(
			React.createElement(RootComponent, {
				childRef = ref,
				textCallback = textCallback,
				clickCallback = clickCallback,
			}),
			{
				createNodeMock = function(element)
					return element
				end,
			}
		)

		ref.current.props[React.Change.Text]("Changed Text")
		jestExpect(textCallback).toHaveBeenCalledWith("Changed Text")

		ref.current.props[React.Event.Activated]()
		ref.current.props[React.Event.Activated]()
		jestExpect(clickCallback).toHaveBeenCalledTimes(2)

		renderer.unmount()
		jestExpect(ref.current).never.toBeDefined()
	end)

	it("Collects tagged instances", function()
		local renderer = ReactTestRenderer.create(React.createElement("div", {
			Name = "A",
			[React.Tag] = "foo",
			key = "A",
		}, {
			B = React.createElement("div", {
				[React.Tag] = "foo",
			}),
			C = React.createElement("div", {
				[React.Tag] = "bar,foo",
			}),
			D = React.createElement("div", {
				[React.Tag] = "bar,foo",
			}, {
				E = React.createElement("div", {
					[React.Tag] = "bar",
				}),
			}),
		}))

		local barInstances = renderer.getInstancesForTag("bar")
		jestExpect(#barInstances).toEqual(3)

		local fooInstances = renderer.getInstancesForTag("foo")
		jestExpect(#fooInstances).toEqual(4)

		local bazInstances = renderer.getInstancesForTag("baz")
		jestExpect(#bazInstances).toEqual(0)

		-- Should update tags when components update
		renderer.update(React.createElement("div", {
			Name = "A",
			[React.Tag] = "foo",
			key = "A",
		}, {
			B = React.createElement("div", {
				[React.Tag] = "bar,baz",
			}),
			C = React.createElement("div", {
				[React.Tag] = "baz",
			}),
		}))

		fooInstances = renderer.getInstancesForTag("foo")
		jestExpect(#fooInstances).toEqual(1)

		barInstances = renderer.getInstancesForTag("bar")
		jestExpect(#barInstances).toEqual(1)

		bazInstances = renderer.getInstancesForTag("baz")
		jestExpect(#bazInstances).toEqual(2)

		-- Should remove tags when unmounting
		renderer.unmount()
		fooInstances = renderer.getInstancesForTag("foo")
		jestExpect(#fooInstances).toEqual(0)

		barInstances = renderer.getInstancesForTag("bar")
		jestExpect(#barInstances).toEqual(0)

		bazInstances = renderer.getInstancesForTag("baz")
		jestExpect(#bazInstances).toEqual(0)
	end)
end) ]]
gQ.Children._bd385f5cceda4138f3d923a332575d4e=gX
local gY

local gZ={ClassName="ModuleScript",Children={},Properties={}}
gZ.Name="ReactTestRendererTraversal.spec"
gZ.Properties.Source=[[ -- Upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-test-renderer/src/__tests__/ReactTestRendererTraversal-test.js
--!strict
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @emails react-core
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local React
local ReactTestRenderer
local Context
local RCTView = "RCTView"
local View

describe("ReactTestRendererTraversal", function()
	local ExampleFn
	local ExampleNull
	local ExampleSpread
	local ExampleForwardRef

	local Example

	beforeEach(function()
		jest.resetModules()
		React = require(Packages.React)
		View = function(props)
			return React.createElement(RCTView, props)
		end
		ReactTestRenderer = require(Packages.ReactTestRenderer)
		ExampleSpread = React.Component:extend("ExampleSpread")
		Context = React.createContext(nil)

		Example = React.Component:extend("Example")
		function Example:render()
			return React.createElement(
				View,
				nil,
				React.createElement(
					View,
					{
						foo = "foo",
					},
					React.createElement(View, {
						bar = "bar",
					}),
					React.createElement(View, {
						bar = "bar",
						baz = "baz",
						itself = "itself",
					}),
					React.createElement(View),
					React.createElement(ExampleSpread, {
						bar = "bar",
					}),
					React.createElement(ExampleFn, {
						bar = "bar",
						bing = "bing",
					}),
					React.createElement(ExampleNull, {
						bar = "bar",
					}),
					React.createElement(
						ExampleNull,
						{
							null = "null",
						},
						React.createElement(View, {
							void = "void",
						}),
						React.createElement(View, {
							void = "void",
						})
					),
					React.createElement(
						React.Profiler,
						{
							id = "test",
							onRender = function()
								return
							end,
						},
						React.createElement(ExampleForwardRef, {
							qux = "qux",
						})
					),
					React.createElement(
						React.Fragment,
						nil,
						React.createElement(
							React.Fragment,
							nil,
							React.createElement(
								Context.Provider,
								{ value = Object.None },
								React.createElement(Context.Consumer, nil, function()
									return React.createElement(View, { nested = true })
								end)
							)
						),
						React.createElement(View, { nested = true }),
						React.createElement(View, { nested = true })
					)
				)
			)
		end

		function ExampleSpread:render()
			return React.createElement(View, self.props)
		end

		ExampleFn = function(props)
			return React.createElement(View, {
				baz = "baz",
			})
		end
		ExampleNull = function(props)
			return nil
		end
		ExampleForwardRef = React.forwardRef(function(props, ref)
			-- ROBLOX deviation: no easy spread operator, and tests don't demand a generic solution
			return React.createElement(View, { qux = props.qux, ref = ref })
		end)
	end)

	it("initializes", function()
		local render = ReactTestRenderer.create(React.createElement(Example))
		local hasFooProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "foo") ~= nil
		end

		-- assert .props, .type and .parent attributes
		local foo = render.root:find(hasFooProp)

		jestExpect(foo.props.children).toHaveLength(9)
		jestExpect(foo.type).toBe(View)
		jestExpect(render.root.parent).toBe(nil)
		-- ROBLOX FIXME: when this matches upstream, jestExpect takes an hour to complete
		jestExpect(foo.children[1].parent._fiber).toBe(foo._fiber)
	end)
	it("searches via .find() / .findAll()", function()
		local render = ReactTestRenderer.create(React.createElement(Example))
		local hasFooProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "foo") ~= nil
		end
		local hasBarProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "bar") ~= nil
		end
		local hasBazProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "baz") ~= nil
		end
		local hasBingProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "bing") ~= nil
		end
		local hasNullProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "null") ~= nil
		end
		local hasVoidProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "void") ~= nil
		end
		local hasItselfProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "itself") ~= nil
		end
		local hasNestedProp = function(node)
			-- ROBLOX deviation: workaround for hasOwnProperty
			return rawget(node.props, "nested") ~= nil
		end

		jestExpect(function()
			return render.root:find(hasFooProp)
		end).never.toThrow() -- 1 match
		jestExpect(function()
			return render.root:find(hasBarProp)
		end).toThrow() -- >1 matches
		jestExpect(function()
			return render.root:find(hasBazProp)
		end).toThrow() -- >1 matches
		jestExpect(function()
			return render.root:find(hasBingProp)
		end).never.toThrow() -- 1 match
		jestExpect(function()
			return render.root:find(hasNullProp)
		end).never.toThrow() -- 1 match
		jestExpect(function()
			return render.root:find(hasVoidProp)
		end).toThrow() -- 0 matches
		jestExpect(function()
			return render.root:find(hasNestedProp)
		end).toThrow() -- >1 matches

		-- same assertion as :find(), but confirm length
		jestExpect(render.root:findAll(hasFooProp, { deep = false })).toHaveLength(1)
		jestExpect(render.root:findAll(hasBarProp, { deep = false })).toHaveLength(5)
		jestExpect(render.root:findAll(hasBazProp, { deep = false })).toHaveLength(2)
		jestExpect(render.root:findAll(hasBingProp, { deep = false })).toHaveLength(1)
		jestExpect(render.root:findAll(hasNullProp, { deep = false })).toHaveLength(1)
		jestExpect(render.root:findAll(hasVoidProp, { deep = false })).toHaveLength(0)
		jestExpect(render.root:findAll(hasNestedProp, { deep = false })).toHaveLength(3)

		-- note: with {deep: true}, :findAll() will continue to
		--       search children, even after finding a match
		jestExpect(render.root:findAll(hasFooProp)).toHaveLength(2)
		jestExpect(render.root:findAll(hasBarProp)).toHaveLength(9)
		jestExpect(render.root:findAll(hasBazProp)).toHaveLength(4)
		jestExpect(render.root:findAll(hasBingProp)).toHaveLength(1) -- no spread
		jestExpect(render.root:findAll(hasNullProp)).toHaveLength(1) -- no spread
		jestExpect(render.root:findAll(hasVoidProp)).toHaveLength(0)
		jestExpect(render.root:findAll(hasNestedProp, { deep = false })).toHaveLength(3)

		local bing = render.root:find(hasBingProp)

		jestExpect(bing:find(hasBarProp)).toBe(bing)
		jestExpect(bing:find(hasBingProp)).toBe(bing)
		jestExpect(bing:findAll(hasBazProp, { deep = false })).toHaveLength(1)
		jestExpect(bing:findAll(hasBazProp)).toHaveLength(2)

		local foo = render.root:find(hasFooProp)
		jestExpect(foo:findAll(hasFooProp, { deep = false })).toHaveLength(1)
		jestExpect(foo:findAll(hasFooProp)).toHaveLength(2)

		local itself = foo:find(hasItselfProp)

		jestExpect(itself:find(hasBarProp)).toBe(itself)
		jestExpect(itself:find(hasBazProp)).toBe(itself)
		jestExpect(itself:findAll(hasBazProp, { deep = false })).toHaveLength(1)
		jestExpect(itself:findAll(hasBazProp)).toHaveLength(2)
	end)
	it("searches via .findByType() / .findAllByType()", function()
		local render = ReactTestRenderer.create(React.createElement(Example))
		jestExpect(function()
			return render.root:findByType(ExampleFn)
		end).never.toThrow() -- 1 match
		jestExpect(function()
			return render.root:findByType(View)
		end).never.toThrow() -- 1 match

		jestExpect(function()
			return render.root:findByType(ExampleForwardRef)
		end).never.toThrow() -- 1 match

		-- note: there are clearly multiple <View /> in general, but there
		--       is only one being rendered at root node level
		jestExpect(function()
			return render.root:findByType(ExampleNull)
		end).toThrow() -- 2 matches
		jestExpect(#render.root:findAllByType(ExampleFn)).toEqual(1)
		jestExpect(#render.root:findAllByType(View, { deep = false })).toEqual(1)

		jestExpect(#render.root:findAllByType(View)).toEqual(11)

		jestExpect(#render.root:findAllByType(ExampleNull)).toEqual(2)

		jestExpect(#render.root:findAllByType(ExampleForwardRef)).toEqual(1)

		local nulls = render.root:findAllByType(ExampleNull)

		jestExpect(#nulls[1]:findAllByType(View)).toEqual(0)
		jestExpect(#nulls[2]:findAllByType(View)).toEqual(0)

		local fn = render.root:findAllByType(ExampleFn)

		jestExpect(#fn[1]:findAllByType(View)).toEqual(1)
	end)
	it("searches via .findByProps() / .findAllByProps()", function()
		local render = ReactTestRenderer.create(React.createElement(Example))
		local foo = "foo"
		local bar = "bar"
		local baz = "baz"
		local qux = "qux"

		jestExpect(function()
			return render.root:findByProps({ foo = foo })
		end).never.toThrow() -- 1 match
		jestExpect(function()
			return render.root:findByProps({ bar = bar })
		end).toThrow() -- >1 matches
		jestExpect(function()
			return render.root:findByProps({ baz = baz })
		end).toThrow() -- >1 matches

		jestExpect(function()
			return render.root:findByProps({ qux = qux })
		end).never.toThrow() -- 1 match

		jestExpect(render.root:findAllByProps({ foo = foo }, { deep = false })).toHaveLength(
			1
		)
		jestExpect(render.root:findAllByProps({ bar = bar }, { deep = false })).toHaveLength(
			5
		)
		jestExpect(render.root:findAllByProps({ baz = baz }, { deep = false })).toHaveLength(
			2
		)
		jestExpect(render.root:findAllByProps({ qux = qux }, { deep = false })).toHaveLength(
			1
		)

		jestExpect(render.root:findAllByProps({ foo = foo })).toHaveLength(2)
		jestExpect(render.root:findAllByProps({ bar = bar })).toHaveLength(9)
		jestExpect(render.root:findAllByProps({ baz = baz })).toHaveLength(4)
		-- ROBLOX FIXME: this assert currently fails, only gets 1
		jestExpect(render.root:findAllByProps({ qux = qux })).toHaveLength(3)
	end)
	it("skips special nodes", function()
		local render = ReactTestRenderer.create(React.createElement(Example))

		jestExpect(render.root:findAllByType(React.Fragment)).toHaveLength(0)
		jestExpect(render.root:findAllByType(Context.Consumer)).toHaveLength(0)
		jestExpect(render.root:findAllByType(Context.Provider)).toHaveLength(0)

		local expectedParent = render.root:findByProps({
			foo = "foo",
		}, {
			deep = false,
		}).children[1]
		local nestedViews = render.root:findAllByProps(
			{ nested = true },
			{ deep = false }
		)

		jestExpect(#nestedViews).toEqual(3)

		-- ROBLOX FIXME: jest expect take a long time to complete, it needs to be fixed
		jestExpect(nestedViews[1].parent._fiber).toBe(expectedParent._fiber)
		jestExpect(nestedViews[2].parent._fiber).toBe(expectedParent._fiber)
		jestExpect(nestedViews[3].parent._fiber).toBe(expectedParent._fiber)
	end)
	it("can have special nodes as roots", function()
		local FR = React.forwardRef(function(props, ref)
			return React.createElement("section", props)
		end)

		jestExpect(
			#ReactTestRenderer.create(
				React.createElement(
					FR,
					nil,
					React.createElement("div"),
					React.createElement("div")
				)
			).root
				:findAllByType("div")
		).toEqual(2)
		jestExpect(
			#ReactTestRenderer.create(
				React.createElement(
					React.Fragment,
					nil,
					React.createElement("div"),
					React.createElement("div")
				)
			).root
				:findAllByType("div")
		).toEqual(2)
		jestExpect(#ReactTestRenderer.create(React.createElement(React.Fragment, {
			key = "foo",
		}, React.createElement("div", nil), React.createElement("div", nil))).root
			:findAllByType("div")).toEqual(2)
		jestExpect(
			#ReactTestRenderer.create(
				React.createElement(
					React.StrictMode,
					nil,
					React.createElement("div"),
					React.createElement("div")
				)
			).root
				:findAllByType("div")
		).toEqual(2)
		jestExpect(
			#ReactTestRenderer.create(
				React.createElement(
					Context.Provider,
					{ value = Object.None },
					React.createElement("div"),
					React.createElement("div")
				)
			).root
				:findAllByType("div")
		).toEqual(2)
	end)
end) ]]
gQ.Children._7db1203e11f54f984a5a961df66965e6=gZ
local g_

local g0={ClassName="ModuleScript",Children={},Properties={}}
g0.Name="RobloxComponentProps.roblox.spec"
g0.Properties.Source=[[ local Packages = script.Parent.Parent.Parent

local RobloxComponentProps
local setInitialTags
local updateTags
local removeTags
local getInstancesForTag
local Tag

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("TestRenderer Tag Support", function()
	beforeEach(function()
		jest.resetModules()
		RobloxComponentProps = require(script.Parent.Parent.roblox.RobloxComponentProps)
		setInitialTags = RobloxComponentProps.setInitialTags
		updateTags = RobloxComponentProps.updateTags
		removeTags = RobloxComponentProps.removeTags
		getInstancesForTag = RobloxComponentProps.getInstancesForTag
		Tag = require(Packages.Shared).Tag
	end)

	it("should set initial tags for an instance", function()
		local rootContainer = "rootContainer1"
		local hostInstances = {
			{
				props = { [Tag] = "foo" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "foo,bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
		}

		for _, inst in hostInstances do
			setInitialTags(inst, "Instance", inst.props, inst.rootContainerInstance)
		end

		local fooTags = getInstancesForTag(rootContainer, "foo")
		jestExpect(#fooTags).toEqual(2)
		jestExpect(fooTags).toEqual({
			hostInstances[1],
			hostInstances[3],
		})

		local barTags = getInstancesForTag(rootContainer, "bar")
		jestExpect(#barTags).toEqual(3)
		jestExpect(barTags).toEqual({
			hostInstances[2],
			hostInstances[3],
			hostInstances[4],
		})
	end)

	it("should update tags", function()
		local rootContainer = "rootContainer1"
		local hostInstances = {
			{
				props = { [Tag] = "foo" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "foo,bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
		}

		for _, inst in hostInstances do
			setInitialTags(inst, "Instance", inst.props, inst.rootContainerInstance)
		end

		local newProps = {
			{ [Tag] = "foo,bar" },
			{ [Tag] = "baz" },
			{ [Tag] = "baz" },
			{ [Tag] = "bar" },
		}

		for i, inst in hostInstances do
			updateTags(inst, newProps[i], inst.props)
		end

		local fooTags = getInstancesForTag(rootContainer, "foo")
		jestExpect(#fooTags).toEqual(1)
		jestExpect(fooTags).toEqual({
			hostInstances[1],
		})

		local barTags = getInstancesForTag(rootContainer, "bar")
		jestExpect(#barTags).toEqual(2)
		jestExpect(barTags).toEqual({
			hostInstances[4],
			hostInstances[1],
		})

		local bazTags = getInstancesForTag(rootContainer, "baz")
		jestExpect(#bazTags).toEqual(2)
		jestExpect(bazTags).toEqual({
			hostInstances[2],
			hostInstances[3],
		})
	end)

	it("should remove tags", function()
		local rootContainer = "rootContainer1"
		local hostInstances = {
			{
				props = { [Tag] = "foo" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "foo,bar" },
				rootContainerInstance = rootContainer,
			},
			{
				props = { [Tag] = "bar" },
				rootContainerInstance = rootContainer,
			},
		}

		for _, inst in hostInstances do
			setInitialTags(inst, "Instance", inst.props, inst.rootContainerInstance)
		end

		-- Children should have tags removed as well
		hostInstances[1]["children"] = {
			[2] = hostInstances[2],
			[3] = hostInstances[3],
		}

		removeTags(hostInstances[1])

		local fooTags = getInstancesForTag(rootContainer, "foo")
		jestExpect(#fooTags).toEqual(0)

		local barTags = getInstancesForTag(rootContainer, "bar")
		jestExpect(#barTags).toEqual(1)
		jestExpect(barTags).toEqual({
			hostInstances[4],
		})
	end)
end) ]]
gQ.Children._080830ab1ff9b14ed9fa833882adba39=g0
local g1

local g2={ClassName="Folder",Children={},Properties={}}
g2.Name="roblox"
gK.Children._d8f96df3d16ef98ea9d021ef1270c1c8=g2
local g3
local g4={ClassName="ModuleScript",Children={},Properties={}}
g4.Name="RobloxComponentProps"
g4.Properties.Source=[[ local Packages = script.Parent.Parent.Parent

local Shared = require(Packages.Shared)
local LuauPolyfill = require(Packages.LuauPolyfill)

type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>

local Tag = Shared.Tag

local TagManagers = {}

local function setInitialTags(
	hostInstance: any,
	_tag: string,
	rawProps: Object,
	rootContainerElement: any
)
	for key, newValue in rawProps do
		if key == Tag then
			local rootTagManager = TagManagers[rootContainerElement]
			if rootTagManager == nil then
				rootTagManager = {}
				TagManagers[rootContainerElement] = rootTagManager
			end

			local tagSet = string.split(newValue or "", ",")

			for _, newTag in tagSet do
				local instancesForTag = rootTagManager[newTag]
				if instancesForTag == nil then
					instancesForTag = {}
					rootTagManager[newTag] = instancesForTag
				end
				table.insert(instancesForTag, hostInstance)
			end
		end
	end
end

local function updateTags(hostInstance: any, newProps: Object, lastProps: Object)
	for propKey, newValue in newProps do
		if propKey == Tag then
			local rootTagManager = TagManagers[hostInstance.rootContainerInstance]
			if rootTagManager == nil then
				rootTagManager = {}
				TagManagers[hostInstance.rootContainerInstance] = rootTagManager
			end

			local newTagSet = string.split(newValue or "", ",")
			local lastTagSet = string.split(lastProps[Tag] or "", ",")

			for _, lastTag in lastTagSet do
				local existingTagIndex = table.find(newTagSet, lastTag)
				if existingTagIndex == nil then
					local index = table.find(rootTagManager[lastTag], hostInstance)
					table.remove(rootTagManager[lastTag], index)
				else
					table.remove(newTagSet, existingTagIndex)
				end
			end

			for _, newTag in newTagSet do
				local instancesForTag = rootTagManager[newTag]
				if instancesForTag == nil then
					instancesForTag = {}
					rootTagManager[newTag] = instancesForTag
				end
				table.insert(instancesForTag, hostInstance)
			end
		end
	end
end

local function removeTags(hostInstance)
	for _, childInstance in hostInstance.children or {} do
		removeTags(childInstance)
	end

	local rootTagManager = TagManagers[hostInstance.rootContainerInstance]
	if rootTagManager == nil then
		return
	end

	local tagSet = string.split(hostInstance.props[Tag] or "", ",")
	for _, tag in tagSet do
		local instancesForTag = rootTagManager[tag]
		if instancesForTag ~= nil then
			local index = table.find(instancesForTag, hostInstance)
			table.remove(instancesForTag, index)
		end
	end
end

local function getInstancesForTag(rootContainerElement, tag)
	local rootTagManager = TagManagers[rootContainerElement] or {}
	return rootTagManager[tag] or {}
end

local exports = {
	setInitialTags = setInitialTags,
	updateTags = updateTags,
	removeTags = removeTags,
	getInstancesForTag = getInstancesForTag,
}

return exports ]]
g3.Children._45055f99b1b5263bc91135f4849cac11=g4
local g5

local g6={ClassName="ModuleScript",Children={},Properties={}}
g6.Name="RoactCompat"
g6.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
local Packages = script.Parent

local React = require(Packages.React)
local ReactRoblox = require(Packages.ReactRoblox)
local Shared = require(Packages.Shared)

local RoactTree = require(script.RoactTree)

return {
	-- Overlapping contents of public `React` interface
	Component = React.Component,
	PureComponent = React.PureComponent,
	createElement = React.createElement,
	createRef = React.createRef,
	forwardRef = React.forwardRef,
	createContext = React.createContext,
	-- This public interface is aligned but is a deviation in React. It's
	-- necessary to accommodate lua table semantics when merging state
	None = React.None,

	-- Compatibility layer for top-level interface, stands in for `createRoot`
	-- and similar APIs
	mount = RoactTree.mount,
	update = RoactTree.update,
	unmount = RoactTree.unmount,

	-- API compatibility layers to accommodate old interfaces
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	setGlobalConfig = require(script.setGlobalConfig),
	Portal = require(script.Portal),

	-- Compatibility layer for special symbol keys which will be replaced with
	-- reserved prop names in Roact 17
	Ref = "ref",
	-- FIXME: React actually _does_ have a `.Children`, which has different
	-- behavior (none of which overlaps with Roact). Should we keep this as is
	-- and accept that React.Children and RoactCompat.Children will be totally
	-- different things?
	Children = "children",

	-- Event/Change keys for Roact-specific event subscription behavior
	Event = Shared.Event,
	Change = Shared.Change,

	-- Binding interface entry-point for Roact-specific 'bindings' feature
	createBinding = React.createBinding,
	joinBindings = React.joinBindings,

	act = ReactRoblox.act,
} ]]
c.Children._8e5b90eeec4b70beb4b84c5c6344136f=g6
local g7
local g8={ClassName="ModuleScript",Children={},Properties={}}
g8.Name="Portal"
g8.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent
local ReactRoblox = require(Packages.ReactRoblox)

local warnOnce = require(script.Parent.warnOnce)

local function PortalComponent(props)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("Roact.Portal", "Please use the createPortal API on ReactRoblox instead")
	end
	return ReactRoblox.createPortal(props.children, props.target)
end

return PortalComponent ]]
g7.Children._d635a9d429a2c25409ef326b8eff2cd5=g8
local g9

local ha={ClassName="ModuleScript",Children={},Properties={}}
ha.Name="RoactTree"
ha.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
local ReactRoblox = require(Packages.ReactRoblox)
type RootType = ReactRoblox.RootType

local warnOnce = require(script.Parent.warnOnce)

type RoactHandle = {
	root: RootType,
	key: string | number,
	parent: any, -- ROBLOX TODO: Instance?
}

local function mount(element: any, parent: any, key: string?): RoactHandle
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("mount", "Please use the createRoot API in ReactRoblox")
	end

	if parent ~= nil and typeof(parent) ~= "Instance" then
		error(
			string.format(
				"Cannot mount element (`%s`) into a parent that is not a Roblox Instance (got type `%s`) \n%s",
				(function()
					if element then
						return tostring(element.type)
					end
					return "<unknown>"
				end)(),
				typeof(parent),
				(function()
					if parent ~= nil then
						return inspect(parent)
					end
					return ""
				end)()
			)
		)
	end

	-- Since we use portals to actually parent to the provided parent argument,
	-- the container instance that we provide to createRoot is just a
	-- dummy instance.
	local root
	if _G.__ROACT_17_COMPAT_LEGACY_ROOT__ then
		root = ReactRoblox.createLegacyRoot(Instance.new("Folder"))
	else
		root = ReactRoblox.createRoot(Instance.new("Folder"))
	end
	if parent == nil then
		local newParent = Instance.new("Folder")
		newParent.Name = "Target"
		parent = newParent
	end
	if key == nil then
		if _G.__ROACT_17_COMPAT_LEGACY_ROOT__ then
			key = "ReactLegacyRoot"
		else
			key = "ReactRoot"
		end
	end

	-- ROBLOX TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			root:render(ReactRoblox.createPortal({ [key] = element }, parent))
		end)
	else
		root:render(ReactRoblox.createPortal({ [key] = element }, parent))
	end

	return {
		root = root,
		-- To preserve the same key and portal to the same parent on update, we
		-- need to stash them in the opaque "tree" reference returned by `mount`
		parent = parent,
		key = key :: string,
	}
end

local function update(roactHandle: RoactHandle, element)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("update", "Please use the createRoot API in ReactRoblox")
	end

	local key = roactHandle.key
	local parent = roactHandle.parent
	-- ROBLOX TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			roactHandle.root:render(
				ReactRoblox.createPortal({ [key :: string] = element }, parent)
			)
		end)
	else
		roactHandle.root:render(
			ReactRoblox.createPortal({ [key :: string] = element }, parent)
		)
	end

	return roactHandle
end

local function unmount(roactHandle: RoactHandle)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("unmount", "Please use the createRoot API in ReactRoblox")
	end

	-- ROBLOX TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			roactHandle.root:unmount()
		end)
	else
		roactHandle.root:unmount()
	end
end

return {
	mount = mount,
	update = update,
	unmount = unmount,
} ]]
g7.Children._e481bbc383257f38905e890e1798873d=ha
local hb

local hc={ClassName="Folder",Children={},Properties={}}
hc.Name="__tests__"
g7.Children._023bc6385e62336f096ea0069a49cb79=hc
local hd
local he={ClassName="ModuleScript",Children={},Properties={}}
he.Name="RoactCompatibility.spec"
he.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local Roact
local RoactCompat

local UNSUPPORTED = {
	-- Container for features that are unstable in current Roact
	UNSTABLE = true,
	-- Very old aliases for the top-level Roact tree management API
	reify = true,
	reconcile = true,
	teardown = true,
}
beforeEach(function()
	jest.resetModules()
	Roact = require(Packages.Dev.Roact)
	RoactCompat = require(script.Parent.Parent)
end)

it("has all interface members that old Roact exposes", function()
	for k, v in Roact do
		if UNSUPPORTED[k] then
			-- Skip any API members that are well and truly unsupported
			continue
		end

		jestExpect(RoactCompat).toHaveProperty(k)
		local memberType = typeof(v)
		-- Exports common Roact symbol keys as the reserved key names used
		-- by RoactCompat ("ref" and "children", respectively)
		if k == "Ref" or k == "Children" then
			memberType = "string"
		end
		-- Roact.Portal is replaced by ReactRoblox.createPortal. The
		-- latter is a function that returns a portal object, while the
		-- former is a special component type. By implementing Roact.Portal
		-- as a function component that returns `createPortal`'s result, we
		-- can get similar behavior, but with `Roact.Portal` having a
		-- different type.
		if k == "Portal" then
			memberType = "function"
		end
		jestExpect(typeof(RoactCompat[k])).toBe(memberType)
	end
end)

describe("warns about deprecated Roact API features", function()
	it("warns about createFragment", function()
		jestExpect(function()
			RoactCompat.createFragment({ div = RoactCompat.createElement("div") })
		end).toWarnDev(
			"Warning: The legacy Roact API 'createFragment' is deprecated",
			{ withoutStack = true }
		)
	end)

	it("warns about Component:extend() with no args", function()
		jestExpect(function()
			RoactCompat.Component:extend()
		end).toWarnDev(
			"Component:extend() accepting no arguments is deprecated",
			{ withoutStack = true }
		)
	end)

	it("warns about oneChild", function()
		jestExpect(function()
			RoactCompat.oneChild({ RoactCompat.createElement("div") })
		end).toWarnDev(
			"Warning: The legacy Roact API 'oneChild' is deprecated",
			{ withoutStack = true }
		)
	end)

	it("warns about setGlobalConfig", function()
		jestExpect(function()
			RoactCompat.setGlobalConfig({ propValidation = true })
		end).toWarnDev(
			"Warning: The legacy Roact API 'setGlobalConfig' is deprecated",
			{ withoutStack = true }
		)
	end)

	it("warns about Roact.Portal", function()
		local ReactRoblox = require(Packages.ReactRoblox)
		local target = Instance.new("Folder")
		local function withPortal(_props)
			return RoactCompat.createElement(RoactCompat.Portal, {
				target = target,
			}, RoactCompat.createElement("Frame"))
		end
		jestExpect(function()
			local root = ReactRoblox.createLegacyRoot(Instance.new("ScreenGui"))
			root:render(RoactCompat.createElement(withPortal))
		end).toWarnDev("Warning: The legacy Roact API 'Roact.Portal' is deprecated")
	end)

	it("warns about mount", function()
		jestExpect(function()
			RoactCompat.mount(RoactCompat.createElement("TextLabel", { Text = "Foo" }))
		end).toWarnDev({
			"Warning: The legacy Roact API 'mount' is deprecated",
		}, { withoutStack = true })
	end)

	it("warns about mount with invalid instance", function()
		jestExpect(function()
			jestExpect(function()
				RoactCompat.mount(
					RoactCompat.createElement("TextLabel", { Text = "Foo" }),
					"I'm not an instance!"
				)
			end).toWarnDev({
				"Warning: The legacy Roact API 'mount' is deprecated",
			}, { withoutStack = true })
		end).toThrow(
			"Cannot mount element (`TextLabel`) into a parent that is not a Roblox Instance (got type `string`)",
			{ withoutStack = true }
		)

		jestExpect(function()
			jestExpect(function()
				RoactCompat.mount(
					RoactCompat.createElement("Frame"),
					{ bogusParent = true }
				)
			end).toWarnDev({
				"Warning: The legacy Roact API 'mount' is deprecated",
			}, { withoutStack = true })
		end).toThrow(
			"Cannot mount element (`Frame`) into a parent that is not a Roblox Instance (got type `table`) \n{ bogusParent",
			{ withoutStack = true }
		)
	end)

	it("warns about update", function()
		local tree
		jestExpect(function()
			tree = RoactCompat.mount(
				RoactCompat.createElement("TextLabel", { Text = "Foo" })
			)
		end).toWarnDev(
			"Warning: The legacy Roact API 'mount' is deprecated",
			{ withoutStack = true }
		)

		jestExpect(function()
			RoactCompat.update(
				tree,
				RoactCompat.createElement("TextLabel", { Text = "Bar" })
			)
		end).toWarnDev(
			"Warning: The legacy Roact API 'update' is deprecated",
			{ withoutStack = true }
		)
	end)

	it("warns about unmount", function()
		local tree
		jestExpect(function()
			tree = RoactCompat.mount(
				RoactCompat.createElement("TextLabel", { Text = "Foo" })
			)
		end).toWarnDev(
			"Warning: The legacy Roact API 'mount' is deprecated",
			{ withoutStack = true }
		)

		jestExpect(function()
			RoactCompat.unmount(tree)
		end).toWarnDev(
			"Warning: The legacy Roact API 'unmount' is deprecated",
			{ withoutStack = true }
		)
	end)
end)

describe("handles uninitialized state", function()
	it("errors if uninitialized state is assigned", function()
		local ReactRoblox = require(Packages.ReactRoblox)
		local Scheduler = require(Packages.Dev.Scheduler)
		local parent = Instance.new("Folder")
		local Component = RoactCompat.Component:extend("Component")

		function Component:render()
			self.state.foo = "bar"
		end

		local componentInstance = RoactCompat.createElement(Component)
		local root = ReactRoblox.createRoot(parent)

		jestExpect(function()
			root:render(componentInstance)
			Scheduler.unstable_flushAllWithoutAsserting()
		end).toErrorDev(
			"Attempted to directly mutate state. Use setState to assign new values to state."
		)
	end)

	it("warns if uninitialized state is accessed", function()
		local ReactRoblox = require(Packages.ReactRoblox)
		local parent = Instance.new("Folder")
		local Scheduler = require(Packages.Dev.Scheduler)
		local Component = RoactCompat.Component:extend("Component")

		local capturedBool = false

		function Component:render()
			if self.state.foo == nil then
				capturedBool = true
			end
		end

		local componentInstance = RoactCompat.createElement(Component)
		local root = ReactRoblox.createRoot(parent)

		jestExpect(function()
			root:render(componentInstance)
			Scheduler.unstable_flushAllWithoutAsserting()
		end).toWarnDev(
			"Attempted to access uninitialized state. Use setState to initialize state"
		)

		jestExpect(capturedBool).toBe(true)
	end)
end)

describe("ChildArray Keys", function()
	it("Shozuld assign keys to children in an array", function()
		local ReactRoblox = require(Packages.ReactRoblox)
		local parent = Instance.new("Folder")
		local Scheduler = require(Packages.Dev.Scheduler)
		local Component = RoactCompat.Component:extend("Component")

		function Component:render()
			return RoactCompat.createElement("Frame", {}, {
				RoactCompat.createElement("TextLabel", { Text = "one" }),
				RoactCompat.createElement("TextLabel", { Text = "two" }),
				RoactCompat.createElement("TextLabel", { Text = "three" }),
			})
		end

		local componentInstance = RoactCompat.createElement(Component)

		local root = ReactRoblox.createRoot(parent)

		-- We expect this to warn us about the implicit keys even though
		-- it's assigning them to maintain ordering
		jestExpect(function()
			root:render(componentInstance)
			Scheduler.unstable_flushAllWithoutAsserting()
		end).toErrorDev(
			'Warning: Each child in a list should have a unique "key" prop.'
		)

		local firstChild = parent:FindFirstChild(1, true)
		jestExpect(firstChild).toBeDefined()
		jestExpect(firstChild.Text).toEqual("one")

		local secondChild = parent:FindFirstChild(2, true)
		jestExpect(secondChild).toBeDefined()
		jestExpect(secondChild.Text).toEqual("two")

		local thirdChild = parent:FindFirstChild(3, true)
		jestExpect(thirdChild).toBeDefined()
		jestExpect(thirdChild.Text).toEqual("three")
	end)
end) ]]
hd.Children._293cf784afc36c8ad7eaff908d8b1e90=he
local hf

local hg={ClassName="ModuleScript",Children={},Properties={}}
hg.Name="RoactRecursiveLayoutPcallDepth.spec"
hg.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local React
local ReactRoblox
local RoactCompat
local Scheduler

beforeEach(function()
	jest.resetModules()
	RoactCompat = require(script.Parent.Parent)
	ReactRoblox = require(Packages.ReactRoblox)
	Scheduler = require(Packages.Dev.Scheduler)
	React = require(Packages.React)
end)

describe("pcall depth", function()
	-- ROBLOX: we no longer warn, but this test is a good way to programmaitcally create a complex tree
	it("should render even when pcall depth limit is hit", function()
		local function LayoutEffect(props)
			React.useLayoutEffect(function()
				Scheduler.unstable_yieldValue("Layout Effect")
			end)
			return RoactCompat.createElement("TextLabel", { Text = "Layout" })
		end

		local function constructDeepTree(n)
			local constructTreeTable = {
				[1] = function()
					return RoactCompat.createElement(LayoutEffect)
				end,
			}
			for i = 2, 500 do
				constructTreeTable[i] = function()
					return RoactCompat.createElement(constructTreeTable[i - 1])
				end
			end
			return constructTreeTable[n]
		end

		local DeepTree = RoactCompat.createElement(
			"Frame",
			nil,
			RoactCompat.createElement(constructDeepTree(500))
		)

		local instance = Instance.new("Folder")
		local root = ReactRoblox.createRoot(instance)
		jestExpect(function()
			root:render(DeepTree)
			Scheduler.unstable_flushAllWithoutAsserting()
		end).toWarnDev({})
		local children = instance:GetChildren()

		jestExpect(#children).toBe(1)
	end)
end) ]]
hd.Children._237a9546b81eedfdf9bea309355b5140=hg
local hh

local hi={ClassName="ModuleScript",Children={},Properties={}}
hi.Name="RoactTree.spec"
hi.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local afterEach = JestGlobals.afterEach
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local Roact
local RoactCompat

local prevCompatWarnings
beforeEach(function()
	prevCompatWarnings = _G.__COMPAT_WARNINGS__
	-- Silence warnings; we're intersted in functionality in these tests
	_G.__COMPAT_WARNINGS__ = false
end)

afterEach(function()
	_G.__COMPAT_WARNINGS__ = prevCompatWarnings
end)

describe("Concurrent root (default behavior)", function()
	local prevInlineAct, prevMockScheduler
	beforeEach(function()
		prevInlineAct = _G.__ROACT_17_INLINE_ACT__
		prevMockScheduler = _G.__ROACT_17_MOCK_SCHEDULER__
		_G.__ROACT_17_INLINE_ACT__ = true
		_G.__ROACT_17_MOCK_SCHEDULER__ = true
		jest.resetModules()
		Roact = require(Packages.Dev.Roact)
		RoactCompat = require(script.Parent.Parent)
	end)

	afterEach(function()
		_G.__ROACT_17_INLINE_ACT__ = prevInlineAct
		_G.__ROACT_17_MOCK_SCHEDULER__ = prevMockScheduler
	end)

	it("should create an orphaned instance to mount under if none is provided", function()
		local ref = RoactCompat.createRef()
		local tree = RoactCompat.mount(RoactCompat.createElement("Frame", { ref = ref }))

		jestExpect(ref.current).never.toBeNil()
		jestExpect(ref.current.Parent).never.toBeNil()
		jestExpect(ref.current.Parent.ClassName).toBe("Folder")

		jestExpect(ref.current.Name).toBe("ReactRoot")

		RoactCompat.unmount(tree)
	end)

	it("should name children using the key", function()
		local legacyTarget = Instance.new("Folder")
		local legacyTree =
			Roact.mount(Roact.createElement("Frame"), legacyTarget, "SameNameTree")

		local compatTarget = Instance.new("Folder")
		local compatTree = RoactCompat.mount(
			RoactCompat.createElement("Frame"),
			compatTarget,
			"SameNameTree"
		)

		local legacyRootInstance = legacyTarget:FindFirstChildWhichIsA("Frame")
		jestExpect(legacyRootInstance).never.toBeNil()
		local compatRootInstance = compatTarget:FindFirstChildWhichIsA("Frame")
		jestExpect(compatRootInstance).never.toBeNil()

		jestExpect(legacyRootInstance.Name).toEqual(compatRootInstance.Name)
		jestExpect(compatRootInstance.Name).toBe("SameNameTree")

		Roact.unmount(legacyTree)
		RoactCompat.unmount(compatTree)
	end)

	it("keeps the same root name on update", function()
		local legacyTarget = Instance.new("Folder")
		local legacyTree =
			Roact.mount(Roact.createElement("Frame"), legacyTarget, "SameNameTree")

		local compatTarget = Instance.new("Folder")
		local compatTree = RoactCompat.mount(
			RoactCompat.createElement("Frame"),
			compatTarget,
			"SameNameTree"
		)

		local legacyRootInstance = legacyTarget:FindFirstChildWhichIsA("Frame")
		jestExpect(legacyRootInstance.Name).toBe("SameNameTree")
		local compatRootInstance = compatTarget:FindFirstChildWhichIsA("Frame")
		jestExpect(compatRootInstance.Name).toBe("SameNameTree")

		Roact.update(legacyTree, Roact.createElement("TextLabel"))
		RoactCompat.update(compatTree, RoactCompat.createElement("TextLabel"))

		legacyRootInstance = legacyTarget:FindFirstChildWhichIsA("TextLabel")
		jestExpect(legacyRootInstance.Name).toBe("SameNameTree")
		compatRootInstance = compatTarget:FindFirstChildWhichIsA("TextLabel")
		jestExpect(compatRootInstance.Name).toBe("SameNameTree")

		Roact.unmount(legacyTree)
		RoactCompat.unmount(compatTree)
	end)

	it("should not clear out other children of the target", function()
		local compatTarget = Instance.new("Folder")

		local preexistingChild = Instance.new("Frame")
		preexistingChild.Name = "PreexistingChild"
		preexistingChild.Parent = compatTarget

		local compatTree = RoactCompat.mount(
			RoactCompat.createElement("TextLabel"),
			compatTarget,
			"RoactTree"
		)

		local compatRootInstance = compatTarget:FindFirstChildWhichIsA("TextLabel")
		jestExpect(compatRootInstance.Name).toBe("RoactTree")

		local existingChild = compatTarget:FindFirstChildWhichIsA("Frame")
		jestExpect(existingChild.Name).toBe("PreexistingChild")

		RoactCompat.unmount(compatTree)
	end)
end)

describe("Legacy root", function()
	local previousGlobalValue
	beforeEach(function()
		previousGlobalValue = _G.__ROACT_17_COMPAT_LEGACY_ROOT__
		_G.__ROACT_17_COMPAT_LEGACY_ROOT__ = true
		jest.resetModules()
		Roact = require(Packages.Dev.Roact)
		RoactCompat = require(script.Parent.Parent)
	end)

	afterEach(function()
		_G.__ROACT_17_COMPAT_LEGACY_ROOT__ = previousGlobalValue
	end)

	it("should create an orphaned instance to mount under if none is provided", function()
		local ref = RoactCompat.createRef()
		local tree = RoactCompat.mount(RoactCompat.createElement("Frame", { ref = ref }))

		jestExpect(ref.current).never.toBeNil()
		jestExpect(ref.current.Parent).never.toBeNil()
		jestExpect(ref.current.Parent.ClassName).toBe("Folder")

		jestExpect(ref.current.Name).toBe("ReactLegacyRoot")

		RoactCompat.unmount(tree)
	end)
end) ]]
hd.Children._2bd4dbaec2e92eb2b5a4a89f79ce4f2f=hi
local hj

local hk={ClassName="ModuleScript",Children={},Properties={}}
hk.Name="act.spec"
hk.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local afterEach = JestGlobals.afterEach
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local RoactCompat

describe("production mode", function()
	local prevMockScheduler
	beforeEach(function()
		prevMockScheduler = _G.__ROACT_17_MOCK_SCHEDULER__
		_G.__ROACT_17_MOCK_SCHEDULER__ = nil
		jest.resetModules()
		RoactCompat = require(script.Parent.Parent)
	end)

	it("disallows use of 'act'", function()
		jest.resetModules()
		RoactCompat = require(script.Parent.Parent)

		jestExpect(function()
			RoactCompat.act(function()
				RoactCompat.mount(RoactCompat.createElement("TextLabel"))
			end)
		end).toThrow(
			"ReactRoblox.act is only available in testing environments, "
				.. "not production. Enable the `__ROACT_17_MOCK_SCHEDULER__` "
				.. "global in your test configuration in order to use `act`."
		)
	end)

	afterEach(function()
		_G.__ROACT_17_MOCK_SCHEDULER__ = prevMockScheduler
	end)
end)

describe("test mode", function()
	local prevMockScheduler
	beforeEach(function()
		prevMockScheduler = _G.__ROACT_17_MOCK_SCHEDULER__
		_G.__ROACT_17_MOCK_SCHEDULER__ = true
		jest.resetModules()
		RoactCompat = require(script.Parent.Parent)
	end)

	it("allows use of 'act'", function()
		jest.resetModules()
		RoactCompat = require(script.Parent.Parent)

		local parent = Instance.new("Folder")
		local tree
		jestExpect(function()
			jestExpect(function()
				RoactCompat.act(function()
					tree =
						RoactCompat.mount(RoactCompat.createElement("TextLabel"), parent)
				end)
			end).toWarnDev("'mount' is deprecated", { withoutStack = true })
		end).never.toThrow()

		jestExpect(parent:FindFirstChildWhichIsA("TextLabel")).toBeDefined()
		jestExpect(function()
			jestExpect(function()
				RoactCompat.act(function()
					RoactCompat.unmount(tree)
				end)
			end).toWarnDev("'unmount' is deprecated", { withoutStack = true })
		end).never.toThrow()

		jestExpect(parent:FindFirstChildWhichIsA("TextLabel")).toBeNil()
	end)

	afterEach(function()
		_G.__ROACT_17_MOCK_SCHEDULER__ = prevMockScheduler
	end)
end) ]]
hd.Children._14220cb3d262642f6347854c94add5ee=hk
local hl

local hm={ClassName="ModuleScript",Children={},Properties={}}
hm.Name="warnOnce.spec"
hm.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest
local warnOnce

beforeEach(function()
	jest.resetModules()
	warnOnce = require(script.Parent.Parent.warnOnce)
end)

it("warns exactly once", function()
	jestExpect(function()
		warnOnce("oldAPI", "Foo")
	end).toWarnDev(
		"Warning: The legacy Roact API 'oldAPI' is deprecated, and will be "
			.. "removed in a future release.\n\nFoo",
		{ withoutStack = true }
	)

	jestExpect(function()
		warnOnce("oldAPI", "Foo")
	end).toWarnDev({})
end) ]]
hd.Children._f942b50c15f123a428918d1f5bc027bd=hm
local hn

local ho={ClassName="ModuleScript",Children={},Properties={}}
ho.Name="createFragment"
ho.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
local Packages = script.Parent.Parent
local React = require(Packages.React)

local warnOnce = require(script.Parent.warnOnce)

return function(elements)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce(
			"createFragment",
			"Please instead use:\n\tReact.createElement(React.Fragment, ...)"
		)
	end
	return React.createElement(React.Fragment, nil, elements)
end ]]
g7.Children._3507a8773311f51164154a254d7eebd8=ho
local hp

local hq={ClassName="ModuleScript",Children={},Properties={}}
hq.Name="oneChild"
hq.Properties.Source=[[ -- ROBLOX upstream: https://github.com/Roblox/roact/blob/master/src/oneChild.lua
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
local Packages = script.Parent.Parent
local React = require(Packages.React)

local warnOnce = require(script.Parent.warnOnce)

local function oneChild(children)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce(
			"oneChild",
			"You likely don't need this at all! If you were assigning children "
				.. "via `React.oneChild(someChildren)`, you can simply use "
				.. "`someChildren` directly."
		)
	end

	-- This behavior is a bit different from upstream, so we're adapting current
	-- Roact's logic (which will unwrap a table with a single member)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most one child, had more than one child.", 2)
	end

	return React.Children.only(child)
end

return oneChild ]]
g7.Children._2a74813ba9326db696179198e2824064=hq
local hr

local hs={ClassName="ModuleScript",Children={},Properties={}}
hs.Name="setGlobalConfig"
hs.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local warnOnce = require(script.Parent.warnOnce)

return function(_config)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce(
			"setGlobalConfig",
			"Roact 17 uses a `_G.__DEV__` flag to enable development behavior. "
				.. "If you're seeing this warning, you already have it enabled. "
				.. "Please remove any redundant uses of `setGlobalConfig`."
		)
	end
	-- No equivalent behavior can be applied here
end ]]
g7.Children._02e8457cc91b10736412ea2e4f744edf=hs
local ht

local hu={ClassName="ModuleScript",Children={},Properties={}}
hu.Name="warnOnce"
hu.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent
local console = require(Packages.Shared).console

local warnedAbout = {}

local function warnOnce(name: string, message: string)
	if not warnedAbout[name] then
		console.warn(
			"The legacy Roact API '%s' is deprecated, and will be removed "
				.. "in a future release.\n\n%s",
			name,
			message
		)
	end
	warnedAbout[name] = true
end

return warnOnce ]]
g7.Children._3001c964c76e5c742b832a14f4120b54=hu
local hv

local hw={ClassName="ModuleScript",Children={},Properties={}}
hw.Name="Scheduler"
hw.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/scheduler/index.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local initializeScheduler = require(script.Scheduler)

local function onlyInTestError(functionName: string)
	return function()
		error(functionName .. " is only available in tests, not in production")
	end
end

local Scheduler = initializeScheduler(nil --\[\[ no host config, use default \]\])
local Tracing = require(script.Tracing)
local TracingSubscriptions = require(script.TracingSubscriptions)
-- ROBLOX deviation export Tracing type from the package exports to avoid direct file access
export type Interaction = Tracing.Interaction

-- Enables `act` to use mock scheduling logic when running tests. Since there
-- are numerous testing scenarios in which we call `require` on the Roact
-- library _before_ we bootstrap tests, we expose an additional global to toggle
-- this explicilty
if _G.__ROACT_17_MOCK_SCHEDULER__ then
	return require(script.unstable_mock)
end

local exports = {
	unstable_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
	unstable_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
	unstable_NormalPriority = Scheduler.unstable_NormalPriority,
	unstable_IdlePriority = Scheduler.unstable_IdlePriority,
	unstable_LowPriority = Scheduler.unstable_LowPriority,
	unstable_runWithPriority = Scheduler.unstable_runWithPriority,
	unstable_next = Scheduler.unstable_next,
	unstable_scheduleCallback = Scheduler.unstable_scheduleCallback,
	unstable_cancelCallback = Scheduler.unstable_cancelCallback,
	unstable_wrapCallback = Scheduler.unstable_wrapCallback,
	unstable_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
	unstable_shouldYield = Scheduler.unstable_shouldYield,
	unstable_requestPaint = Scheduler.unstable_requestPaint,
	unstable_continueExecution = Scheduler.unstable_continueExecution,
	unstable_pauseExecution = Scheduler.unstable_pauseExecution,
	unstable_getFirstCallbackNode = Scheduler.unstable_getFirstCallbackNode,
	unstable_now = Scheduler.unstable_now,
	unstable_forceFrameRate = Scheduler.unstable_forceFrameRate,
	unstable_flushAllWithoutAsserting = onlyInTestError(
		"unstable_flushAllWithoutAsserting"
	) :: any,
	unstable_flushAll = onlyInTestError("unstable_flushAll"),
	unstable_flushNumberOfYields = onlyInTestError("unstable_flushNumberOfYields"),
	unstable_clearYields = onlyInTestError("unstable_clearYields") :: any,
	unstable_flushUntilNextPaint = onlyInTestError("unstable_clearYields"),
	unstable_advanceTime = onlyInTestError("unstable_advanceTime"),
	unstable_flushExpired = onlyInTestError("unstable_flushExpired"),
	unstable_yieldValue = onlyInTestError("unstable_yieldValue"),

	tracing = {
		unstable_wrap = onlyInTestError("unstable_wrap"),
		__interactionsRef = {},
		__subscriberRef = {},
	},
}

-- ROBLOX FIXME Luau: need to fix CLI-56768 to remove any cast
for k, v in Tracing :: any do
	exports.tracing[k] = v
end
for k, v in TracingSubscriptions :: any do
	exports.tracing[k] = v
end

return exports ]]
c.Children._4ee41f372a3b678914df790af875b785=hw
local hx
local hy={ClassName="ModuleScript",Children={},Properties={}}
hy.Name="Scheduler"
hy.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/Scheduler.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
\]\]

-- ROBLOX deviation: return an initializer function instead of the module itself
-- for easier dependency injection with unstable_mock
return function(hostConfig)
	local Packages = script.Parent.Parent
	local describeError = require(Packages.Shared).describeError

	local SchedulerFeatureFlags = require(script.Parent.SchedulerFeatureFlags)
	local enableSchedulerDebugging = SchedulerFeatureFlags.enableSchedulerDebugging
	local enableProfiling = SchedulerFeatureFlags.enableProfiling

	local SchedulerHostConfig = hostConfig or require(script.Parent.SchedulerHostConfig)
	local requestHostCallback = SchedulerHostConfig.requestHostCallback
	local requestHostTimeout = SchedulerHostConfig.requestHostTimeout
	local cancelHostTimeout = SchedulerHostConfig.cancelHostTimeout
	local shouldYieldToHost = SchedulerHostConfig.shouldYieldToHost
	local getCurrentTime = SchedulerHostConfig.getCurrentTime
	local forceFrameRate = SchedulerHostConfig.forceFrameRate
	local requestPaint = SchedulerHostConfig.requestPaint

	-- ROBLOX deviation? inline the MinHeap to see if the module-level visibility lets Luau optimize better
	-- local SchedulerMinHeap = require(script.Parent.SchedulerMinHeap)
	-- local push = SchedulerMinHeap.push
	-- local peek = SchedulerMinHeap.peek
	-- local pop = SchedulerMinHeap.pop
	type Heap = { [number]: Node? }
	type Node = {
		id: number,
		sortIndex: number,
	}

	-- ROBLOX deviation: This file contains several workarounds for Luau analysis issues by using the `::` operator
	local compare, siftUp, siftDown

	local push = function(heap: Heap, node: Node): ()
		local index = #heap + 1
		heap[index] = node

		siftUp(heap, node, index)
	end

	local peek = function(heap: Heap): Node?
		return heap[1]
	end

	local pop = function(heap: Heap): Node?
		local first = heap[1]
		if first ~= nil then
			local last = heap[#heap]
			heap[#heap] = nil

			if last :: Node ~= first :: Node then
				heap[1] = last
				siftDown(heap, last :: Node, 1)
			end
			return first
		else
			return nil
		end
	end

	siftUp = function(heap: Heap, node: Node, index: number): ()
		while true do
			local parentIndex = math.floor(index / 2)
			local parent = heap[parentIndex]
			if parent ~= nil and compare(parent :: Node, node :: Node) > 0 then
				-- The parent is larger. Swap positions.
				heap[parentIndex] = node
				heap[index] = parent
				index = parentIndex
			else
				-- The parent is smaller. Exit.
				return
			end
		end
	end

	siftDown = function(heap: Heap, node: Node, index: number): ()
		local length = #heap
		while index < length do
			local leftIndex = index * 2
			local left = heap[leftIndex]
			local rightIndex = leftIndex + 1
			local right = heap[rightIndex]

			-- If the left or right node is smaller, swap with the smaller of those.
			if left ~= nil and compare(left :: Node, node) < 0 then
				if right ~= nil and compare(right :: Node, left :: Node) < 0 then
					heap[index] = right
					heap[rightIndex] = node
					index = rightIndex
				else
					heap[index] = left
					heap[leftIndex] = node
					index = leftIndex
				end
			elseif right ~= nil and compare(right :: Node, node :: Node) < 0 then
				heap[index] = right
				heap[rightIndex] = node
				index = rightIndex
			else
				-- Neither child is smaller. Exit.
				return
			end
		end
	end

	compare = function(a: Node, b: Node): number
		-- Compare sort index first, then task id.
		local diff = a.sortIndex - b.sortIndex

		if diff == 0 then
			return a.id - b.id
		end

		return diff
	end

	-- TODO: Use symbols?
	local SchedulerPriorities = require(script.Parent.SchedulerPriorities)
	local ImmediatePriority = SchedulerPriorities.ImmediatePriority
	local UserBlockingPriority = SchedulerPriorities.UserBlockingPriority
	local NormalPriority = SchedulerPriorities.NormalPriority
	local LowPriority = SchedulerPriorities.LowPriority
	local IdlePriority = SchedulerPriorities.IdlePriority

	local SchedulerProfiling = require(script.Parent.SchedulerProfiling)
	local markTaskRun = SchedulerProfiling.markTaskRun
	local markTaskYield = SchedulerProfiling.markTaskYield
	local markTaskCompleted = SchedulerProfiling.markTaskCompleted
	local markTaskCanceled = SchedulerProfiling.markTaskCanceled
	local markTaskErrored = SchedulerProfiling.markTaskErrored
	local markSchedulerSuspended = SchedulerProfiling.markSchedulerSuspended
	local markSchedulerUnsuspended = SchedulerProfiling.markSchedulerUnsuspended
	local markTaskStart = SchedulerProfiling.markTaskStart
	local stopLoggingProfilingEvents = SchedulerProfiling.stopLoggingProfilingEvents
	local startLoggingProfilingEvents = SchedulerProfiling.startLoggingProfilingEvents

	-- Max 31 bit integer. The max integer size in V8 for 32-bit systems.
	-- Math.pow(2, 30) - 1
	-- 0b111111111111111111111111111111
	local maxSigned31BitInt = 1073741823

	-- Times out immediately
	local IMMEDIATE_PRIORITY_TIMEOUT = -1
	-- Eventually times out
	local USER_BLOCKING_PRIORITY_TIMEOUT = 250
	local NORMAL_PRIORITY_TIMEOUT = 5000
	local LOW_PRIORITY_TIMEOUT = 10000
	-- Never times out
	local IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt

	-- Tasks are stored on a min heap
	local taskQueue = {}
	local timerQueue = {}

	-- Incrementing id counter. Used to maintain insertion order.
	local taskIdCounter = 1

	-- Pausing the scheduler is useful for debugging.
	local isSchedulerPaused = false

	local currentTask = nil
	local currentPriorityLevel = NormalPriority

	-- This is set while performing work, to prevent re-entrancy.
	local isPerformingWork = false

	local isHostCallbackScheduled = false
	local isHostTimeoutScheduled = false

	-- deviation: Preemptively declare these functions so that Lua understands them
	local handleTimeout, flushWork, workLoop

	local function advanceTimers(currentTime)
		-- Check for tasks that are no longer delayed and add them to the queue.
		local timer = peek(timerQueue)

		while timer ~= nil do
			if timer.callback == nil then
				-- Timer was cancelled, remove from queue
				pop(timerQueue)
			elseif timer.startTime <= currentTime then
				-- Timer fired. Transfer to the task queue.
				pop(timerQueue)
				timer.sortIndex = timer.expirationTime
				push(taskQueue, timer)
				if enableProfiling then
					markTaskStart(timer, currentTime)
					timer.isQueued = true
				end
			else
				-- Remaining timers are pending.
				return
			end

			timer = peek(timerQueue)
		end
	end

	handleTimeout = function(currentTime)
		isHostTimeoutScheduled = false
		advanceTimers(currentTime)

		if not isHostCallbackScheduled then
			if peek(taskQueue) ~= nil then
				isHostCallbackScheduled = true
				requestHostCallback(flushWork)
			else
				local firstTimer = peek(timerQueue)
				if firstTimer ~= nil then
					requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
				end
			end
		end
	end

	flushWork = function(hasTimeRemaining, initialTime)
		if enableProfiling then
			markSchedulerUnsuspended(initialTime)
		end

		-- We'll need a host callback the next time work is scheduled.
		isHostCallbackScheduled = false
		if isHostTimeoutScheduled then
			-- We scheduled a timeout but it's no longer needed. Cancel it.
			isHostTimeoutScheduled = false
			cancelHostTimeout()
		end

		isPerformingWork = true
		local previousPriorityLevel = currentPriorityLevel

		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			-- ROBLOX performance: don't nest try/catch here, Lua can do better, and it eliminated an anon function creation
			if enableProfiling then
				ok, result =
					xpcall(workLoop, describeError, hasTimeRemaining, initialTime)

				if not ok then
					if currentTask ~= nil then
						local currentTime = getCurrentTime()
						markTaskErrored(currentTask, currentTime)
						currentTask.isQueued = false
					end
				end
			else
				-- No catch in prod code path.
				ok = true
				result = workLoop(hasTimeRemaining, initialTime)
			end
		else
			ok = true
			result = workLoop(hasTimeRemaining, initialTime)
		end

		-- ROBLOX: finally
		currentTask = nil
		currentPriorityLevel = previousPriorityLevel
		isPerformingWork = false
		if enableProfiling then
			local currentTime = getCurrentTime()
			markSchedulerSuspended(currentTime)
		end

		if not ok then
			error(result)
		end

		return result
	end

	workLoop = function(hasTimeRemaining, initialTime)
		local currentTime = initialTime
		advanceTimers(currentTime)
		currentTask = peek(taskQueue)
		while
			currentTask ~= nil and not (enableSchedulerDebugging and isSchedulerPaused)
		do
			if
				currentTask.expirationTime > currentTime
				and (not hasTimeRemaining or shouldYieldToHost())
			then
				-- This currentTask hasn't expired, and we've reached the deadline.
				break
			end

			local callback = currentTask.callback
			if typeof(callback) == "function" then
				currentTask.callback = nil
				currentPriorityLevel = currentTask.priorityLevel
				local didUserCallbackTimeout = currentTask.expirationTime <= currentTime
				markTaskRun(currentTask, currentTime)
				local continuationCallback = callback(didUserCallbackTimeout)
				currentTime = getCurrentTime()
				if typeof(continuationCallback) == "function" then
					currentTask.callback = continuationCallback
					markTaskYield(currentTask, currentTime)
				else
					if enableProfiling then
						markTaskCompleted(currentTask, currentTime)
						currentTask.isQueued = false
					end

					if currentTask == peek(taskQueue) then
						pop(taskQueue)
					end
				end
				advanceTimers(currentTime)
			else
				pop(taskQueue)
			end

			currentTask = peek(taskQueue)
		end

		-- Return whether there's additional work
		if currentTask ~= nil then
			return true
		else
			local firstTimer = peek(timerQueue)
			if firstTimer ~= nil then
				requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
			end

			return false
		end
	end

	local function unstable_runWithPriority(priorityLevel, eventHandler)
		if
			priorityLevel == ImmediatePriority
			or priorityLevel == UserBlockingPriority
			or priorityLevel == NormalPriority
			or priorityLevel == LowPriority
			or priorityLevel == IdlePriority
		then
			-- Leave priority alone if assigned
		else
			priorityLevel = NormalPriority
		end

		local previousPriorityLevel = currentPriorityLevel
		currentPriorityLevel = priorityLevel

		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			ok, result = xpcall(eventHandler, describeError)
		else
			ok = true
			result = eventHandler()
		end

		-- ROBLOX: finally
		currentPriorityLevel = previousPriorityLevel

		if not ok then
			error(result)
		end

		return result
	end

	local function unstable_next(eventHandler)
		local priorityLevel
		if
			currentPriorityLevel == ImmediatePriority
			or currentPriorityLevel == UserBlockingPriority
			or currentPriorityLevel == NormalPriority
		then
			-- Shift down to normal priority
			priorityLevel = NormalPriority
		else
			-- Anything lower than normal priority should remain at the current level.
			priorityLevel = currentPriorityLevel
		end

		local previousPriorityLevel = currentPriorityLevel
		currentPriorityLevel = priorityLevel

		-- ROBLOX deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			ok, result = xpcall(eventHandler, describeError)
		else
			ok = true
			result = eventHandler()
		end

		-- ROBLOX: finally
		currentPriorityLevel = previousPriorityLevel

		if not ok then
			error(result)
		end

		return result
	end

	local function unstable_wrapCallback(callback)
		local parentPriorityLevel = currentPriorityLevel

		return function(...)
			-- This is a fork of runWithPriority, inlined for performance.
			local previousPriorityLevel = currentPriorityLevel
			currentPriorityLevel = parentPriorityLevel

			-- ROBLOX deviation: YOLO flag for disabling pcall
			local ok, result
			if not _G.__YOLO__ then
				ok, result = xpcall(callback, describeError, ...)
			else
				ok = true
				result = callback(...)
			end

			-- ROBLOX: finally
			currentPriorityLevel = previousPriorityLevel

			if not ok then
				error(result)
			end

			return result
		end
	end

	local function unstable_scheduleCallback(priorityLevel, callback, options)
		local currentTime = getCurrentTime()

		local startTime

		if typeof(options) == "table" then
			local delay_ = options.delay
			if typeof(delay_) == "number" and delay_ > 0 then
				startTime = currentTime + delay_
			else
				startTime = currentTime
			end
		else
			startTime = currentTime
		end

		local timeout
		if priorityLevel == ImmediatePriority then
			timeout = IMMEDIATE_PRIORITY_TIMEOUT
		elseif priorityLevel == UserBlockingPriority then
			timeout = USER_BLOCKING_PRIORITY_TIMEOUT
		elseif priorityLevel == IdlePriority then
			timeout = IDLE_PRIORITY_TIMEOUT
		elseif priorityLevel == LowPriority then
			timeout = LOW_PRIORITY_TIMEOUT
		else
			timeout = NORMAL_PRIORITY_TIMEOUT
		end

		local expirationTime = startTime + timeout

		local newTask = {
			id = taskIdCounter,
			callback = callback,
			priorityLevel = priorityLevel,
			startTime = startTime,
			expirationTime = expirationTime,
			sortIndex = -1,
		}
		taskIdCounter += 1

		if enableProfiling then
			newTask.isQueued = false
		end

		if startTime > currentTime then
			-- This is a delayed task.
			newTask.sortIndex = startTime
			push(timerQueue, newTask)
			-- TODO(align): VALIDATE conversion from `peek(taskQueue) === null && newTask === peek(timerQueue)`
			if #taskQueue == 0 and newTask == peek(timerQueue) then
				-- All tasks are delayed, and this is the task with the earliest delay.
				if isHostTimeoutScheduled then
					-- Cancel an existing timeout.
					cancelHostTimeout()
				else
					isHostTimeoutScheduled = true
				end
				-- Schedule a timeout.
				requestHostTimeout(handleTimeout, startTime - currentTime)
			end
		else
			newTask.sortIndex = expirationTime
			push(taskQueue, newTask)
			if enableProfiling then
				markTaskStart(newTask, currentTime)
				newTask.isQueued = true
			end

			-- Schedule a host callback, if needed. If we're already performing work,
			-- wait until the next time we yield.
			if not isHostCallbackScheduled and not isPerformingWork then
				isHostCallbackScheduled = true
				requestHostCallback(flushWork)
			end
		end

		return newTask
	end

	local function unstable_pauseExecution()
		isSchedulerPaused = true
	end

	local function unstable_continueExecution()
		isSchedulerPaused = false
		if not isHostCallbackScheduled and not isPerformingWork then
			isHostCallbackScheduled = true
			requestHostCallback(flushWork)
		end
	end

	local function unstable_getFirstCallbackNode()
		return peek(taskQueue)
	end

	local function unstable_cancelCallback(task)
		if enableProfiling then
			if task.isQueued then
				local currentTime = getCurrentTime()
				markTaskCanceled(task, currentTime)
				task.isQueued = false
			end
		end

		-- Null out the callback to indicate the task has been canceled. (Can't
		-- remove from the queue because you can't remove arbitrary nodes from an
		-- array based heap, only the first one.)
		task.callback = nil
	end

	local function unstable_getCurrentPriorityLevel()
		return currentPriorityLevel
	end

	local unstable_requestPaint = requestPaint

	return {
		unstable_ImmediatePriority = ImmediatePriority,
		unstable_UserBlockingPriority = UserBlockingPriority,
		unstable_NormalPriority = NormalPriority,
		unstable_IdlePriority = IdlePriority,
		unstable_LowPriority = LowPriority,
		unstable_runWithPriority = unstable_runWithPriority,
		unstable_next = unstable_next,
		unstable_scheduleCallback = unstable_scheduleCallback,
		unstable_cancelCallback = unstable_cancelCallback,
		unstable_wrapCallback = unstable_wrapCallback,
		unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel,
		unstable_shouldYield = shouldYieldToHost,
		unstable_requestPaint = unstable_requestPaint,
		unstable_continueExecution = unstable_continueExecution,
		unstable_pauseExecution = unstable_pauseExecution,
		unstable_getFirstCallbackNode = unstable_getFirstCallbackNode,
		unstable_now = getCurrentTime,
		unstable_forceFrameRate = forceFrameRate,
		-- ROBLOX TODO: use if-expressions when all clients are on 503+
		unstable_Profiling = (function()
			if enableProfiling then
				return {
					startLoggingProfilingEvents = startLoggingProfilingEvents,
					stopLoggingProfilingEvents = stopLoggingProfilingEvents,
				}
			end
			return nil
		end)(),
	}
end ]]
hx.Children._c9680b481fe99f91cd643d913e4f24d5=hy
local hz

local hA={ClassName="ModuleScript",Children={},Properties={}}
hA.Name="SchedulerFeatureFlags"
hA.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/SchedulerFeatureFlags.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
\]\]

return {
	enableSchedulerDebugging = false,
	enableIsInputPending = false,
	enableProfiling = _G.__PROFILE__,
} ]]
hx.Children._12834140f7b2388aae294d79bd769439=hA
local hB

local hC={ClassName="ModuleScript",Children={},Properties={}}
hC.Name="SchedulerHostConfig"
hC.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/00748c53e183952696157088a858352cc77b0010/packages/scheduler/src/SchedulerHostConfig.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

-- deviation: In React, this module throws an error and is expected to be
-- replaced via a bundler. In our case, we mock it explicitly when we need to
-- mock it, and return the "default" here
return require(script.Parent.forks["SchedulerHostConfig.default"]) ]]
hx.Children._ae2d0fbb5ec6ef9256662676f8c3bfea=hC
local hD

local hE={ClassName="ModuleScript",Children={},Properties={}}
hE.Name="SchedulerMinHeap"
hE.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/e706721490e50d0bd6af2cd933dbf857fd8b61ed/packages/scheduler/src/SchedulerMinHeap.js
--!strict
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

type Heap = { [number]: Node? }
type Node = {
	id: number,
	sortIndex: number,
}

local exports = {}
-- ROBLOX deviation: This file contains several workarounds for Luau analysis issues by using the `::` operator
local compare, siftUp, siftDown

exports.push = function(heap: Heap, node: Node): ()
	local index = #heap + 1
	heap[index] = node

	siftUp(heap, node, index)
end

exports.peek = function(heap: Heap): Node?
	return heap[1]
end

exports.pop = function(heap: Heap): Node?
	local first = heap[1]
	if first ~= nil then
		local last = heap[#heap]
		heap[#heap] = nil

		if last :: Node ~= first :: Node then
			heap[1] = last
			siftDown(heap, last :: Node, 1)
		end
		return first
	else
		return nil
	end
end

siftUp = function(heap: Heap, node: Node, index: number): ()
	while true do
		local parentIndex = math.floor(index / 2)
		local parent = heap[parentIndex]
		if parent ~= nil and compare(parent :: Node, node :: Node) > 0 then
			-- The parent is larger. Swap positions.
			heap[parentIndex] = node
			heap[index] = parent
			index = parentIndex
		else
			-- The parent is smaller. Exit.
			return
		end
	end
end

siftDown = function(heap: Heap, node: Node, index: number): ()
	local length = #heap
	while index < length do
		local leftIndex = index * 2
		local left = heap[leftIndex]
		local rightIndex = leftIndex + 1
		local right = heap[rightIndex]

		-- If the left or right node is smaller, swap with the smaller of those.
		if left ~= nil and compare(left :: Node, node) < 0 then
			if right ~= nil and compare(right :: Node, left :: Node) < 0 then
				heap[index] = right
				heap[rightIndex] = node
				index = rightIndex
			else
				heap[index] = left
				heap[leftIndex] = node
				index = leftIndex
			end
		elseif right ~= nil and compare(right :: Node, node :: Node) < 0 then
			heap[index] = right
			heap[rightIndex] = node
			index = rightIndex
		else
			-- Neither child is smaller. Exit.
			return
		end
	end
end

compare = function(a: Node, b: Node): number
	-- Compare sort index first, then task id.
	local diff = a.sortIndex - b.sortIndex

	if diff == 0 then
		return a.id - b.id
	end

	return diff
end

return exports ]]
hx.Children._347dd6019df63a391baf96951a50f56b=hE
local hF

local hG={ClassName="ModuleScript",Children={},Properties={}}
hG.Name="SchedulerPriorities"
hG.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/00748c53e183952696157088a858352cc77b0010/packages/scheduler/src/SchedulerHostConfig.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

export type PriorityLevel = number

-- TODO: Use symbols?
return {
	NoPriority = 0,
	ImmediatePriority = 1,
	UserBlockingPriority = 2,
	NormalPriority = 3,
	LowPriority = 4,
	IdlePriority = 5,
} ]]
hx.Children._ce660bc4a92bb1fda5c8afe9e8787bc7=hG
local hH

local hI={ClassName="ModuleScript",Children={},Properties={}}
hI.Name="SchedulerProfiling"
hI.Properties.Source=[[ --!strict
-- ROBLOX upstream https://github.com/facebook/react/blob/8af27aeedbc6b00bc2ef49729fc84f116c70a27c/packages/scheduler/src/SchedulerProfiling.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
\]\]
-- ROBLOX NOTE: this file is synced against a post-17.0.1 version that doesn't use SharedArrayBuffer
local Packages = script.Parent.Parent
-- ROBLOX: use patched console from shared
local console = require(Packages.Shared).console
local exports = {}

local SchedulerPriorities = require(script.Parent.SchedulerPriorities)
type PriorityLevel = SchedulerPriorities.PriorityLevel

local ScheduleFeatureFlags = require(script.Parent.SchedulerFeatureFlags)
local enableProfiling = ScheduleFeatureFlags.enableProfiling

local runIdCounter: number = 0
local mainThreadIdCounter: number = 0

-- Bytes per element is 4
local INITIAL_EVENT_LOG_SIZE = 131072
local MAX_EVENT_LOG_SIZE = 524288 -- Equivalent to 2 megabytes

-- Strictly speaking, only the first element of an EventLog can be a reference to another EventLog.
type EventLog = { EventLog | { number } }

local eventLogSize = 0
local eventLogBuffer = nil
local eventLog: EventLog? = nil
local eventLogIndex = 1

local TaskStartEvent = 1
local TaskCompleteEvent = 2
local TaskErrorEvent = 3
local TaskCancelEvent = 4
local TaskRunEvent = 5
local TaskYieldEvent = 6
local SchedulerSuspendEvent = 7
local SchedulerResumeEvent = 8

local function logEvent(entries)
	if eventLog ~= nil then
		-- ROBLOX deviation: upstream uses a packed array for performance. we do something simpler for now
		eventLogIndex += #entries
		if eventLogIndex + 1 > eventLogSize then
			eventLogSize *= 2
			if eventLogSize > MAX_EVENT_LOG_SIZE then
				-- Using console['error'] to evade Babel and ESLint
				console["error"](
					"Scheduler Profiling: Event log exceeded maximum size. Don't "
						.. "forget to call `stopLoggingProfilingEvents()`."
				)
				exports.stopLoggingProfilingEvents()
				return
			end
			local newEventLog = {}
			table.insert(newEventLog, eventLog)
			eventLogBuffer = newEventLog
			eventLog = newEventLog
		end
		table.insert(eventLog, entries)
	end
end

exports.startLoggingProfilingEvents = function()
	eventLogSize = INITIAL_EVENT_LOG_SIZE
	eventLogBuffer = {}
	eventLog = eventLogBuffer
	eventLogIndex = 1
end

exports.stopLoggingProfilingEvents = function()
	local buffer = eventLogBuffer
	eventLogSize = 0
	-- ROBLOX FIXME Luau: needs local inference? Type 'nil' could not be converted into '{|  |}'
	eventLogBuffer = nil :: any
	eventLog = nil :: any
	eventLogIndex = 1
	return buffer
end

exports.markTaskStart = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			-- performance.now returns a float, representing milliseconds. When the
			-- event is logged, it's coerced to an int. Convert to microseconds to
			-- maintain extra degrees of precision.
			logEvent({ TaskStartEvent, ms * 1000, task.id, task.priorityLevel })
		end
	end
end

exports.markTaskCompleted = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			-- performance.now returns a float, representing milliseconds. When the
			-- event is logged, it's coerced to an int. Convert to microseconds to
			-- maintain extra degrees of precision.
			logEvent({ TaskCompleteEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskCanceled = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskCancelEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskErrored = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskErrorEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskRun = function(task, ms: number)
	if enableProfiling then
		runIdCounter += 1

		if eventLog ~= nil then
			logEvent({ TaskRunEvent, ms * 1000, task.id, runIdCounter })
		end
	end
end

exports.markTaskYield = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskYieldEvent, ms * 1000, task.id, runIdCounter })
		end
	end
end

exports.markSchedulerSuspended = function(ms: number)
	if enableProfiling then
		mainThreadIdCounter += 1

		if eventLog ~= nil then
			logEvent({ SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter })
		end
	end
end

exports.markSchedulerUnsuspended = function(ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ SchedulerResumeEvent, ms * 1000, mainThreadIdCounter })
		end
	end
end

return exports ]]
hx.Children._278842df89688a8ccacba7d8bb4be351=hI
local hJ

local hK={ClassName="ModuleScript",Children={},Properties={}}
hK.Name="Tracing"
hK.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/Tracing.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

type Function = (any) -> any
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Set<T> = LuauPolyfill.Set<T>
local Set = LuauPolyfill.Set
local exports = {}

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing

export type Interaction = {
	__count: number,
	id: number,
	name: string,
	timestamp: number,
}

export type Subscriber = {
	-- A new interaction has been created via the trace() method.
	onInteractionTraced: (Interaction) -> (),

	-- All scheduled async work for an interaction has finished.
	onInteractionScheduledWorkCompleted: (Interaction) -> (),

	-- New async work has been scheduled for a set of interactions.
	-- When this work is later run, onWorkStarted/onWorkStopped will be called.
	-- A batch of async/yieldy work may be scheduled multiple times before completing.
	-- In that case, onWorkScheduled may be called more than once before onWorkStopped.
	-- Work is scheduled by a "thread" which is identified by a unique ID.
	onWorkScheduled: (Set<Interaction>, number) -> (),

	-- A batch of scheduled work has been canceled.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkCanceled: (Set<Interaction>, number) -> (),

	-- A batch of work has started for a set of interactions.
	-- When this work is complete, onWorkStopped will be called.
	-- Work is not always completed synchronously yielding may occur in between.
	-- A batch of async/yieldy work may also be re-started before completing.
	-- In that case, onWorkStarted may be called more than once before onWorkStopped.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkStarted: (Set<Interaction>, number) -> (),

	-- A batch of work has completed for a set of interactions.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkStopped: (Set<Interaction>, number) -> (),
	-- ...
}

export type InteractionsRef = { current: Set<Interaction> }

export type SubscriberRef = { current: Subscriber | nil }

local DEFAULT_THREAD_ID = 0

-- Counters used to generate unique IDs.
local interactionIDCounter: number = 0
local threadIDCounter: number = 0

-- Set of currently traced interactions.
-- Interactions "stack"–
-- Meaning that newly traced interactions are appended to the previously active set.
-- When an interaction goes out of scope, the previous set (if any) is restored.
local interactionsRef: InteractionsRef

-- Listener(s) to notify when interactions begin and end.
local subscriberRef: SubscriberRef

if enableSchedulerTracing then
	interactionsRef = {
		current = Set.new(),
	}
	subscriberRef = {
		current = nil,
	}
end

exports.__interactionsRef = interactionsRef
exports.__subscriberRef = subscriberRef

exports.unstable_clear = function(callback: Function)
	if not enableSchedulerTracing then
		return callback()
	end

	local prevInteractions = interactionsRef.current
	interactionsRef.current = Set.new()

	-- ROBLOX try
	local ok, result = pcall(callback)
	-- ROBLOX finally
	interactionsRef.current = prevInteractions

	if not ok then
		error(result)
	end

	return result
end

exports.unstable_getCurrent = function(): Set<Interaction> | nil
	if not enableSchedulerTracing then
		return nil
	else
		return interactionsRef.current
	end
end

exports.unstable_getThreadID = function(): number
	threadIDCounter += 1
	return threadIDCounter
end

exports.unstable_trace =
	function(name: string, timestamp: number, callback: Function, threadID_: number?): any
		-- ROBLOX: default argument value
		local threadID = if threadID_ ~= nil then threadID_ else DEFAULT_THREAD_ID

		if not enableSchedulerTracing then
			return callback()
		end

		local interaction: Interaction = {
			__count = 1,
			id = interactionIDCounter,
			name = name,
			timestamp = timestamp,
		}
		interactionIDCounter += 1

		local prevInteractions = interactionsRef.current

		-- Traced interactions should stack/accumulate.
		-- To do that, clone the current interactions.
		-- The previous set will be restored upon completion.
		local interactions = Set.new(prevInteractions)
		interactions:add(interaction)
		interactionsRef.current = interactions

		local subscriber = subscriberRef.current
		local returnValue

		-- ROBLOX try
		local ok, result = pcall(function()
			if subscriber ~= nil then
				subscriber.onInteractionTraced(interaction)
			end
		end)
		-- ROBLOX finally
		-- ROBLOX try 2
		local ok2, result2 = pcall(function()
			if subscriber ~= nil then
				subscriber.onWorkStarted(interactions, threadID)
			end
		end)

		-- ROBLOX finally 2
		-- ROBLOX try 3
		local ok3, result3 = pcall(function()
			returnValue = callback()
		end)
		-- ROBLOX finally 3
		interactionsRef.current = prevInteractions
		-- ROBLOX try 4
		local ok4, result4 = pcall(function()
			if subscriber ~= nil then
				subscriber.onWorkStopped(interactions, threadID)
			end
		end)
		-- ROBLOX finally 4
		interaction.__count -= 1

		-- If no async work was scheduled for this interaction,
		-- Notify subscribers that it's completed.
		if subscriber ~= nil and interaction.__count == 0 then
			subscriber.onInteractionScheduledWorkCompleted(interaction)
		end

		if not ok4 then
			error(result4)
		end

		if not ok3 then
			error(result3)
		end

		if not ok2 then
			error(result2)
		end

		if not ok then
			error(result)
		end

		return returnValue
	end

exports.unstable_wrap = function(
	callback: Function,
	threadID: number
): any -- ROLBOX deviation: any, since __call doesn't map to Function
	-- ROBLOX: default argument value
	if threadID == nil then
		threadID = DEFAULT_THREAD_ID
	end

	if not enableSchedulerTracing then
		return callback
	end

	local wrappedInteractions = interactionsRef.current

	local subscriber = subscriberRef.current
	if subscriber ~= nil then
		subscriber.onWorkScheduled(wrappedInteractions, threadID)
	end

	-- Update the pending async work count for the current interactions.
	-- Update after calling subscribers in case of error.
	for _, interaction in wrappedInteractions do
		interaction.__count += 1
	end

	local hasRun = false

	local function _wrapped(self, ...)
		local prevInteractions = interactionsRef.current
		interactionsRef.current = wrappedInteractions

		subscriber = subscriberRef.current

		-- ROBLOX try
		local ok, result = pcall(function(...)
			local returnValue

			-- ROBLOX try 2
			local ok2, result2 = pcall(function()
				if subscriber ~= nil then
					subscriber.onWorkStarted(wrappedInteractions, threadID)
				end
			end)
			-- ROBLOX finally 2
			-- ROBLOX try 3
			local ok3, result3 = pcall(function(...)
				returnValue = callback(...)
			end, ...)
			-- ROBLOX finally 3
			interactionsRef.current = prevInteractions

			if subscriber ~= nil then
				subscriber.onWorkStopped(wrappedInteractions, threadID)
			end

			if not ok3 then
				error(result3)
			end

			if not ok2 then
				error(result2)
			end

			return returnValue
		end, ...)

		-- ROBLOX finally {
		if not hasRun then
			-- We only expect a wrapped function to be executed once,
			-- But in the event that it's executed more than once–
			-- Only decrement the outstanding interaction counts once.
			hasRun = true

			-- Update pending async counts for all wrapped interactions.
			-- If this was the last scheduled async work for any of them,
			-- Mark them as completed.
			for _, interaction in wrappedInteractions do
				interaction.__count -= 1

				if subscriber ~= nil and interaction.__count == 0 then
					subscriber.onInteractionScheduledWorkCompleted(interaction)
				end
			end
		end

		if not ok then
			error(result)
		end

		return result
	end

	local _cancel = function()
		subscriber = subscriberRef.current

		local ok, result = pcall(function()
			if subscriber ~= nil then
				subscriber.onWorkCanceled(wrappedInteractions, threadID)
			end
		end)
		--ROBLOX finally {
		-- Update pending async counts for all wrapped interactions.
		-- If this was the last scheduled async work for any of them,
		-- Mark them as completed.
		for _, interaction in wrappedInteractions do
			interaction.__count -= 1

			if subscriber ~= nil and interaction.__count == 0 then
				subscriber.onInteractionScheduledWorkCompleted(interaction)
			end
		end

		if not ok then
			error(result)
		end
	end

	local wrapped = {}
	setmetatable(wrapped, {
		__call = _wrapped,
	})
	wrapped.cancel = _cancel

	return wrapped
end

return exports ]]
hx.Children._3a1f462ae16b54e3beacfe86162e51cf=hK
local hL

local hM={ClassName="ModuleScript",Children={},Properties={}}
hM.Name="TracingSubscriptions"
hM.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/TracingSubscriptions.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */
type Set<T> = { [T]: boolean? }
type Array<T> = { [number]: T }
local exports = {}
local Packages = script.Parent.Parent
local Object = require(Packages.LuauPolyfill).Object

local Tracing = require(script.Parent.Tracing)
type Interaction = Tracing.Interaction
type Subscriber = Tracing.Subscriber

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags

local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local __subscriberRef = Tracing.__subscriberRef

local subscribers: Set<Subscriber> = {}
if enableSchedulerTracing then
	subscribers = {}
end

exports.unstable_subscribe = function(subscriber: Subscriber): ()
	if enableSchedulerTracing then
		subscribers[subscriber] = true

		if #Object.keys(subscribers) == 1 then
			__subscriberRef.current = {
				onInteractionScheduledWorkCompleted = onInteractionScheduledWorkCompleted,
				onInteractionTraced = onInteractionTraced,
				onWorkCanceled = onWorkCanceled,
				onWorkScheduled = onWorkScheduled,
				onWorkStarted = onWorkStarted,
				onWorkStopped = onWorkStopped,
			}
		end
	end
end

exports.unstable_unsubscribe = function(subscriber: Subscriber): ()
	if enableSchedulerTracing then
		subscribers[subscriber] = nil

		if #Object.keys(subscribers) == 0 then
			__subscriberRef.current = nil
		end
	end
end

function onInteractionTraced(interaction: Interaction): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result = pcall(subscriber.onInteractionTraced, interaction)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onInteractionScheduledWorkCompleted(interaction: Interaction): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result =
			pcall(subscriber.onInteractionScheduledWorkCompleted, interaction)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkScheduled(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result = pcall(subscriber.onWorkScheduled, interactions, threadID)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkStarted(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result = pcall(subscriber.onWorkStarted, interactions, threadID)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkStopped(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result = pcall(subscriber.onWorkStopped, interactions, threadID)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkCanceled(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- ROBLOX try
		local ok, result = pcall(subscriber.onWorkCanceled, interactions, threadID)
		-- ROBLOX catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

return exports ]]
hx.Children._ec966d8463766b354f56ac15e1221483=hM
local hN

local hO={ClassName="Folder",Children={},Properties={}}
hO.Name="__tests__"
hx.Children._dde47737a376fbe9cdb6082055cf51ab=hO
local hP
local hQ={ClassName="ModuleScript",Children={},Properties={}}
hQ.Name="Scheduler.spec"
hQ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/__tests__/Scheduler-test.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @emails react-core
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

local Scheduler
local runWithPriority
local ImmediatePriority
local UserBlockingPriority
local NormalPriority
-- deviation: These are only used in a commented-out _G.__DEV__-only test
-- (commented out to silence lints)
-- local LowPriority
-- local IdlePriority
local scheduleCallback
local cancelCallback
local wrapCallback
local getCurrentPriorityLevel
local shouldYield

local function shift(list)
	local first = list[1]
	local newLength = #list - 1

	for i = 1, newLength do
		list[i] = list[i + 1]
	end

	-- We need to explicitly nil out the end of the list
	list[newLength + 1] = nil

	return first
end

beforeEach(function()
	jest.resetModules()
	-- deviation: In react, jest mocks Scheduler -> unstable_mock; since
	-- unstable_mock depends on the real Scheduler, and our mock
	-- functionality isn't smart enough to prevent self-requires, we simply
	-- require the mock entry point directly for use in tests
	Scheduler = require(script.Parent.Parent.unstable_mock)

	runWithPriority = Scheduler.unstable_runWithPriority
	ImmediatePriority = Scheduler.unstable_ImmediatePriority
	UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
	NormalPriority = Scheduler.unstable_NormalPriority
	-- deviation: These are only used in a commented-out _G.__DEV__-only
	-- test (commented out to silence lints)
	-- LowPriority = Scheduler.unstable_LowPriority
	-- IdlePriority = Scheduler.unstable_IdlePriority
	scheduleCallback = Scheduler.unstable_scheduleCallback
	cancelCallback = Scheduler.unstable_cancelCallback
	wrapCallback = Scheduler.unstable_wrapCallback
	getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel
	shouldYield = Scheduler.unstable_shouldYield
end)

it("flushes work incrementally", function()
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("A")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("B")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("C")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("D")
	end)

	jestExpect(Scheduler).toFlushAndYieldThrough({ "A", "B" })
	jestExpect(Scheduler).toFlushAndYieldThrough({ "C" })
	jestExpect(Scheduler).toFlushAndYield({ "D" })
end)

it("cancels work", function()
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("A")
	end)
	local callbackHandleB = scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("B")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("C")
	end)

	cancelCallback(callbackHandleB)

	jestExpect(Scheduler).toFlushAndYield({
		"A",
		-- B should have been cancelled
		"C",
	})
end)

it("executes the highest priority callbacks first", function()
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("A")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("B")
	end)

	-- Yield before B is flushed
	jestExpect(Scheduler).toFlushAndYieldThrough({ "A" })

	scheduleCallback(UserBlockingPriority, function()
		Scheduler.unstable_yieldValue("C")
	end)
	scheduleCallback(UserBlockingPriority, function()
		Scheduler.unstable_yieldValue("D")
	end)

	-- C and D should come first, because they are higher priority
	jestExpect(Scheduler).toFlushAndYield({ "C", "D", "B" })
end)

it("expires work", function()
	scheduleCallback(NormalPriority, function(didTimeout)
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue(
			string.format("A (did timeout: %s)", tostring(didTimeout))
		)
	end)
	scheduleCallback(UserBlockingPriority, function(didTimeout)
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue(
			string.format("B (did timeout: %s)", tostring(didTimeout))
		)
	end)
	scheduleCallback(UserBlockingPriority, function(didTimeout)
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue(
			string.format("C (did timeout: %s)", tostring(didTimeout))
		)
	end)

	-- Advance time, but not by enough to expire any work
	Scheduler.unstable_advanceTime(249)
	jestExpect(Scheduler).toHaveYielded({})

	-- Schedule a few more callbacks
	scheduleCallback(NormalPriority, function(didTimeout)
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue(
			string.format("D (did timeout: %s)", tostring(didTimeout))
		)
	end)
	scheduleCallback(NormalPriority, function(didTimeout)
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue(
			string.format("E (did timeout: %s)", tostring(didTimeout))
		)
	end)

	-- Advance by just a bit more to expire the user blocking callbacks
	Scheduler.unstable_advanceTime(1)
	jestExpect(Scheduler).toFlushExpired({
		"B (did timeout: true)",
		"C (did timeout: true)",
	})

	-- Expire A
	Scheduler.unstable_advanceTime(4600)
	jestExpect(Scheduler).toFlushExpired({ "A (did timeout: true)" })

	-- Flush the rest without expiring
	jestExpect(Scheduler).toFlushAndYield({
		"D (did timeout: false)",
		"E (did timeout: true)",
	})
end)

it("has a default expiration of ~5 seconds", function()
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("A")
	end)

	Scheduler.unstable_advanceTime(4999)
	jestExpect(Scheduler).toHaveYielded({})

	Scheduler.unstable_advanceTime(1)
	jestExpect(Scheduler).toFlushExpired({ "A" })
end)

it("continues working on same task after yielding", function()
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue("A")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue("B")
	end)

	local didYield = false
	local tasks = {
		{ "C1", 100 },
		{ "C2", 100 },
		{ "C3", 100 },
	}
	local function C()
		while #tasks > 0 do
			local label, ms = unpack(shift(tasks))
			Scheduler.unstable_advanceTime(ms)
			Scheduler.unstable_yieldValue(label)
			if shouldYield() then
				didYield = true
				return C
			end
		end

		return nil
	end

	scheduleCallback(NormalPriority, C)

	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue("D")
	end)
	scheduleCallback(NormalPriority, function()
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue("E")
	end)

	-- Flush, then yield while in the middle of C.
	jestExpect(didYield).toBe(false)
	jestExpect(Scheduler).toFlushAndYieldThrough({ "A", "B", "C1" })
	jestExpect(didYield).toBe(true)

	-- When we resume, we should continue working on C.
	jestExpect(Scheduler).toFlushAndYield({ "C2", "C3", "D", "E" })
end)

it("continuation callbacks inherit the expiration of the previous callback", function()
	local tasks = {
		{ "A", 125 },
		{ "B", 124 },
		{ "C", 100 },
		{ "D", 100 },
	}
	local function work()
		while #tasks > 0 do
			local label, ms = unpack(shift(tasks))
			Scheduler.unstable_advanceTime(ms)
			Scheduler.unstable_yieldValue(label)
			if shouldYield() then
				return work
			end
		end

		return nil
	end

	-- Schedule a high priority callback
	scheduleCallback(UserBlockingPriority, work)

	-- Flush until just before the expiration time
	jestExpect(Scheduler).toFlushAndYieldThrough({ "A", "B" })

	-- Advance time by just a bit more. This should expire all the remaining work.
	Scheduler.unstable_advanceTime(1)
	jestExpect(Scheduler).toFlushExpired({ "C", "D" })
end)

it("continuations are interrupted by higher priority work", function()
	local tasks = {
		{ "A", 100 },
		{ "B", 100 },
		{ "C", 100 },
		{ "D", 100 },
	}
	local function work()
		while #tasks > 0 do
			local label, ms = unpack(shift(tasks))
			Scheduler.unstable_advanceTime(ms)
			Scheduler.unstable_yieldValue(label)
			if #tasks > 0 and shouldYield() then
				return work
			end
		end

		return nil
	end
	scheduleCallback(NormalPriority, work)
	jestExpect(Scheduler).toFlushAndYieldThrough({ "A" })

	scheduleCallback(UserBlockingPriority, function()
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_yieldValue("High pri")
	end)

	jestExpect(Scheduler).toFlushAndYield({ "High pri", "B", "C", "D" })
end)

it(
	"continuations do not block higher priority work scheduled "
		.. "inside an executing callback",
	function()
		local tasks = {
			{ "A", 100 },
			{ "B", 100 },
			{ "C", 100 },
			{ "D", 100 },
		}
		local function work()
			while #tasks > 0 do
				local task = shift(tasks)
				local label, ms = unpack(task)
				Scheduler.unstable_advanceTime(ms)
				Scheduler.unstable_yieldValue(label)
				if label == "B" then
					-- Schedule high pri work from inside another callback
					Scheduler.unstable_yieldValue("Schedule high pri")
					scheduleCallback(UserBlockingPriority, function()
						Scheduler.unstable_advanceTime(100)
						Scheduler.unstable_yieldValue("High pri")
					end)
				end
				if #tasks > 0 then
					-- Return a continuation
					return work
				end
			end

			return nil
		end
		scheduleCallback(NormalPriority, work)
		jestExpect(Scheduler).toFlushAndYield({
			"A",
			"B",
			"Schedule high pri",
			-- The high pri callback should fire before the continuation of the
			-- lower pri work
			"High pri",
			-- Continue low pri work
			"C",
			"D",
		})
	end
)

it("cancelling a continuation", function()
	local task = scheduleCallback(NormalPriority, function()
		Scheduler.unstable_yieldValue("Yield")
		return function()
			Scheduler.unstable_yieldValue("Continuation")
		end
	end)

	jestExpect(Scheduler).toFlushAndYieldThrough({ "Yield" })
	cancelCallback(task)
	jestExpect(Scheduler).toFlushWithoutYielding()
end)

it("top-level immediate callbacks fire in a subsequent task", function()
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("A")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("B")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("C")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("D")
	end)
	-- Immediate callback hasn't fired, yet.
	jestExpect(Scheduler).toHaveYielded({})
	-- They all flush immediately within the subsequent task.
	jestExpect(Scheduler).toFlushExpired({ "A", "B", "C", "D" })
end)

it("nested immediate callbacks are added to the queue of immediate callbacks", function()
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("A")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("B")
		-- This callback should go to the end of the queue
		scheduleCallback(ImmediatePriority, function()
			Scheduler.unstable_yieldValue("C")
		end)
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("D")
	end)
	jestExpect(Scheduler).toHaveYielded({})
	-- C should flush at the end
	jestExpect(Scheduler).toFlushExpired({ "A", "B", "D", "C" })
end)

it("wrapped callbacks have same signature as original callback", function()
	local wrappedCallback = wrapCallback(function(...)
		return {
			args = { ... },
		}
	end)
	local result = wrappedCallback("a", "b")
	jestExpect(#result.args).toBe(2)
	jestExpect(result.args).toEqual({ "a", "b" })
end)

it("wrapped callbacks inherit the current priority", function()
	local wrappedCallback = runWithPriority(NormalPriority, function()
		return wrapCallback(function()
			Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
		end)
	end)

	local wrappedUserBlockingCallback = runWithPriority(UserBlockingPriority, function()
		return wrapCallback(function()
			Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
		end)
	end)

	wrappedCallback()
	jestExpect(Scheduler).toHaveYielded({ NormalPriority })

	wrappedUserBlockingCallback()
	jestExpect(Scheduler).toHaveYielded({ UserBlockingPriority })
end)

it("wrapped callbacks inherit the current priority even when nested", function()
	local wrappedCallback
	local wrappedUserBlockingCallback

	runWithPriority(NormalPriority, function()
		wrappedCallback = wrapCallback(function()
			Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
		end)
		wrappedUserBlockingCallback = runWithPriority(UserBlockingPriority, function()
			return wrapCallback(function()
				Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
			end)
		end)
	end)

	wrappedCallback()
	jestExpect(Scheduler).toHaveYielded({ NormalPriority })

	wrappedUserBlockingCallback()
	jestExpect(Scheduler).toHaveYielded({ UserBlockingPriority })
end)

it("immediate callbacks fire even if there's an error", function()
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("A")
		error("Oops A")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("B")
	end)
	scheduleCallback(ImmediatePriority, function()
		Scheduler.unstable_yieldValue("C")
		error(Error.new("Oops C"))
	end)

	jestExpect(function()
		jestExpect(Scheduler).toFlushExpired()
	end).toThrow("Oops A")
	jestExpect(Scheduler).toHaveYielded({ "A" })

	-- B and C flush in a subsequent event. That way, the second error is not
	-- swallowed.
	jestExpect(function()
		jestExpect(Scheduler).toFlushExpired()
	end).toThrow("Oops C")
	jestExpect(Scheduler).toHaveYielded({ "B", "C" })
end)

it(
	"multiple immediate callbacks can throw and there will be an error for each one",
	function()
		scheduleCallback(ImmediatePriority, function()
			error("First error")
		end)
		scheduleCallback(ImmediatePriority, function()
			error("Second error")
		end)
		jestExpect(function()
			Scheduler.unstable_flushAll()
		end).toThrow("First error")
		-- The next error is thrown in the subsequent event
		jestExpect(function()
			Scheduler.unstable_flushAll()
		end).toThrow("Second error")
	end
)

it("exposes the current priority level", function()
	Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
	runWithPriority(ImmediatePriority, function()
		Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
		runWithPriority(NormalPriority, function()
			Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
			runWithPriority(UserBlockingPriority, function()
				Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
			end)
		end)
		Scheduler.unstable_yieldValue(getCurrentPriorityLevel())
	end)

	jestExpect(Scheduler).toHaveYielded({
		NormalPriority,
		ImmediatePriority,
		NormalPriority,
		UserBlockingPriority,
		ImmediatePriority,
	})
end)

-- if _G.__DEV__ then
-- ROBLOX TODO(align): Re-enable this test if it's useful
--
-- Function names are minified in prod, though you could still infer the
-- priority if you have sourcemaps.
-- TODO: Feature temporarily disabled while we investigate a bug in one of
-- our minifiers.
-- it.skip('adds extra function to the JS stack whose name includes the priority level', function()
-- 	function inferPriorityFromCallstack()
-- 		try {
-- 			throw Error()
-- 		} catch (e) {
-- 			local stack = e.stack
-- 			local lines = stack.split('\n')
-- 			for (local i = lines.length - 1 i >= 0 i--) {
-- 				local line = lines[i]
-- 				local found = line.match(
-- 					/scheduler_flushTaskAtPriority_({A-Za-z]+)/,
-- 				)
-- 				if (found !== null) {
-- 					local priorityStr = found[1]
-- 					switch (priorityStr) {
-- 						case 'Immediate':
-- 							return ImmediatePriority
-- 						case 'UserBlocking':
-- 							return UserBlockingPriority
-- 						case 'Normal':
-- 							return NormalPriority
-- 						case 'Low':
-- 							return LowPriority
-- 						case 'Idle':
-- 							return IdlePriority
-- 					}
-- 				}
-- 			}
-- 			return null
-- 		}
-- 	end

-- 	scheduleCallback(ImmediatePriority, () =>
-- 		Scheduler.unstable_yieldValue(
-- 			'Immediate: ' + inferPriorityFromCallstack(),
-- 		),
-- 	)
-- 	scheduleCallback(UserBlockingPriority, () =>
-- 		Scheduler.unstable_yieldValue(
-- 			'UserBlocking: ' + inferPriorityFromCallstack(),
-- 		),
-- 	)
-- 	scheduleCallback(NormalPriority, () =>
-- 		Scheduler.unstable_yieldValue(
-- 			'Normal: ' + inferPriorityFromCallstack(),
-- 		),
-- 	)
-- 	scheduleCallback(LowPriority, () =>
-- 		Scheduler.unstable_yieldValue('Low: ' + inferPriorityFromCallstack()),
-- 	)
-- 	scheduleCallback(IdlePriority, () =>
-- 		Scheduler.unstable_yieldValue('Idle: ' + inferPriorityFromCallstack()),
-- 	)

-- 	jestExpect(Scheduler).toFlushAndYield({
-- 		'Immediate: ' + ImmediatePriority,
-- 		'UserBlocking: ' + UserBlockingPriority,
-- 		'Normal: ' + NormalPriority,
-- 		'Low: ' + LowPriority,
-- 		'Idle: ' + IdlePriority,
-- 	})
-- end)
-- end

describe("delayed tasks", function()
	it("schedules a delayed task", function()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
		end, {
			delay = 1000,
		})

		-- Should flush nothing, because delay hasn't elapsed
		jestExpect(Scheduler).toFlushAndYield({})

		-- Advance time until right before the threshold
		Scheduler.unstable_advanceTime(999)
		-- Still nothing
		jestExpect(Scheduler).toFlushAndYield({})

		-- Advance time past the threshold
		Scheduler.unstable_advanceTime(1)

		-- Now it should flush like normal
		jestExpect(Scheduler).toFlushAndYield({ "A" })
	end)

	it("schedules multiple delayed tasks", function()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("C")
		end, {
			delay = 300,
		})

		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("B")
		end, {
			delay = 200,
		})

		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("D")
		end, {
			delay = 400,
		})

		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
		end, {
			delay = 100,
		})

		-- Should flush nothing, because delay hasn't elapsed
		jestExpect(Scheduler).toFlushAndYield({})

		-- Advance some time.
		Scheduler.unstable_advanceTime(200)
		-- Both A and B are no longer delayed. They can now flush incrementally.
		jestExpect(Scheduler).toFlushAndYieldThrough({ "A" })
		jestExpect(Scheduler).toFlushAndYield({ "B" })

		-- Advance the rest
		Scheduler.unstable_advanceTime(200)
		jestExpect(Scheduler).toFlushAndYield({ "C", "D" })
	end)

	it("interleaves normal tasks and delayed tasks", function()
		-- Schedule some high priority callbacks with a delay. When their delay
		-- elapses, they will be the most important callback in the queue.
		scheduleCallback(UserBlockingPriority, function()
			Scheduler.unstable_yieldValue("Timer 2")
		end, {
			delay = 300,
		})
		scheduleCallback(UserBlockingPriority, function()
			Scheduler.unstable_yieldValue("Timer 1")
		end, {
			delay = 100,
		})

		-- Schedule some tasks at default priority.
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
			Scheduler.unstable_advanceTime(100)
		end)
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("B")
			Scheduler.unstable_advanceTime(100)
		end)
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("C")
			Scheduler.unstable_advanceTime(100)
		end)
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("D")
			Scheduler.unstable_advanceTime(100)
		end)

		-- Flush all the work. The timers should be interleaved with the
		-- other tasks.
		jestExpect(Scheduler).toFlushAndYield({
			"A",
			"Timer 1",
			"B",
			"C",
			"Timer 2",
			"D",
		})
	end)

	it("interleaves delayed tasks with time-sliced tasks", function()
		-- Schedule some high priority callbacks with a delay. When their delay
		-- elapses, they will be the most important callback in the queue.
		scheduleCallback(UserBlockingPriority, function()
			Scheduler.unstable_yieldValue("Timer 2")
		end, {
			delay = 300,
		})
		scheduleCallback(UserBlockingPriority, function()
			Scheduler.unstable_yieldValue("Timer 1")
		end, {
			delay = 100,
		})

		-- Schedule a time-sliced task at default priority.
		local tasks = {
			{ "A", 100 },
			{ "B", 100 },
			{ "C", 100 },
			{ "D", 100 },
		}
		local function work()
			while #tasks > 0 do
				local task = shift(tasks)
				local label, ms = unpack(task)
				Scheduler.unstable_advanceTime(ms)
				Scheduler.unstable_yieldValue(label)
				if #tasks > 0 then
					return work
				end
			end

			return nil
		end
		scheduleCallback(NormalPriority, work)

		-- Flush all the work. The timers should be interleaved with the
		-- other tasks.
		jestExpect(Scheduler).toFlushAndYield({
			"A",
			"Timer 1",
			"B",
			"C",
			"Timer 2",
			"D",
		})
	end)

	it("cancels a delayed task", function()
		-- Schedule several tasks with the same delay
		local options = {
			delay = 100,
		}

		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
		end, options)
		local taskB = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("B")
		end, options)
		local taskC = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("C")
		end, options)

		-- Cancel B before its delay has elapsed
		jestExpect(Scheduler).toFlushAndYield({})
		cancelCallback(taskB)

		-- Cancel C after its delay has elapsed
		Scheduler.unstable_advanceTime(500)
		cancelCallback(taskC)

		-- Only A should flush
		jestExpect(Scheduler).toFlushAndYield({ "A" })
	end)

	it("gracefully handles scheduled tasks that are not a function", function()
		scheduleCallback(ImmediatePriority)
		jestExpect(Scheduler).toFlushWithoutYielding()

		scheduleCallback(ImmediatePriority, {})
		jestExpect(Scheduler).toFlushWithoutYielding()

		scheduleCallback(ImmediatePriority, 42)
		jestExpect(Scheduler).toFlushWithoutYielding()
	end)

	it("delayed tasks stringify their error", function()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
			error(Error.new("Oops A"))
		end, {
			delay = 100,
		})

		Scheduler.unstable_advanceTime(100)
		jestExpect(Scheduler).toFlushAndThrow("Oops A")
	end)
end) ]]
hP.Children._f4087bb015ee0761b25febc804a5f800=hQ
local hR

local hS={ClassName="ModuleScript",Children={},Properties={}}
hS.Name="SchedulerMinHeap.roblox.spec"
hS.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local Heap = require(script.Parent.Parent.SchedulerMinHeap)

local function verifyOrder(heap)
	for pos = 2, #heap do
		local parent = math.floor(pos / 2)
		jestExpect(heap[pos].sortIndex).toBeGreaterThan(heap[parent].sortIndex)
	end
end

local increment = 0
local function getIncrement()
	increment = increment + 1
	return increment
end

local function makeNode(sortIndex: number, id: number?)
	return {
		sortIndex = sortIndex,
		id = id or getIncrement(),
	}
end

describe("push", function()
	it("should add a value to the minHeap", function()
		local h = {}
		Heap.push(h, makeNode(42))
		verifyOrder(h)
	end)

	it("properly sort a minHeap each time", function()
		local h = {}
		Heap.push(h, makeNode(2))
		verifyOrder(h)
		Heap.push(h, makeNode(1))
		verifyOrder(h)
		Heap.push(h, makeNode(3))
		verifyOrder(h)
	end)
end)

describe("peek", function()
	it("should return nil from an empty minHeap", function()
		local h = {}
		jestExpect(Heap.peek(h)).never.toBeDefined()
		verifyOrder(h)
	end)

	it("return the only value on a minHeap of one element", function()
		local h = {}
		Heap.push(h, makeNode(42))
		verifyOrder(h)

		local node = Heap.peek(h)
		jestExpect(node.sortIndex).toBe(42)
	end)

	it("return the smaller value on a minHeap of two elements", function()
		local h = {}
		Heap.push(h, makeNode(42))
		verifyOrder(h)
		Heap.push(h, makeNode(1))
		verifyOrder(h)

		local node = Heap.peek(h)
		jestExpect(node.sortIndex).toBe(1)
	end)

	it("return the smallest value on a minHeap of 10 elements", function()
		local h = {}
		Heap.push(h, makeNode(10))
		Heap.push(h, makeNode(7))
		Heap.push(h, makeNode(1))
		Heap.push(h, makeNode(5))
		Heap.push(h, makeNode(6))
		Heap.push(h, makeNode(9))
		Heap.push(h, makeNode(8))
		Heap.push(h, makeNode(4))
		Heap.push(h, makeNode(2))
		Heap.push(h, makeNode(3))
		verifyOrder(h)

		local node = Heap.peek(h)
		jestExpect(node.sortIndex).toBe(1)
	end)
end)

describe("pop", function()
	it("remove the smallest element on a minHeap of 5 elements", function()
		local h = {}
		Heap.push(h, makeNode(1))
		Heap.push(h, makeNode(2))
		Heap.push(h, makeNode(3))
		Heap.push(h, makeNode(4))
		Heap.push(h, makeNode(5))

		local node = Heap.pop(h)
		verifyOrder(h)
		jestExpect(node.sortIndex).toBe(1)
		node = Heap.peek(h)
		jestExpect(node.sortIndex).toBe(2)
	end)
end) ]]
hP.Children._c3eabaec439704d66c0eb84bb4c2e64d=hS
local hT

local hU={ClassName="ModuleScript",Children={},Properties={}}
hU.Name="SchedulerNoDOM.spec"
hU.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/3e94bce765d355d74f6a60feb4addb6d196e3482/packages/scheduler/src/__tests__/SchedulerNoDOM-test.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @emails react-core
\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest

local scheduleCallback
local ImmediatePriority
local UserBlockingPriority
local NormalPriority

beforeEach(function()
	jest.resetModules()
	jest.useFakeTimers()
	local Scheduler = require(script.Parent.Parent.Scheduler)()

	scheduleCallback = Scheduler.unstable_scheduleCallback
	ImmediatePriority = Scheduler.unstable_ImmediatePriority
	UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
	NormalPriority = Scheduler.unstable_NormalPriority
end)

it("runAllTimers flushes all scheduled callbacks", function()
	local log = {}
	scheduleCallback(NormalPriority, function()
		table.insert(log, "A")
	end)
	scheduleCallback(NormalPriority, function()
		table.insert(log, "B")
	end)
	scheduleCallback(NormalPriority, function()
		table.insert(log, "C")
	end)

	jestExpect(log).toEqual({})

	jest.runAllTimers()

	jestExpect(log).toEqual({ "A", "B", "C" })
end)

it("executes callbacks in order of priority", function()
	local log = {}

	scheduleCallback(NormalPriority, function()
		table.insert(log, "A")
	end)
	scheduleCallback(NormalPriority, function()
		table.insert(log, "B")
	end)
	scheduleCallback(UserBlockingPriority, function()
		table.insert(log, "C")
	end)
	scheduleCallback(UserBlockingPriority, function()
		table.insert(log, "D")
	end)

	jestExpect(log).toEqual({})
	jest.runAllTimers()
	jestExpect(log).toEqual({ "C", "D", "A", "B" })
end)

it("handles errors", function()
	local log = {}

	scheduleCallback(ImmediatePriority, function()
		table.insert(log, "A")
		error("Oops A")
	end)
	scheduleCallback(ImmediatePriority, function()
		table.insert(log, "B")
	end)
	scheduleCallback(ImmediatePriority, function()
		table.insert(log, "C")
		error("Oops C")
	end)

	jestExpect(jest.runAllTimers).toThrow("Oops A")
	jestExpect(log).toEqual({ "A" })

	log = {}

	-- B and C flush in a subsequent event. That way, the second error is not
	-- swallowed.
	jestExpect(function()
		jest.runAllTimers()
	end).toThrow("Oops C")
	jestExpect(log).toEqual({ "B", "C" })
end) ]]
hP.Children._abbd36db97b0c61eb4fed53d63065dee=hU
local hV

local hW={ClassName="ModuleScript",Children={},Properties={}}
hW.Name="SchedulerProfiling.spec"
hW.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/8af27aeedbc6b00bc2ef49729fc84f116c70a27c/packages/scheduler/src/__tests__/SchedulerProfiling-test.js
--\[\[**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 *
 * LICENSE file in the root directory of this source tree.
 * @flow
 *\]\]

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
-- ROBLOX note: this uses a post-17.0.1 commit that removes a reliance on SharedArrayBuffer, but remains API compatible with 17.x

local Scheduler
local ImmediatePriority
local UserBlockingPriority
local NormalPriority
local LowPriority
local IdlePriority
local scheduleCallback
local cancelCallback
local function priorityLevelToString(priorityLevel)
	if priorityLevel == ImmediatePriority then
		return "Immediate"
	elseif priorityLevel == UserBlockingPriority then
		return "User-blocking"
	elseif priorityLevel == NormalPriority then
		return "Normal"
	elseif priorityLevel == LowPriority then
		return "Low"
	elseif priorityLevel == IdlePriority then
		return "Idle"
	else
		return nil
	end
end
describe("Scheduler", function()
	it("profiling APIs are not available", function()
		local SchedulerFeatureFlags = require(script.Parent.Parent.SchedulerFeatureFlags)
		SchedulerFeatureFlags.enableProfiling = false

		Scheduler = require(script.Parent.Parent.Scheduler)()
		jestExpect(Scheduler.unstable_Profiling).toBe(nil)
	end)
	beforeEach(function()
		jest.resetModules()

		jest.useFakeTimers()
		local SchedulerFeatureFlags = require(script.Parent.Parent.SchedulerFeatureFlags)
		SchedulerFeatureFlags.enableProfiling = true

		-- ROBLOX deviation: In react, jest mocks Scheduler -> unstable_mock since
		-- unstable_mock depends on the real Scheduler, and our mock
		-- functionality isn't smart enough to prevent self-requires, we simply
		-- require the mock entry point directly for use in tests
		Scheduler = require(script.Parent.Parent.unstable_mock)
		ImmediatePriority = Scheduler.unstable_ImmediatePriority
		UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
		NormalPriority = Scheduler.unstable_NormalPriority
		LowPriority = Scheduler.unstable_LowPriority
		IdlePriority = Scheduler.unstable_IdlePriority
		scheduleCallback = Scheduler.unstable_scheduleCallback
		cancelCallback = Scheduler.unstable_cancelCallback
	end)
	local TaskStartEvent = 1
	local TaskCompleteEvent = 2
	local TaskErrorEvent = 3
	local TaskCancelEvent = 4
	local TaskRunEvent = 5
	local TaskYieldEvent = 6
	local SchedulerSuspendEvent = 7
	local SchedulerResumeEvent = 8
	local function stopProfilingAndPrintFlamegraph()
		local eventBuffer = Scheduler.unstable_Profiling.stopLoggingProfilingEvents()
		if eventBuffer == nil then
			return "(empty profile)"
		end
		local eventLog = { table.unpack(eventBuffer) }
		local tasks = {}
		local mainThreadRuns = {}
		local isSuspended = true
		local i = 1
		while i <= #eventLog do
			local instruction = eventLog[i][1]
			local time_ = eventLog[i][2]
			if instruction == 0 then
				break
			elseif instruction == TaskStartEvent then
				local taskId = eventLog[i][3]
				local priorityLevel = eventLog[i][4]
				local task_ = {
					id = taskId,
					priorityLevel = priorityLevel,
					label = nil,
					start = time_,
					end_ = -1,
					exitStatus = nil,
					runs = {},
				}
				tasks[taskId] = task_
				i += 1
			elseif instruction == TaskCompleteEvent then
				if isSuspended then
					error("Task cannot Complete outside the work loop.")
				end
				local taskId = eventLog[i][3]
				local task_ = tasks[taskId]
				if task_ == nil then
					error("Task does not exist.")
				end
				task_.end_ = time_
				task_.exitStatus = "completed"
				i += 1
			elseif instruction == TaskErrorEvent then
				if isSuspended then
					error("Task cannot Error outside the work loop.")
				end
				local taskId = eventLog[i][3]
				local task_ = tasks[taskId]
				if task_ == nil then
					error("Task does not exist.")
				end
				task_.end_ = time_
				task_.exitStatus = "errored"
				i += 1
			elseif instruction == TaskCancelEvent then
				local taskId = eventLog[i][3]
				local task_ = tasks[taskId]
				if task_ == nil then
					error("Task does not exist.")
				end
				task_.end_ = time_
				task_.exitStatus = "canceled"
				i += 1
			elseif instruction == TaskRunEvent or instruction == TaskYieldEvent then
				if isSuspended then
					error("Task cannot Run or Yield outside the work loop.")
				end
				local taskId = eventLog[i][3]
				local task_ = tasks[taskId]
				if task_ == nil then
					error("Task does not exist.")
				end
				table.insert(task_.runs, time_)
				i += 1
			elseif instruction == SchedulerSuspendEvent then
				if isSuspended then
					error("Scheduler cannot Suspend outside the work loop.")
				end
				isSuspended = true
				table.insert(mainThreadRuns, time_)
				i += 1
			elseif instruction == SchedulerResumeEvent then
				if not isSuspended then
					error("Scheduler cannot Resume inside the work loop.")
				end
				isSuspended = false
				table.insert(mainThreadRuns, time_)
				i += 1
			else
				error("Unknown instruction type: " + instruction)
			end
		end
		local labelColumnWidth = 30
		local microsecondsPerChar = 50000
		local result = ""
		local mainThreadLabelColumn = "!!! Main thread              "
		local mainThreadTimelineColumn = ""
		local isMainThreadBusy = true
		for _, time_ in mainThreadRuns do
			local index = time_ / microsecondsPerChar
			for i = 1, index - string.len(mainThreadTimelineColumn), 1 do
				mainThreadTimelineColumn ..= (function()
					if isMainThreadBusy then
						return "X"
					end
					return "_"
				end)()
			end
			isMainThreadBusy = not isMainThreadBusy
		end
		result ..= mainThreadLabelColumn .. "│" .. mainThreadTimelineColumn .. "\n"
		local tasksValues = {}
		for _, tasksValue in tasks do
			table.insert(tasksValues, tasksValue)
		end
		table.sort(tasksValues, function(t1, t2)
			return t2.priorityLevel > t1.priorityLevel
		end)
		for _, task_ in tasksValues do
			local label = task_.label
			if label == nil then
				label = "Task"
			end
			local labelColumn = string.format(
				"Task %d [%s]",
				task_.id,
				priorityLevelToString(task_.priorityLevel)
			)
			for i = 1, labelColumnWidth - string.len(labelColumn) - 1, 1 do
				labelColumn ..= " "
			end

			-- Add empty space up until the start mark
			local timelineColumn = ""
			for i = 1, task_.start / microsecondsPerChar, 1 do
				timelineColumn ..= " "
			end

			local isRunning = false
			for _, time_ in task_.runs do
				local index = time_ / microsecondsPerChar
				for i = 1, index - string.len(timelineColumn), 1 do
					timelineColumn ..= (function()
						if isRunning then
							return "X"
						end
						return "_"
					end)()
				end

				isRunning = not isRunning
			end

			local endIndex = task_.end_ / microsecondsPerChar
			for i = 1, endIndex - string.len(timelineColumn), 1 do
				timelineColumn ..= (function()
					if isRunning then
						return "X"
					end
					return "_"
				end)()
			end

			if task_.exitStatus ~= "completed" then
				timelineColumn ..= "O " .. (task_.exitStatus or "")
			end

			result ..= labelColumn .. "│" .. timelineColumn .. "\n"
		end
		return "\n" .. result
	end

	it("creates a basic flamegraph", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		Scheduler.unstable_advanceTime(100)
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_advanceTime(300)
			Scheduler.unstable_yieldValue("Yield 1")
			scheduleCallback(UserBlockingPriority, function()
				Scheduler.unstable_yieldValue("Yield 2")
				Scheduler.unstable_advanceTime(300)
			end, {
				label = "Bar",
			})
			Scheduler.unstable_advanceTime(100)
			Scheduler.unstable_yieldValue("Yield 3")
			return function()
				Scheduler.unstable_yieldValue("Yield 4")
				Scheduler.unstable_advanceTime(300)
			end
		end, {
			label = "Foo",
		})
		jestExpect(Scheduler).toFlushAndYieldThrough({ "Yield 1", "Yield 3" })
		Scheduler.unstable_advanceTime(100)
		jestExpect(Scheduler).toFlushAndYield({ "Yield 2", "Yield 4" })
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │XX________XX____________
Task 2 [User-blocking]       │        ____XXXXXX
Task 1 [Normal]              │  XXXXXXXX________XXXXXX
\]\])
	end)
	it("marks when a Task is canceled", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		local task_ = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("Yield 1")
			Scheduler.unstable_advanceTime(300)
			Scheduler.unstable_yieldValue("Yield 2")
			return function()
				Scheduler.unstable_yieldValue("Continuation")
				Scheduler.unstable_advanceTime(200)
			end
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({ "Yield 1", "Yield 2" })
		Scheduler.unstable_advanceTime(100)
		cancelCallback(task_)
		Scheduler.unstable_advanceTime(1000)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │______XXXXXXXXXXXXXXXXXXXXXX
Task 1 [Normal]              │XXXXXX__O canceled
\]\])
	end)
	it("marks when a task errors", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_advanceTime(300)
			error("Oops")
		end)
		jestExpect(Scheduler).toFlushAndThrow("Oops")
		Scheduler.unstable_advanceTime(100)
		Scheduler.unstable_advanceTime(1000)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │______XXXXXXXXXXXXXXXXXXXXXX
Task 1 [Normal]              │XXXXXXO errored
\]\])
	end)

	it("marks when multiple tasks are canceled", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		local task1 = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("Yield 1")
			Scheduler.unstable_advanceTime(300)
			Scheduler.unstable_yieldValue("Yield 2")
			return function()
				Scheduler.unstable_yieldValue("Continuation")
				Scheduler.unstable_advanceTime(200)
			end
		end)
		local task2 = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("Yield 3")
			Scheduler.unstable_advanceTime(300)
			Scheduler.unstable_yieldValue("Yield 4")
			return function()
				Scheduler.unstable_yieldValue("Continuation")
				Scheduler.unstable_advanceTime(200)
			end
		end)
		jestExpect(Scheduler).toFlushAndYieldThrough({ "Yield 1", "Yield 2" })
		Scheduler.unstable_advanceTime(100)
		cancelCallback(task1)
		cancelCallback(task2)
		Scheduler.unstable_advanceTime(1000)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │______XXXXXXXXXXXXXXXXXXXXXX
Task 1 [Normal]              │XXXXXX__O canceled
Task 2 [Normal]              │________O canceled
\]\])
	end)
	it("handles cancelling a task_ that already finished", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		local task_ = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
			Scheduler.unstable_advanceTime(1000)
		end)
		jestExpect(Scheduler).toFlushAndYield({ "A" })
		cancelCallback(task_)
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │____________________
Task 1 [Normal]              │XXXXXXXXXXXXXXXXXXXX
\]\])
	end)

	it("handles cancelling a task multiple times", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("A")
			Scheduler.unstable_advanceTime(1000)
		end, {
			label = "A",
		})
		Scheduler.unstable_advanceTime(200)
		local task_ = scheduleCallback(NormalPriority, function()
			Scheduler.unstable_yieldValue("B")
			Scheduler.unstable_advanceTime(1000)
		end, {
			label = "B",
		})
		Scheduler.unstable_advanceTime(400)
		cancelCallback(task_)
		cancelCallback(task_)
		cancelCallback(task_)
		jestExpect(Scheduler).toFlushAndYield({ "A" })
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │XXXXXXXXXXXX____________________
Task 1 [Normal]              │____________XXXXXXXXXXXXXXXXXXXX
Task 2 [Normal]              │    ________O canceled
\]\])
	end)
	it("handles delayed tasks", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_advanceTime(1000)
			Scheduler.unstable_yieldValue("A")
		end, {
			delay = 1000,
		})
		jestExpect(Scheduler).toFlushWithoutYielding()
		Scheduler.unstable_advanceTime(1000)
		jestExpect(Scheduler).toFlushAndYield({ "A" })
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │XXXXXXXXXXXXXXXXXXXX____________________
Task 1 [Normal]              │                    XXXXXXXXXXXXXXXXXXXX
\]\])
	end)
	it("handles cancelling a delayed Task", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		local task_ = scheduleCallback(NormalPriority, function()
			return Scheduler.unstable_yieldValue("A")
		end, {
			delay = 1000,
		})
		cancelCallback(task_)
		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │
\]\])
	end)
	it("automatically stops profiling and warns if event log gets too big", function()
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		-- ROBLOX deviation: use toWarvDev matcher below instead of overriding console global
		-- spyOnDevAndProd(console, "error")
		-- ROBLOX deviation: any lower than this, and the buffer doesn't overslow and we try to table.unpack() too many elements
		local originalMaxIterations = 41000
		local taskId = 1
		jestExpect(function()
			while taskId < originalMaxIterations do
				taskId += 1
				local task_ = scheduleCallback(NormalPriority, function()
					return {}
				end)
				cancelCallback(task_)
				jestExpect(Scheduler).toFlushAndYield({})
			end
		end).toErrorDev("Event log exceeded maximum size", { withoutStack = true })
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual("(empty profile)")
		Scheduler.unstable_Profiling.startLoggingProfilingEvents()
		scheduleCallback(NormalPriority, function()
			Scheduler.unstable_advanceTime(1000)
		end)
		jestExpect(Scheduler).toFlushAndYield({})
		jestExpect(stopProfilingAndPrintFlamegraph()).toEqual(\[\[

!!! Main thread              │____________________
Task 41000 [Normal]          │XXXXXXXXXXXXXXXXXXXX
\]\])
	end)
end) ]]
hP.Children._173c678e7231ab536136b16725905855=hW
local hX

local hY={ClassName="ModuleScript",Children={},Properties={}}
hY.Name="Tracing-internal.spec"
hY.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/__tests__/Tracing-test.internal.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set

describe("Tracing", function()
	local SchedulerTracing
	local ReactFeatureFlags

	local advanceTimeBy
	local currentTime

	local function loadModules(config)
		local enableSchedulerTracing = config.enableSchedulerTracing
		jest.resetModules()
		jest.useFakeTimers()

		currentTime = os.time

		advanceTimeBy = jest.advanceTimersByTime

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.enableSchedulerTracing = enableSchedulerTracing

		SchedulerTracing = require(Packages.Scheduler).tracing
	end

	describe("enableSchedulerTracing enabled", function()
		beforeEach(function()
			loadModules({ enableSchedulerTracing = true })
		end)

		it("should return the value of a traced function", function()
			jestExpect(
				SchedulerTracing.unstable_trace("arbitrary", currentTime(), function()
					return 123
				end)
			).toBe(123)
		end)

		it("should return the value of a clear function", function()
			jestExpect(SchedulerTracing.unstable_clear(function()
				return 123
			end)).toBe(123)
		end)

		it("should return the value of a wrapped function", function()
			local wrapped
			SchedulerTracing.unstable_trace("arbitrary", currentTime(), function()
				wrapped = SchedulerTracing.unstable_wrap(function()
					return 123
				end)
			end)
			jest.runAllTimers()

			jestExpect(wrapped()).toBe(123)
		end)

		it("should pass arguments through to a wrapped function", function()
			local wrapped
			local done = false
			SchedulerTracing.unstable_trace("arbitrary", currentTime(), function()
				wrapped = SchedulerTracing.unstable_wrap(function(param1, param2)
					jestExpect(param1).toBe("foo")
					jestExpect(param2).toBe("bar")
					done = true
				end)
			end)
			wrapped("foo", "bar")
			jest.runAllTimers()
			jestExpect(done).toBe(true)
		end)

		it("should return an empty set when outside of a traced event", function()
			jestExpect(SchedulerTracing.unstable_getCurrent()).toContainNoInteractions()
		end)

		it(
			"should report the traced interaction from within the trace callback",
			function()
				local done = false
				advanceTimeBy(100)

				SchedulerTracing.unstable_trace("some event", currentTime(), function()
					local interactions = SchedulerTracing.unstable_getCurrent()
					jestExpect(interactions).toMatchInteractions({
						{ name = "some event", timestamp = 100 },
					})

					done = true
				end)

				jestExpect(done).toBe(true)
			end
		)

		it(
			"should report the traced interaction from within wrapped callbacks",
			function()
				local done = false
				local wrappedIndirection

				local function indirection()
					local interactions = SchedulerTracing.unstable_getCurrent()
					jestExpect(interactions).toMatchInteractions({
						{ name = "some event", timestamp = 100 },
					})

					done = true
				end

				advanceTimeBy(100)

				SchedulerTracing.unstable_trace("some event", currentTime(), function()
					wrappedIndirection = SchedulerTracing.unstable_wrap(indirection)
				end)

				advanceTimeBy(50)

				wrappedIndirection()
				jestExpect(done).toBe(true)
			end
		)

		it("should clear the interaction stack for traced callbacks", function()
			local innerTestReached = false

			SchedulerTracing.unstable_trace("outer event", currentTime(), function()
				jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
					{ name = "outer event" },
				})

				SchedulerTracing.unstable_clear(function()
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({})

					SchedulerTracing.unstable_trace(
						"inner event",
						currentTime(),
						function()
							jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
								{ name = "inner event" },
							})

							innerTestReached = true
						end
					)
				end)

				jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
					{ name = "outer event" },
				})
			end)

			jestExpect(innerTestReached).toBe(true)
		end)

		it("should clear the interaction stack for wrapped callbacks", function()
			local innerTestReached = false
			local wrappedIndirection

			local indirection = jest.fn(function()
				jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
					{ name = "outer event" },
				})

				SchedulerTracing.unstable_clear(function()
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({})

					SchedulerTracing.unstable_trace(
						"inner event",
						currentTime(),
						function()
							jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
								{ name = "inner event" },
							})

							innerTestReached = true
						end
					)
				end)

				jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
					{ name = "outer event" },
				})
			end)

			SchedulerTracing.unstable_trace("outer event", currentTime(), function()
				wrappedIndirection = SchedulerTracing.unstable_wrap(indirection)
			end)

			wrappedIndirection()

			jestExpect(innerTestReached).toBe(true)
		end)

		it("should support nested traced events", function()
			local done = false
			advanceTimeBy(100)

			local innerIndirectionTraced = false
			local outerIndirectionTraced = false

			local function innerIndirection()
				local interactions = SchedulerTracing.unstable_getCurrent()
				jestExpect(interactions).toMatchInteractions({
					{ name = "outer event", timestamp = 100 },
					{ name = "inner event", timestamp = 150 },
				})

				innerIndirectionTraced = true
			end

			local function outerIndirection()
				local interactions = SchedulerTracing.unstable_getCurrent()
				jestExpect(interactions).toMatchInteractions({
					{ name = "outer event", timestamp = 100 },
				})

				outerIndirectionTraced = true
			end

			SchedulerTracing.unstable_trace("outer event", currentTime(), function()
				-- Verify the current traced event
				local interactions = SchedulerTracing.unstable_getCurrent()
				jestExpect(interactions).toMatchInteractions({
					{ name = "outer event", timestamp = 100 },
				})

				advanceTimeBy(50)

				local wrapperOuterIndirection =
					SchedulerTracing.unstable_wrap(outerIndirection)

				local wrapperInnerIndirection
				local innerEventTraced = false

				-- Verify that a nested event is properly traced
				SchedulerTracing.unstable_trace("inner event", currentTime(), function()
					interactions = SchedulerTracing.unstable_getCurrent()
					jestExpect(interactions).toMatchInteractions({
						{ name = "outer event", timestamp = 100 },
						{ name = "inner event", timestamp = 150 },
					})

					-- Verify that a wrapped outer callback is properly traced
					wrapperOuterIndirection()
					jestExpect(outerIndirectionTraced).toBe(true)

					wrapperInnerIndirection =
						SchedulerTracing.unstable_wrap(innerIndirection)

					innerEventTraced = true
				end)

				jestExpect(innerEventTraced).toBe(true)

				-- Verify that the original event is restored
				interactions = SchedulerTracing.unstable_getCurrent()
				jestExpect(interactions).toMatchInteractions({
					{ name = "outer event", timestamp = 100 },
				})

				-- Verify that a wrapped nested callback is properly traced
				wrapperInnerIndirection()
				jestExpect(innerIndirectionTraced).toBe(true)

				done = true
			end)
			jestExpect(done).toBe(true)
		end)

		describe("error handling", function()
			it(
				"should reset state appropriately when an error occurs in a trace callback",
				function()
					local done = false
					advanceTimeBy(100)

					SchedulerTracing.unstable_trace(
						"outer event",
						currentTime(),
						function()
							jestExpect(function()
								SchedulerTracing.unstable_trace(
									"inner event",
									currentTime(),
									function()
										error("intentional")
									end
								)
							end).toThrow()

							jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
								{ name = "outer event", timestamp = 100 },
							})

							done = true
						end
					)
					jestExpect(done).toBe(true)
				end
			)

			it(
				"should reset state appropriately when an error occurs in a wrapped callback",
				function()
					local done = false
					advanceTimeBy(100)

					SchedulerTracing.unstable_trace(
						"outer event",
						currentTime(),
						function()
							local wrappedCallback

							SchedulerTracing.unstable_trace(
								"inner event",
								currentTime(),
								function()
									wrappedCallback = SchedulerTracing.unstable_wrap(
										function()
											error("intentional")
										end
									)
								end
							)

							-- ROBLOX deviation: unstable_wrap returns a table with a __call metamethod so it can have a cancel field
							jestExpect(function()
								wrappedCallback()
							end).toThrow()

							jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
								{ name = "outer event", timestamp = 100 },
							})

							done = true
						end
					)
					jestExpect(done).toBe(true)
				end
			)
		end)

		describe("advanced integration", function()
			it("should return a unique threadID per request", function()
				jestExpect(SchedulerTracing.unstable_getThreadID()).never.toBe(
					SchedulerTracing.unstable_getThreadID()
				)
			end)

			it(
				"should expose the current set of interactions to be externally manipulated",
				function()
					SchedulerTracing.unstable_trace(
						"outer event",
						currentTime(),
						function()
							jestExpect(SchedulerTracing.__interactionsRef.current).toBe(
								SchedulerTracing.unstable_getCurrent()
							)

							SchedulerTracing.__interactionsRef.current = Set.new({
								{ name = "override event" },
							})

							jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
								{ name = "override event" },
							})
						end
					)
				end
			)

			it("should expose a subscriber ref to be externally manipulated", function()
				SchedulerTracing.unstable_trace("outer event", currentTime(), function()
					jestExpect(SchedulerTracing.__subscriberRef).toEqual({
						current = nil,
					})
				end)
			end)
		end)
	end)

	describe("enableSchedulerTracing disabled", function()
		beforeEach(function()
			loadModules({ enableSchedulerTracing = false })
		end)

		it("should return the value of a traced function", function()
			jestExpect(
				SchedulerTracing.unstable_trace("arbitrary", currentTime(), function()
					return 123
				end)
			).toBe(123)
		end)

		it("should return the value of a wrapped function", function()
			local wrapped
			SchedulerTracing.unstable_trace("arbitrary", currentTime(), function()
				wrapped = SchedulerTracing.unstable_wrap(function()
					return 123
				end)
			end)
			jestExpect(wrapped()).toBe(123)
		end)

		it("should return nil for traced interactions", function()
			jestExpect(SchedulerTracing.unstable_getCurrent()).toBe(nil)
		end)

		it("should execute traced callbacks", function()
			local done = false
			SchedulerTracing.unstable_trace("some event", currentTime(), function()
				jestExpect(SchedulerTracing.unstable_getCurrent()).toBe(nil)

				done = true
			end)
			jestExpect(done).toBe(true)
		end)

		it("should return the value of a clear function", function()
			jestExpect(SchedulerTracing.unstable_clear(function()
				return 123
			end)).toBe(123)
		end)

		it("should execute wrapped callbacks", function()
			local done = false
			local wrappedCallback = SchedulerTracing.unstable_wrap(function()
				jestExpect(SchedulerTracing.unstable_getCurrent()).toBe(nil)

				done = true
			end)

			wrappedCallback()
			jestExpect(done).toBe(true)
		end)

		describe("advanced integration", function()
			it("should not create unnecessary objects", function()
				jestExpect(SchedulerTracing.__interactionsRef).toBe(nil)
			end)
		end)
	end)
end) ]]
hP.Children._c824b88e8b597dc408bd439bc89cc647=hY
local hZ

local h_={ClassName="ModuleScript",Children={},Properties={}}
h_.Name="Tracing.spec"
h_.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/__tests__/Tracing-test.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @jest-environment node
--  */

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest

describe("Tracing", function()
	local JestGlobals = require(Packages.Dev.JestGlobals)
	local jestExpect = JestGlobals.expect

	local SchedulerTracing

	beforeEach(function()
		jest.resetModules()

		SchedulerTracing = require(Packages.Scheduler).tracing
	end)

	it("should return the value of a traced function", function()
		jestExpect(SchedulerTracing.unstable_trace("arbitrary", 0, function()
			return 123
		end)).toBe(123)
	end)

	it("should return the value of a wrapped function", function()
		local wrapped
		SchedulerTracing.unstable_trace("arbitrary", 0, function()
			wrapped = SchedulerTracing.unstable_wrap(function()
				return 123
			end)
		end)
		jestExpect(wrapped()).toBe(123)
	end)

	it("should execute traced callbacks", function()
		local done = false

		SchedulerTracing.unstable_trace("some event", 0, function()
			done = true
		end)

		jestExpect(done).toBe(true)
	end)

	it("should return the value of a clear function", function()
		jestExpect(SchedulerTracing.unstable_clear(function()
			return 123
		end)).toBe(123)
	end)

	it("should execute wrapped callbacks", function()
		local done = false
		local wrappedCallback = SchedulerTracing.unstable_wrap(function()
			done = true
		end)

		wrappedCallback()
		jestExpect(done).toBe(true)
	end)
end) ]]
hP.Children._98a8185f7035418311f0bb921ecc6975=h_
local h0

local h1={ClassName="ModuleScript",Children={},Properties={}}
h1.Name="TracingSubscriptions-internal.spec"
h1.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/__tests__/TracingSubscriptions-test.internal.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set

describe("TracingSubscriptions", function()
	local SchedulerTracing
	local ReactFeatureFlags
	local currentTime
	local onInteractionScheduledWorkCompleted
	local onInteractionTraced
	local onWorkCanceled
	local onWorkScheduled
	local onWorkStarted
	local onWorkStopped
	local throwInOnInteractionScheduledWorkCompleted
	local throwInOnInteractionTraced
	local throwInOnWorkCanceled
	local throwInOnWorkScheduled
	local throwInOnWorkStarted
	local throwInOnWorkStopped
	local firstSubscriber
	local secondSubscriber
	local firstEvent = { id = 0, name = "first", timestamp = 0 }
	local secondEvent = { id = 1, name = "second", timestamp = 0 }
	local threadID = 123
	local function loadModules(config)
		local enableSchedulerTracing = config.enableSchedulerTracing
		local autoSubscribe = (function()
			if config.autoSubscribe == nil then
				return true
			end
			return config.autoSubscribe
		end)()

		jest.resetModules()
		jest.useFakeTimers()

		currentTime = 0

		ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
		ReactFeatureFlags.enableSchedulerTracing = enableSchedulerTracing

		SchedulerTracing = require(Packages.Scheduler).tracing

		throwInOnInteractionScheduledWorkCompleted = false
		throwInOnInteractionTraced = false
		throwInOnWorkCanceled = false
		throwInOnWorkScheduled = false
		throwInOnWorkStarted = false
		throwInOnWorkStopped = false

		onInteractionScheduledWorkCompleted = jest.fn(function()
			if throwInOnInteractionScheduledWorkCompleted then
				error("Expected error onInteractionScheduledWorkCompleted")
			end
		end)
		onInteractionTraced = jest.fn(function()
			if throwInOnInteractionTraced then
				error("Expected error onInteractionTraced")
			end
		end)
		onWorkCanceled = jest.fn(function()
			if throwInOnWorkCanceled then
				error("Expected error onWorkCanceled")
			end
		end)
		onWorkScheduled = jest.fn(function()
			if throwInOnWorkScheduled then
				error("Expected error onWorkScheduled")
			end
		end)
		onWorkStarted = jest.fn(function()
			if throwInOnWorkStarted then
				error("Expected error onWorkStarted")
			end
		end)
		onWorkStopped = jest.fn(function()
			if throwInOnWorkStopped then
				error("Expected error onWorkStopped")
			end
		end)

		firstSubscriber = {
			onInteractionScheduledWorkCompleted = onInteractionScheduledWorkCompleted,
			onInteractionTraced = onInteractionTraced,
			onWorkCanceled = onWorkCanceled,
			onWorkScheduled = onWorkScheduled,
			onWorkStarted = onWorkStarted,
			onWorkStopped = onWorkStopped,
		}

		secondSubscriber = {
			onInteractionScheduledWorkCompleted = jest.fn(),
			onInteractionTraced = jest.fn(),
			onWorkCanceled = jest.fn(),
			onWorkScheduled = jest.fn(),
			onWorkStarted = jest.fn(),
			onWorkStopped = jest.fn(),
		}
		if autoSubscribe then
			SchedulerTracing.unstable_subscribe(firstSubscriber)
			SchedulerTracing.unstable_subscribe(secondSubscriber)
		end
	end
	describe("enabled", function()
		beforeEach(function()
			return loadModules({ enableSchedulerTracing = true })
		end)
		it(
			"should lazily subscribe to tracing and unsubscribe again if there are no external subscribers",
			function()
				loadModules({ enableSchedulerTracing = true, autoSubscribe = false })
				jestExpect(SchedulerTracing.__subscriberRef.current).toBe(nil)
				SchedulerTracing.unstable_subscribe(firstSubscriber)
				jestExpect(SchedulerTracing.__subscriberRef.current).toBeDefined()
				SchedulerTracing.unstable_subscribe(secondSubscriber)
				jestExpect(SchedulerTracing.__subscriberRef.current).toBeDefined()
				SchedulerTracing.unstable_unsubscribe(secondSubscriber)
				jestExpect(SchedulerTracing.__subscriberRef.current).toBeDefined()
				SchedulerTracing.unstable_unsubscribe(firstSubscriber)
				jestExpect(SchedulerTracing.__subscriberRef.current).toBe(nil)
			end
		)
		describe("error handling", function()
			it("should cover onInteractionTraced/onWorkStarted within", function()
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					local mock = jest.fn()

					-- It should call the callback before re-throwing
					throwInOnInteractionTraced = true
					jestExpect(function()
						return SchedulerTracing.unstable_trace(
							secondEvent.name,
							currentTime,
							mock,
							threadID
						)
					end).toThrow("Expected error onInteractionTraced")
					throwInOnInteractionTraced = false
					jestExpect(mock).toHaveBeenCalledTimes(1)
					throwInOnWorkStarted = true
					jestExpect(function()
						return SchedulerTracing.unstable_trace(
							secondEvent.name,
							currentTime,
							mock,
							threadID
						)
					end).toThrow("Expected error onWorkStarted")
					jestExpect(mock).toHaveBeenCalledTimes(2)

					-- It should restore the previous/outer interactions
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
						firstEvent,
					})

					-- It should call other subscribers despite the earlier error
					jestExpect(secondSubscriber.onInteractionTraced).toHaveBeenCalledTimes(
						3
					)
					jestExpect(secondSubscriber.onWorkStarted).toHaveBeenCalledTimes(3)
				end)
			end)
			it("should cover onWorkStopped within trace", function()
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					local innerInteraction
					local mock = jest.fn(function()
						innerInteraction =
							SchedulerTracing.unstable_getCurrent()._array[2] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					end)

					throwInOnWorkStopped = true

					jestExpect(function()
						return SchedulerTracing.unstable_trace(
							secondEvent.name,
							currentTime,
							mock
						)
					end).toThrow("Expected error onWorkStopped")
					throwInOnWorkStopped = false

					-- It should restore the previous/outer interactions
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
						firstEvent,
					})

					-- It should update the interaction count so as not to interfere with subsequent calls
					jestExpect(innerInteraction.__count).toBe(0)

					-- It should call other subscribers despite the earlier error
					jestExpect(secondSubscriber.onWorkStopped).toHaveBeenCalledTimes(1)
				end)
			end)
			it("should cover onInteractionScheduledWorkCompleted within trace", function()
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					local mock = jest.fn()
					throwInOnInteractionScheduledWorkCompleted = true
					jestExpect(function()
						return SchedulerTracing.unstable_trace(
							secondEvent.name,
							currentTime,
							mock
						)
					end).toThrow(
						"Expected error onInteractionScheduledWorkCompleted"
					)
					throwInOnInteractionScheduledWorkCompleted = false
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
						firstEvent,
					})
					jestExpect(secondSubscriber.onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(
						1
					)
				end)
			end)
			it("should cover the callback within trace", function()
				jestExpect(onWorkStarted).never.toHaveBeenCalled()
				jestExpect(onWorkStopped).never.toHaveBeenCalled()
				jestExpect(function()
					SchedulerTracing.unstable_trace(
						firstEvent.name,
						currentTime,
						function()
							error("Expected error callback")
						end
					)
				end).toThrow("Expected error callback")
				jestExpect(onWorkStarted).toHaveBeenCalledTimes(1)
				jestExpect(onWorkStopped).toHaveBeenCalledTimes(1)
			end)
			it("should cover onWorkScheduled within wrap", function()
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
					local interaction = SchedulerTracing.unstable_getCurrent()._array[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					local beforeCount = interaction.__count
					throwInOnWorkScheduled = true
					jestExpect(function()
						return SchedulerTracing.unstable_wrap(function() end)
					end).toThrow("Expected error onWorkScheduled")
					jestExpect(interaction.__count).toBe(beforeCount)
					jestExpect(secondSubscriber.onWorkScheduled).toHaveBeenCalledTimes(1)
				end)
			end)
			it("should cover onWorkStarted within wrap", function()
				local mock = jest.fn()
				local interaction, wrapped
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
					interaction = SchedulerTracing.unstable_getCurrent()._array[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					wrapped = SchedulerTracing.unstable_wrap(mock)
				end)
				jestExpect(interaction.__count).toBe(1)
				throwInOnWorkStarted = true
				jestExpect(function()
					wrapped()
				end).toThrow("Expected error onWorkStarted")
				jestExpect(mock).toHaveBeenCalledTimes(1)
				jestExpect(interaction.__count).toBe(0)
				jestExpect(secondSubscriber.onWorkStarted).toHaveBeenCalledTimes(2)
			end)
			it("should cover onWorkStopped within wrap", function()
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
					local outerInteraction =
						SchedulerTracing.unstable_getCurrent()._array[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					jestExpect(outerInteraction.__count).toBe(1)
					local wrapped
					local innerInteraction
					SchedulerTracing.unstable_trace(
						secondEvent.name,
						currentTime,
						function()
							-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
							innerInteraction =
								SchedulerTracing.unstable_getCurrent()._array[2] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
							jestExpect(outerInteraction.__count).toBe(1)
							jestExpect(innerInteraction.__count).toBe(1)
							wrapped = SchedulerTracing.unstable_wrap(jest.fn())
							jestExpect(outerInteraction.__count).toBe(2)
							jestExpect(innerInteraction.__count).toBe(2)
						end
					)
					jestExpect(outerInteraction.__count).toBe(2)
					jestExpect(innerInteraction.__count).toBe(1)
					throwInOnWorkStopped = true
					jestExpect(function()
						wrapped()
					end).toThrow("Expected error onWorkStopped")
					throwInOnWorkStopped = false
					jestExpect(SchedulerTracing.unstable_getCurrent()).toMatchInteractions({
						outerInteraction,
					})
					jestExpect(outerInteraction.__count).toBe(1)
					jestExpect(innerInteraction.__count).toBe(0)
					jestExpect(secondSubscriber.onWorkStopped).toHaveBeenCalledTimes(2)
				end)
			end)

			it("should cover the callback within wrap", function()
				jestExpect(onWorkStarted).never.toHaveBeenCalled()
				jestExpect(onWorkStopped).never.toHaveBeenCalled()

				local wrapped
				local interaction
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
					interaction = SchedulerTracing.unstable_getCurrent()._array[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					wrapped = SchedulerTracing.unstable_wrap(function()
						error("Expected error wrap")
					end)
				end)

				jestExpect(onWorkStarted).toHaveBeenCalledTimes(1)
				jestExpect(onWorkStopped).toHaveBeenCalledTimes(1)

				jestExpect(function()
					wrapped()
				end).toThrow("Expected error wrap")

				jestExpect(onWorkStarted).toHaveBeenCalledTimes(2)
				jestExpect(onWorkStopped).toHaveBeenCalledTimes(2)
				jestExpect(onWorkStopped).toHaveBeenLastNotifiedOfWork({ interaction })
			end)

			it("should cover onWorkCanceled within wrap", function()
				local interaction, wrapped
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					-- ROBLOX FIXME: Array.from() polyfill doesn't recognize Set correctly
					interaction = SchedulerTracing.unstable_getCurrent()._array[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
					wrapped = SchedulerTracing.unstable_wrap(jest.fn())
				end)
				jestExpect(interaction.__count).toBe(1)
				throwInOnWorkCanceled = true
				jestExpect(function()
					wrapped.cancel()
				end).toThrow("Expected error onWorkCanceled")
				jestExpect(onWorkCanceled).toHaveBeenCalledTimes(1)
				jestExpect(interaction.__count).toBe(0)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
				jestExpect(secondSubscriber.onWorkCanceled).toHaveBeenCalledTimes(1)
			end)
		end)
		it("calls lifecycle methods for trace", function()
			jestExpect(onInteractionTraced).never.toHaveBeenCalled()
			jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
			SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionTraced).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				jestExpect(onWorkStarted).toHaveBeenCalledTimes(1)
				jestExpect(onWorkStarted).toHaveBeenLastNotifiedOfWork(
					Set.new({ firstEvent }),
					threadID
				)
				jestExpect(onWorkStopped).never.toHaveBeenCalled()

				SchedulerTracing.unstable_trace(secondEvent.name, currentTime, function()
					jestExpect(onInteractionTraced).toHaveBeenCalledTimes(2)
					jestExpect(onInteractionTraced).toHaveBeenLastNotifiedOfInteraction(
						secondEvent
					)
					jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
					jestExpect(onWorkStarted).toHaveBeenCalledTimes(2)
					jestExpect(onWorkStarted).toHaveBeenLastNotifiedOfWork(
						Set.new({ firstEvent, secondEvent }),
						threadID
					)
					jestExpect(onWorkStopped).never.toHaveBeenCalled()
				end, threadID)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					secondEvent
				)
				jestExpect(onWorkStopped).toHaveBeenCalledTimes(1)
				jestExpect(onWorkStopped).toHaveBeenLastNotifiedOfWork(
					Set.new({ firstEvent, secondEvent }),
					threadID
				)
			end, threadID)
			jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(2)
			jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
				firstEvent
			)
			jestExpect(onWorkScheduled).never.toHaveBeenCalled()
			jestExpect(onWorkCanceled).never.toHaveBeenCalled()
			jestExpect(onWorkStarted).toHaveBeenCalledTimes(2)
			jestExpect(onWorkStopped).toHaveBeenCalledTimes(2)
			jestExpect(onWorkStopped).toHaveBeenLastNotifiedOfWork(
				Set.new({ firstEvent }),
				threadID
			)
		end)
		it("calls lifecycle methods for wrap", function()
			local unwrapped = jest.fn()
			local wrapped
			SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionTraced).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
				SchedulerTracing.unstable_trace(secondEvent.name, currentTime, function()
					jestExpect(onInteractionTraced).toHaveBeenCalledTimes(2)
					jestExpect(onInteractionTraced).toHaveBeenLastNotifiedOfInteraction(
						secondEvent
					)
					wrapped = SchedulerTracing.unstable_wrap(unwrapped, threadID)
					jestExpect(onWorkScheduled).toHaveBeenCalledTimes(1)
					jestExpect(onWorkScheduled).toHaveBeenLastNotifiedOfWork(
						Set.new({ firstEvent, secondEvent }),
						threadID
					)
				end)
			end)
			jestExpect(onInteractionTraced).toHaveBeenCalledTimes(2)
			jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
			wrapped()
			jestExpect(unwrapped).toHaveBeenCalled()
			jestExpect(onWorkScheduled).toHaveBeenCalledTimes(1)
			jestExpect(onWorkCanceled).never.toHaveBeenCalled()
			jestExpect(onWorkStarted).toHaveBeenCalledTimes(3)
			jestExpect(onWorkStarted).toHaveBeenLastNotifiedOfWork(
				Set.new({ firstEvent, secondEvent }),
				threadID
			)
			jestExpect(onWorkStopped).toHaveBeenCalledTimes(3)
			jestExpect(onWorkStopped).toHaveBeenLastNotifiedOfWork(
				Set.new({ firstEvent, secondEvent }),
				threadID
			)
			jestExpect(onInteractionScheduledWorkCompleted
				.mock
				.calls
				[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
				[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]).toMatchInteraction(
				firstEvent
			)
			jestExpect(onInteractionScheduledWorkCompleted
				.mock
				.calls
				[2] --\[\[ ROBLOX adaptation: added 1 to array index \]\]
				[1] --\[\[ ROBLOX adaptation: added 1 to array index \]\]).toMatchInteraction(
				secondEvent
			)
		end)
		it(
			"should call the correct interaction subscriber methods when a wrapped callback is canceled",
			function()
				local fnOne = jest.fn()
				local fnTwo = jest.fn()
				local wrappedOne, wrappedTwo
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					wrappedOne = SchedulerTracing.unstable_wrap(fnOne, threadID)
					SchedulerTracing.unstable_trace(
						secondEvent.name,
						currentTime,
						function()
							wrappedTwo = SchedulerTracing.unstable_wrap(fnTwo, threadID)
						end
					)
				end)
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(2)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				jestExpect(onWorkCanceled).never.toHaveBeenCalled()
				jestExpect(onWorkStarted).toHaveBeenCalledTimes(2)
				jestExpect(onWorkStopped).toHaveBeenCalledTimes(2)
				wrappedTwo:cancel()
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					secondEvent
				)
				jestExpect(onWorkCanceled).toHaveBeenCalledTimes(1)
				jestExpect(onWorkCanceled).toHaveBeenLastNotifiedOfWork(
					Set.new({ firstEvent, secondEvent }),
					threadID
				)
				wrappedOne:cancel()
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(2)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
				jestExpect(onWorkCanceled).toHaveBeenCalledTimes(2)
				jestExpect(onWorkCanceled).toHaveBeenLastNotifiedOfWork(
					Set.new({ firstEvent }),
					threadID
				)
				jestExpect(fnOne).never.toHaveBeenCalled()
				jestExpect(fnTwo).never.toHaveBeenCalled()
			end
		)
		it(
			"should not end an interaction twice if wrap is used to schedule follow up work within another wrap",
			function()
				local wrappedOne, wrappedTwo
				local fnTwo = jest.fn()
				local fnOne = jest.fn(function()
					wrappedTwo = SchedulerTracing.unstable_wrap(fnTwo, threadID)
				end)
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					wrappedOne = SchedulerTracing.unstable_wrap(fnOne, threadID)
				end)
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				wrappedOne()
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				wrappedTwo()
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
			end
		)
		it(
			"should not decrement the interaction count twice if a wrapped function is run twice",
			function()
				local unwrappedOne = jest.fn()
				local unwrappedTwo = jest.fn()
				local wrappedOne, wrappedTwo
				SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function()
					wrappedOne = SchedulerTracing.unstable_wrap(unwrappedOne, threadID)
					wrappedTwo = SchedulerTracing.unstable_wrap(unwrappedTwo, threadID)
				end)
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				wrappedOne()
				jestExpect(unwrappedOne).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				wrappedOne()
				jestExpect(unwrappedOne).toHaveBeenCalledTimes(2)
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).never.toHaveBeenCalled()
				wrappedTwo()
				jestExpect(onInteractionTraced).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenCalledTimes(1)
				jestExpect(onInteractionScheduledWorkCompleted).toHaveBeenLastNotifiedOfInteraction(
					firstEvent
				)
			end
		)
		it("should unsubscribe", function()
			SchedulerTracing.unstable_unsubscribe(firstSubscriber)
			SchedulerTracing.unstable_trace(firstEvent.name, currentTime, function() end)
			jestExpect(onInteractionTraced).never.toHaveBeenCalled()
		end)
	end)
	describe("disabled", function()
		beforeEach(function()
			return loadModules({ enableSchedulerTracing = false })
		end)

		it("TODO - we need at least one test for JestRoblox not to throw", function() end)

		-- TODO
	end)
end) ]]
hP.Children._69992dae6853132a74edaf7e8f12d8fb=h1
local h2

local h3={ClassName="Folder",Children={},Properties={}}
h3.Name="forks"
hx.Children._47c169bebecf50bb8b459389d45feba3=h3
local h4
local h5={ClassName="ModuleScript",Children={},Properties={}}
h5.Name="SchedulerHostConfig.default"
h5.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/5474a83e258b497584bed9df95de1d554bc53f89/packages/scheduler/src/forks/SchedulerHostConfig.default.js
--!strict
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Shared = require(Packages.Shared)
local console = Shared.console
local errorToString = Shared.errorToString
local describeError = Shared.describeError

-- ROBLOX deviation: getCurrentTime will always map to `tick` in Luau
local getCurrentTime = function()
	-- Return a result in milliseconds
	return os.clock() * 1000
end

-- ROBLOX deviation: This module in React exports a different implementation if
-- it detects certain APIs from the DOM interface. We instead attempt to
-- approximate that behavior so that we can access features like dividing work
-- according to frame time

-- Capture local references to native APIs, in case a polyfill overrides them.
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout

local isMessageLoopRunning = false
local scheduledHostCallback: ((boolean, number) -> boolean) | nil = nil
local taskTimeoutID = Object.None

-- Scheduler periodically yields in case there is other work on the main
-- thread, like user events. By default, it yields multiple times per frame.
-- It does not attempt to align with frame boundaries, since most tasks don't
-- need to be frame aligned; for those that do, use requestAnimationFrame.
local yieldInterval = 15
local deadline = 0

-- ROBLOX deviation: Removed some logic around browser functionality that's not
-- present in the roblox engine
local function shouldYieldToHost()
	return getCurrentTime() >= deadline
end

-- Since we yield every frame regardless, `requestPaint` has no effect.
local function requestPaint() end

local function forceFrameRate(fps)
	if fps < 0 or fps > 125 then
		console.warn(
			"forceFrameRate takes a positive int between 0 and 125, "
				.. "forcing frame rates higher than 125 fps is not supported"
		)
		return
	end
	if fps > 0 then
		yieldInterval = math.floor(1000 / fps)
	else
		-- reset the framerate
		yieldInterval = 5
	end
end

local function performWorkUntilDeadline()
	if scheduledHostCallback ~= nil then
		local currentTime = getCurrentTime()
		-- Yield after `yieldInterval` ms, regardless of where we are in the vsync
		-- cycle. This means there's always time remaining at the beginning of
		-- the message event.
		deadline = currentTime + yieldInterval
		local hasTimeRemaining = true

		local ok, result
		local function doWork()
			local hasMoreWork = (scheduledHostCallback :: any)(
				hasTimeRemaining,
				currentTime
			)
			if not hasMoreWork then
				isMessageLoopRunning = false
				scheduledHostCallback = nil
			else
				-- If there's more work, schedule the next message event at the end
				-- of the preceding one.

				-- ROBLOX deviation: Use task api instead of message channel;
				-- depending on whether or not we still have time to perform
				-- more work, either yield and defer till later this frame, or
				-- delay work till next frame

				-- ROBLOX FIXME: What's the proper combination of task.defer and
				-- task.delay that makes this optimal?
				task.delay(0, performWorkUntilDeadline)
			end
			return nil
		end
		if not _G.__YOLO__ then
			ok, result = xpcall(doWork, describeError)
		else
			result = doWork()
			ok = true
		end

		if not ok then
			-- If a scheduler task throws, exit the current coroutine so the
			-- error can be observed.
			task.delay(0, performWorkUntilDeadline)

			-- ROBLOX FIXME: the top-level Luau VM handler doesn't deal with
			-- non-string errors, so massage it until VM support lands
			error(errorToString(result :: any))
		end
	else
		isMessageLoopRunning = false
	end
end

local function requestHostCallback(callback)
	scheduledHostCallback = callback
	if not isMessageLoopRunning then
		isMessageLoopRunning = true

		task.delay(0, performWorkUntilDeadline)
	end
end

local function cancelHostCallback()
	scheduledHostCallback = nil
end

local function requestHostTimeout(callback, ms)
	taskTimeoutID = setTimeout(function()
		callback(getCurrentTime())
	end, ms)
end

local function cancelHostTimeout()
	clearTimeout(taskTimeoutID)
	taskTimeoutID = Object.None
end

return {
	requestHostCallback = requestHostCallback,
	cancelHostCallback = cancelHostCallback,
	requestHostTimeout = requestHostTimeout,
	cancelHostTimeout = cancelHostTimeout,
	shouldYieldToHost = shouldYieldToHost,
	requestPaint = requestPaint,
	getCurrentTime = getCurrentTime,
	forceFrameRate = forceFrameRate,
} ]]
h4.Children._2b4e4933524b4bdc978be6393b015728=h5
local h6

local h7={ClassName="ModuleScript",Children={},Properties={}}
h7.Name="SchedulerHostConfig.mock"
h7.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/5474a83e258b497584bed9df95de1d554bc53f89/packages/scheduler/src/forks/SchedulerHostConfig.mock.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

local exports = {}

local currentTime: number = 0
local scheduledCallback: ((boolean, number) -> ()) | nil = nil
local scheduledTimeout: ((number) -> ()) | nil = nil
local timeoutTime: number = -1
local yieldedValues: { [number]: any } | nil = nil
local expectedNumberOfYields: number = -1
local didStop: boolean = false
local isFlushing: boolean = false
local needsPaint: boolean = false
local shouldYieldForPaint: boolean = false
local Packages = script.Parent.Parent.Parent
local console = require(Packages.Shared).console
local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disabledLog = ConsolePatchingDev.disabledLog

exports.requestHostCallback = function(callback: (boolean) -> ())
	scheduledCallback = callback
end

exports.cancelHostCallback = function()
	scheduledCallback = nil
end

exports.requestHostTimeout = function(callback: (number) -> (), ms: number)
	scheduledTimeout = callback
	timeoutTime = currentTime + ms
end

exports.cancelHostTimeout = function()
	scheduledTimeout = nil
	timeoutTime = -1
end

exports.shouldYieldToHost = function(): boolean
	-- deviation: widening type to workaround Luau shortcomings
	-- https://jira.rbx.com/browse/CLI-35978
	local values: any = yieldedValues
	if
		(
			expectedNumberOfYields ~= -1
			and values ~= nil
			and #values >= expectedNumberOfYields
		) or (shouldYieldForPaint and needsPaint)
	then
		-- We yielded at least as many values as expected. Stop flushing.
		didStop = true
		return true
	end

	return false
end

exports.getCurrentTime = function(): number
	return currentTime
end

exports.forceFrameRate = function()
	-- No-op
end

exports.reset = function()
	if isFlushing then
		error("Cannot reset while already flushing work.")
	end

	currentTime = 0
	scheduledCallback = nil
	scheduledTimeout = nil
	timeoutTime = -1
	yieldedValues = nil
	expectedNumberOfYields = -1
	didStop = false
	isFlushing = false
	needsPaint = false
end

-- Should only be used via an assertion helper that inspects the yielded values.
exports.unstable_flushNumberOfYields = function(count: number)
	if isFlushing then
		error("Already flushing work.")
	end

	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		expectedNumberOfYields = count
		isFlushing = true

		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork or didStop

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		expectedNumberOfYields = -1
		didStop = false
		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushUntilNextPaint = function()
	if isFlushing then
		error("Already flushing work.")
	end

	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		shouldYieldForPaint = true
		needsPaint = false
		isFlushing = true
		-- ROBLOX try
		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork or didStop

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		-- ROBLOX finally
		shouldYieldForPaint = false
		didStop = false
		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushExpired = function()
	if isFlushing then
		error("Already flushing work.")
	end
	if scheduledCallback ~= nil then
		isFlushing = true
		local ok, result = pcall(function()
			-- deviation: widening type to workaround Luau shortcomings
			-- https://jira.rbx.com/browse/CLI-35978
			local callback: any = scheduledCallback
			local hasMoreWork = callback(false, currentTime)
			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushAllWithoutAsserting = function(): boolean
	-- Returns false if no work was flushed.
	if isFlushing then
		error("Already flushing work.")
	end
	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		isFlushing = true
		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		isFlushing = false

		if not ok then
			error(result)
		end

		return true
	else
		return false
	end
end

exports.unstable_clearYields = function(): { [number]: any }
	if yieldedValues == nil then
		return {}
	end
	local values = yieldedValues
	yieldedValues = nil
	return values
end

exports.unstable_flushAll = function()
	if yieldedValues ~= nil then
		error(
			"Log is not empty. Assert on the log of yielded values before "
				.. "flushing additional work."
		)
	end
	exports.unstable_flushAllWithoutAsserting()
	if yieldedValues ~= nil then
		error(
			"While flushing work, something yielded a value. Use an "
				.. "assertion helper to assert on the log of yielded values, e.g. "
				.. "expect(Scheduler).toFlushAndYield([...])"
		)
	end
end

exports.unstable_yieldValue = function(value: any)
	-- eslint-disable-next-line react-internal/no-production-logging
	if console.log == disabledLog then
		-- If console.log has been patched, we assume we're in render
		-- replaying and we ignore any values yielding in the second pass.
		return
	end
	if yieldedValues == nil then
		yieldedValues = { value }
	else
		-- deviation: widening type to workaround Luau shortcomings
		-- https://jira.rbx.com/browse/CLI-35978
		local values: any = yieldedValues
		table.insert(values, value)
	end
end

exports.unstable_advanceTime = function(ms: number)
	-- eslint-disable-next-line react-internal/no-production-logging
	if console.log == disabledLog then
		-- If console.log has been patched, we assume we're in render
		-- replaying and we ignore any time advancing in the second pass.
		return
	end
	currentTime += ms

	if scheduledTimeout ~= nil and timeoutTime <= currentTime then
		-- deviation: widening type to workaround Luau shortcomings
		-- https://jira.rbx.com/browse/CLI-35978
		local timeout: any = scheduledTimeout
		timeout(currentTime)
		timeoutTime = -1
		scheduledTimeout = nil
	end
end

exports.requestPaint = function()
	needsPaint = true
end

return exports ]]
h4.Children._e90b6127b2816f5e1a10bbe07d286605=h7
local h8

local h9={ClassName="ModuleScript",Children={},Properties={}}
h9.Name="unstable_mock"
h9.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*\]\]
local Tracing = require(script.Parent.Tracing)
local TracingSubscriptions = require(script.Parent.TracingSubscriptions)
-- ROBLOX deviation: export Tracing type from the package exports to avoid direct file access
export type Interaction = Tracing.Interaction

local initializeScheduler = require(script.Parent.Scheduler)
local HostConfig = require(script.Parent.forks["SchedulerHostConfig.mock"])

local Scheduler = initializeScheduler(HostConfig)

local exports = {}
exports.tracing = {}
-- ROBLOX FIXME Luau: need to fix CLI-56768 to remove any casts
for key, value in Scheduler :: any do
	exports[key] = value
end
for key, value in Tracing :: any do
	exports.tracing[key] = value
end
for key, value in TracingSubscriptions :: any do
	exports.tracing[key] = value
end

exports.unstable_flushAllWithoutAsserting = HostConfig.unstable_flushAllWithoutAsserting
exports.unstable_flushNumberOfYields = HostConfig.unstable_flushNumberOfYields
exports.unstable_flushExpired = HostConfig.unstable_flushExpired
exports.unstable_clearYields = HostConfig.unstable_clearYields
exports.unstable_flushUntilNextPaint = HostConfig.unstable_flushUntilNextPaint
exports.unstable_flushAll = HostConfig.unstable_flushAll
exports.unstable_yieldValue = HostConfig.unstable_yieldValue
exports.unstable_advanceTime = HostConfig.unstable_advanceTime
exports.unstable_Profiling = Scheduler.unstable_Profiling

return exports ]]
hx.Children._cedc2c5b66d387d02907bd51b7731782=h9
local ia

local ib={ClassName="ModuleScript",Children={},Properties={}}
ib.Name="Shared"
ib.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

-- ROBLOX deviation: Promote `shared` to an actual unpublished package with a
-- real interface instead of just a bag of loose source code
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local ReactTypes = require(script.ReactTypes)
local flowtypes = require(script["flowtypes.roblox"])
local ReactElementType = require(script.ReactElementType)
local ReactFiberHostConfig = require(script.ReactFiberHostConfig)
local ReactSharedInternals = require(script.ReactSharedInternals)
local ErrorHandling = require(script["ErrorHandling.roblox"])

-- Re-export all top-level public types
export type ReactEmpty = ReactTypes.ReactEmpty
export type ReactFragment = ReactTypes.ReactFragment
export type ReactNodeList = ReactTypes.ReactNodeList
export type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
export type ReactConsumer<T> = ReactTypes.ReactConsumer<T>
export type ReactProvider<T> = ReactTypes.ReactProvider<T>
export type ReactContext<T> = ReactTypes.ReactContext<T>
export type ReactPortal = ReactTypes.ReactPortal
export type RefObject = ReactTypes.RefObject
export type EventPriority = ReactTypes.EventPriority
export type ReactFundamentalComponentInstance<C, H> =
	ReactTypes.ReactFundamentalComponentInstance<C, H>
export type ReactFundamentalImpl<C, H> = ReactTypes.ReactFundamentalImpl<C, H>
export type ReactFundamentalComponent<C, H> = ReactTypes.ReactFundamentalComponent<C, H>
export type ReactScope = ReactTypes.ReactScope
export type ReactScopeQuery = ReactTypes.ReactScopeQuery
export type ReactScopeInstance = ReactTypes.ReactScopeInstance
-- ROBLOX deviation START: Re-export bindings types
export type ReactBinding<T> = ReactTypes.ReactBinding<T>
export type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END
export type MutableSourceVersion = ReactTypes.MutableSourceVersion
export type MutableSourceGetSnapshotFn<Source, Snapshot> =
	ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>
export type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
export type MutableSourceGetVersionFn = ReactTypes.MutableSourceGetVersionFn
export type MutableSource<Source> = ReactTypes.MutableSource<Source>
export type Wakeable = ReactTypes.Wakeable
export type Thenable<R> = ReactTypes.Thenable<R>
export type Source = ReactElementType.Source
export type ReactElement<P = Object, T = any> = ReactElementType.ReactElement<P, T>
export type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType
export type Dispatcher = ReactSharedInternals.Dispatcher

-- re-export flowtypes from here. I wonder if this should be a separate 'package'?
export type React_Ref<ElementType> = flowtypes.React_Ref<ElementType>
export type React_Context<T> = flowtypes.React_Context<T>
export type React_AbstractComponent<Config, Instance> = flowtypes.React_AbstractComponent<
	Config,
	Instance
>
export type React_ComponentType<Config> = flowtypes.React_ComponentType<Config>
export type React_PureComponent<Props, State = nil> = flowtypes.React_PureComponent<
	Props,
	State
>
export type React_Component<Props, State> = flowtypes.React_Component<Props, State>
export type React_ElementProps<ElementType> = flowtypes.React_ElementProps<ElementType>
export type React_StatelessFunctionalComponent<Props> =
	flowtypes.React_StatelessFunctionalComponent<Props>
export type React_Node = flowtypes.React_Node
export type React_Element<ElementType> = flowtypes.React_Element<ElementType>
export type React_ElementType = flowtypes.React_ElementType
export type React_ElementConfig<C> = flowtypes.React_ElementConfig<C>
export type React_ElementRef<C> = flowtypes.React_ElementRef<C>
export type React_Portal = flowtypes.React_Portal
export type React_Key = flowtypes.React_Key

return {
	checkPropTypes = require(script.checkPropTypes),
	console = require(script.console),
	ConsolePatchingDev = require(script["ConsolePatchingDev.roblox"]),
	consoleWithStackDev = require(script.consoleWithStackDev),
	enqueueTask = require(script["enqueueTask.roblox"]),
	ExecutionEnvironment = require(script.ExecutionEnvironment),
	formatProdErrorMessage = require(script.formatProdErrorMessage),
	getComponentName = require(script.getComponentName),
	invariant = require(script.invariant),
	invokeGuardedCallbackImpl = require(script.invokeGuardedCallbackImpl),
	isValidElementType = require(script.isValidElementType),
	objectIs = require(script.objectIs),
	ReactComponentStackFrame = require(script.ReactComponentStackFrame),
	ReactElementType = require(script.ReactElementType),
	ReactErrorUtils = require(script.ReactErrorUtils),
	ReactFeatureFlags = require(script.ReactFeatureFlags),
	ReactInstanceMap = require(script.ReactInstanceMap),
	-- ROBLOX deviation: Instead of re-exporting from here, Shared actually owns
	-- these files itself
	ReactSharedInternals = ReactSharedInternals,
	-- ROBLOX deviation: Instead of extracting these out of the reconciler and
	-- then re-injecting the host config _into_ the reconciler, export these
	-- from shared for easier reuse
	ReactFiberHostConfig = ReactFiberHostConfig,

	ReactSymbols = require(script.ReactSymbols),
	ReactVersion = require(script.ReactVersion),
	shallowEqual = require(script.shallowEqual),
	UninitializedState = require(script["UninitializedState.roblox"]),
	ReactTypes = ReactTypes,

	-- ROBLOX DEVIATION: export error-stack-preserving utilities for use in
	-- scheduler and reconciler, and parsing function for use in public API
	describeError = ErrorHandling.describeError,
	errorToString = ErrorHandling.errorToString,
	parseReactError = ErrorHandling.parseReactError,

	-- ROBLOX DEVIATION: export Symbol and Type from Shared
	Symbol = require(script["Symbol.roblox"]),
	Type = require(script["Type.roblox"]),

	-- ROBLOX DEVIATION: export propmarkers from Shared
	Change = require(script.PropMarkers.Change),
	Event = require(script.PropMarkers.Event),
	Tag = require(script.PropMarkers.Tag),
} ]]
c.Children._54f71b4fd49dbd0ad28f64bf0315cfb7=ib
local ic
local id={ClassName="ModuleScript",Children={},Properties={}}
id.Name="ConsolePatchingDev.roblox"
id.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

-- deviation: Lua objects don't have any special properties the way that JS
-- Objects do; this has been modified from the JS, which uses
-- `Object.defineProperties` to ensure that properties are modifiable. In Lua,
-- these operations are as simple as assigning to functions.
-- ROBLOX: use patched console from shared
local console = require(script.Parent.console)

-- Helpers to patch console.logs to avoid logging during side-effect free
-- replaying on render function. This currently only patches the object
-- lazily which won't cover if the log function was extracted eagerly.
-- We could also eagerly patch the method.
local disabledDepth = 0
local prevLog
local prevInfo
local prevWarn
local prevError
local prevGroup
local prevGroupCollapsed
local prevGroupEnd

local disabledLog = function() end

local exports = {}

-- ROBLOX deviation: console.log's name property is checked in SchedulerHostConfig.
-- But since Lua functions don't carry properties, we export this and import it there
-- for a reference equality.
exports.disabledLog = disabledLog

exports.disableLogs = function()
	if _G.__DEV__ then
		if disabledDepth == 0 then
			prevLog = console.log
			prevInfo = console.info
			prevWarn = console.warn
			prevError = console.error
			prevGroup = console.group
			prevGroupCollapsed = console.groupCollapsed
			prevGroupEnd = console.groupEnd

			console.info = disabledLog
			console.log = disabledLog
			console.warn = disabledLog
			console.error = disabledLog
			console.group = disabledLog
			console.groupCollapsed = disabledLog
			console.groupEnd = disabledLog
		end

		disabledDepth = disabledDepth + 1
	end
end

exports.reenableLogs = function()
	if _G.__DEV__ then
		disabledDepth = disabledDepth - 1

		if disabledDepth == 0 then
			console.log = prevLog
			console.info = prevInfo
			console.warn = prevWarn
			console.error = prevError
			console.group = prevGroup
			console.groupCollapsed = prevGroupCollapsed
			console.groupEnd = prevGroupEnd
		end

		if disabledDepth < 0 then
			console.error(
				"disabledDepth fell below zero. "
					.. "This is a bug in React. Please file an issue."
			)
		end
	end
end

return exports ]]
ic.Children._0150d3655bc9cd15d4fdf1e7d5711177=id
local ie

local ig={ClassName="ModuleScript",Children={},Properties={}}
ig.Name="ErrorHandling.roblox"
ig.Properties.Source=[[ --!strict
--\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect

local DIVIDER = "\n------ Error caught by React ------\n"

--\[\[
	React does a lot of catching, retrying, and rethrowing errors that would
	typically result in loss of meaningful stack information.

	We use xpcall combined with this error function to capture and rethrow in a
	way that retains some stack information.
\]\]
local function describeError(e: string | Error): Error
	if typeof(e) == "string" then
		local _, endOfStackFrame = string.find(e, ":[%d]+: ")
		local message = if endOfStackFrame then string.sub(e, endOfStackFrame + 1) else e

		local err = LuauPolyfill.Error.new(message)
		err.stack = debug.traceback(nil, 2)
		return err
	end
	return e :: Error
end

--\[\[
	Even though Luau can catch and rethrow arbitrary objects, only string errors
	are supported by the ScriptContext.ErrorDetailed signal (the mechanism used
	to catch unhandled errors at the top level).

	This function turns an arbitrary error object into a detailed string message
	to avoid any loss of information.
\]\]
local function errorToString(error_: Error | Object | string | Array<any>): string
	local errorString
	if typeof(error_) == "table" then
		if (error_ :: Error).message and (error_ :: Error).stack then
			-- Adding these clear dividers helps us split this error back up
			-- into pieces later. We include one at the beginning so that the
			-- final stack frame added by rethrowing can be carved off
			errorString = DIVIDER
				.. (error_ :: Error).message
				.. DIVIDER
				.. tostring((error_ :: Error).stack)
		else
			errorString = inspect(error_)
		end
	else
		errorString = inspect(error_)
	end

	return errorString
end

--\[\[
	If an error string was generated from an Error object via the errorToString
	function above, it can be easily split back out into an informative error
	object.
\]\]
local function parseReactError(error_: string): (Error, string)
	local split = string.split(error_, DIVIDER)

	if #split == 3 then
		local rethrow, message, stack = table.unpack(split)

		local newError = Error.new(message)
		newError.stack = stack

		return newError, rethrow
	else
		-- This error was not in the expected format, so we use the whole string
		-- as the 'message' value and nil out the stack (it would be misleading
		-- if we included the one generated here)
		local newError = Error.new(error_)
		newError.stack = nil

		return newError, ""
	end
end

return {
	describeError = describeError,
	errorToString = errorToString,
	parseReactError = parseReactError,
	-- Used only by tests
	__ERROR_DIVIDER = DIVIDER,
} ]]
ic.Children._a83bdf677db6560f99ac65364070094a=ig
local ih

local ii={ClassName="ModuleScript",Children={},Properties={}}
ii.Name="ExecutionEnvironment"
ii.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/ExecutionEnvironment.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local exports = {}

exports.canUseDOM = function()
	-- ROBLOX deviation START
	return false
	-- ROBLOX deviation END
end

return exports ]]
ic.Children._30f395caafda507458d27af53d88cd21=ii
local ij

local ik={ClassName="Folder",Children={},Properties={}}
ik.Name="PropMarkers"
ic.Children._be997bb88222716e3c158972608abaf0=ik
local il
local im={ClassName="ModuleScript",Children={},Properties={}}
im.Name="Change"
im.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
\]\]

local Type = require(script.Parent.Parent["Type.roblox"])

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return string.format("RoactHostChangeEvent(%s)", self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change ]]
il.Children._f5989f3192b5335a66fa1aad3c540607=im
local ip

local iq={ClassName="ModuleScript",Children={},Properties={}}
iq.Name="Event"
iq.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
\]\]

local Type = require(script.Parent.Parent["Type.roblox"])

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return string.format("RoactHostEvent(%s)", self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event ]]
il.Children._dc7c19bed137ed6c28a4e40acdc40ecd=iq
local ir

local is={ClassName="ModuleScript",Children={},Properties={}}
is.Name="Tag"
is.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	Special value for assigning tags to roblox instances via Roact
\]\]
local Symbol = require(script.Parent.Parent["Symbol.roblox"])

local Tag = Symbol.named("RobloxTag")

return Tag ]]
il.Children._d7b3b5bf16d5f557b7f4cf3859a77d5d=is
local it

local iu={ClassName="Folder",Children={},Properties={}}
iu.Name="__tests__"
il.Children._fdfaafec916334456a9f0ae7adf8a30f=iu
local iv
local iw={ClassName="ModuleScript",Children={},Properties={}}
iw.Name="Change.spec"
iw.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local it = JestGlobals.it

local Type = require(script.Parent.Parent.Parent["Type.roblox"])
local Change = require(script.Parent.Parent.Change)

it("should yield change listener objects when indexed", function()
	jestExpect(Type.of(Change.Text)).toBe(Type.HostChangeEvent)
	jestExpect(Type.of(Change.Selected)).toBe(Type.HostChangeEvent)
end)

it("should yield the same object when indexed again", function()
	local a = Change.Text
	local b = Change.Text
	local c = Change.Selected

	jestExpect(a).toBe(b)
	jestExpect(a).never.toBe(c)
end) ]]
iv.Children._3b884723346285059223418a1b49e5ae=iw
local ix

local iy={ClassName="ModuleScript",Children={},Properties={}}
iy.Name="Event.spec"
iy.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

local Packages = script.Parent.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local it = JestGlobals.it

local Type = require(script.Parent.Parent.Parent["Type.roblox"])
local Event = require(script.Parent.Parent.Event)

it("should yield event objects when indexed", function()
	jestExpect(Type.of(Event.MouseButton1Click)).toBe(Type.HostEvent)
	jestExpect(Type.of(Event.Touched)).toBe(Type.HostEvent)
end)

it("should yield the same object when indexed again", function()
	local a = Event.MouseButton1Click
	local b = Event.MouseButton1Click
	local c = Event.Touched

	jestExpect(a).toBe(b)
	jestExpect(a).never.toBe(c)
end) ]]
iv.Children._6b18c91723b608715ea11115448d12c8=iy
local iz

local iA={ClassName="ModuleScript",Children={},Properties={}}
iA.Name="ReactComponentStackFrame"
iA.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/shared/ReactComponentStackFrame.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

type Object = { [string]: any }
type Function = (...any) -> ...any

local ReactElementType = require(script.Parent.ReactElementType)
type Source = ReactElementType.Source

-- ROBLOX deviation: Needed to properly type class components
local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>
type ReactComponent<P> = React_StatelessFunctionalComponent<P> | React_ComponentType<P>

-- ROBLOX DEVIATION: Ignore enableComponentStackLocations
-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableComponentStackLocations = ReactFeatureFlags.enableComponentStackLocations

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE

local ConsolePatchingDev = require(script.Parent["ConsolePatchingDev.roblox"])
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher

-- ROBLOX deviation: the prefix is constant because the console prints the stack
-- frames the same way on every platform.
local prefix = "    in "

-- ROBLOX deviation: declare these now because of scoping differences between in
-- Lua and JS
local describeComponentFrame
local describeFunctionComponentFrame

-- ROBLOX deviation: since owner could be a function or a class component, we
-- need to do additional handling to get its name. It's easier to make this a
-- reusable function
local function describeOwner(owner: nil | ReactComponent<any>): string?
	if type(owner) == "function" then
		return debug.info(owner :: (any) -> any, "n")
	elseif type(owner) == "table" then
		return tostring(owner)
	end
	return nil
end

local function describeBuiltInComponentFrame(
	name: string,
	source: Source | nil,
	-- ROBLOX deviation: owner could be a class component
	owner: nil | ReactComponent<any>
): string
	-- ROBLOX deviation START: for built-in components, we can provide the full
	-- description regardless of `enableStackLocations` since we don't actually
	-- need to do any callstack trickery to get it

	-- if enableComponentStackLocations then
	-- 	if prefix == nil then
	-- 		-- Extract the VM specific prefix used by each line.
	-- 		local _, x = pcall(error, debug.traceback())

	-- 		local match = x.stack.trim().match("\n00:00:00.000 - ")
	-- 		if match then
	-- 			prefix = match[1]
	-- 		else
	-- 			prefix = ''
	-- 		end
	-- 	end
	-- 	-- We use the prefix to ensure our stacks line up with native stack frames.
	-- 	return "\n" .. prefix .. name
	-- else
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and owner then
	-- 		ownerName = describeOwner(owner)
	-- 	end

	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end

	return describeComponentFrame(name, source, ownerName)
	-- ROBLOX deviation END
end

local reentry = false
local componentFrameCache = nil
if _G.__DEV__ then
	componentFrameCache = setmetatable({}, { __mode = "k" })
end

local function describeNativeComponentFrame(
	fn: nil | ReactComponent<any>, -- ROBLOX TODO: only accept tables with __tostring metamethod overridden
	construct: boolean
): string
	-- // If something asked for a stack inside a fake render, it should get ignored.
	if not fn or reentry then
		return ""
	end

	if _G.__DEV__ then
		local frame = componentFrameCache[fn]

		if frame ~= nil then
			return frame
		end
	end

	local control
	reentry = true

	-- deviation: Error.prepareStackTrace is not implemented
	-- local previousPrepareStackTrace = Error.prepareStackTrace
	-- Error.prepareStackTrace = undefined
	local previousDispatcher

	if _G.__DEV__ then
		previousDispatcher = ReactCurrentDispatcher.current
		-- Set the dispatcher in DEV because this might be call in the render
		-- function for warnings.
		ReactCurrentDispatcher.current = nil
		disableLogs()
	end

	-- // This should throw.
	-- deviation: Lua does not have stack traces with errors, so we
	-- use xpcall to convert the error and append a stack trace.
	-- This will change the theorical stack trace we want, because of
	-- the function where we call 'debug.traceback()', but the control
	-- stack will have the same added frame.
	local traceback
	local _, sample = xpcall(function()
		if construct then
			-- deviation: since we can't have a meaningful stack trace when
			-- constructing from a component class (because it does not locate
			-- component definition), we skip this case.
		else
			local _, x = pcall(function()
				traceback = debug.traceback()
				error({
					stack = traceback,
				})
			end)
			control = x;
			-- ROBLOX FIXME: Luau flow analysis bug workaround
			(fn :: (...any) -> ...any)()
		end
	end, function(message)
		return {
			message = message,
			stack = traceback,
		}
	end)

	-- deviation: Lua does not have a structure that works like a try-catch-finally
	-- so we a variable to know if the catch block returns a value. If it returns,
	-- 'earlyOutValue' will be set and we can return its value after running the
	-- instructions in the finally block.
	local earlyOutValue = nil

	if sample and control and type(sample.stack) == "string" then
		-- // This extracts the first frame from the sample that isn't also in the control.
		-- // Skipping one frame that we assume is the frame that calls the two.
		local sampleLines = string.split(sample.stack, "\n")
		local controlLines = string.split(control.stack, "\n")
		-- deviation: remove one because our array of lines contains an empty string
		-- at the end
		local sampleIndex = #sampleLines - 1
		local controlIndex = #controlLines - 1

		while
			sampleIndex >= 2
			and controlIndex >= 0
			and sampleLines[sampleIndex] ~= controlLines[controlIndex]
		do
			-- // We expect at least one stack frame to be shared.
			-- // Typically this will be the root most one. However, stack frames may be
			-- // cut off due to maximum stack limits. In this case, one maybe cut off
			-- // earlier than the other. We assume that the sample is longer or the same
			-- // and there for cut off earlier. So we should find the root most frame in
			-- // the sample somewhere in the control.
			controlIndex = controlIndex - 1
		end

		while sampleIndex >= 3 and controlIndex >= 1 do
			sampleIndex = sampleIndex - 1
			controlIndex = controlIndex - 1
			-- // Next we find the first one that isn't the same which should be the
			-- // frame that called our sample function and the control.
			if sampleLines[sampleIndex] ~= controlLines[controlIndex] then
				-- // In V8, the first line is describing the message but other VMs don't.
				-- // If we're about to return the first line, and the control is also on the same
				-- // line, that'sampleIndex a pretty good indicator that our sample threw at same line as
				-- // the control. I.e. before we entered the sample frame. So we ignore this result.
				-- // This can happen if you passed a class to function component, or non-function.
				if sampleIndex ~= 1 or controlIndex ~= 1 then
					repeat
						sampleIndex = sampleIndex - 1
						controlIndex = controlIndex - 1
						-- // We may still have similar intermediate frames from the construct call.
						-- // The next one that isn't the same should be our match though.
						if
							controlIndex < 0
							or sampleLines[sampleIndex] ~= controlLines[controlIndex]
						then
							-- deviation: add the '    in ' prefix to format the component stack
							-- similar to React
							local frame = "\n" .. prefix .. sampleLines[sampleIndex]

							if _G.__DEV__ then
								componentFrameCache[fn] = frame
							end
							-- // Return the line we found.
							-- deviation: to mimic the behavior of the try-catch-finally
							-- we cannot return the value here.
							earlyOutValue = frame
						end
					until not (sampleIndex >= 3 and controlIndex >= 1)
				end

				break
			end
		end
	end

	reentry = false
	if _G.__DEV__ then
		ReactCurrentDispatcher.current = previousDispatcher
		reenableLogs()
	end

	-- deviation: Error.prepareStackTrace is not implemented
	-- Error.prepareStackTrace = previousPrepareStackTrace

	-- deviation: return here to micmic the end of the finally block
	if earlyOutValue ~= nil then
		return earlyOutValue
	end

	-- Fallback to just using the name if we couldn't make it throw.
	-- ROBLOX deviation START: Can't get displayName for functions, since fn can be a class, we can get the class name here
	local name = if type(fn) == "function"
		then debug.info(fn :: Function, "n")
		-- ROBLOX deviation :
		else if type(fn) == "table" then tostring(fn) else ""

	local syntheticFrame = ""
	if name ~= nil and name ~= "" then
		syntheticFrame = describeBuiltInComponentFrame(name)
	end

	if _G.__DEV__ then
		componentFrameCache[fn] = syntheticFrame
	end

	return syntheticFrame
end

-- ROBLOX deviation: Lua's patterns work slightly differently than regexes
local BEFORE_SLASH_PATTERN = "^(.*)[\\/]"

function describeComponentFrame(
	name: string | nil,
	source: Source | nil,
	ownerName: string | nil
): string
	local sourceInfo = ""

	if _G.__DEV__ and source then
		local path = source.fileName
		local fileName = string.gsub(path, BEFORE_SLASH_PATTERN, "")

		-- // In DEV, include code for a common special case:
		-- // prefer "folder/index.js" instead of just "index.js".
		-- ROBLOX deviation: instead of having a special case for 'index.',
		-- we use 'init.'
		if string.match(fileName, "^init%.") then
			-- deviation: finding matching strings works differently in Lua
			local pathBeforeSlash = string.match(path, BEFORE_SLASH_PATTERN)

			if pathBeforeSlash and #pathBeforeSlash ~= 0 then
				local folderName = string.gsub(pathBeforeSlash, BEFORE_SLASH_PATTERN, "")
				fileName = folderName .. "/" .. fileName
			end
		end

		sourceInfo = " (at " .. fileName .. ":" .. source.lineNumber .. ")"
	elseif ownerName then
		sourceInfo = " (created by " .. ownerName .. ")"
	end

	return "\n    in " .. (name or "Unknown") .. sourceInfo
end

local function describeClassComponentFrame(
	-- ROBLOX deviation: React.Component<any>
	ctor: any,
	source: nil | Source,
	-- ROBLOX deviation: this could be a class component OR a function component
	owner: nil | ReactComponent<any>
): string
	-- ROBLOX deviation START: In Roact, class components are tables, so we
	-- jump directly to using the basic component description.

	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(componentClass, true)
	-- else
	-- 	return describeFunctionComponentFrame(ctor, source, ownerFn);
	-- end
	local name = tostring(ctor)
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end
	return describeComponentFrame(name, source, ownerName)
	-- ROBLOX deviation END
end

function describeFunctionComponentFrame(
	-- ROBLOX TODO: this annotation is incorrect upstream, we fix it here
	fn: nil | Function,
	source: nil | Source,
	-- ROBLOX deviation: this could be a class component OR a function component
	ownerFn: nil | ReactComponent<any>
): string
	-- ROBLOX DEVIATION Jump directly to using basic component description:
	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(fn, false)
	-- else
	-- 	if not fn then
	-- 		return ""
	-- 	end
	-- 	-- ROBLOX deviation: use debug.info to discover function names
	-- 	local name = debug.info(fn :: Function, "n")
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and ownerFn then
	-- 		-- ROBLOX deviation: owner may be a function or a table
	-- 		ownerName = describeOwner(ownerFn)
	-- 	end
	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	if not fn then
		return ""
	end
	-- ROBLOX deviation: use debug.info to discover function names
	-- ROBLOX FIXME: find out how non-functions are getting into here, they pollute test output
	local name = if type(fn) == "function"
		then debug.info(fn :: Function, "n")
		else tostring(fn)
	local ownerName = nil
	if _G.__DEV__ and ownerFn then
		-- ROBLOX deviation: owner may be a function or a table
		ownerName = describeOwner(ownerFn)
	end
	return describeComponentFrame(name, source, ownerName)
end

-- ROBLOX deviation: because of deviations in other functions, this function is
-- not needed. If we need to bring it, it should return true if Component is a
-- class component, and false if a function component
-- local function shouldConstruct(Component)
-- 	local prototype = Component.prototype
-- 	return not not (prototype and prototype.isReactComponent)
-- end

local function describeUnknownElementTypeFrameInDEV(
	type_: any,
	source: nil | Source,
	-- ROBLOX deviation: owner could be a class component
	ownerFn: nil | ReactComponent<any>
): string
	if not _G.__DEV__ then
		return ""
	end
	if type_ == nil then
		return ""
	end

	-- ROBLOX deviation: in JavaScript, if `type` contains a class, typeof will
	-- return "function". We need to specifically check for the class.
	if type(type_) == "table" and type(type_.__ctor) == "function" then
		-- ROBLOX deviation: since Roact class components are tables, we can't
		-- count on describeClassComponent being a thin wrapper for
		-- describeFunctionComponent like upstream does implicitly
		return describeClassComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "function" then
		-- ROBLOX DEVIATION: ignore enableComponentStackLocations
		-- if enableComponentStackLocations then
		-- 	-- ROBLOX deviation: since functions and classes have different
		-- 	-- types in Lua, we already know that shouldConstruct would return
		-- 	-- false
		-- 	return describeNativeComponentFrame(type, false)
		-- else
		-- 	return describeFunctionComponentFrame(type, source, ownerFn)
		-- end
		return describeFunctionComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "string" then
		return describeBuiltInComponentFrame(type_, source, ownerFn)
	end

	if type_ == REACT_SUSPENSE_TYPE then
		return describeBuiltInComponentFrame("Suspense", source, ownerFn)
	elseif type_ == REACT_SUSPENSE_LIST_TYPE then
		return describeBuiltInComponentFrame("SuspenseList", source, ownerFn)
	end

	if type(type_) == "table" then
		local typeProp = type_["$$typeof"]
		if typeProp == REACT_FORWARD_REF_TYPE then
			return describeFunctionComponentFrame(type_.render, source, ownerFn)
		elseif typeProp == REACT_MEMO_TYPE then
			-- // Memo may contain any component type so we recursively resolve it.
			return describeUnknownElementTypeFrameInDEV(type_.type, source, ownerFn)
		elseif typeProp == REACT_BLOCK_TYPE then
			return describeFunctionComponentFrame(type_._render, source, ownerFn)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent = type_
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			local ok, result = pcall(function()
				describeUnknownElementTypeFrameInDEV(
					-- // Lazy may contain any component type so we recursively resolve it.
					init(payload),
					source,
					ownerFn
				)
			end)

			if ok then
				return result
			end
		end
	end

	return ""
end

return {
	-- deviation: ReactShallowRenderer depends on this, but the upstream `react`
	-- repo doesn't expose it; instead, the shallow-renderer's copies of shared
	-- modules do so. Since we opted to reuse the shared modules in this repo
	-- instead of duplicating, we need to have them include this field
	describeComponentFrame = describeComponentFrame,

	describeBuiltInComponentFrame = describeBuiltInComponentFrame,
	describeNativeComponentFrame = describeNativeComponentFrame,
	describeClassComponentFrame = describeClassComponentFrame,
	describeFunctionComponentFrame = describeFunctionComponentFrame,
	describeUnknownElementTypeFrameInDEV = describeUnknownElementTypeFrameInDEV,
} ]]
ic.Children._6065326b33d143e3b78bae407debeb84=iA
local iB

local iC={ClassName="ModuleScript",Children={},Properties={}}
iC.Name="ReactElementType"
iC.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<ElementType> = flowtypes.React_Element<ElementType>
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<
	P
>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>

export type Source = {
	fileName: string,
	lineNumber: number,
}
type Key = string | number
-- ROBLOX deviation: we're using the TypeScript definition here, which is more strict
export type ReactElement<P = Object, T = any> = {
	["$$typeof"]: number,

	-- ROBLOX FIXME Luau: Luau has some trouble and inlining the type param from createElement doesn't help
	type: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | string,
	-- type: T,
	key: Key | nil,
	ref: any,
	props: P,

	-- ROBLOX deviation: upstream has this as interface, which is extensible, Luau types are closed by default
	-- ReactFiber
	_owner: any,

	-- __DEV__
	_store: any?,
	_self: React_Element<any>?,
	_shadowChildren: any?,
	_source: Source?,
}

-- deviation: Return something so that the module system is happy
return {} ]]
ic.Children._f4fd99b2ef25c98e8bc3b021036cb358=iC
local iD

local iE={ClassName="ModuleScript",Children={},Properties={}}
iE.Name="ReactErrorUtils"
iE.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactErrorUtils.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]
local invariant = require(script.Parent.invariant)
local invokeGuardedCallbackImpl = require(script.Parent.invokeGuardedCallbackImpl)

-- deviation: preemptively declare function
local clearCaughtError

-- Used by Fiber to simulate a try-catch.
local hasError = false
local caughtError = nil

-- Used by event system to capture/rethrow the first error.
local hasRethrowError = false
local rethrowError = nil
local reporter = {
	onError = function(err)
		hasError = true
		caughtError = err
	end,
}
local exports = {}

--\[\[*
* Call a function while guarding against errors that happens within it.
* Returns an error if it throws, otherwise nil.
*
* In production, this is implemented using a try-catch. The reason we don't
* use a try-catch directly is so that we can swap out a different
* implementation in DEV mode.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
\]\]
exports.invokeGuardedCallback = function(...)
	hasError = false
	caughtError = nil
	-- deviation: passing in reporter directly
	invokeGuardedCallbackImpl(reporter, ...)
end

--\[\[*
* Same as invokeGuardedCallback, but instead of returning an error, it stores
* it in a global so it can be rethrown by `rethrowCaughtError` later.
* TODO: See if caughtError and rethrowError can be unified.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
\]\]
exports.invokeGuardedCallbackAndCatchFirstError = function(...)
	-- deviation: instead of the weird `this` indirection, pass varargs through
	exports.invokeGuardedCallback(...)

	if hasError then
		local err = clearCaughtError()

		if not hasRethrowError then
			hasRethrowError = true
			rethrowError = err
		end
	end
end

--\[\[*
* During execution of guarded functions we will capture the first error which
* we will rethrow to be handled by the top level error handler.
\]\]
exports.rethrowCaughtError = function()
	if hasRethrowError then
		local err = rethrowError
		hasRethrowError = false
		rethrowError = nil
		error(err)
	end
end

exports.hasCaughtError = function()
	return hasError
end

clearCaughtError = function()
	if hasError then
		local err = caughtError
		hasError = false
		caughtError = nil
		return err
	else
		invariant(
			false,
			"clearCaughtError was called but no error was captured. This error "
				.. "is likely caused by a bug in React. Please file an issue."
		)
		-- deviation: luau doesn't know that invariant throws, so we return nil
		return nil
	end
end
exports.clearCaughtError = clearCaughtError

return exports ]]
ic.Children._10f4a12d6c39f4bbe0430920f5cd0094=iE
local iF

local iG={ClassName="ModuleScript",Children={},Properties={}}
iG.Name="ReactFeatureFlags"
iG.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/ba82eea3837e4aaeb5a30b7827b664a8c2128d2e/packages/shared/ReactFeatureFlags.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
-- Unknown globals fail type checking (see "Unknown symbols" section of
-- https://roblox.github.io/luau/typecheck.html)
local exports = {}

-- Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
-- This prevents e.g. <img src=""> from making an unnecessary HTTP request for certain browsers.
exports.enableFilterEmptyStringAttributesDOM = true

-- Adds verbose console logging for e.g. state updates, suspense, and work loop stuff.
-- Intended to enable React core members to more easily debug scheduling issues in DEV builds.
exports.enableDebugTracing = false

-- Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
-- for an experimental scheduling profiler tool.
exports.enableSchedulingProfiler = _G.__PROFILE__ and _G.__EXPERIMENTAL__

-- Helps identify side effects in render-phase lifecycle hooks and setState
-- reducers by double invoking them in Strict Mode.
-- ROBLOX TODO: we'll want to enable this for DEV app bundles
exports.debugRenderPhaseSideEffectsForStrictMode = _G.__DEV__

-- To preserve the "Pause on caught exceptions" behavior of the debugger, we
-- replay the begin phase of a failed component inside invokeGuardedCallback.
exports.replayFailedUnitOfWorkWithInvokeGuardedCallback = _G.__DEV__

-- Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
exports.warnAboutDeprecatedLifecycles = true

-- Gather advanced timing metrics for Profiler subtrees.
exports.enableProfilerTimer = _G.__PROFILE__

-- Record durations for commit and passive effects phases.
exports.enableProfilerCommitHooks = false

-- Trace which interactions trigger each commit.
exports.enableSchedulerTracing = _G.__PROFILE__

-- SSR experiments
exports.enableSuspenseServerRenderer = _G.__EXPERIMENTAL__
exports.enableSelectiveHydration = _G.__EXPERIMENTAL__

-- Flight experiments
exports.enableBlocksAPI = _G.__EXPERIMENTAL__
exports.enableLazyElements = _G.__EXPERIMENTAL__

-- Only used in www builds.
exports.enableSchedulerDebugging = false

-- Disable javascript: URL strings in href for XSS protection.
exports.disableJavaScriptURLs = false

-- Experimental Host Component support.
exports.enableFundamentalAPI = false

-- Experimental Scope support.
exports.enableScopeAPI = false

-- Experimental Create Event Handle API.
exports.enableCreateEventHandleAPI = false

-- New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

-- We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v18?)
-- Till then, we warn about the missing mock, but still fallback to a legacy mode compatible version
exports.warnAboutUnmockedScheduler = false

-- Add a callback property to suspense to notify which promises are currently
-- in the update queue. This allows reporting and tracing of what is causing
-- the user to see a loading state.
-- Also allows hydration callbacks to fire when a dehydrated boundary gets
-- hydrated or deleted.
exports.enableSuspenseCallback = false

-- Part of the simplification of React.createElement so we can eventually move
-- from React.createElement to React.jsx
-- https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md
exports.warnAboutDefaultPropsOnFunctionComponents = false

exports.disableSchedulerTimeoutBasedOnReactExpirationTime = false

exports.enableTrustedTypesIntegration = false

-- Enables a warning when trying to spread a 'key' to an element
-- a deprecated pattern we want to get rid of in the future
exports.warnAboutSpreadingKeyToJSX = true

exports.enableComponentStackLocations = true

exports.enableNewReconciler = true

-- Errors that are thrown while unmounting (or after in the case of passive effects)
-- should bypass any error boundaries that are also unmounting (or have unmounted)
-- and be handled by the nearest still-mounted boundary.
-- If there are no still-mounted boundaries, the errors should be rethrown.
exports.skipUnmountedBoundaries = true

-- --------------------------
-- Future APIs to be deprecated
-- --------------------------

-- Prevent the value and checked attributes from syncing
-- with their related DOM properties
exports.disableInputAttributeSyncing = true

exports.warnAboutStringRefs = false

exports.disableLegacyContext = false

-- Disables children for <textarea> elements
exports.disableTextareaChildren = false

exports.disableModulePatternComponents = false

-- We should remove this flag once the above flag becomes enabled
exports.warnUnstableRenderSubtreeIntoContainer = false

-- Support legacy Primer support on internal FB www
exports.enableLegacyFBSupport = true

-- Updates that occur in the render phase are not officially supported. But when
-- they do occur, we defer them to a subsequent render by picking a lane that's
-- not currently rendering. We treat them the same as if they came from an
-- interleaved event. Remove this flag once we have migrated to the
-- new behavior.
exports.deferRenderPhaseUpdateToNextBatch = false

-- Replacement for runWithPriority in React internals.
exports.decoupleUpdatePriorityFromScheduler = true

exports.enableDiscreteEventFlushingChange = false

exports.enableEagerRootListeners = false

exports.enableDoubleInvokingEffects = false
return exports ]]
ic.Children._2a4c4490522cce292b7955a6734885be=iG
local iH

local iI={ClassName="ModuleScript",Children={},Properties={}}
iI.Name="ReactFiberHostConfig"
iI.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	ROBLOX deviation: ReactFiberHostConfig captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactFiberHostConfig (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactFiberHostConfig (cycle)

	After:
	* ReactFiberHostConfig (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
\]\]

-- types that are common across ReactFiberHostConfig files, moved here to avoid circular deps
type Object = { [string]: any }
export type OpaqueIDType = string | Object

return {
	WithNoHydration = require(script.WithNoHydration),
	WithNoPersistence = require(script.WithNoPersistence),
	WithNoTestSelectors = require(script.WithNoTestSelectors),
} ]]
ic.Children._7a8711d0a49618b7409c00f4d3cc215e=iI
local iJ
local iK={ClassName="ModuleScript",Children={},Properties={}}
iK.Name="WithNoHydration"
iK.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoHydration.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support hydration
-- can re-export everything from this module.

function shim(...)
	invariant(
		false,
		"The current renderer does not support hydration. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Hydration (when unsupported)
export type SuspenseInstance = any
return {
	supportsHydration = false,
	canHydrateInstance = shim,
	canHydrateTextInstance = shim,
	canHydrateSuspenseInstance = shim,
	isSuspenseInstancePending = shim,
	isSuspenseInstanceFallback = shim,
	registerSuspenseInstanceRetry = shim,
	getNextHydratableSibling = shim,
	getFirstHydratableChild = shim,
	hydrateInstance = shim,
	hydrateTextInstance = shim,
	hydrateSuspenseInstance = shim,
	getNextHydratableInstanceAfterSuspenseInstance = shim,
	commitHydratedContainer = shim,
	commitHydratedSuspenseInstance = shim,
	clearSuspenseBoundary = shim,
	clearSuspenseBoundaryFromContainer = shim,
	didNotMatchHydratedContainerTextInstance = shim,
	didNotMatchHydratedTextInstance = shim,
	didNotHydrateContainerInstance = shim,
	didNotHydrateInstance = shim,
	didNotFindHydratableContainerInstance = shim,
	didNotFindHydratableContainerTextInstance = shim,
	didNotFindHydratableContainerSuspenseInstance = shim,
	didNotFindHydratableInstance = shim,
	didNotFindHydratableTextInstance = shim,
	didNotFindHydratableSuspenseInstance = shim,
} ]]
iJ.Children._0b05ba86639342239b3f9d95cb099a88=iK
local iL

local iM={ClassName="ModuleScript",Children={},Properties={}}
iM.Name="WithNoPersistence"
iM.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoPersistence.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support persistence
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support persistence. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Persistence (when unsupported)
return {
	supportsPersistence = false,
	cloneInstance = shim,
	cloneFundamentalInstance = shim,
	createContainerChildSet = shim,
	appendChildToContainerChildSet = shim,
	finalizeContainerChildren = shim,
	replaceContainerChildren = shim,
	cloneHiddenInstance = shim,
	cloneHiddenTextInstance = shim,
} ]]
iJ.Children._1e859b93b1538cbdb32c90553231d2ab=iM
local iN

local iO={ClassName="ModuleScript",Children={},Properties={}}
iO.Name="WithNoTestSelectors"
iO.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/3cde22a84e246fc5361f038bf0c23405b2572c22/packages/react-reconciler/src/ReactFiberHostConfigWithNoTestSelectors.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support test selectors
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support test selectors. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Test selectors (when unsupported)
return {
	supportsTestSelectors = false,
	findFiberRoot = shim,
	getBoundingRect = shim,
	getTextContent = shim,
	isHiddenSubtree = shim,
	matchAccessibilityRole = shim,
	setFocusIfFocusable = shim,
	setupIntersectionObserver = shim,
} ]]
iJ.Children._a1e8a19c16cf2b605c007e2f6f45e7bb=iO
local iP

local iQ={ClassName="ModuleScript",Children={},Properties={}}
iQ.Name="ReactInstanceMap"
iQ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/2ba43edc2675380a0f2222f351475bf9d750c6a9/packages/shared/ReactInstanceMap.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]

--\[\[*
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 \]\]

--\[\[*
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 \]\]

local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local getComponentName = require(script.Parent.getComponentName)

local exports = {}

local function isValidFiber(fiber): boolean
	return fiber.tag ~= nil
		and fiber.subtreeFlags ~= nil
		and fiber.lanes ~= nil
		and fiber.childLanes ~= nil
end

exports.remove = function(key)
	key._reactInternals = nil
end

exports.get = function(key)
	local value = key._reactInternals

	-- ROBLOX deviation: we have a crash in production this will help catch
	-- ROBLOX TODO: wrap this in __DEV__
	if not isValidFiber(value) then
		error(
			Error.new(
				"invalid fiber in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " during get from ReactInstanceMap! "
					.. inspect(value)
			)
		)
	elseif value.alternate ~= nil and not isValidFiber(value.alternate) then
		error(
			Error.new(
				"invalid alternate fiber ("
					.. (getComponentName(key) or "UNNAMED alternate")
					.. ") in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " during get from ReactInstanceMap! "
					.. inspect(value.alternate)
			)
		)
	end

	return value
end

exports.has = function(key)
	return key._reactInternals ~= nil
end

exports.set = function(key, value)
	-- ROBLOX deviation: we have a crash in production this will help catch
	-- ROBLOX TODO: wrap this in __DEV__
	local parent = value
	local message
	while parent ~= nil do
		if not isValidFiber(parent) then
			message = "invalid fiber in "
				.. (getComponentName(key) or "UNNAMED Component")
				.. " being set in ReactInstanceMap! "
				.. inspect(parent)
				.. "\n"

			if value ~= parent then
				message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
			end
			error(Error.new(message))
		elseif
			(parent :: any).alternate ~= nil
			and not isValidFiber((parent :: any).alternate)
		then
			message = "invalid alternate fiber ("
				.. (getComponentName(key) or "UNNAMED alternate")
				.. ") in "
				.. (getComponentName(key) or "UNNAMED Component")
				.. " being set in ReactInstanceMap! "
				.. inspect((parent :: any).alternate)
				.. "\n"

			if value ~= parent then
				message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
			end
			error(Error.new(message))
		end
		parent = (parent :: any).return_
	end

	(key :: any)._reactInternals = value
end

return exports ]]
ic.Children._d7f0a5e61609cc83b343e93599e5aa97=iQ
local iR

local iS={ClassName="ModuleScript",Children={},Properties={}}
iS.Name="ReactSharedInternals"
iS.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/607148673b3156d051d1fed17cd49e83698dce54/packages/react/src/ReactSharedInternals.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
\]\]

--\[\[
	ROBLOX deviation: ReactSharedInternals captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactSharedInternals (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactSharedInternals (cycle)

	After:
	* ReactSharedInternals (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
\]\]
local Packages = script.Parent.Parent
local console = require(Packages.LuauPolyfill).console
local function onlyInTestError(functionName: string)
	return function()
		console.error(functionName .. " is only available in tests, not in production")
	end
end

-- import assign from 'object-assign';
local ReactCurrentDispatcher = require(script.ReactCurrentDispatcher)
export type Dispatcher = ReactCurrentDispatcher.Dispatcher
local ReactCurrentBatchConfig = require(script.ReactCurrentBatchConfig)
local ReactCurrentOwner = require(script.ReactCurrentOwner)
local ReactDebugCurrentFrame = require(script.ReactDebugCurrentFrame)
local IsSomeRendererActing = require(script.IsSomeRendererActing)

local ReactSharedInternals = {
	ReactCurrentDispatcher = ReactCurrentDispatcher,
	ReactCurrentBatchConfig = ReactCurrentBatchConfig,
	ReactCurrentOwner = ReactCurrentOwner,
	IsSomeRendererActing = IsSomeRendererActing,
	-- ROBLOX deviation: Luau type checking requires us to have a consistent export shape regardless of __DEV__
	-- ROBLOX TODO: use if-expressions when all clients are on 503+
	ReactDebugCurrentFrame = if _G.__DEV__
		then ReactDebugCurrentFrame
		else {
			setExtraStackFrame = function(_: string?): ()
				onlyInTestError("setExtraStackFrame")
			end,
		},
	-- deviation: We shouldn't have to worry about duplicate bundling here
	-- Used by renderers to avoid bundling object-assign twice in UMD bundles:
	-- assign,
}

return ReactSharedInternals ]]
ic.Children._8b7c7df9c213d698d94942e3b90b0306=iS
local iT
local iU={ClassName="ModuleScript",Children={},Properties={}}
iU.Name="IsSomeRendererActing"
iU.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/a457e02ae3a2d3903fcf8748380b1cc293a2445e/packages/react/src/IsSomeRendererActing.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[*
 * Used by act() to track whether you're inside an act() scope.
 \]\]

local IsSomeRendererActing = {
	current = false,
}
return IsSomeRendererActing ]]
iT.Children._e43c47aec2a0dd808440d811dcd97f27=iU
local iV

local iW={ClassName="ModuleScript",Children={},Properties={}}
iW.Name="ReactCurrentBatchConfig"
iW.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/92fcd46cc79bbf45df4ce86b0678dcef3b91078d/packages/react/src/ReactCurrentBatchConfig.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[*
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
\]\]
local ReactCurrentBatchConfig = {
	transition = 0,
}

return ReactCurrentBatchConfig ]]
iT.Children._5f24825c65b66fe1adb25c896fb22040=iW
local iX

local iY={ClassName="ModuleScript",Children={},Properties={}}
iY.Name="ReactCurrentDispatcher"
iY.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentDispatcher.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]

--\[\[*
 * Keeps track of the current dispatcher.
\]\]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

-- ROBLOX deviation: we duplicate the Dispatcher type here because upstream has a circular dependency between Shared and Reconciler
local ReactElementType = require(script.Parent.Parent.ReactElementType)
type Source = ReactElementType.Source
local ReactTypes = require(script.Parent.Parent.ReactTypes)
type RefObject = ReactTypes.RefObject
type ReactContext<T> = ReactTypes.ReactContext<T>
-- ROBLOX deviation START: binding support
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- ROBLOX deviation END: binding support
type MutableSourceVersion = ReactTypes.MutableSourceVersion
type MutableSource<Source> = ReactTypes.MutableSource<Source>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

export type Dispatcher = {
	readContext: <T>(
		context: ReactContext<T>,
		observedBits: nil | number | boolean
	) -> T,
	useState: <S>(initialState: (() -> S) | S) -> (S, Dispatch<BasicStateAction<S>>),
	useReducer: <S, I, A>(
		reducer: (S, A) -> S,
		initialArg: I,
		init: ((I) -> S)?
	) -> (S, Dispatch<A>),
	useContext: <T>(
		context: ReactContext<T>,
		observedBits: nil | number | boolean
	) -> T,
	-- ROBLOX deviation START: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
	useRef: <T>(initialValue: T) -> { current: T | nil },
	-- ROBLOX deviation END
	-- ROBLOX deviation START: Bindings are a feature unique to Roact
	useBinding: <T>(initialValue: T) -> (ReactBinding<T>, ReactBindingUpdater<T>),
	-- ROBLOX deviation END
	useEffect: (
		-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useLayoutEffect: (
		-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useCallback: <T>(callback: T, deps: Array<any> | nil) -> T,
	useMemo: <T...>(nextCreate: () -> T..., deps: Array<any> | nil) -> T...,
	useImperativeHandle: <T>(
		ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
		create: () -> T,
		deps: Array<any> | nil
	) -> (),
	useDebugValue: <T>(value: T, formatterFn: ((value: T) -> any)?) -> (),
	-- ROBLOX TODO: make these non-optional and implement them in the dispatchers
	useDeferredValue: (<T>(value: T) -> T)?,
	useTransition: (() -> ((() -> ()) -> (), boolean))?, -- ROBLOX deviation: Luau doesn't support jagged array types [(() -> ()) -> (), boolean],
	useMutableSource: <Source, Snapshot>(
		source: MutableSource<Source>,
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		subscribe: MutableSourceSubscribeFn<Source, Snapshot>
	) -> Snapshot,
	useOpaqueIdentifier: () -> any,

	unstable_isNewReconciler: boolean?,
	-- [string]: any,
}

local ReactCurrentDispatcher: { current: nil | Dispatcher } = {
	--\[\[
		* @internal
		* @type {ReactComponent}
		*/
	\]\]
	current = nil,
}

return ReactCurrentDispatcher ]]
iT.Children._f1cf8156948054b627409b7e080a25c3=iY
local iZ

local i_={ClassName="ModuleScript",Children={},Properties={}}
i_.Name="ReactCurrentOwner"
i_.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentOwner.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

--\[\[*
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
\]\]
local ReactCurrentOwner = {
	--\[\[*
   * @internal
   * @type {ReactComponent}
   \]\]
	-- ROBLOX deviation START: upstream types this as Fiber, but that would incur a circular dependency between reconciler and shared
	current = nil :: any,
	-- ROBLOX deviation END
}

return ReactCurrentOwner ]]
iT.Children._0fe5db5182bc13e1c1ea30352e5a7638=i_
local i0

local i1={ClassName="ModuleScript",Children={},Properties={}}
i1.Name="ReactDebugCurrentFrame"
i1.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/98d410f5005988644d01c9ec79b7181c3dd6c847/packages/react/src/ReactDebugCurrentFrame.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

local ReactDebugCurrentFrame = {}

local currentExtraStackFrame = nil :: nil | string

function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?): ()
	if _G.__DEV__ then
		currentExtraStackFrame = stack
	end
end

if _G.__DEV__ then
	-- deviation: in Lua, the implementation is duplicated
	-- function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?)
	-- 	if _G.__DEV__ then
	-- 		currentExtraStackFrame = stack
	-- 	end
	-- end

	-- Stack implementation injected by the current renderer.
	ReactDebugCurrentFrame.getCurrentStack = nil :: nil | (() -> string)

	function ReactDebugCurrentFrame.getStackAddendum(): string
		local stack = ""

		-- Add an extra top frame while an element is being validated
		if currentExtraStackFrame then
			stack = stack .. currentExtraStackFrame
		end

		-- Delegate to the injected renderer-specific implementation
		local impl = ReactDebugCurrentFrame.getCurrentStack
		if impl then
			stack = stack .. (impl() or "")
		end

		return stack
	end
end

return ReactDebugCurrentFrame ]]
iT.Children._31d663235786fc0efcd4b5ab0e71b0b6=i1
local i2

local i3={ClassName="ModuleScript",Children={},Properties={}}
i3.Name="ReactSymbols"
i3.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/ReactSymbols.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

-- ATTENTION
-- When adding new symbols to this file,
-- Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'

-- local Packages = script.Parent.Parent
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Symbol = LuauPolyfill.Symbol

local exports: { [string]: any } = {}

-- The Symbol used to tag the ReactElement-like types. If there is no native Symbol
-- nor polyfill, then a plain number is used for performance.
exports.REACT_ELEMENT_TYPE = 0xeac7
exports.REACT_PORTAL_TYPE = 0xeaca
exports.REACT_FRAGMENT_TYPE = 0xeacb
exports.REACT_STRICT_MODE_TYPE = 0xeacc
exports.REACT_PROFILER_TYPE = 0xead2
exports.REACT_PROVIDER_TYPE = 0xeacd
exports.REACT_CONTEXT_TYPE = 0xeace
exports.REACT_FORWARD_REF_TYPE = 0xead0
exports.REACT_SUSPENSE_TYPE = 0xead1
exports.REACT_SUSPENSE_LIST_TYPE = 0xead8
exports.REACT_MEMO_TYPE = 0xead3
exports.REACT_LAZY_TYPE = 0xead4
exports.REACT_BLOCK_TYPE = 0xead9
exports.REACT_SERVER_BLOCK_TYPE = 0xeada
exports.REACT_FUNDAMENTAL_TYPE = 0xead5
exports.REACT_SCOPE_TYPE = 0xead7
exports.REACT_OPAQUE_ID_TYPE = 0xeae0
exports.REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1
exports.REACT_OFFSCREEN_TYPE = 0xeae2
exports.REACT_LEGACY_HIDDEN_TYPE = 0xeae3
exports.REACT_BINDING_TYPE = 0xeae4

-- ROBLOX TODO: Use Symbol again once jest-mock knows to exclude the LuauPolyfill module from being reset
-- deviation: In Lua, Symbol will be a callable table, not a function
-- if typeof(Symbol) == "table" and Symbol.for_ ~= nil then
--   local symbolFor = Symbol.for_
--   exports.REACT_ELEMENT_TYPE = symbolFor('react.element')
--   exports.REACT_PORTAL_TYPE = symbolFor('react.portal')
--   exports.REACT_FRAGMENT_TYPE = symbolFor('react.fragment')
--   exports.REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode')
--   exports.REACT_PROFILER_TYPE = symbolFor('react.profiler')
--   exports.REACT_PROVIDER_TYPE = symbolFor('react.provider')
--   exports.REACT_CONTEXT_TYPE = symbolFor('react.context')
--   exports.REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref')
--   exports.REACT_SUSPENSE_TYPE = symbolFor('react.suspense')
--   exports.REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list')
--   exports.REACT_MEMO_TYPE = symbolFor('react.memo')
--   exports.REACT_LAZY_TYPE = symbolFor('react.lazy')
--   exports.REACT_BLOCK_TYPE = symbolFor('react.block')
--   exports.REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block')
--   exports.REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental')
--   exports.REACT_SCOPE_TYPE = symbolFor('react.scope')
--   exports.REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id')
--   exports.REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode')
--   exports.REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen')
--   exports.REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden')
-- end

-- deviation: short circuit for now
--local MAYBE_ITERATOR_SYMBOL = false -- deviation: typeof(Symbol) == 'function' and Symbol.iterator
--local FAUX_ITERATOR_SYMBOL = '@@iterator'

type Iterator<T> = {
	next: () -> {
		value: T,
		key: any,
		done: boolean,
	},
}
-- ROBLOX deviation: upstream type is incorrect, as returned function takes a parameter in reconcileChildrenIterator()
exports.getIteratorFn = function(maybeIterable): nil | (...any) -> Iterator<any>
	if typeof(maybeIterable) == "table" then
		-- ROBLOX deviation: Upstream understands that portal objects are not
		-- iterable; we need to check explicitly
		if maybeIterable["$$typeof"] == exports.REACT_PORTAL_TYPE then
			return nil
		end
		return function()
			local currentKey: any, currentValue: any
			return {
				next = function()
					currentKey, currentValue = next(maybeIterable, currentKey)
					return {
						done = currentValue == nil,
						-- deviation: To support Roact's table-keys-as-stable-keys feature,
						-- we need the iterator to return the key as well
						key = currentKey,
						value = currentValue,
					}
				end,
			}
		end
	end

	return nil
end

return exports ]]
ic.Children._b276b30a1295d90df3253f6a378157cb=i3
local i4

local i5={ClassName="ModuleScript",Children={},Properties={}}
i5.Name="ReactTypes"
i5.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
\]\]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type void = nil
type NonMaybeType<T> = T

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<T> = flowtypes.React_Element<T>
type React_Node = flowtypes.React_Node
type SimpleMap<K, V> = { [K]: V }
type Iterable<T> = SimpleMap<string | number, T> | Array<T>

export type ReactNode<T = any> =
	React_Element<T>
	| ReactPortal
	-- | ReactText
	| ReactFragment
	| ReactProvider<T>
	| ReactConsumer<T>

export type ReactEmpty = nil | void | boolean

export type ReactFragment = ReactEmpty | Iterable<React_Node>

export type ReactNodeList = ReactEmpty | React_Node

-- ROBLOX deviation START: Roblox renderer doesn't support TextNode, only use of this type is in this file
-- export type ReactText = string | number;
-- ROBLOX deviation END
export type ReactProvider<T> = {
	["$$typeof"]: number,
	type: ReactProviderType<T>,
	key: nil | string,
	ref: nil,
	props: {
		value: T,
		children: ReactNodeList?,
		-- ROBLOX deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- ROBLOX deviation END
	},
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactProviderType<T> = {
	["$$typeof"]: number,
	_context: ReactContext<T>,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactConsumer<T> = {
	["$$typeof"]: number,
	type: ReactContext<T>, -- ROBLOX FIXME: Luau can't do <T> because:  Recursive type being used with different parameters
	key: nil | string,
	ref: nil,
	props: {
		children: (value: T) -> ReactNodeList,
		unstable_observedBits: number?,
		-- ROBLOX deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- ROBLOX deviation END
	},
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactContext<T> = {
	["$$typeof"]: number,
	Consumer: ReactContext<T>,
	Provider: ReactProviderType<T>,
	_calculateChangedBits: ((T, T) -> number)?,
	_currentValue: T,
	_currentValue2: T,
	_threadCount: number,
	-- DEV only
	_currentRenderer: Object | nil,
	_currentRenderer2: Object | nil,
	-- This value may be added by application code
	-- to improve DEV tooling display names
	displayName: string?,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type ReactPortal = {
	["$$typeof"]: number,
	key: nil | string,
	containerInfo: any,
	children: ReactNodeList,
	-- TODO: figure out the API for cross-renderer implementation.
	implementation: any,
	-- ROBLOX deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- ROBLOX deviation END
}

export type RefObject = { current: any }

-- ROBLOX deviation START: No Luau support for numeric literal types
-- export type EventPriority = 0 | 1 | 2;
export type EventPriority = number
-- ROBLOX deviation END

local exports = {}
exports.DiscreteEvent = 0
exports.UserBlockingEvent = 1
exports.ContinuousEvent = 2

export type ReactFundamentalComponentInstance<C, H> = {
	currentFiber: Object,
	instance: any,
	prevProps: Object?,
	props: Object,
	impl: ReactFundamentalImpl<C, H>,
	state: Object,
}

export type ReactFundamentalImpl<C, H> = {
	displayName: string,
	reconcileChildren: boolean,
	getInitialState: nil | (Object) -> (Object),
	getInstance: (C, Object, Object) -> (H),
	getServerSideString: nil | (C, Object) -> (string),
	getServerSideStringClose: nil | (C, Object) -> (string),
	onMount: (C, any, Object, Object) -> (),
	shouldUpdate: nil | (C, Object?, Object, Object) -> (boolean),
	onUpdate: nil | (C, any, Object?, Object, Object) -> (),
	onUnmount: nil | (C, any, Object, Object) -> (),
	onHydrate: nil | (C, Object, Object) -> boolean,
	onFocus: nil | (C, Object, Object) -> boolean,
}
export type ReactFundamentalComponent<C, H> = {
	["$$typeof"]: number,
	impl: ReactFundamentalImpl<C, H>,
}

export type ReactScope = {
	["$$typeof"]: number,
}

export type ReactScopeQuery = (
	type: string,
	-- ROBLOX deviation START: leave closed to extension unless necessary
	props: { [string]: any? },
	-- ROBLOX deviation END
	instance: any
) -> boolean

export type ReactScopeInstance = {
	DO_NOT_USE_queryAllNodes: (ReactScopeQuery) -> nil | Array<Object>,
	DO_NOT_USE_queryFirstNode: (ReactScopeQuery) -> nil | Object,
	containsNode: (Object) -> boolean,
	getChildContextValues: <T>(context: ReactContext<T>) -> Array<T>,
}

-- ROBLOX deviation START: Bindings are unique to Roact
-- FIXME Luau: can't create recursive type with different parameters, so we
-- need to split the generic `map` method into a different type and then
-- re-combine those types together
type CoreReactBinding<T> = {
	getValue: (self: CoreReactBinding<T>) -> T,
	_source: string?,
}
type ReactBindingMap = {
	map: <T, U>(
		self: CoreReactBinding<T> & ReactBindingMap,
		(T) -> U
	) -> ReactBindingMap & CoreReactBinding<U>,
}

export type ReactBinding<T> = CoreReactBinding<T> & ReactBindingMap
export type ReactBindingUpdater<T> = (T) -> ()
-- ROBLOX deviation END

-- Mutable source version can be anything (e.g. number, string, immutable data structure)
-- so long as it changes every time any part of the source changes.
export type MutableSourceVersion = NonMaybeType<any>

export type MutableSourceGetSnapshotFn<Source, Snapshot> = (source: Source) -> Snapshot

export type MutableSourceSubscribeFn<Source, Snapshot> = (
	source: Source,
	callback: (snapshot: Snapshot) -> ()
) -> (() -> ())

export type MutableSourceGetVersionFn = (
	_source: NonMaybeType<any>
) -> MutableSourceVersion

export type MutableSource<Source> = {
	_source: Source,

	_getVersion: MutableSourceGetVersionFn,

	-- Tracks the version of this source at the time it was most recently read.
	-- Used to determine if a source is safe to read from before it has been subscribed to.
	-- Version number is only used during mount,
	-- since the mechanism for determining safety after subscription is expiration time.
	--
	-- As a workaround to support multiple concurrent renderers,
	-- we categorize some renderers as primary and others as secondary.
	-- We only expect there to be two concurrent renderers at most:
	-- React Native (primary) and Fabric (secondary);
	-- React DOM (primary) and React ART (secondary).
	-- Secondary renderers store their context values on separate fields.
	-- We use the same approach for Context.
	_workInProgressVersionPrimary: nil | MutableSourceVersion,
	_workInProgressVersionSecondary: nil | MutableSourceVersion,

	-- DEV only
	-- Used to detect multiple renderers using the same mutable source.
	_currentPrimaryRenderer: Object | nil,
	_currentSecondaryRenderer: Object | nil,
}

-- The subset of a Thenable required by things thrown by Suspense.
-- This doesn't require a value to be passed to either handler.
export type Wakeable = {
	andThen: (
		self: Wakeable,
		onFulfill: () -> ...any,
		onReject: () -> ...any
		-- ROBLOX FIXME Luau: needs union type packs to parse () | Wakeable
	) -> nil | Wakeable,
	-- Special flag to opt out of tracing interactions across a Suspense boundary.
	__reactDoNotTraceInteractions: boolean?,
}

-- The subset of a Promise that React APIs rely on. This resolves a value.
-- This doesn't require a return value neither from the handler nor the
-- then function.
-- ROBLOX FIXME: workaround for Luau recursive type used with different parameters. delete this copy once that issue is resolved.
export type _Thenable<R> = {
	andThen: <U>(
		self: _Thenable<R>,
		onFulfill: (R) -> ...U,
		onReject: (error: any) -> ...U
	) -> (),
}

export type Thenable<R> = {
	andThen: <U>(
		self: Thenable<R>,
		onFulfill: (R) -> ...(_Thenable<U> | U),
		onReject: (error: any) -> ...(_Thenable<U> | U)
		-- ROBLOX FIXME Luau: need union type packs to parse () | Thenable<U>: CLI-49836
	) -> nil | _Thenable<U>,
}

return exports ]]
ic.Children._a627dd0aba3630d41b560068b9685bd5=i5
local i6

local i7={ClassName="ModuleScript",Children={},Properties={}}
i7.Name="ReactVersion"
i7.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/a89854bc936668d325cac9a22e2ebfa128c7addf/packages/shared/ReactVersion.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 \]\]

-- TODO: this is special because it gets imported during build.
return "17.0.1" ]]
ic.Children._c9f36a7f7367f43587e5e932ce1fc1f1=i7
local i8

local i9={ClassName="ModuleScript",Children={},Properties={}}
i9.Name="Symbol.roblox"
i9.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
\]\]

local Symbol = {}

--\[\[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
\]\]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = string.format("Symbol(%s)", name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol ]]
ic.Children._978f1bb5ef0f7b40ae1f1b69a1f55458=i9
local ja

local jb={ClassName="ModuleScript",Children={},Properties={}}
jb.Name="Type.roblox"
jb.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--\[\[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
\]\]

local Symbol = require(script.Parent["Symbol.roblox"])

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("HostChangeEvent")
addType("HostEvent")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

return Type ]]
ic.Children._c23eabfc3474929b2b33875db46cc9c1=jb
local jc

local jd={ClassName="ModuleScript",Children={},Properties={}}
jd.Name="UninitializedState.roblox"
jd.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
--!strict
local console = require(script.Parent.console)

-- ROBLOX DEVIATION: Initialize state to a singleton that warns on access and errors on assignment
-- initial state singleton
local UninitializedState = {}

setmetatable(UninitializedState, {
	__index = function(table, key)
		if _G.__DEV__ then
			console.warn(
				"Attempted to access uninitialized state. Use setState to initialize state"
			)
		end
		return nil
	end,
	__newindex = function(table, key)
		if _G.__DEV__ then
			console.error(
				"Attempted to directly mutate state. Use setState to assign new values to state."
			)
		end
		return nil
	end,
	__tostring = function(self)
		return "<uninitialized component state>"
	end,
	__metatable = "UninitializedState",
})

return UninitializedState ]]
ic.Children._daa61561c482386146be0333b9a46e1a=jd
local je

local jf={ClassName="Folder",Children={},Properties={}}
jf.Name="__tests__"
ic.Children._de37e2df92367cbd47dcadc9a0eb3935=jf
local jg
local jh={ClassName="ModuleScript",Children={},Properties={}}
jh.Name="ErrorHandling.roblox.spec"
jh.Properties.Source=[[ local Packages = script.Parent.Parent.Parent

local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it

local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local ErrorHandling = require(script.Parent.Parent["ErrorHandling.roblox"])
local describeError = ErrorHandling.describeError
local errorToString = ErrorHandling.errorToString
local parseReactError = ErrorHandling.parseReactError

describe("describeError", function()
	it("preserves original stack from string error when rethrown", function()
		local message = "preserve stack from string error"
		local function throws()
			error(message)
		end

		local ok, e = xpcall(throws, describeError)

		jestExpect(ok).toBe(false)
		jestExpect(e.message).toBe(message)
		local originalStack = e.stack

		local ok2, e2 = xpcall(function()
			error(e)
		end, describeError)

		jestExpect(ok2).toBe(false)
		jestExpect(e2.message).toBe(message)
		jestExpect(e2.stack).toBe(originalStack)
	end)

	it("preserves original stack from Error when rethrown", function()
		local message = "preserve stack from Error"
		local function throws()
			error(Error.new(message))
		end

		local ok, e = xpcall(throws, describeError)

		jestExpect(ok).toBe(false)
		jestExpect(e.message).toBe(message)
		local originalStack = e.stack

		local ok2, e2 = xpcall(function()
			error(e)
		end, describeError)

		jestExpect(ok2).toBe(false)
		jestExpect(e2.message).toBe(message)
		jestExpect(e2.stack).toBe(originalStack)
	end)

	it("transforms string errors into Error objects", function()
		local message = "transform string into Error"
		local function throws()
			error(message)
		end

		local ok, e = xpcall(throws, describeError)

		jestExpect(ok).toBe(false)
		jestExpect(LuauPolyfill.instanceof(e, Error)).toBe(true)
		jestExpect(e.message).toBe(message)
		jestExpect(e.stack).toContain(script:GetFullName())
	end)

	it("rethrows Error objects without changing them", function()
		local errorObject = Error.new("rethrow Error without changes")
		local function throws()
			error(errorObject)
		end

		local ok, e = xpcall(throws, describeError)

		jestExpect(ok).toBe(false)
		jestExpect(e).toBe(errorObject)
	end)
end)

describe("errorToString", function()
	it("gives stack trace for Error", function()
		local errorString = errorToString(Error.new("h0wdy"))

		jestExpect(errorString).toContain(script.Name)
		jestExpect(errorString).toContain("h0wdy")
	end)
	it("prints random tables", function()
		local errorString = errorToString({ ["$$h0wdy\n"] = 31337 })

		jestExpect(errorString).toContain("$$h0wdy")
		jestExpect(errorString).toContain("31337")
	end)
	it("prints arrays", function()
		local errorString = errorToString({ foo = 1, 2, 3 })

		jestExpect(errorString).toContain("foo: 1")
	end)
end)

describe("parseReactError", function()
	it("returns the whole message if not formatted as expected", function()
		local errorString = inspect(Error.new("not formatted for split"))

		local parsed, rethrow = parseReactError(errorString)
		jestExpect(parsed.message).toBe(errorString)
		-- Stack is nil because it's presumed to be included in the message
		-- and we wouldn't be able to generate a useful stack at parse time
		jestExpect(parsed.stack).toBeNil()
		-- The error was not rethrown, so rethrow will be an empty string
		jestExpect(rethrow).toBe("")
	end)

	it("does not split errors with the wrong number of sections", function()
		local errorString =
			table.concat({ "a", "b", "c", "d" }, ErrorHandling.__ERROR_DIVIDER)

		local parsed, rethrow = parseReactError(errorString)
		jestExpect(parsed.message).toBe(errorString)
		-- Stack is nil because it's presumed to be included in the message
		-- and we wouldn't be able to generate a useful stack at parse time
		jestExpect(parsed.stack).toBeNil()
		-- The error was not rethrown, so rethrow will be an empty string
		jestExpect(rethrow).toBe("")
	end)

	it("parses errors created by errorToString", function()
		local errorString = errorToString(Error.new("foo"))
		local stackIndex = debug.info(1, "l") - 1
		local throwFrame = string.format("%s:%d", debug.info(1, "s"), stackIndex)

		local parsed, rethrow = parseReactError(errorString)

		jestExpect(parsed.message).toBe("foo")
		jestExpect(parsed.stack).toContain(throwFrame)
		-- The error was not rethrown, so rethrow will be an empty string
		jestExpect(rethrow).toBe("")
	end)

	it("separates the stack frame from the rethrow", function()
		local errorObject = Error.new("bar")
		local stackIndex = debug.info(1, "l") - 1
		local throwFrame = string.format("%s:%d", debug.info(1, "s"), stackIndex)

		local ok, caughtString = xpcall(function()
			error(errorObject)
		end, errorToString)

		jestExpect(ok).toBe(false)
		-- Simluate rethrowing the stringified error (like Scheduler does in
		-- `performWorkUntilDeadline`) and catching it elsewhere
		local ok2, errorString = pcall(function()
			error(caughtString)
		end)
		stackIndex = debug.info(1, "l") - 2
		local rethrowFrame = string.format("%s:%d", debug.info(1, "s"), stackIndex)

		jestExpect(ok2).toBe(false)

		local parsed, rethrow = parseReactError(errorString)
		jestExpect(parsed.message).toBe("bar")
		jestExpect(parsed.stack).toContain(throwFrame)
		jestExpect(rethrow).toContain(rethrowFrame)
	end)
end) ]]
jg.Children._5035837fae17aced5f56b45af523ebd1=jh
local ji

local jj={ClassName="ModuleScript",Children={},Properties={}}
jj.Name="ReactComponentStackFrame.roblox.spec"
jj.Properties.Source=[[ --!strict

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local String = LuauPolyfill.String

local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local ReactComponentStackFrame = nil

local function assertStringContains(testString: string, subString)
	assert(
		string.find(testString, subString, 1, true),
		string.format("could not find %q in %q", subString, testString)
	)
end

describe("describeNativeComponentFrame", function()
	local describeNativeComponentFrame

	beforeEach(function()
		jest.resetModules()

		ReactComponentStackFrame = require(script.Parent.Parent.ReactComponentStackFrame)
		describeNativeComponentFrame =
			ReactComponentStackFrame.describeNativeComponentFrame
	end)

	it("finds the appropriate line in the stack trace", function()
		local errorMessage = "some error"

		local function FooComponent()
			error(errorMessage)
		end

		local frame = describeNativeComponentFrame(FooComponent, false)
		jestExpect(frame).toBeDefined()
		local lines = String.trim(frame):split("\n")

		jestExpect(#lines).toBe(1)
		assertStringContains(lines[1], "FooComponent")
	end)
end)

describe("with enableComponentStackLocations to false", function()
	beforeEach(function()
		jest.resetModules()

		local ReactFeatureFlags = require(script.Parent.Parent.ReactFeatureFlags)

		-- ROBLOX FIXME: Calling mock after require won't work
		jest.mock(script.Parent.Parent.ReactFeatureFlags :: any, function()
			return Object.assign({}, ReactFeatureFlags, {
				enableComponentStackLocations = false,
			})
		end)

		ReactComponentStackFrame = require(script.Parent.Parent.ReactComponentStackFrame)
	end)

	describe("describeBuiltInComponentFrame", function()
		it("shows only the component name if there is no source", function()
			local componentName = "SomeComponent"
			local frame =
				ReactComponentStackFrame.describeBuiltInComponentFrame(componentName)
			assertStringContains(frame, componentName)
		end)

		-- deviation: cannot have a field in a function object
		-- if _G.__DEV__ then
		-- 	it("shows the owner name if there is no source", function()
		-- 		local owner = function() end
		--  	owner.displayName = "foo"
		-- 		local frame = ReactComponentStackFrame.describeBuiltInComponentFrame(
		-- 			"FooComponent",
		-- 			nil,
		-- 			owner
		-- 		)
		-- 		assertStringContains(
		-- 			frame
		-- 			"created by " .. owner.displayName,
		-- 		)
		-- 	end)
		-- end

		local fileNames = {
			[""] = "",
			["/"] = "",
			["\\"] = "",
			Foo = "Foo",
			["Bar/Foo"] = "Foo",
			["Bar\\Foo"] = "Foo",
			["Baz/Bar/Foo"] = "Foo",
			["Baz\\Bar\\Foo"] = "Foo",
			["Foo.lua"] = "Foo.lua",
			["/Foo.lua"] = "Foo.lua",
			["\\Foo.lua"] = "Foo.lua",
			["Bar/Foo.lua"] = "Foo.lua",
			["Bar\\Foo.lua"] = "Foo.lua",
			["/Bar/Foo.lua"] = "Foo.lua",
			["\\Bar\\Foo.lua"] = "Foo.lua",
			["Bar/Baz/Foo.lua"] = "Foo.lua",
			["Bar\\Baz\\Foo.lua"] = "Foo.lua",
			["/Bar/Baz/Foo.lua"] = "Foo.lua",
			["\\Bar\\Baz\\Foo.lua"] = "Foo.lua",
			["C:\\funny long (path)/Foo.lua"] = "Foo.lua",
			["init.lua"] = "init.lua",
			["/init.lua"] = "init.lua",
			["\\init.lua"] = "init.lua",
			["Bar/init.lua"] = "Bar/init.lua",
			["Bar\\init.lua"] = "Bar/init.lua",
			["/Bar/init.lua"] = "Bar/init.lua",
			["\\Bar\\init.lua"] = "Bar/init.lua",
			["Bar/Baz/init.lua"] = "Baz/init.lua",
			["Bar\\Baz\\init.lua"] = "Baz/init.lua",
			["/Bar/Baz/init.lua"] = "Baz/init.lua",
			["\\Bar\\Baz\\init.lua"] = "Baz/init.lua",
			["C:\\funny long (path)/init.lua"] = "funny long (path)/init.lua",
		}

		local lineNumber = 0
		-- ROBLOX FIXME Luau: need to fix CLI-56768 to remove any casts
		for fileName, expectedFileName in fileNames :: any do
			lineNumber = lineNumber + 1

			it(string.format("converts the file name %q", fileName), function()
				local owner = nil
				local componentName = "SomeComponent"
				local frame = ReactComponentStackFrame.describeBuiltInComponentFrame(
					componentName,
					{
						fileName = fileName,
						lineNumber = lineNumber,
					},
					owner
				)

				if _G.__DEV__ then
					assertStringContains(
						frame,
						string.format(
							"%s (at %s:%d)",
							componentName,
							expectedFileName,
							lineNumber
						)
					)
				else
					assertStringContains(frame, componentName)
				end
			end)
		end
	end)
end)

describe("with enableComponentStackLocations to true", function()
	local describeBuiltInComponentFrame

	beforeEach(function()
		jest.resetModules()

		local ReactFeatureFlags = require(script.Parent.Parent.ReactFeatureFlags)

		-- ROBLOX FIXME: Calling mock after require won't work
		jest.mock(script.Parent.Parent.ReactFeatureFlags :: any, function()
			return Object.assign({}, ReactFeatureFlags, {
				enableComponentStackLocations = true,
			})
		end)

		ReactComponentStackFrame = require(script.Parent.Parent.ReactComponentStackFrame)
		describeBuiltInComponentFrame =
			ReactComponentStackFrame.describeBuiltInComponentFrame
	end)

	describe("describeBuiltInComponentFrame", function()
		it("has the component name", function()
			local componentName = "foo"
			local frame = describeBuiltInComponentFrame(componentName, {
				fileName = "file name",
				lineNumber = 7,
			})

			assertStringContains(frame, componentName)
		end)
	end)
end)

describe("DEV warning stack trace", function()
	local React
	local describeUnknownElementTypeFrameInDev

	beforeEach(function()
		jest.resetModules()
		React = require(Packages.Dev.React)
		describeUnknownElementTypeFrameInDev = require(
			script.Parent.Parent.ReactComponentStackFrame
		).describeUnknownElementTypeFrameInDEV
	end)

	it("should accept class component to describeUnknownElementTypeFrameInDev", function()
		local TestDevStackComponent = React.Component:extend("TestDevStackComponent")

		function TestDevStackComponent:render()
			return if self.state.isFrame
				then React.createElement("Frame")
				else React.createElement("TextLabel", {
					Text = "Hello!",
				})
		end

		local source = {
			fileName = "TestDev-file.lua",
			lineNumber = 20,
		}

		local function DevParent()
			return React.createElement("Frame")
		end

		local description = describeUnknownElementTypeFrameInDev(
			React.createElement(TestDevStackComponent).type,
			source,
			DevParent
		)

		if _G.__DEV__ then
			jestExpect(description).toEqual(
				"\n    in TestDevStackComponent (at TestDev-file.lua:20)"
			)
		else
			jestExpect(description).toEqual("")
		end
	end)

	it(
		"should accept function component in describeUnknownElementTypeFrameInDev",
		function()
			local function DevStackFunctionComponent()
				error("Thrown Error")
				return React.createElement("Frame")
			end

			local source = {
				fileName = "TestDevFunction-file.lua",
				lineNumber = 15,
			}

			local function DevParent()
				return React.createElement("Frame")
			end

			local description = describeUnknownElementTypeFrameInDev(
				React.createElement(DevStackFunctionComponent).type,
				source,
				DevParent
			)

			if _G.__DEV__ then
				jestExpect(description).toEqual(
					"\n    in DevStackFunctionComponent (at TestDevFunction-file.lua:15)"
				)
			else
				jestExpect(description).toEqual("")
			end
		end
	)
end) ]]
jg.Children._1c753c0310ef88f13a9f6c9b3674c1f3=jj
local jk

local jl={ClassName="ModuleScript",Children={},Properties={}}
jl.Name="ReactErrorProd-internal.spec"
jl.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/9a5576f4d263ac5d7a9462a287d1524fda3355b8/packages/shared/__tests__/ReactErrorProd-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]
--!strict

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest
local formatProdErrorMessage

beforeEach(function()
	jest.resetModules()
	formatProdErrorMessage = require(script.Parent.Parent.formatProdErrorMessage)
end)

it("should throw with the correct number of `%s`s in the URL", function()
	jestExpect(formatProdErrorMessage(124, "foo", "bar")).toEqual(
		"Minified React error #124; visit "
			.. "https://reactjs.org/docs/error-decoder.html?invariant=124&args[]=foo&args[]=bar"
			.. " for the full message or use the non-minified dev environment"
			.. " for full errors and additional helpful warnings."
	)

	jestExpect(formatProdErrorMessage(20)).toEqual(
		"Minified React error #20; visit "
			.. "https://reactjs.org/docs/error-decoder.html?invariant=20"
			.. " for the full message or use the non-minified dev environment"
			.. " for full errors and additional helpful warnings."
	)

	jestExpect(formatProdErrorMessage(77, "<div>", "&?bar")).toEqual(
		"Minified React error #77; visit "
			.. "https://reactjs.org/docs/error-decoder.html?invariant=77&args[]=%3Cdiv%3E&args[]=%26%3Fbar"
			.. " for the full message or use the non-minified dev environment"
			.. " for full errors and additional helpful warnings."
	)
end) ]]
jg.Children._f12f6ff004af1dd6329b703af837bb75=jl
local jm

local jn={ClassName="ModuleScript",Children={},Properties={}}
jn.Name="ReactErrorUtils-internal.spec"
jn.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/3e94bce765d355d74f6a60feb4addb6d196e3482/packages/shared/__tests__/ReactErrorUtils-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local JestGlobals = require(Packages.Dev.JestGlobals)
local afterEach = JestGlobals.afterEach
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local it = JestGlobals.it
local jest = JestGlobals.jest
local ReactErrorUtils

beforeEach(function()
	-- TODO: can we express this test with only public API?
	jest.resetModules()
	ReactErrorUtils = require(script.Parent.Parent.ReactErrorUtils)
end)

afterEach(function()
	jest.unmock(script.Parent.Parent.invokeGuardedCallbackImpl)
end)

it("it should rethrow caught errors", function()
	local err = Error("foo")
	local callback = function()
		error(err)
	end
	ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError("foo", callback, nil)
	jestExpect(ReactErrorUtils.hasCaughtError()).toBe(false)
	jestExpect(function()
		ReactErrorUtils.rethrowCaughtError()
	end).toThrow(err)
end)

it("should call the callback the passed arguments", function()
	-- ROBLOX deviation: In Lua, calling a function with `self` (which is the
	-- equivalent of the `context` argument used in
	-- invokeGuardedCallbackImpl) is explicit; if the context argument is
	-- nil, the function is presumed to not rely on `self` and is called
	-- without the `context` argument. For this test, we validate both
	-- cases.
	local callback = jest.fn()
	ReactErrorUtils.invokeGuardedCallback("foo", callback, nil, "arg1", "arg2")
	jestExpect(callback).toBeCalledWith("arg1", "arg2")
end)

it("should call the callback with the provided context", function()
	local context = { didCall = false }
	ReactErrorUtils.invokeGuardedCallback("foo", function(self)
		self.didCall = true
	end, context)
	jestExpect(context.didCall).toBe(true)
end)

it("should catch errors", function()
	local error_ = Error()
	local returnValue = ReactErrorUtils.invokeGuardedCallback("foo", function()
		error(error_)
	end, nil, "arg1", "arg2")
	jestExpect(returnValue).toBe(nil)
	jestExpect(ReactErrorUtils.hasCaughtError()).toBe(true)
	jestExpect(ReactErrorUtils.clearCaughtError()).toBe(error_)
end)

it("should return false from clearCaughtError if no error was thrown", function()
	local callback = jest.fn()
	ReactErrorUtils.invokeGuardedCallback("foo", callback, nil)
	jestExpect(ReactErrorUtils.hasCaughtError()).toBe(false)
	jestExpect(ReactErrorUtils.clearCaughtError).toThrow("no error was captured")
end)

it("can nest with same debug name", function()
	local err1 = Error()
	local err2
	local err3 = Error()
	ReactErrorUtils.invokeGuardedCallback("foo", function()
		ReactErrorUtils.invokeGuardedCallback("foo", function()
			error(err1)
		end, nil)
		err2 = ReactErrorUtils.clearCaughtError()
		error(err3)
	end, nil)
	local err4 = ReactErrorUtils.clearCaughtError()

	jestExpect(err2).toBe(err1)
	jestExpect(err4).toBe(err3)
end)

it("handles nested errors", function()
	local err1 = Error()
	local err2
	ReactErrorUtils.invokeGuardedCallback("foo", function()
		ReactErrorUtils.invokeGuardedCallback("foo", function()
			error(err1)
		end, nil)
		err2 = ReactErrorUtils.clearCaughtError()
	end, nil)
	-- Returns nil because inner error was already captured
	jestExpect(ReactErrorUtils.hasCaughtError()).toBe(false)

	jestExpect(err2).toBe(err1)
end)

it("handles nested errors in separate renderers", function()
	local ReactErrorUtils1 = require(script.Parent.Parent.ReactErrorUtils)
	jest.resetModules()
	local ReactErrorUtils2 = require(script.Parent.Parent.ReactErrorUtils)
	jestExpect(ReactErrorUtils1).never.toEqual(ReactErrorUtils2)

	local ops = {}

	ReactErrorUtils1.invokeGuardedCallback(nil, function()
		ReactErrorUtils2.invokeGuardedCallback(nil, function()
			error(Error("nested error"))
		end)
		-- ReactErrorUtils2 should catch the error
		table.insert(ops, ReactErrorUtils2.hasCaughtError())
		-- ROBLOX TODO: this is a missing assert/cast in upstream
		table.insert(ops, (ReactErrorUtils2.clearCaughtError() :: any).message)
	end, nil)

	-- ReactErrorUtils1 should not catch the error
	table.insert(ops, ReactErrorUtils1.hasCaughtError())

	jestExpect(ops).toEqual({ true, "nested error", false })
end)

if not _G.__DEV__ then
	-- jsdom doesn't handle this properly, but Chrome and Firefox should. Test
	-- this with a fixture.
	it("catches nil values", function()
		ReactErrorUtils.invokeGuardedCallback(nil, function()
			error(nil) -- eslint-disable-line no-throw-literal
		end, nil)
		jestExpect(ReactErrorUtils.hasCaughtError()).toBe(true)
		jestExpect(ReactErrorUtils.clearCaughtError()).toBe(nil)
	end)
end

it("can be shimmed", function()
	local ops = {}
	jest.resetModules()
	jest.mock(script.Parent.Parent.invokeGuardedCallbackImpl, function()
		return function(reporter, name, func, context, a)
			table.insert(ops, a)
			local ok, result = pcall(func, context, a)

			if not ok then
				reporter.onError(result)
			end
		end
	end)
	ReactErrorUtils = require(script.Parent.Parent.ReactErrorUtils)

	-- deviation: no need to wrap in try/finally since we don't need to
	-- undo the mock like we would with jest
	local err = Error("foo")
	local callback = function()
		error(err)
	end
	ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(
		"foo",
		callback,
		nil,
		"somearg"
	)

	jestExpect(function()
		ReactErrorUtils.rethrowCaughtError()
	end).toThrow(err)
	jestExpect(ops).toEqual({ "somearg" })
end) ]]
jg.Children._34d9fef4ec82c781005f79f4c4d28a4b=jn
local jo

local jp={ClassName="ModuleScript",Children={},Properties={}}
jp.Name="ReactInstanceMap.roblox.spec"
jp.Properties.Source=[[ -- ROBLOX deviation: we have a crash in production this deviant logic will help catch
-- ROBLOX TODO: make this only pass in __DEV__

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it

local ReactInstanceMap = require(Packages.Shared).ReactInstanceMap

describe("get", function()
	it("with invalid fiber", function()
		local elementWithBadFiber = {
			_reactInternals = {
				tag = 0,
				-- missing key fields of Fiber
			},
		}
		jestExpect(function()
			ReactInstanceMap.get(elementWithBadFiber)
		end).toThrow(
			"invalid fiber in UNNAMED Component during get from ReactInstanceMap!"
		)
	end)
	it("with valid fiber that has invalid alternate", function()
		local elementWithGoodFiberBadAlternate = {
			_reactInternals = {
				tag = 0,
				subtreeFlags = 0,
				lanes = 0,
				childLanes = 0,
				alternate = {
					tag = 1,
					-- missing key fields of Fiber
				},
			},
		}
		jestExpect(function()
			ReactInstanceMap.get(elementWithGoodFiberBadAlternate)
		end).toThrow(
			"invalid alternate fiber (UNNAMED alternate) in UNNAMED Component during get from ReactInstanceMap!"
		)
	end)
end)
describe("set", function()
	it("with invalid fiber", function()
		local badFiber = {
			tag = 0,
			-- missing key fields of Fiber
		}
		jestExpect(function()
			ReactInstanceMap.set({ displayName = "MyComponent" }, badFiber)
		end).toThrow("invalid fiber in MyComponent being set in ReactInstanceMap!")
	end)
	it("with valid fiber with no return that has invalid alternate", function()
		local goodFiberBadAlternate = {
			tag = 0,
			subtreeFlags = 0,
			lanes = 0,
			childLanes = 0,
			alternate = {
				tag = 1,
				-- missing key fields of Fiber
			},
		}
		jestExpect(function()
			ReactInstanceMap.set({}, goodFiberBadAlternate)
		end).toThrow(
			"invalid alternate fiber (UNNAMED alternate) in UNNAMED Component being set in ReactInstanceMap!"
		)
	end)
	it("with valid fiber with a valid return_ that has invalid alternate", function()
		local goodFiberGoodReturnBadAlternate = {
			tag = 0,
			subtreeFlags = 0,
			lanes = 0,
			childLanes = 0,
			alternate = {
				tag = 1,
				subtreeFlags = 1,
				lanes = 1,
				childLanes = 1,
			},
			return_ = {
				tag = 2,
				subtreeFlags = 2,
				lanes = 2,
				childLanes = 2,
				alternate = {
					tag = 3,
					-- missing key fields of Fiber
				},
			},
		}
		jestExpect(function()
			ReactInstanceMap.set({}, goodFiberGoodReturnBadAlternate)
		end).toThrow(
			"invalid alternate fiber (UNNAMED alternate) in UNNAMED Component being set in ReactInstanceMap! { tag: 3 }\n (from original fiber UNNAMED Component)"
		)
	end)
end) ]]
jg.Children._adfe5df69e6e2ad3db88b15e40c874b7=jp
local jq

local jr={ClassName="ModuleScript",Children={},Properties={}}
jr.Name="ReactSymbols-internal.spec"
jr.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/cdbfa6b5dd692220e5996ec453d46fc10aff046a/packages/shared/__tests__/ReactSymbols-test.internal.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
\]\]
--!strict

local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local it = JestGlobals.it

-- deviation: This doesn't have any affect for this test
-- beforeEach(() => jest.resetModules());

local function expectToBeUnique(keyValuePairs)
	local map = {}
	for key, value in keyValuePairs do
		if map[value] ~= nil then
			-- ROBLOX TODO: workaround for Luau false positive nil-ability
			error(
				string.format(
					"%s value %s is the same as %s",
					key,
					tostring(value),
					map[value] :: any
				)
			)
		end
		-- ROBLOX TODO: workaround for Luau false positive nil-ability
		map[value] = key :: any
	end
end

-- deviation: Symbol values are not used
it.skip("Symbol values should be unique", function()
	-- expectToBeUnique(require(script.Parent.ReactSymbols));
end)

-- deviation: FIXME: verify that the equivalent legacy numeric values in the
-- commented out portion of this test are actually a thing; they don't seem
-- to exist, so we may be able to update the upstream test and the pull in
-- the simplified logic
it("numeric values should be unique", function()
	-- deviation: We don't use symbol anyways, so it's no use to
	-- override it. We also don't need to filter any values, since
	-- they're internal-only.
	local ReactSymbols = require(script.Parent.Parent.ReactSymbols)
	expectToBeUnique(ReactSymbols)

	-- deviation: We comment out this chunk because we're not actually using
	-- a global `Symbol` definition in the first place, so we don't need to
	-- un-polyfill them

	-- const originalSymbolFor = global.Symbol.for;
	-- global.Symbol.for = null;
	-- try {
	-- 	entries = Object.entries(require('shared/ReactSymbols')).filter(
	-- 		// REACT_ASYNC_MODE_TYPE and REACT_CONCURRENT_MODE_TYPE have the same numeric value
	-- 		// for legacy backwards compatibility
	-- 		([key]) => key !== 'REACT_ASYNC_MODE_TYPE',
	-- 	);
	-- 	expectToBeUnique(entries);
	-- } finally {
	-- 	global.Symbol.for = originalSymbolFor;
	-- }
end) ]]
jg.Children._62100177701d55e17a3197b423333703=jr
local js

local jt={ClassName="ModuleScript",Children={},Properties={}}
jt.Name="checkPropTypes.roblox.spec"
jt.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local React

local ReactNoop
local Scheduler
local JestGlobals = require(Packages.Dev.JestGlobals)
local afterEach = JestGlobals.afterEach
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local jest = JestGlobals.jest
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

describe("tests propTypes and validateProps behavior", function()
	beforeEach(function()
		jest.resetModules()
		ReactNoop = require(Packages.Dev.ReactNoop)
		Scheduler = require(Packages.Dev.Scheduler)
		React = require(Packages.Dev.React)
	end)
	it("propTypes defined, returns error", function()
		local Foo = React.Component:extend("div")

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				return Error("no no no no no")
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end
		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end)
		end).toWarnDev("no no no no no")
	end)
	it("propTypes defined, returns nil", function()
		local Foo = React.Component:extend("Foo")

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				return nil
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end
		ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
		jestExpect(Scheduler).toFlushWithoutYielding()
	end)
	it("validateProps defined, returns false", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return false, "no no no no no"
		end

		function Foo:render()
			return React.createElement("div")
		end
		local function testValidation()
			ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
			jestExpect(Scheduler).toFlushWithoutYielding()
		end
		if _G.__DEV__ then
			-- For legacy compatibility, this test throws as well as warning
			jestExpect(testValidation).toThrow("no no no no no")
		else
			jestExpect(testValidation).never.toThrow()
		end
	end)
	it("validateProps defined, returns true", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return true
		end

		function Foo:render()
			return React.createElement("div")
		end

		ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
		jestExpect(Scheduler).toFlushWithoutYielding()
	end)
	it("warning when both methods are defined", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return true
		end

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				return nil
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end)
		end).toWarnDev(
			"You've defined both propTypes and validateProps on Foo",
			{ withoutStack = true }
		)
	end)
	it("validateProps fails, propTypes fails", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return false, "no no no no no"
		end

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				error(Error("no no no no no"))
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end

		local function testValidation()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
					jestExpect(Scheduler).toFlushWithoutYielding()
				end)
			end).toWarnDev(
				"You've defined both propTypes and validateProps on Foo",
				{ withoutStack = 2 }
			)
		end
		if _G.__DEV__ then
			-- For legacy compatibility, this test throws as well as warning
			jestExpect(testValidation).toThrow("no no no no no")
		else
			jestExpect(testValidation).never.toThrow()
		end
	end)
	it("validateProps succeeds, propTypes fails", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return true
		end

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				error(Error("no no no no no"))
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end)
		end).toWarnDev({
			"You've defined both propTypes and validateProps on Foo",
			"no no no no no",
		}, { withoutStack = 1 })
	end)
	it("validateProps fails, propTypes succeeds", function()
		local Foo = React.Component:extend("Foo")

		Foo.validateProps = function(props)
			return false, "no no no no no"
		end

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				return nil
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end

		local function testValidation()
			jestExpect(function()
				ReactNoop.act(function()
					ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
					jestExpect(Scheduler).toFlushWithoutYielding()
				end)
			end).toWarnDev(
				"You've defined both propTypes and validateProps on Foo",
				{ withoutStack = 2 }
			)
		end
		if _G.__DEV__ then
			-- For legacy compatibility, this test throws as well as warning
			jestExpect(testValidation).toThrow("no no no no no")
		else
			jestExpect(testValidation).never.toThrow()
		end
	end)
	it("bad propTypes method", function()
		local Foo = React.Component:extend("Foo")

		Foo.propTypes = {
			myProp = function(prop, propName, componentName)
				return "nil"
			end,
		}

		function Foo:render()
			return React.createElement("div")
		end

		jestExpect(function()
			ReactNoop.act(function()
				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end)
		end).toErrorDev({
			"Foo: type specification of prop"
				.. " `myProp` is invalid; the type checker "
				.. "function must return `nil` or an `Error` but returned a string. "
				.. "You may have forgotten to pass an argument to the type checker "
				.. "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and "
				.. "shape all require an argument).",
		})
	end)
	it("bad validateProps method", function()
		local Foo = React.Component:extend("Foo")

		function Foo:render()
			return React.createElement("div")
		end

		jestExpect(Scheduler).toFlushWithoutYielding()
		jestExpect(function()
			ReactNoop.act(function()
				Foo.validateProps = "this is a string"

				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
			end)
		end).toErrorDev({
			'validateProps must be a function, but it is a string.\nCheck the definition of the component "Foo".',
		}, { withoutStack = 1 })
	end)

	describe("__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__", function()
		beforeEach(function(context)
			context.oldValidate = _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__
			_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ = true
		end)

		afterEach(function(context)
			_G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ = context.oldValidate
		end)

		it("validateProps defined, returns false", function()
			local Foo = React.Component:extend("Foo")

			Foo.validateProps = function(props)
				return false, "no no no no no"
			end

			function Foo:render()
				return React.createElement("div")
			end
			local function testValidation()
				ReactNoop.render(React.createElement(Foo, { myProp = "hello" }))
				jestExpect(Scheduler).toFlushWithoutYielding()
			end

			-- For legacy compatibility, this test throws as well as warning
			if _G.__DEV__ then
				jestExpect(testValidation).toThrow("no no no no no")
			else
				jestExpect(testValidation).never.toThrow()
			end
		end)
	end)
end) ]]
jg.Children._da1a6b35170235a32ed85af856de45b0=jt
local ju

local jv={ClassName="ModuleScript",Children={},Properties={}}
jv.Name="getComponentName.roblox.spec"
jv.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local beforeEach = JestGlobals.beforeEach
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it
local React

local getComponentName
local function MyComponent() end
local anonymous = function() end

beforeEach(function()
	React = require(Packages.Dev.React)

	getComponentName = require(Packages.Shared).getComponentName
end)

describe("function components", function()
	it("gets name from non-anonymous function", function()
		jestExpect(getComponentName(MyComponent)).toBe("MyComponent")
	end)
	it("gets nil from anonymous function", function()
		local anonymous = function() end
		jestExpect(getComponentName(anonymous)).toBe(nil)
	end)
end)
describe("Lazy components", function()
	it("gets name from lazy-wrapped non-anonymous function", function()
		local lazyMyComponent = React.lazy(function()
			return {
				andThen = function(self, resolve)
					resolve({ default = MyComponent })
				end,
			}
		end)
		jestExpect(getComponentName(lazyMyComponent)).toBe("MyComponent")
	end)
	it("gets nil from lazy-wrapped anonymous function", function()
		local lazyAnonymous = React.lazy(function()
			return {
				andThen = function(self, resolve)
					resolve({ default = anonymous })
				end,
			}
		end)
		jestExpect(getComponentName(lazyAnonymous)).toBe(nil)
	end)
end) ]]
jg.Children._0fb33f2bd5a698d6c16042eed3004c48=jv
local jw

local jx={ClassName="ModuleScript",Children={},Properties={}}
jx.Name="isValidElementType.roblox.spec"
jx.Properties.Source=[[ local Packages = script.Parent.Parent.Parent
local JestGlobals = require(Packages.Dev.JestGlobals)
local jestExpect = JestGlobals.expect
local describe = JestGlobals.describe
local it = JestGlobals.it

local isValidElementType = require(Packages.Shared).isValidElementType
local ReactSymbols = require(Packages.Shared).ReactSymbols
local element

describe("accept element primitives", function()
	it("from strings", function()
		element = "TextLabel"
		jestExpect(isValidElementType(element)).toBe(true)
	end)

	it("from functions", function()
		element = function() end
		jestExpect(isValidElementType(element)).toBe(true)
	end)

	it("from tables", function()
		element = {}
		element["$$typeof"] = ReactSymbols.REACT_CONTEXT_TYPE
		jestExpect(isValidElementType(element)).toBe(true)
	end)
end)

describe("does not accept", function()
	it("REACT_ELEMENT_TYPE", function()
		element = {}
		element["$$typeof"] = ReactSymbols.REACT_ELEMENT_TYPE
		jestExpect(isValidElementType(element)).toBe(false)
	end)
end) ]]
jg.Children._25bb261f51f1f5365ea9dec9a31d11a7=jx
local jy

local jz={ClassName="ModuleScript",Children={},Properties={}}
jz.Name="checkPropTypes"
jz.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Function = (...any) -> ...any

-- ROBLOX: use patched console from shared
local console = require(script.Parent.console)

local loggedTypeFailures = {}

local ReactComponentStackFrame = require(script.Parent.ReactComponentStackFrame)
local describeUnknownElementTypeFrameInDEV =
	ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

-- ROBLOX FIXME Luau: doesn't see `if element` as nilable table, so we get TypeError: Type 'any?' could not be converted into '{| _owner: {| type: nil |}, _source: Source?, type: any |}'
local function setCurrentlyValidatingElement(element: any?)
	if _G.__DEV__ then
		if element then
			local owner = element._owner
			local stack = describeUnknownElementTypeFrameInDEV(
				element.type,
				element._source,
				if owner ~= nil then owner.type else nil
			);
			-- ROBLOX FIXME Luau: Cannot call non-function ((string?) -> ()) | ((string?) -> ())
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(stack)
		else
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(nil)
		end
	end
end

local function checkPropTypes<P>(
	-- ROBLOX deviation START: also checks validateProps if present
	propTypes: Object?,
	validateProps: (P) -> (boolean, string?)?,
	props: P,
	-- ROBLOX deviation END
	location: string,
	componentName: string?,
	element: any?
): ()
	if _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		-- deviation: hasOwnProperty shouldn't be relevant to lua objects
		-- $FlowFixMe This is okay but Flow doesn't know it.
		-- local has = Function.call.bind(Object.prototype.hasOwnProperty)

		-- ROBLOX deviation: warns if both propType and validateProps defined.
		if propTypes and validateProps then
			console.warn(
				"You've defined both propTypes and validateProps on "
					.. (componentName or "a component")
			)
		end

		-- ROBLOX deviation: also checks validateProps if present
		if validateProps then
			if typeof(validateProps) ~= "function" then
				console.error(
					("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
						typeof(validateProps),
						componentName or ""
					)
				)
			else
				local success, failureReason = validateProps(props)

				if not success then
					failureReason = failureReason
						or "<Validator function did not supply a message>"
					local message = string.format(
						"validateProps failed on a %s type in %s: %s",
						location,
						componentName or "<UNKNOWN Component>",
						tostring(failureReason)
					)
					-- ROBLOX deviation: In legacy Roact, prop validation
					-- failures throw. We replicate that behavior, even though
					-- it differs from propTypes (which only warns)
					-- ROBLOX FIXME: align with upstream behavior during React 18 Lua transition
					error(message)
				end
			end
		end

		if propTypes then
			-- ROBLOX deviation: since we can't constrain the generic, we assert so Luau knows propTypes is a table
			assert(typeof(propTypes) == "table", "propTypes needs to be a table")
			for typeSpecName, _ in propTypes do
				-- deviation: since our loop won't hit metatable members, we don't
				-- need to worry about encountering inherited properties here
				-- if has(propTypes, typeSpecName) then

				-- Prop type validation may throw. In case they do, we don't want to
				-- fail the render phase where it didn't fail before. So we log it.
				-- After these have been cleaned up, we'll local them throw.
				local _, result = xpcall(function()
					-- This is intentionally an invariant that gets caught. It's the same
					-- behavior as without this statement except with a better message.
					if typeof(propTypes[typeSpecName]) ~= "function" then
						local err = Error.new(
							(componentName or "React class")
								.. ": "
								.. location
								.. " type `"
								.. typeSpecName
								.. "` is invalid; "
								.. "it must be a function, usually from the `prop-types` package, but received `"
								.. typeof(propTypes[typeSpecName])
								.. "`."
								.. "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
						)
						err.name = "Invariant Violation"
						error(err)
					end

					return (propTypes[typeSpecName] :: Function)(
						props,
						typeSpecName,
						componentName,
						location,
						nil,
						"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
					)
				end, describeError)

				-- ROBLOX deviation: FIXME: Can we expose something from JSPolyfill that
				-- will let us verify that this is specifically the Error object
				-- defined there? if we check for result.message ~= nil, ReactNewContext.spec:1368 fails
				local isErrorObject = typeof(result) == "table"
				if result ~= nil and not isErrorObject then
					setCurrentlyValidatingElement(element)
					console.error(string.format(
						-- ROBLOX deviation: s/null/nil
						"%s: type specification of %s"
							.. " `%s` is invalid; the type checker "
							.. "function must return `nil` or an `Error` but returned a %s. "
							.. "You may have forgotten to pass an argument to the type checker "
							.. "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and "
							.. "shape all require an argument).",
						componentName or "React class",
						location,
						typeSpecName,
						typeof(result)
					))
					setCurrentlyValidatingElement(nil)
				end

				-- ROBLOX FIXME: Luau analyze doesn't understand isErrorObject's effect as a predicate meaning result ~= nil
				if
					isErrorObject
					and loggedTypeFailures[(result :: any).message] == nil
				then
					-- Only monitor this failure once because there tends to be a lot of the
					-- same error.
					loggedTypeFailures[tostring((result :: any).message)] = true
					setCurrentlyValidatingElement(element)
					console.warn(
						string.format(
							"Failed %s type: %s",
							location,
							tostring((result :: any).message)
						)
					)
					setCurrentlyValidatingElement(nil)
				end
			end
		end
	end
end

return checkPropTypes ]]
ic.Children._a916a34c2148f898b4b84085fa0daca9=jz
local jA

local jB={ClassName="ModuleScript",Children={},Properties={}}
jB.Name="console"
jB.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]

-- deviation: this lets us have the same functionality as in React, without
-- having something like Babel to inject a different implementation of
-- console.warn and console.error into the code
-- Instead of using `LuauPolyfill.console`, React internals should use this
-- wrapper to be able to use consoleWithStackDev in dev mode
local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local consoleWithStackDev = require(Shared.consoleWithStackDev)

if _G.__DEV__ then
	local newConsole = setmetatable({
		warn = consoleWithStackDev.warn,
		error = consoleWithStackDev.error,
	}, {
		__index = console,
	})
	return newConsole
end

return console ]]
ic.Children._4bda521022df8f1f565a8bff1e836fb2=jB
local jC

local jD={ClassName="ModuleScript",Children={},Properties={}}
jD.Name="consoleWithStackDev"
jD.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/cb141681750c8221ac799074df09df2bb448c7a4/packages/shared/consoleWithStackDev.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
\]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local Array = LuauPolyfill.Array

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
-- In DEV, calls to console.warn and console.error get replaced
-- by calls to these methods by a Babel plugin.
--
-- In PROD (or in packages without access to React internals),
-- they are left as they are instead.

-- deviation: declare this ahead of time so that `warn` and `error` are able to
-- reference it
local printWarning

local exports = {}
exports.warn = function(format, ...)
	if _G.__DEV__ then
		printWarning("warn", format, { ... })
	end
end
exports.error = function(format, ...)
	if _G.__DEV__ then
		printWarning("error", format, { ... })
	end
end

function printWarning(level, format, args)
	-- When changing this logic, you might want to also
	-- update consoleWithStackDev.www.js as well.
	if _G.__DEV__ then
		local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
		local stack = ReactDebugCurrentFrame.getStackAddendum()

		if stack ~= "" then
			format ..= "%s"
			-- deviation: no array `concat` function in lua
			args = Array.slice(args, 1)
			table.insert(args, stack)
		end

		local argsWithFormat = Array.map(args, tostring)
		-- Careful: RN currently depends on this prefix
		table.insert(argsWithFormat, 1, "Warning: " .. format)
		-- We intentionally don't use spread (or .apply) directly because it
		-- breaks IE9: https://github.com/facebook/react/issues/13610
		-- eslint-disable-next-line react-internal/no-production-logging
		console[level](unpack(argsWithFormat))
	end
end

return exports ]]
ic.Children._1dbde5f0e93e1694fc1f866ae4a91b12=jD
local jE

local jF={ClassName="ModuleScript",Children={},Properties={}}
jF.Name="enqueueTask.roblox"
jF.Properties.Source=[[ --!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 \]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local setTimeout = LuauPolyfill.setTimeout

return function(task)
	-- deviation: Replace with setImmediate once we create an equivalent polyfill
	return setTimeout(task, 0)
end ]]
ic.Children._74cc47f0f19819d2a1097c79bfb43669=jF
local jG

local jH={ClassName="ModuleScript",Children={},Properties={}}
jH.Name="flowtypes.roblox"
jH.Properties.Source=[[ --\[\[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
\]\]
-- built-in flowtypes reverse engineered based on usage and enabling strict type checking on test suites
--!strict
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
type Object = { [string]: any }
-- duplicated from ReactElementType to avoid circular dep
type Source = {
	fileName: string,
	lineNumber: number,
}

-- ROBLOX deviation: alias for internal React$ flow types
export type React_Node =
	nil
	| boolean
	| number
	| string
	| React_Element<any>
	-- ROBLOX TODO: only include this once it's more specific than `any`
	-- | React_Portal
	| Array<React_Node?>
	-- ROBLOX TODO Luau: this more closely matches the upstream Iterable<>, hypothetically the UNIQUE_TAG field makes it so we don't unify with other tables and squad field resolution
	| { [string]: React_Node?, UNIQUE_TAG: any? }

export type React_Element<ElementType> = {
	type: ElementType,
	props: React_ElementProps<ElementType>?,
	key: React_Key | nil,
	ref: any,
}

export type React_PureComponent<Props, State = nil> = React_Component<Props, State>

-- ROBLOX note: this flowtype built-in is derived from the object shape returned by forwardRef
export type React_AbstractComponent<Config, Instance> = {
	["$$typeof"]: number,
	render: ((props: Config, ref: React_Ref<Instance>) -> React_Node)?,
	displayName: string?,
	defaultProps: Config?,
	-- not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
	-- allows methods to be hung on a component, used in forwardRef.spec regression test we added
	[string]: any,
}

-- ROBLOX TODO: ElementConfig: something like export type React_ElementConfig<React_Component<P>> = P
export type React_ElementConfig<C> = Object

-- ROBLOX deviation: this is a class export upstream, so optional overrides are nil-able, and it's extensible by default
export type React_Component<Props, State = nil> = {
	-- fields
	props: Props,
	state: State,

	-- action methods

	setState: (
		self: React_Component<Props, State>,
		partialState: State | ((State, Props) -> State?),
		callback: (() -> ())?
	) -> (),

	forceUpdate: (self: React_Component<Props, State>, callback: (() -> ())?) -> (),

	-- lifecycle methods

	init: ((
		self: React_Component<Props, State>,
		props: Props,
		context: any?
	) -> ())?,
	render: (self: React_Component<Props, State>) -> React_Node,
	componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	UNSAFE_componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	componentDidMount: ((self: React_Component<Props, State>) -> ())?,
	componentWillReceiveProps: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextContext: any
	) -> ())?,
	UNSAFE_componentWillReceiveProps: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextContext: any
	) -> ())?,
	shouldComponentUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> boolean)?,
	componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	UNSAFE_componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	componentDidUpdate: ((
		self: React_Component<Props, State>,
		prevProps: Props,
		prevState: State,
		prevContext: any
	) -> ())?,
	componentWillUnmount: ((self: React_Component<Props, State>) -> ())?,
	componentDidCatch: ((
		self: React_Component<Props, State>,
		error: Error,
		info: {
			componentStack: string,
		}
	) -> ())?,
	getDerivedStateFromProps: ((props: Props, state: State) -> State?)?,
	getDerivedStateFromError: ((error: Error) -> State?)?,
	getSnapshotBeforeUpdate: ((props: Props, state: State) -> any)?,

	-- long tail of other stuff not modeled very well

	-- ROBLOX deviation START: these fields are mostly used internally including in ReactBaseClasses
	__refs: Object,
	__updater: any,
	-- ROBLOX deviation END

	-- ROBLOX deviation: this field is only used in relation to string refs, which we do not support
	-- refs: any,
	context: any,
	getChildContext: (self: React_Component<Props, State>) -> any,
	-- statics
	__componentName: string,
	displayName: string?,
	-- ROBLOX deviation: not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
	childContextTypes: any?,
	contextTypes: any?,
	propTypes: any?,

	-- ROBLOX FIXME: this is a legacy Roact field and should be removed in React 18 Lua
	validateProps: ((Props) -> (boolean, string?))?,

	-- We don't add a type for `defaultProps` so that its type may be entirely
	-- inferred when we diff the type for `defaultProps` with `Props`. Otherwise
	-- the user would need to define a type (which would be redundant) to override
	-- the type we provide here in the base class.
	-- ROBLOX deviation: Luau doesn't do the inference above
	defaultProps: Props?,
	-- ROBLOX deviation: class export allows assigning additional custom instance fields
	[string]: any,
}

-- ROBLOX deviation: Lua doesn't allow fields on functions, and we haven't implemented callable tables as "function" components
export type React_StatelessFunctionalComponent<Props> = (
	props: Props,
	context: any
) -> React_Node
export type React_ComponentType<Config> = React_Component<Config, any>

export type React_ElementType = string | React_Component<any, any>

-- This was reverse engineered from usage, no specific flowtype or TS artifact
export type React_ElementProps<ElementType> = {
	ref: React_Ref<ElementType>?,
	key: React_Key?,
	__source: Source?,
	children: any?,
}

-- ROBLOX deviation: this is a built-in flow type, and very complex. we fudge this with `any`
-- type ElementRef<
--   C extends keyof JSX.IntrinsicElements
--   | React.ForwardRefExoticComponent<any>
--   | (new (props: any) -> React.Component<any, {}, any>)
--   | ((props: any, context?: any) -> ReactElement | null)
--   > = "ref" extends keyof ComponentPropsWithRef<C>
--     ? NonNullable<ComponentPropsWithRef<C>["ref"]> extends Ref<infer Instance>
--       ? Instance
--       : never
--     : never

-- ROBLOX TODO: Not sure how to model this, upstream: https://github.com/facebook/flow/blob/main/tests/react_instance/class.js#L10
-- ROBLOX FIXME Luau: if I make this Object, we run into normalization issues: '{| current: React_ElementRef<any>? |}' could not be converted into '(((?) -> any) | {| current: ? |})?
export type React_ElementRef<C> = C

export type React_Ref<ElementType> =
	{ current: React_ElementRef<ElementType> | nil }
	| ((React_ElementRef<ElementType> | nil) -> ())
-- ROBLOX deviation: we don't support string refs, and this is unsound flowtype when used with ref param of useImperativeHandle
-- | string

export type React_Context<T> = {
	Provider: React_ComponentType<{ value: T, children: React_Node? }>,
	Consumer: React_ComponentType<{ children: (value: T) -> React_Node? }>,
}

-- ROBLOX TODO: declared as an opaque type in flowtype: https://github.com/facebook/flow/blob/422821fd42c09c3ef609c60516fe754b601ea205/lib/react.js#L182
export type React_Portal = any
export type React_Key = string | number

return {} ]]
ic.Children._0b61fa34b352a51d7e64bba9378ad38e=jH
local jI

local jJ={ClassName="ModuleScript",Children={},Properties={}}
jJ.Name="formatProdErrorMessage"
jJ.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/75955bf1d7ff6c2c1f4052f4a84dd2ce6944c62e/packages/shared/formatProdErrorMessage.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 \]\]

-- Do not require this module directly! Use normal `invariant` calls with
-- template literal strings. The messages will be replaced with error codes
-- during build.

local HttpService = game:GetService("HttpService")

local function formatProdErrorMessage(code, ...)
	local url = "https://reactjs.org/docs/error-decoder.html?invariant=" .. tostring(code)
	local argsLength = select("#", ...)
	for i = 1, argsLength, 1 do
		-- deviation: UrlEncode should be equivalent to encodeURIComponent
		url = url .. "&args[]=" .. HttpService:UrlEncode(select(i, ...))
	end
	return string.format(
		"Minified React error #%d; visit %s for the full message or "
			.. "use the non-minified dev environment for full errors and additional "
			.. "helpful warnings.",
		code,
		url
	)
end

return formatProdErrorMessage ]]
ic.Children._2ba5131ca67d8e385e9884d1f0e13ce2=jJ
local jK

local jL={ClassName="ModuleScript",Children={},Properties={}}
jL.Name="getComponentName"
jL.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/a774502e0ff2a82e3c0a3102534dbc3f1406e5ea/packages/shared/getComponentName.js
--\[\[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
\]\]
type Function = (...any) -> ...any
local console = require(script.Parent.console)

-- ROBLOX deviation: inline this typedef to avoid upstream's circular dependency
type LazyComponent<T, P> = {
	["$$typeof"]: number,
	_payload: P,
	_init: (payload: P) -> T,
}

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local ReactTypes = require(script.Parent.ReactTypes)
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local function getWrappedName(outerType: any, innerType: any, wrapperName: string): string
	-- deviation: Account for indexing into function
	local functionName = "<function>"
	if typeof(innerType) == "table" then
		functionName = innerType.displayName or innerType.name or ""
	end
	return outerType.displayName
		or (
			functionName ~= "" and string.format("%s(%s)", wrapperName, functionName)
			or wrapperName
		)
end

local function getContextName(type: ReactContext<any>): string
	return type.displayName or "Context"
end

local function getComponentName(type: any): string | nil
	if type == nil then
		-- Host root, text node or just invalid type.
		return nil
	end
	local typeofType = typeof(type)

	if _G.__DEV__ then
		if typeofType == "table" and typeof(type.tag) == "number" then
			console.warn(
				"Received an unexpected object in getComponentName(). "
					.. "This is likely a bug in React. Please file an issue."
			)
		end
	end

	if typeofType == "function" then
		-- ROBLOX deviation: we can't deref functions in Lua, so get the name of the function and move logic to table section
		-- ROBLOX FIXME Luau: this line gets a bunch of bizarre errors in strict mode
		local name = debug.info((type :: any) :: Function, "n")
		-- ROBLOX deviaton:when name = (null) we want it to be treated as nil, not as an empty (truthy) string
		if name and string.len(name) > 0 then
			return name
		else
			return nil
		end
	end

	if typeofType == "string" then
		return (type :: any) :: string
	end

	if type == REACT_FRAGMENT_TYPE then
		return "Fragment"
	elseif type == REACT_PORTAL_TYPE then
		return "Portal"
	elseif type == REACT_PROFILER_TYPE then
		return "Profiler"
	elseif type == REACT_STRICT_MODE_TYPE then
		return "StrictMode"
	elseif type == REACT_SUSPENSE_TYPE then
		return "Suspense"
	elseif type == REACT_SUSPENSE_LIST_TYPE then
		return "SuspenseList"
	end

	if typeofType == "table" then
		local typeProp = type["$$typeof"]
		if typeProp == REACT_CONTEXT_TYPE then
			local context: ReactContext<any> = type :: any
			return getContextName(context) .. ".Consumer"
		elseif typeProp == REACT_PROVIDER_TYPE then
			local provider: ReactProviderType<any> = type :: any
			return getContextName(provider._context) .. ".Provider"
		elseif typeProp == REACT_FORWARD_REF_TYPE then
			return getWrappedName(type, type.render, "ForwardRef")
		elseif typeProp == REACT_MEMO_TYPE then
			return getComponentName(type.type)
		elseif typeProp == REACT_BLOCK_TYPE then
			return getComponentName(type._render)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent: LazyComponent<any, any> = type :: any
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			-- ROBLOX performance: getComponentName won't throw, but init() might, extract it out to eliminate an anon function
			local ok, result = xpcall(init, describeError, payload)
			if ok then
				return getComponentName(result)
			else
				return nil
			end
		else
			-- ROBLOX deviation: Normally, the `typeofType == "function"` check would
			-- cover this case, but in Lua, class components are tables. We need
			-- to check for that here and use the name the component was
			-- assigned.
			if type.displayName then
				return type.displayName
			end
			if type.name then
				return type.name
			end
			-- ROBLOX note: only use tostring() if its overridden to avoid "table: 0xabcd9012"
			local mt = getmetatable(type)
			if mt and rawget(mt, "__tostring") then
				return tostring(type)
			end
		end
	end

	return nil
end

return getComponentName ]]
ic.Children._ec4c4492bda1840e8d459bf165e7f67e=jL
local jM

local jN={ClassName="ModuleScript",Children={},Properties={}}
jN.Name="invariant"
jN.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/42c3c967d1e4ca4731b47866f2090bc34caa086c/packages/shared/invariant.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
\]\]

--\[\[*
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
\]\]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local function invariant(condition, format, ...)
	-- ROBLOX TODO: we should encapsulate all formatting compatibility here,
	-- rather than spreading workarounds throughout the codebase, eg this
	-- should print an array without the need for a table.concat on the consumer side
	if not condition then
		error(Error(string.format(format, ...)))
	end
end

return invariant ]]
ic.Children._014a9d2600e9e4e010d914450bb7a515=jN
local jO

local jP={ClassName="ModuleScript",Children={},Properties={}}
jP.Name="invokeGuardedCallbackImpl"
jP.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/shared/invokeGuardedCallbackImpl.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]
-- local invariant = require(script.Parent.invariant)
local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

-- deviation: with flow types stripped, it's easier to use varargs directly
local function invokeGuardedCallbackProd(reporter, name, func, context, ...)
	-- local funcArgs = Array.prototype.slice.call(arguments, 3)

	-- ROBLOX deviation: YOLO flag for disabling pcall
	local ok, result
	if not _G.__YOLO__ then
		-- deviation: Since functions in lua _explicitly_ accept 'self' as a
		-- first argument when they use it, it becomes incorrect for us to call
		-- a function with a nil "context", where context in this case is
		-- analogous to the implicit `self` that we get with a `:` call
		if context == nil then
			ok, result = xpcall(func, describeError, ...)
		else
			ok, result = xpcall(func, describeError, context, ...)
		end
	else
		ok = true
		if context == nil then
			func(...)
		else
			func(context, ...)
		end
	end

	if not ok then
		-- deviation: functions have no notion of "this"/"self", so we expect
		-- the first argument to be the reporter itself, in conjunction with
		-- deviations in `ReactErrorUtils`
		reporter.onError(result)
	end
end

local invokeGuardedCallbackImpl = invokeGuardedCallbackProd

if _G.__DEV__ then
	-- In DEV mode, we swap out invokeGuardedCallback for a special version
	-- that plays more nicely with the browser's DevTools. The idea is to preserve
	-- "Pause on exceptions" behavior. Because React wraps all user-provided
	-- functions in invokeGuardedCallback, and the production version of
	-- invokeGuardedCallback uses a try-catch, all user exceptions are treated
	-- like caught exceptions, and the DevTools won't pause unless the developer
	-- takes the extra step of enabling pause on caught exceptions. This is
	-- unintuitive, though, because even though React has caught the error, from
	-- the developer's perspective, the error is uncaught.
	--
	-- To preserve the expected "Pause on exceptions" behavior, we don't use a
	-- try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
	-- DOM node, and call the user-provided callback from inside an event handler
	-- for that fake event. If the callback throws, the error is "captured" using
	-- a global event handler. But because the error happens in a different
	-- event loop context, it does not interrupt the normal program flow.
	-- Effectively, this gives us try-catch behavior without actually using
	-- try-catch. Neat!
	-- Check that the browser supports the APIs we need to implement our special
	-- DEV version of invokeGuardedCallback

	-- deviation: `window` is not defined in our environment
	-- deviation: FIXME: should we define our own impl for invokeGuardedCallbackDev?
	--\[\[
	if typeof window ~= 'undefined' and typeof window.dispatchEvent == 'function' and typeof document ~= 'undefined' and typeof document.createEvent == 'function' then
		local fakeNode = document.createElement('react')

		invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
			-- If document doesn't exist we know for sure we will crash in this method
			-- when we call document.createEvent(). However this can cause confusing
			-- errors: https://github.com/facebookincubator/create-react-app/issues/3482
			-- So we preemptively throw with a better message instead.
			invariant(typeof document ~= 'undefined', 'The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.')
			local evt = document.createEvent('Event')
			local didCall = false; -- Keeps track of whether the user-provided callback threw an error. We
			-- set this to true at the beginning, then set it to false right after
			-- calling the function. If the function errors, `didError` will never be
			-- set to false. This strategy works even if the browser is flaky and
			-- fails to call our global error handler, because it doesn't rely on
			-- the error event at all.

			local didError = true; -- Keeps track of the value of window.event so that we can reset it
			-- during the callback to local user code access window.event in the
			-- browsers that support it.

			local windowEvent = window.event; -- Keeps track of the descriptor of window.event to restore it after event
			-- dispatching: https://github.com/facebook/react/issues/13688

			local windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event')

			function restoreAfterDispatch() {
				-- We immediately remove the callback from event listeners so that
				-- nested `invokeGuardedCallback` calls do not clash. Otherwise, a
				-- nested call would trigger the fake event handlers of any call higher
				-- in the stack.
				fakeNode.removeEventListener(evtType, callCallback, false); -- We check for window.hasOwnProperty('event') to prevent the
				-- window.event assignment in both IE <= 10 as they throw an error
				-- "Member not found" in strict mode, and in Firefox which does not
				-- support window.event.

				if typeof window.event ~= 'undefined' and window.hasOwnProperty('event') then
					window.event = windowEvent
				}
			} -- Create an event handler for our fake event. We will synchronously
			-- dispatch our fake event using `dispatchEvent`. Inside the handler, we
			-- call the user-provided callback.


			local funcArgs = Array.prototype.slice.call(arguments, 3)

			function callCallback() {
				didCall = true
				restoreAfterDispatch()
				func.apply(context, funcArgs)
				didError = false
			} -- Create a global error event handler. We use this to capture the value
			-- that was thrown. It's possible that this error handler will fire more
			-- than once; for example, if non-React code also calls `dispatchEvent`
			-- and a handler for that event throws. We should be resilient to most of
			-- those cases. Even if our error event handler fires more than once, the
			-- last error event is always used. If the callback actually does error,
			-- we know that the last error event is the correct one, because it's not
			-- possible for anything else to have happened in between our callback
			-- erroring and the code that follows the `dispatchEvent` call below. If
			-- the callback doesn't error, but the error event was fired, we know to
			-- ignore it because `didError` will be false, as described above.


			local error; -- Use this to track whether the error event is ever called.

			local didSetError = false
			local isCrossOriginError = false

			function handleWindowError(event) {
				error = event.error
				didSetError = true

				if error == nil and event.colno == 0 and event.lineno == 0 then
					isCrossOriginError = true
				}

				if event.defaultPrevented then
					-- Some other error handler has prevented default.
					-- Browsers silence the error report if this happens.
					-- We'll remember this to later decide whether to log it or not.
					if error ~= nil and typeof error == 'object' then
						try {
							error._suppressLogging = true
						} catch (inner) {-- Ignore.
						}
					}
				}
			} -- Create a fake event type.


			local evtType = `react-${function () {
				if name then
					return name
				}

				return 'invokeguardedcallback'
			}()}`; -- Attach our event handlers

			window.addEventListener('error', handleWindowError)
			fakeNode.addEventListener(evtType, callCallback, false); -- Synchronously dispatch our fake event. If the user-provided function
			-- errors, it will trigger our global error handler.

			evt.initEvent(evtType, false, false)
			fakeNode.dispatchEvent(evt)

			if windowEventDescriptor then
				Object.defineProperty(window, 'event', windowEventDescriptor)
			}

			if didCall and didError then
				if !didSetError then
					-- The callback errored, but the error event never fired.
					error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.')
				} else if isCrossOriginError then
					error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.')
				}

				this.onError(error)
			} -- Remove our event listeners


			window.removeEventListener('error', handleWindowError)

			if !didCall then
				-- Something went really wrong, and our event was not dispatched.
				-- https://github.com/facebook/react/issues/16734
				-- https://github.com/facebook/react/issues/16585
				-- Fall back to the production implementation.
				restoreAfterDispatch()
				return invokeGuardedCallbackProd.apply(this, arguments)
			}
		}
	}
\]\]
end

return invokeGuardedCallbackImpl ]]
ic.Children._e5749b095fae5c1712b7fce54a8dbd12=jP
local jQ

local jR={ClassName="ModuleScript",Children={},Properties={}}
jR.Name="isValidElementType"
jR.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/isValidElementType.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 \]\]
local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_DEBUG_TRACING_MODE_TYPE = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
-- local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_FUNDAMENTAL_TYPE = ReactSymbols.REACT_FUNDAMENTAL_TYPE
-- local REACT_SCOPE_TYPE = ReactSymbols.REACT_SCOPE_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_SERVER_BLOCK_TYPE = ReactSymbols.REACT_SERVER_BLOCK_TYPE
local REACT_LEGACY_HIDDEN_TYPE = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE

-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI

return function(type)
	local typeofType = typeof(type)
	if typeofType == "string" or typeofType == "function" then
		return true
	end

	-- Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
	if
		type == REACT_FRAGMENT_TYPE
		or type == REACT_PROFILER_TYPE
		or type == REACT_DEBUG_TRACING_MODE_TYPE
		or type == REACT_STRICT_MODE_TYPE
		or type == REACT_SUSPENSE_TYPE
		or type == REACT_LEGACY_HIDDEN_TYPE
		-- ROBLOX performance: eliminate compares that will only be true in React 18
		-- or type == REACT_SUSPENSE_LIST_TYPE
		-- or (enableScopeAPI and type == REACT_SCOPE_TYPE)
	then
		return true
	end

	if typeofType == "table" then
		-- ROBLOX deviation: In React, component classes are of type 'function'; for
		-- us, they're tables with a special value on their metatable
		if type.isReactComponent then
			return true
		end

		if
			type["$$typeof"] == REACT_LAZY_TYPE
			or type["$$typeof"] == REACT_MEMO_TYPE
			or type["$$typeof"] == REACT_PROVIDER_TYPE
			or type["$$typeof"] == REACT_CONTEXT_TYPE
			or type["$$typeof"] == REACT_FORWARD_REF_TYPE
			or type["$$typeof"] == REACT_FUNDAMENTAL_TYPE
			or type["$$typeof"] == REACT_BLOCK_TYPE
			or type[1] == REACT_SERVER_BLOCK_TYPE
		then
			return true
		end
	end

	return false
end ]]
ic.Children._ce37eedebdbab38fd0b817cd6ca4aafa=jR
local jS

local jT={ClassName="ModuleScript",Children={},Properties={}}
jT.Name="objectIs"
jT.Properties.Source=[[ --!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/6faf6f5eb1705eef39a1d762d6ee381930f36775/packages/shared/objectIs.js
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 \]\]

--\[\[*
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 \]\]
local function is(x: any, y: any): boolean
	return x == y and (x ~= 0 or 1 / x == 1 / y) or x ~= x and y ~= y -- eslint-disable-line no-self-compare
end

-- deviation: Object isn't a global in lua, so `Object.is` will never exist
local objectIs = is

return objectIs ]]
ic.Children._1ae30607be2984211bf394bf85524721=jT
local jU

local jV={ClassName="ModuleScript",Children={},Properties={}}
jV.Name="shallowEqual"
jV.Properties.Source=[[ -- ROBLOX upstream: https://github.com/facebook/react/blob/a9b035b0c2b8235405835beca0c4db2cc37f18d0/packages/shared/shallowEqual.js
--!strict
--\[\[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
\]\]
local is = require(script.Parent.objectIs)

--\[\[*
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
\]\]
local function shallowEqual(objA, objB)
	if is(objA, objB) then
		return true
	end

	if
		typeof(objA) ~= "table"
		or objA == nil
		or typeof(objB) ~= "table"
		or objB == nil
	then
		return false
	end

	-- deviation: `Object.keys` does not have an equivalent in Lua, so we
	-- iterate through each table instead
	for key, value in objA do
		if not is(objB[key], value) then
			return false
		end
	end

	for key, value in objB do
		if not is(objA[key], value) then
			return false
		end
	end

	return true
end

return shallowEqual ]]
ic.Children._7d2921b0986b56755cf2cc1f287de9d3=jV
local jW
getfenv(0).rootTree=a
getfenv(0).rootReferent="_9e3c7aedc18c985a2d67909866216e52"
type Runtime= {
getPatchedEnvironment:(script:LuaSourceContainer)->(),
loadedModules:{
[string]:{any }
},
main:()->(),
require:(script:ModuleScript)->...any,
runScript:(script:LuaSourceContainer)->()
}

local jX:Runtime ={}::any
if getfenv().__runtime then
jX=getfenv().__runtime
else
jX.loadedModules={}

local jY=game:GetService"HttpService"
local jZ=game:GetService"SharedTableRegistry"
local j_=getfenv(0).rootTree
local j0=getfenv(0).rootReferent
local j1=Instance.new"Folder"
j1.Name="nil-protected-instances"
j1.Parent=nil
local j2=[=[
		local constructInstanceFromTree
		constructInstanceFromTree = function(tree, rootReferent)
			local sourceMap = {}
			local tags = tree.Tags or {}
			local attributes = tree.Attributes or {}
			local children = tree.Children or {}
			local instance = Instance.new(tree.ClassName)
			local root = rootReferent
			local referentsToInstances = {
				[root] = instance,
			}

			local instancesToTrees = {
				[instance] = tree,
			}

			for _, tag in tags do
				instance:AddTag(tag)
			end

			for index, value in attributes do
				instance:SetAttribute(index, value)
			end
			-- ref is inside property

			local instancePropertyReferences = {}
			for index, value in tree.Properties do
				if typeof(value) == "table" and value.ref then
					-- referent
					instancePropertyReferences[instance] = {
						index = index,
						referent = value.ref,
					}
				else
					if index == "Source" then
						sourceMap[instance] = value
					else
						instance[index] = value
					end
				end
			end

			for referent, child in children do
				local childInstance = constructInstanceFromTree(child, referentsToInstances, sourceMap)
				childInstance.Parent = instance
				instancesToTrees[childInstance] = child
				referentsToInstances[referent] = childInstance
			end

			for affectedInstance, info in instancePropertyReferences do
				-- info.index is property, referents[info.referent] is the value
				affectedInstance[info.index] = referentsToInstances[info.referent]
			end

			return instance, referentsToInstances, instancesToTrees, sourceMap
		end

		return constructInstanceFromTree
	]=]

type constructInstance= (
tree:{},
rootReferent:string
)->(Instance,{[string]:Instance },{[Instance]:string },{[Instance]:string })

local j3:constructInstance =assert(loadstring(j2))()
local j4=os.clock()

local j5=jY:GetAsync(
"https://raw.githubusercontent.com/techs-sus/rojo-script/master/runtime/lua_sandbox.lua",
false
)
local j6,j7,j8,j9=
j3(j_,j0)
print(`rojo-script: took {os.clock()-j4} seconds to construct instance from tree`)

local function wrappedNS(ka:Script |string,kb:Instance,...)
if#({...})~=0 then
error("expected 2 arguments, got ".. 2+#({...}).." arguments")
end
if typeof(ka)=="string"then
return getfenv().NS(ka,kb)
elseif typeof(ka)=="Instance"then
if ka:IsA"LuaSourceContainer"then

local kc=jY:GenerateGUID(false)
local kd=string.format(
[[
						--- rojo-script environment tampering ---
						(function()
							-- setup fake tree with a SharedTable
							script:Destroy();
							script = nil
							local accessToken = "%s"
							local SharedTableRegistry = game:GetService("SharedTableRegistry")
							local scriptInfo = SharedTableRegistry:GetSharedTable(accessToken)
							SharedTableRegistry:SetSharedTable(accessToken, nil)
							local rootTree = scriptInfo.tree

							local constructorSource = [=[
								%s
							]=]
							type constructInstance = (
								tree: {},
								rootReferent: string
							) -> (Instance, { [string]: Instance }, { [Instance]: string }, { [Instance]: string })
							local constructInstanceFromTree: constructInstance = assert(loadstring(constructorSource))()
							local rootModel, rootReferentsToInstances, rootInstancesToTrees, sourceMap =
								constructInstanceFromTree(rootTree, rootReferent)
							rootModel.Parent = nil
							script = rootModel
							
							-- TODO: Sandbox a "real" script that will appear to the outside world
							-- "real" script will not accept any changes

							%s

							-- environment tampering
							setfenv(0, runtime.getPatchedEnvironment(script))

							warn("environment tampering is not done yet")
						end)()
						--- end rojo-script environment tampering ---\n
					]],
kc,
j2,
j5
)
jZ:SetSharedTable(
kc,
SharedTable.new{tree=j8[ka]}
)
local ke:Script =getfenv().NS(kd..j9[ka],j1)
ke.Parent=kb
return ke
else
error("expected instance LuaSourceContainer".." but got "..ka.ClassName)
end
else
error("expected type string | LuaSourceContainer".." but got "..typeof(ka))
end
end

local function wrappedNLS(ka:LocalScript |string,kb:Instance)
if typeof(ka)=="string"then
return getfenv().NLS(ka,kb)
elseif typeof(ka)=="Instance"then
if ka:IsA"LocalScript"then


local kc=getfenv().NLS(j9[ka],j1)
kc.Disabled=true


for kd,ke in ka:Clone():GetChildren()do
ke.Parent=kc
end

kc.Disabled=false
kc.Parent=kb
return kc
else
error("expected class LocalScript".." but got "..ka.ClassName)
end
else
error("expected type string | LocalScript".." but got "..typeof(ka))
end
end

function jX.getPatchedEnvironment(ka)
local kb
kb=setmetatable({
script=ka,
getfenv=function()
return kb
end,
require=jX.require,
NLS=wrappedNLS,
NS=wrappedNS,
__runtime=jX,
},{
__index=getfenv(0),
__metatable="The metatable is locked",
})
return kb
end

jX.require=function(ka):...any
if jX.loadedModules[ka]then
return unpack(jX.loadedModules[ka])
end
if typeof(ka)=="number"then
return require(ka)
end
if not ka:IsA"ModuleScript"then
return error"Instance is not a ModuleScript"
end
local kb=j9[ka]
local kc=jX.getPatchedEnvironment(ka)
local kd:((...any)->...any)?,ke:string?=loadstring(kb)
if not kd then
error("Error loading module, loadstring failed "..if ke then ke else"(no error)")
else
setfenv(kd,kc)
local kf={kd()}
if#kf~=1 then
error("The module did not return exactly one value, "..ka:GetFullName())
end

jX.loadedModules[ka]=kf
return unpack(jX.loadedModules[ka])
end
end

local function runScript(ka:LuaSourceContainer)
local kb=j9[ka]
local kc,kd=loadstring(kb)
local ke=jX.getPatchedEnvironment(ka)
if not kc then
error("Error running script, loadstring failed "..if kd then kd else"(no error)")
end
setfenv(kc,ke)
coroutine.wrap(kc)()
end

function jX.main()

local ka=Instance.new"Script"
ka.Name="Script"
j6.Parent=ka
ka.Parent=workspace

for kb,kc in j6:GetDescendants()do
if kc:IsA"Script"and not kc.Disabled then
runScript(kc)
end
end
end

jX.runScript=runScript
end

jX.main()